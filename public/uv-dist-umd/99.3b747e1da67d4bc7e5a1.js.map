{"version":3,"sources":["webpack://UV/./node_modules/@universalviewer/aleph/dist/esm-es5/al-angle-editor_31-ios.entry.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,cAAc,SAAI;AAC4N;AACxG;AACtC;AACkB;AAC/C;AACK;AACZ;AAC5D,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,2BAA2B,2DAAW;AACtC,yBAAyB,2DAAW;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,UAAU,yBAAyB,2BAA2B,EAAE,EAAE,EAAE,2DAAC,mBAAmB,2DAAC,eAAe,wHAAwH,yCAAyC,EAAE,iBAAiB,IAAI,2DAAC,mBAAmB,2DAAC,kBAAkB,mIAAmI,+CAA+C,EAAE,kBAAkB,IAAI,2DAAC,mBAAmB,2DAAC,gBAAgB;AAC3kB;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,WAAW,2CAA2C,2DAAC,gBAAgB;AAC3G;AACA;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,aAAa;AACjD;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,8CAA8C,8BAA8B,gDAAgD,0CAA0C,8CAA8C,0CAA0C,oCAAoC,aAAa,iDAAiD,iCAAiC,mDAAmD,6CAA6C,iDAAiD,6CAA6C,uCAAuC,EAAE,EAAE;AACppB;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,8BAA8B,2DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,UAAU,yBAAyB,2BAA2B,EAAE,EAAE,EAAE,2DAAC,mBAAmB,2DAAC,kBAAkB,gGAAgG,yCAAyC,EAAE,uCAAuC,8BAA8B,EAAE,EAAE,IAAI,2DAAC,mBAAmB,2DAAC,gBAAgB;AACzX;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,cAAc,aAAa;AAC7C;AACA;AACA,0BAA0B,gBAAgB,iDAAiD,iCAAiC,mDAAmD,6CAA6C,iDAAiD,6CAA6C,sCAAsC,EAAE,EAAE;AACpW;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,yCAAyC,SAAS,2DAAC,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,kBAAkB,2DAAC,wCAAwC,2DAAC,4CAA4C,2DAAC,oBAAoB,aAAa,EAAE,2DAAC,cAAc,aAAa,GAAG,2DAAC,mFAAmF,2DAAC,oBAAoB,kBAAkB,EAAE,2DAAC,cAAc,aAAa,GAAG,2DAAC,qFAAqF,2DAAC,oBAAoB,eAAe,EAAE,2DAAC,cAAc,aAAa,GAAG,2DAAC,oFAAoF,2DAAC,oBAAoB,iBAAiB,EAAE,2DAAC,cAAc,aAAa,GAAG,2DAAC,2FAA2F,2DAAC,aAAa,aAAa,EAAE,2DAAC,sBAAsB,sFAAsF,GAAG,2DAAC,mBAAmB,iCAAiC,uCAAuC,2DAAC,aAAa,kBAAkB,EAAE,2DAAC,UAAU,2BAA2B,EAAE,2DAAC,sBAAsB,sFAAsF,GAAG,2DAAC,iBAAiB,iZAAiZ,qCAAqC,2DAAC,aAAa,eAAe,EAAE,2DAAC,UAAU,2BAA2B,EAAE,2DAAC,sBAAsB,sFAAsF,GAAG,2DAAC,qBAAqB,mLAAmL,uCAAuC,2DAAC,aAAa,iBAAiB,EAAE,2DAAC,UAAU,2BAA2B,EAAE,2DAAC,sBAAsB,sFAAsF,GAAG,2DAAC,gBAAgB,8BAA8B;AACruE;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,iBAAiB,uDAAuD,EAAE,EAAE;AACtG;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,0BAA0B,2DAAW;AACrC,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,UAAU,yBAAyB,2BAA2B,EAAE,EAAE,EAAE,2DAAC,mBAAmB,2DAAC,eAAe,uHAAuH,wCAAwC,EAAE,iBAAiB,IAAI,2DAAC,mBAAmB,2DAAC,kBAAkB,kIAAkI,8CAA8C,EAAE,kBAAkB,IAAI,2DAAC,mBAAmB,2DAAC,gBAAgB;AACvkB;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,WAAW,2CAA2C,2DAAC,gBAAgB;AAC3G;AACA;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,aAAa;AACjD;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,8CAA8C,8BAA8B,gDAAgD,0CAA0C,8CAA8C,0CAA0C,oCAAoC,aAAa,iDAAiD,iCAAiC,mDAAmD,6CAA6C,iDAAiD,6CAA6C,uCAAuC,EAAE,EAAE;AACppB;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAC,uBAAuB,4FAA4F;AAChI,YAAY,2DAAC,kBAAkB,6CAA6C;AAC5E,YAAY,2DAAC;AACb,YAAY,2DAAC,oBAAoB,gCAAgC;AACjE,YAAY,2DAAC,oBAAoB,gCAAgC;AACjE,YAAY,2DAAC,qBAAqB,kCAAkC;AACpE;AACA;AACA;AACA,0BAA0B,WAAW,EAAE;AACvC;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,2BAA2B,2DAAW;AACtC,kCAAkC,2DAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,cAAc,2DAAC,cAAc;AAClD;AACA,iBAAiB,EAAE,EAAE,2DAAC,UAAU,2CAA2C,sCAAsC,2DAAC,gBAAgB,qEAAqE,gDAAgD,EAAE,EAAE,IAAI,2DAAC,cAAc;AAC9Q;AACA,iBAAiB,EAAE,EAAE,2DAAC,UAAU,oCAAoC,+BAA+B,2DAAC,YAAY,sCAAsC,2CAA2C,EAAE,EAAE,EAAE,2DAAC,YAAY,uEAAuE,qCAAqC,2DAAC,YAAY,6DAA6D;AAC1Y;AACA;AACA,mBAAmB,2DAAC;AACpB;AACA;AACA;AACA,gBAAgB,2DAAC,SAAS;AAC1B;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,0BAA0B,gBAAgB,YAAY,gBAAgB,mDAAmD,2BAA2B,YAAY,kCAAkC,OAAO,gCAAgC,sBAAsB,UAAU,2BAA2B,EAAE,EAAE;AACxS;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,0BAA0B,2DAAW;AACrC,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,UAAU,yBAAyB,2BAA2B,EAAE,EAAE,EAAE,2DAAC,mBAAmB,2DAAC,eAAe,uHAAuH,wCAAwC,EAAE,kBAAkB,IAAI,2DAAC,mBAAmB,2DAAC,kBAAkB,kIAAkI,8CAA8C,EAAE,mBAAmB,IAAI,2DAAC,mBAAmB,2DAAC,gBAAgB;AACzkB;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,WAAW,2CAA2C,2DAAC,gBAAgB;AAC3G;AACA;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,cAAc,aAAa;AACjD;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB,8CAA8C,8BAA8B,gDAAgD,0CAA0C,8CAA8C,0CAA0C,oCAAoC,aAAa,iDAAiD,iCAAiC,mDAAmD,6CAA6C,iDAAiD,6CAA6C,uCAAuC,EAAE,EAAE;AACppB;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,8BAA8B,2DAAW;AACzC;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA,wBAAwB,2DAAC,cAAc,oFAAoF,4CAA4C,EAAE,EAAE;AAC3K,aAAa;AACb;AACA,gBAAgB,2DAAC,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC;AAClB;AACA;AACA,0BAA0B,kBAAkB,6BAA6B,2CAA2C,yBAAyB,sBAAsB,qBAAqB,iBAAiB,wBAAwB,sCAAsC,EAAE,EAAE;AAC3Q;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,iCAAiC,2DAAW;AAC5C,iCAAiC,2DAAW;AAC5C,iCAAiC,2DAAW;AAC5C,sCAAsC,2DAAW;AACjD,oCAAoC,2DAAW;AAC/C,sCAAsC,2DAAW;AACjD,oCAAoC,2DAAW;AAC/C,iCAAiC,2DAAW;AAC5C,4CAA4C,2DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,cAAc;AACnC;AACA;AACA,iBAAiB,EAAE,EAAE,2DAAC,UAAU,0CAA0C,WAAW,2DAAC,YAAY,sCAAsC;AACxI,4BAA4B,EAAE,EAAE,EAAE,2DAAC,YAAY,+EAA+E,gCAAgC,2DAAC,YAAY,+EAA+E;AAC1P;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,cAAc;AAC/B;AACA,aAAa,EAAE,EAAE,2DAAC,UAAU,4DAA4D,oDAAoD,2DAAC,cAAc,aAAa,IAAI,2DAAC,gBAAgB,+EAA+E,0DAA0D,EAAE,EAAE;AAC1U;AACA;AACA;AACA,gBAAgB,2DAAC,cAAc,2DAAC,cAAc;AAC9C;AACA,aAAa,EAAE,EAAE,2DAAC,UAAU,mBAAmB,YAAY,2DAAC,YAAY,sCAAsC;AAC9G,wBAAwB,EAAE,EAAE,EAAE,2DAAC,YAAY,iFAAiF,iCAAiC,2DAAC,YAAY,mFAAmF,kCAAkC,2DAAC,YAAY,6EAA6E,iCAAiC,2DAAC,cAAc;AACza;AACA,aAAa,EAAE,EAAE,2DAAC,4CAA4C,2DAAC,eAAe,iHAAiH,6CAA6C,EAAE,EAAE;AAChP;AACA;AACA;AACA,gBAAgB,2DAAC,cAAc,2DAAC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,sDAAsD,2DAAC,cAAc;AACvF;AACA,aAAa,EAAE,EAAE,2DAAC,iDAAiD,2DAAC,eAAe;AACnF;AACA,aAAa,EAAE,IAAI,2DAAC,cAAc;AAClC;AACA,aAAa,EAAE,EAAE,2DAAC,+CAA+C,2DAAC,eAAe,4HAA4H,gDAAgD,EAAE,EAAE;AACjQ;AACA;AACA;AACA,gBAAgB,2DAAC,cAAc,2DAAC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,sDAAsD,2DAAC,cAAc;AACvF;AACA,aAAa,EAAE,EAAE,2DAAC,iDAAiD,2DAAC,eAAe;AACnF;AACA,aAAa,EAAE,IAAI,2DAAC,cAAc;AAClC;AACA,aAAa,EAAE,EAAE,2DAAC,+CAA+C,2DAAC,eAAe,4HAA4H,gDAAgD,EAAE,EAAE;AACjQ;AACA;AACA;AACA;AACA,wBAAwB,2DAAC;AACzB;AACA;AACA,wBAAwB,2DAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,SAAS;AAC1B;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,0BAA0B,gBAAgB,YAAY,gBAAgB,mDAAmD,2BAA2B,YAAY,kCAAkC,OAAO,gCAAgC,sBAAsB,UAAU,2BAA2B,EAAE,EAAE;AACxS;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAW;AACzC,iCAAiC,2DAAW;AAC5C,gCAAgC,2DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,sBAAsB,EAAE;AACvG;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,yCAAyC,EAAE,2DAAC,UAAU,cAAc,GAAG,2DAAC,SAAS,sBAAsB,EAAE,2DAAC,iBAAiB,2DAAC,UAAU,iBAAiB;AAChL;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,sCAAsC,yCAAyC,YAAY,kBAAkB,EAAE,EAAE;AAC1J;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,gCAAgC;AAChC;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA,yBAAyB,2DAAW;AACpC;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,UAAU,yBAAyB,2BAA2B,EAAE,EAAE,EAAE,2DAAC,mBAAmB,2DAAC,gBAAgB,kGAAkG,+CAA+C,EAAE,EAAE;AACnR;AACA,wBAAwB,2DAAC,uBAAuB,aAAa;AAC7D,aAAa,KAAK,2DAAC,mBAAmB,2DAAC,eAAe,+GAA+G,8BAA8B,EAAE,EAAE,IAAI,2DAAC,mBAAmB,2DAAC,gBAAgB,oEAAoE,qDAAqD,EAAE,EAAE,EAAE,2DAAC,cAAc,aAAa;AAC3Y;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB,oBAAoB,WAAW,yBAAyB,OAAO,8CAA8C,8BAA8B,8CAA8C,EAAE,EAAE;AACxO;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,wCAAwC,2DAAW;AACnD,kCAAkC,2DAAW;AAC7C,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,SAAS;AAC1B;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,gBAAgB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa,EAAE,EAAE,2DAAC,SAAS;AAC3B;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,cAAc;AAChC;AACA;AACA;AACA,aAAa,uCAAuC,GAAG,2DAAC,6BAA6B,2DAAC,gBAAgB;AACtG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa,EAAE,EAAE,2DAAC,SAAS;AAC3B;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,cAAc;AAChC;AACA;AACA;AACA,aAAa,oDAAoD,GAAG,2DAAC,+CAA+C,2DAAC,gBAAgB;AACrI;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa,EAAE,EAAE,2DAAC,SAAS;AAC3B;AACA;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,cAAc;AAChC;AACA;AACA;AACA,aAAa,mEAAmE,GAAG,2DAAC;AACpF;AACA;AACA,gBAAgB,2DAAC,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,0BAA0B,gBAAgB,YAAY,gBAAgB,mDAAmD,2BAA2B,YAAY,kCAAkC,OAAO,gCAAgC,sBAAsB,UAAU,2BAA2B,EAAE,EAAE;AACxS;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,oCAAoC;AACpC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,oCAAoC;AACpC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,qEAAqE,eAAe,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF,mFAAmF;AACnF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kCAAkC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kBAAkB;AAC9C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F,8FAA8F;AAC9F,2FAA2F;AAC3F,6FAA6F;AAC7F,6FAA6F;AAC7F,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,6EAA6E,GAAG;AACnH,qCAAqC,8CAA8C,GAAG;AACtF;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC,eAAe,gBAAgB,aAAa,iBAAiB,YAAY,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,wBAAwB;AACxB,0BAA0B;AAC1B,0BAA0B;AAC1B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,SAAS;AACT;AACA,0CAA0C;AAC1C,qEAAqE;AACrE,oEAAoE;AACpE,cAAc;AACd,0BAA0B;AAC1B,4EAA4E;AAC5E;AACA;AACA,cAAc;AACd;AACA;AACA,yCAAyC;AACzC,0CAA0C;AAC1C;AACA;AACA,0BAA0B;AAC1B,4DAA4D;AAC5D,4BAA4B;AAC5B,0FAA0F;AAC1F,mFAAmF;AACnF,8DAA8D;AAC9D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,+FAA+F;AAC/F,gFAAgF;AAChF,wFAAwF;AACxF,+HAA+H,uDAAuD,6HAA6H,yHAAyH;AAC5a,uEAAuE,iCAAiC;AACxG,wDAAwD;AACxD,6DAA6D,iEAAiE;AAC9H,2FAA2F,0DAA0D,oDAAoD,iCAAiC,sEAAsE,6CAA6C,GAAG,+IAA+I,8HAA8H,gCAAgC,0FAA0F,KAAK,2BAA2B,8DAA8D,qFAAqF,KAAK,eAAe,WAAW,2DAA2D,wCAAwC,GAAG,uEAAuE,mEAAmE,6DAA6D,GAAG,yGAAyG,mEAAmE,sDAAsD,6BAA6B,GAAG,yFAAyF,6BAA6B,iEAAiE,iEAAiE,6BAA6B,GAAG,mGAAmG,6BAA6B,iEAAiE,iEAAiE,yCAAyC,GAAG,6DAA6D,6BAA6B,qDAAqD,8CAA8C,GAAG,6JAA6J,oCAAoC,2EAA2E,8EAA8E,uEAAuE,8DAA8D,sEAAsE,+CAA+C,2DAA2D,oCAAoC,yBAAyB,GAAG,6EAA6E,iCAAiC,0DAA0D,2CAA2C,0CAA0C,qDAAqD,mCAAmC,cAAc,GAAG,wDAAwD,0BAA0B,qDAAqD,GAAG,uEAAuE,4BAA4B,uBAAuB,4DAA4D,gDAAgD,oBAAoB,+FAA+F,4CAA4C,GAAG,6HAA6H,gDAAgD,gDAAgD,uCAAuC,2EAA2E,gBAAgB,0CAA0C,0BAA0B,yDAAyD,qBAAqB,gDAAgD,gDAAgD,gDAAgD,gDAAgD,2CAA2C,2CAA2C,2CAA2C,2CAA2C,wCAAwC,6EAA6E,6EAA6E,6EAA6E,6EAA6E,mEAAmE,0BAA0B,GAAG,mIAAmI,uEAAuE,0DAA0D,2CAA2C,GAAG,kMAAkM,uEAAuE,6EAA6E,0DAA0D,sCAAsC,gCAAgC,0BAA0B,mEAAmE,kDAAkD,4BAA4B,8BAA8B,GAAG,kCAAkC,gBAAgB,GAAG,wEAAwE,+EAA+E,GAAG,oKAAoK,2EAA2E,8DAA8D,sEAAsE,+CAA+C,uCAAuC,+CAA+C,yBAAyB,GAAG,oEAAoE,yDAAyD,GAAG,qEAAqE,iDAAiD,GAAG;AACjgO,6EAA6E,4BAA4B,sBAAsB,+BAA+B,+BAA+B,0DAA0D,wEAAwE,wEAAwE,8BAA8B,KAAK,wEAAwE,wFAAwF,wFAAwF,0BAA0B,qCAAqC,qCAAqC,sCAAsC,sDAAsD,kEAAkE,0DAA0D,KAAK;AACn+B,0EAA0E,2CAA2C,2BAA2B,SAAS,kCAAkC,+DAA+D,KAAK,6EAA6E,mEAAmE,yBAAyB,SAAS,oCAAoC,2EAA2E,OAAO,6BAA6B;AACpkB,2KAA2K,iEAAiE;AAC5O,mKAAmK;AACnK,oKAAoK;AACpK,qEAAqE;AACrE,mEAAmE;AACnE,iEAAiE;AACjE,+DAA+D;AAC/D,uVAAuV,YAAY,EAAE,kCAAkC,cAAc,EAAE,kCAAkC,gBAAgB,cAAc,EAAE,wCAAwC,qCAAqC,EAAE,wCAAwC,8DAA8D,mEAAmE,8BAA8B,GAAG,wBAAwB,eAAe,mBAAmB,iBAAiB,IAAI,yBAAyB,uBAAuB,wBAAwB,yBAAyB,0BAA0B,IAAI,2BAA2B,kBAAkB,gBAAgB,iBAAiB,IAAI,0DAA0D,0DAA0D,GAAG,iEAAiE,0DAA0D,GAAG,kFAAkF,8DAA8D,4CAA4C,GAAG,iFAAiF,4DAA4D,GAAG,oHAAoH,gIAAgI,GAAG,yCAAyC,aAAa,oDAAoD,oDAAoD,oDAAoD,eAAe,GAAG,0DAA0D,kDAAkD,qCAAqC,GAAG;AACrsE,8IAA8I,uCAAuC,kBAAkB,2CAA2C,mFAAmF,mDAAmD,KAAK,UAAU,mFAAmF,mDAAmD,KAAK,gBAAgB,GAAG,6LAA6L,yDAAyD,wCAAwC,wCAAwC,gDAAgD,gDAAgD,kDAAkD,yCAAyC,mCAAmC,kDAAkD,GAAG,iMAAiM,uEAAuE,2CAA2C,gEAAgE,qDAAqD,mDAAmD,+DAA+D,yEAAyE,gCAAgC,6CAA6C,WAAW,gBAAgB,+CAA+C,uCAAuC,oBAAoB,uDAAuD,sDAAsD,2DAA2D,KAAK,yBAAyB,sDAAsD,yDAAyD,2DAA2D,KAAK,yBAAyB,sDAAsD,6DAA6D,2DAA2D,KAAK,yBAAyB,sDAAsD,qDAAqD,6DAA6D,KAAK,yBAAyB,uDAAuD,wDAAwD,6DAA6D,KAAK,UAAU,uDAAuD,4DAA4D,6DAA6D,KAAK,qBAAqB,oDAAoD,uDAAuD,6CAA6C,oDAAoD,GAAG,mJAAmJ,oDAAoD,mCAAmC,wBAAwB,kCAAkC,mEAAmE,wBAAwB,6BAA6B,gCAAgC,yCAAyC,2CAA2C,2DAA2D,iEAAiE,2DAA2D,iEAAiE,2CAA2C,iCAAiC,GAAG;AAC9nI,iFAAiF,+DAA+D,uFAAuF,qEAAqE;AAC5S,mGAAmG,oCAAoC,mCAAmC;AAC1K,qLAAqL;AACrL,yGAAyG,sEAAsE,+CAA+C;AAC9N,yFAAyF;AACzF,6EAA6E;AAC7E,uEAAuE,iBAAiB,GAAG,6DAA6D,kEAAkE,GAAG,6DAA6D,wEAAwE,GAAG,sCAAsC,sLAAsL,GAAG,sCAAsC,uKAAuK,GAAG,sCAAsC,oEAAoE,GAAG,sCAAsC,iEAAiE,sEAAsE,sEAAsE,GAAG,yDAAyD,uDAAuD,GAAG,yDAAyD,2DAA2D,mDAAmD,kCAAkC,mDAAmD,GAAG,yDAAyD,uEAAuE,GAAG,yDAAyD,2DAA2D,4CAA4C,uCAAuC,+DAA+D,GAAG,uGAAuG,yCAAyC,0CAA0C,2DAA2D,iBAAiB,4CAA4C,+CAA+C,4BAA4B,wEAAwE,mBAAmB,GAAG,mHAAmH,wCAAwC,yCAAyC,mBAAmB,+CAA+C,wCAAwC,wCAAwC,gDAAgD,yCAAyC,GAAG;AAClwF,+LAA+L,yEAAyE,oGAAoG,6FAA6F,sDAAsD,mIAAmI,4DAA4D,2CAA2C,mFAAmF,6EAA6E,oDAAoD,kFAAkF,2GAA2G,sEAAsE,2CAA2C,yDAAyD,6IAA6I,kIAAkI,8GAA8G;AACjqD,2GAA2G,kCAAkC,wKAAwK,sEAAsE,wCAAwC,uCAAuC,4BAA4B,yIAAyI,qCAAqC;AACppB,2JAA2J,qCAAqC,oCAAoC;AACpO,6JAA6J,qFAAqF,oFAAoF,6FAA6F,sFAAsF;AACzf,6DAA6D;AAC7D,gEAAgE;AAChE,+JAA+J,yEAAyE,8EAA8E;AACtT,iEAAiE,2BAA2B,kDAAkD,qCAAqC,2BAA2B;AAC9M,8EAA8E,oEAAoE,kDAAkD,kDAAkD,+EAA+E,wEAAwE,iBAAiB;AAC9Z,2IAA2I;AAC3I,gFAAgF,oCAAoC;AACpH,wDAAwD,4BAA4B,qCAAqC,mDAAmD,kDAAkD,gCAAgC,4CAA4C,yCAAyC,0CAA0C,4BAA4B,+BAA+B,kDAAkD,gCAAgC,oCAAoC,cAAc,gCAAgC,qEAAqE,sBAAsB,SAAS,+EAA+E,4DAA4D,wDAAwD,kEAAkE,6FAA6F,iBAAiB,4EAA4E,qBAAqB,SAAS,6EAA6E,4DAA4D,wDAAwD,kEAAkE,6FAA6F,iBAAiB,2EAA2E,oBAAoB,SAAS,2FAA2F,4DAA4D,wDAAwD,kEAAkE,6FAA6F,iBAAiB,4EAA4E,qBAAqB,SAAS,wFAAwF,sHAAsH,iBAAiB;AAC9zE,wDAAwD,+BAA+B,yEAAyE,mDAAmD,iDAAiD,uDAAuD,uDAAuD,uDAAuD,2DAA2D,2DAA2D,oEAAoE,2DAA2D,iEAAiE,kBAAkB,GAAG,qGAAqG,gFAAgF,mEAAmE,sBAAsB,GAAG,qEAAqE,wCAAwC,4DAA4D,gCAAgC,GAAG,qDAAqD,qBAAqB,iBAAiB,iBAAiB,uBAAuB,yBAAyB,yBAAyB,MAAM,iEAAiE,+JAA+J,iDAAiD,yDAAyD,iCAAiC,KAAK,yDAAyD,oBAAoB,iBAAiB,qBAAqB,kBAAkB,iBAAiB,uBAAuB,yBAAyB,yBAAyB,6BAA6B,4BAA4B,MAAM,uDAAuD,6IAA6I,6DAA6D,mDAAmD,8CAA8C,2CAA2C,4HAA4H,iEAAiE,KAAK,uDAAuD,oBAAoB,qBAAqB,iBAAiB,qBAAqB,kBAAkB,oBAAoB,wBAAwB,iBAAiB,uBAAuB,yBAAyB,yBAAyB,MAAM,oDAAoD,2IAA2I,4DAA4D,mDAAmD,8CAA8C,yEAAyE,2CAA2C,4FAA4F,4CAA4C,yIAAyI,mCAAmC,OAAO,OAAO,wCAAwC,oCAAoC,OAAO,KAAK,gEAAgE,iBAAiB,oBAAoB,qBAAqB,sBAAsB,MAAM,4BAA4B,0BAA0B,iEAAiE,6DAA6D,qBAAqB,oBAAoB,uBAAuB,MAAM,gEAAgE,iHAAiH,gEAAgE,kDAAkD,4FAA4F,gEAAgE,oCAAoC,KAAK;AAC/mJ,+LAA+L,kFAAkF,wGAAwG,uHAAuH,gGAAgG,+EAA+E,qHAAqH,kEAAkE,kDAAkD,gEAAgE,KAAK,kGAAkG,qDAAqD,+GAA+G,8DAA8D,KAAK,+IAA+I,2GAA2G,oGAAoG,mFAAmF,0FAA0F,6GAA6G,0HAA0H,mGAAmG,+EAA+E,0HAA0H,yHAAyH,gEAAgE,qFAAqF,+EAA+E,iHAAiH,0FAA0F,+EAA+E,oJAAoJ,mIAAmI,4GAA4G,+EAA+E,2DAA2D,KAAK;AAC77G,yDAAyD,2CAA2C,oCAAoC,yCAAyC,+CAA+C;AAChO,6DAA6D,8CAA8C,qCAAqC,uBAAuB,wBAAwB,6BAA6B,4BAA4B,IAAI,kLAAkL,2HAA2H,uFAAuF,kDAAkD,sEAAsE,yGAAyG,oLAAoL,GAAG,iLAAiL,iGAAiG,GAAG;AAC7yC,0DAA0D,uEAAuE,mEAAmE,6HAA6H,0IAA0I,+CAA+C,uEAAuE;AACjkB,8DAA8D,uBAAuB,6BAA6B,wBAAwB,0CAA0C,+BAA+B,cAAc,oKAAoK,6IAA6I,GAAG,yNAAyN,oCAAoC,sCAAsC,wCAAwC,6CAA6C,+CAA+C,iDAAiD,4CAA4C,mDAAmD,2BAA2B,0DAA0D,wDAAwD,0DAA0D,0DAA0D,qDAAqD,uCAAuC,uCAAuC,wHAAwH,yGAAyG,0HAA0H,8IAA8I,KAAK,sLAAsL,4EAA4E,gDAAgD,4DAA4D,uIAAuI,wCAAwC,oLAAoL,wHAAwH,2MAA2M,aAAa,6KAA6K,kIAAkI,aAAa,sOAAsO,6FAA6F,0BAA0B,yGAAyG,wCAAwC,sDAAsD,gFAAgF,yCAAyC,iEAAiE,mJAAmJ,8FAA8F,oFAAoF,mFAAmF,2EAA2E,0KAA0K,6NAA6N,aAAa,kkBAAkkB,kHAAkH,GAAG;AACviL,yDAAyD,sCAAsC,2BAA2B,gDAAgD,4BAA4B,gFAAgF,2CAA2C,sBAAsB,SAAS,oCAAoC,yEAAyE,qTAAqT,+EAA+E,KAAK,qFAAqF,2CAA2C,qBAAqB,SAAS,kCAAkC,uEAAuE,iPAAiP,+EAA+E,KAAK,kGAAkG,2CAA2C,oBAAoB,SAAS,gDAAgD,qFAAqF,2RAA2R,+EAA+E,KAAK,2GAA2G,2CAA2C,0BAA0B,SAAS,0CAA0C,8EAA8E,KAAK,gHAAgH,kEAAkE,8EAA8E,qBAAqB,SAAS,sFAAsF,OAAO,sFAAsF,yCAAyC;AACh3F,wKAAwK,wEAAwE,mDAAmD,6KAA6K,mMAAmM,6JAA6J;AAChzB,qIAAqI,mJAAmJ;AACxR,2JAA2J;AAC3J,iIAAiI,6BAA6B;AAC9J,kHAAkH,2CAA2C;AAC7J,qHAAqH,iGAAiG,qCAAqC;AAC3P,8EAA8E,gDAAgD,+BAA+B;AAC7J,iEAAiE;AACjE,gIAAgI,yCAAyC,iDAAiD;AAC1N,6EAA6E,0BAA0B;AACvG,+DAA+D,kFAAkF,wCAAwC;AACzL,4FAA4F;AAC5F,4HAA4H,2EAA2E,2EAA2E,2EAA2E;AAC7V,+HAA+H,sDAAsD;AACrL,6HAA6H,4EAA4E,4EAA4E,4EAA4E,wGAAwG,4EAA4E,4EAA4E,4EAA4E;AAC7qB,gJAAgJ,iGAAiG,iDAAiD,8CAA8C,uFAAuF,2EAA2E,+CAA+C,6FAA6F,wEAAwE;AACtsB,2IAA2I,iDAAiD,uGAAuG,8DAA8D,wFAAwF,gEAAgE,wCAAwC,0CAA0C,wEAAwE,yHAAyH;AAC5wB,mFAAmF,6BAA6B,gEAAgE,uEAAuE,kFAAkF,kFAAkF,kCAAkC,kCAAkC,4DAA4D,kEAAkE,oEAAoE,wCAAwC,mCAAmC,gEAAgE,+BAA+B,2DAA2D,uCAAuC,OAAO;AACp7B,6DAA6D,2CAA2C,GAAG,+CAA+C,+BAA+B,GAAG,wCAAwC,0CAA0C,0EAA0E,uEAAuE,sCAAsC,4CAA4C,iDAAiD,iCAAiC,yBAAyB,GAAG,8CAA8C,mCAAmC,GAAG,mGAAmG,6CAA6C,GAAG,yGAAyG,+CAA+C,GAAG,kGAAkG,iEAAiE,GAAG,qGAAqG,gEAAgE,GAAG;AAC/yC,qGAAqG;AACrG,mFAAmF,8CAA8C;AACjI,uGAAuG;AACvG,yFAAyF,oDAAoD,gFAAgF,+FAA+F,sCAAsC,KAAK;AACvW,+DAA+D,kFAAkF,wCAAwC;AACzL,4FAA4F;AAC5F,4IAA4I,6DAA6D,8FAA8F,uDAAuD,iGAAiG,yDAAyD,kFAAkF,2EAA2E,KAAK,sFAAsF,2CAA2C,0CAA0C,wDAAwD,yFAAyF,yFAAyF,yFAAyF,yFAAyF,wCAAwC,mCAAmC,mCAAmC,iCAAiC,eAAe,KAAK,wHAAwH,yBAAyB,uCAAuC,kCAAkC,4HAA4H,2CAA2C,sEAAsE,+CAA+C,0BAA0B,4FAA4F,iDAAiD,iDAAiD,iDAAiD,iDAAiD,8BAA8B,8BAA8B,8BAA8B,8BAA8B,miDAAmiD,mGAAmG,iDAAiD,iDAAiD,iDAAiD,iDAAiD,4+BAA4+B,yFAAyF,mBAAmB,oBAAoB,KAAK,+CAA+C,2BAA2B,qEAAqE,0BAA0B,oDAAoD,yBAAyB,4CAA4C,2CAA2C,kCAAkC,uDAAuD,OAAO,kCAAkC,kCAAkC,6CAA6C,OAAO,kCAAkC,kCAAkC,2CAA2C,qCAAqC,OAAO,gEAAgE,KAAK,4KAA4K,0EAA0E,6CAA6C,2GAA2G,qBAAqB,+CAA+C,+IAA+I,4zBAA4zB,2FAA2F,iBAAiB;AACr/O,wIAAwI,6DAA6D,4FAA4F,uDAAuD,+FAA+F,yDAAyD;AAChf,iHAAiH,oBAAoB,SAAS,kFAAkF,KAAK,gFAAgF,qBAAqB,SAAS,oEAAoE,KAAK,iFAAiF,sBAAsB,SAAS,sEAAsE,KAAK;AACvlB,uDAAuD,uBAAuB,wFAAwF,2CAA2C,oBAAoB,SAAS,gDAAgD,yNAAyN,KAAK,6DAA6D,2CAA2C,qBAAqB,SAAS,kCAAkC,+KAA+K,KAAK,gEAAgE,2CAA2C,sBAAsB,SAAS,oCAAoC,mPAAmP,KAAK,sCAAsC,GAAG;AACvyC,2FAA2F,iDAAiD,iDAAiD,iDAAiD;AAC9O,2EAA2E,mCAAmC,iEAAiE,kCAAkC,8CAA8C,0BAA0B,qDAAqD,wDAAwD,kDAAkD,kDAAkD,6BAA6B,wEAAwE,wEAAwE,wEAAwE,wEAAwE,2CAA2C,oBAAoB,OAAO,sDAAsD,8CAA8C,2CAA2C,oBAAoB,OAAO;AACvhC,sGAAsG,+BAA+B,oDAAoD,oDAAoD,oDAAoD,oDAAoD,sDAAsD;AAC3Y,8EAA8E,0CAA0C,0CAA0C,0CAA0C,0CAA0C,8DAA8D,sEAAsE,gGAAgG;AAC1d,mDAAmD,+EAA+E,uCAAuC,kCAAkC;AAC3M,yFAAyF;AACzF,8GAA8G;AAC9G,yIAAyI,sCAAsC,wCAAwC,uCAAuC,GAAG,0CAA0C,iCAAiC,uDAAuD,GAAG,8MAA8M,iCAAiC,qGAAqG,GAAG,iDAAiD,iCAAiC,8CAA8C,4GAA4G,GAAG,4CAA4C,iCAAiC,wGAAwG,GAAG;AACpoC,8QAA8Q;AAC9Q,4QAA4Q,6BAA6B;AACzS,+RAA+R;AAC/R,kGAAkG;AAClG,iGAAiG,sBAAsB;AACvH,oFAAoF;AACpF,oKAAoK;AACpK,6CAA6C,mBAAmB,eAAe,0CAA0C,gDAAgD,uEAAuE;AAChP,wCAAwC,2BAA2B,eAAe,6CAA6C,gDAAgD,GAAG;AAClL,2CAA2C,sBAAsB,wBAAwB,+BAA+B,eAAe,gGAAgG,gDAAgD,8BAA8B,uEAAuE;AAC5X,8CAA8C,kCAAkC,kEAAkE,0FAA0F,GAAG;AAC/O,qEAAqE,4OAA4O,2EAA2E,4DAA4D,yOAAyO,sFAAsF,aAAa;AACpwB,sQAAsQ,2aAA2a;AACjrB,0EAA0E,6BAA6B,4BAA4B,8BAA8B,+LAA+L,2EAA2E,0JAA0J,oEAAoE,4BAA4B,2CAA2C,GAAG;AACntB,uEAAuE,kNAAkN,4cAA4c,GAAG;AACxuB,iDAAiD,+BAA+B,kCAAkC,kDAAkD,kBAAkB,gFAAgF,yEAAyE,qDAAqD,gDAAgD,uEAAuE;AAC3f,kDAAkD,kCAAkC,kEAAkE,2DAA2D;AACjN,4CAA4C,wBAAwB,yBAAyB,0BAA0B,8BAA8B,gLAAgL,8FAA8F,cAAc,KAAK,qCAAqC,iDAAiD,qGAAqG,yDAAyD,6IAA6I;AACvzB,2CAA2C,+BAA+B,8BAA8B,wKAAwK,oEAAoE,8DAA8D,gDAAgD,kGAAkG;AACpiB,2CAA2C,wBAAwB,8CAA8C,8bAA8b,wFAAwF,wSAAwS,mHAAmH,6DAA6D,8FAA8F,wDAAwD,uFAAuF,6IAA6I;AACz9C,uVAAuV,iiBAAiiB;AACx3B,6CAA6C,wBAAwB,wBAAwB,2BAA2B,8BAA8B,iDAAiD,+BAA+B,qpBAAqpB,wFAAwF,yGAAyG,0CAA0C,sTAAsT,mHAAmH,gEAAgE,yHAAyH,0GAA0G,0DAA0D,yGAAyG,4IAA4I,uFAAuF,8KAA8K;AACt2E,kEAAkE,8BAA8B,iDAAiD,+BAA+B,6ZAA6Z,qkBAAqkB;AAClpC,4DAA4D,wBAAwB,2BAA2B,6BAA6B,8CAA8C,4TAA4T,wFAAwF,oPAAoP,8DAA8D,iCAAiC,uEAAuE,sEAAsE,uDAAuD,8CAA8C,sEAAsE,yDAAyD,6IAA6I;AAC/5C,kEAAkE,8CAA8C,0RAA0R,iQAAiQ,0SAA0S,GAAG;AACx7B,0DAA0D,wBAAwB,wBAAwB,0BAA0B,wBAAwB,2vBAA2vB,wFAAwF,yGAAyG,0CAA0C,ooBAAooB,uFAAuF,8KAA8K;AAC3gE,gEAAgE,8CAA8C,qZAAqZ,iTAAiT,+QAA+Q,qHAAqH;AACxrC,gEAAgE,wBAAwB,0BAA0B,0BAA0B,wBAAwB,8CAA8C,qCAAqC,qCAAqC,8CAA8C,kDAAkD,8BAA8B,o2BAAo2B,wFAAwF,yGAAyG,0CAA0C,4qBAA4qB,yDAAyD,8KAA8K;AAC53E,sEAAsE,8CAA8C,kDAAkD,8BAA8B,gYAAgY,iTAAiT,uEAAuE,uEAAuE,yRAAyR,yFAAyF;AACr3C,yDAAyD,2JAA2J,sDAAsD,kDAAkD,8BAA8B,wOAAwO,+MAA+M,GAAG;AACpxB,4LAA4L,sDAAsD,kDAAkD,8BAA8B,qPAAqP,6PAA6P,uEAAuE,uEAAuE,qZAAqZ,WAAW;AACl2C,wCAAwC,wBAAwB,uNAAuN,4EAA4E,iDAAiD,0KAA0K,yDAAyD,6IAA6I;AACpwB,sCAAsC,sBAAsB,4MAA4M,4IAA4I,iGAAiG,sEAAsE,0IAA0I;AACrsB,sCAAsC,wBAAwB,6MAA6M,sEAAsE,8BAA8B;AAC/W,8FAA8F,iJAAiJ;AAC/O,wCAAwC,wBAAwB,2MAA2M,4EAA4E,iDAAiD,oIAAoI,yDAAyD,kGAAkG;AACvqB,0CAA0C,sBAAsB,qKAAqK,2FAA2F,eAAe,2FAA2F,2FAA2F,kGAAkG,mDAAmD,wFAAwF,yBAAyB,kGAAkG,kGAAkG,qCAAqC,gDAAgD,kGAAkG;AACtoC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C,kBAAkB,aAAa;AAC/B,cAAc,cAAc;AAC5B,sBAAsB,uBAAuB;AAC7C,mBAAmB,cAAc;AACjC,KAAK;AACL;AACA,sBAAsB,cAAc;AACpC,KAAK;AACL;AACA,iBAAiB,cAAc;AAC/B,qBAAqB,YAAY;AACjC,uBAAuB,aAAa;AACpC,0BAA0B,cAAc;AACxC,sBAAsB;AACtB,KAAK;AACL;AACA,gBAAgB,cAAc;AAC9B,yBAAyB;AACzB,KAAK;AACL;AACA,mBAAmB,cAAc;AACjC,4BAA4B;AAC5B,KAAK;AACL;AACA,sBAAsB;AACtB,KAAK;AACL;AACA,kBAAkB,cAAc;AAChC,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB,cAAc;AAClC,sBAAsB;AACtB,KAAK;AACL;AACA,0BAA0B,cAAc;AACxC,4BAA4B,WAAW;AACvC,2BAA2B;AAC3B,KAAK;AACL;AACA,uBAAuB;AACvB,KAAK;AACL;AACA,uBAAuB;AACvB,KAAK;AACL;AACA,sBAAsB;AACtB,KAAK;AACL;AACA,qBAAqB,iBAAiB;AACtC,kBAAkB,WAAW;AAC7B,iBAAiB,cAAc;AAC/B,mBAAmB;AACnB,KAAK;AACL;AACA,4BAA4B,YAAY;AACxC,qBAAqB,YAAY;AACjC,4BAA4B;AAC5B,6BAA6B;AAC7B,yBAAyB;AACzB,0BAA0B;AAC1B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA,aAAa,EAAE;AACf,+BAA+B,YAAY;AAC3C,kCAAkC,YAAY;AAC9C,qBAAqB;AACrB,yBAAyB;AACzB,4BAA4B;AAC5B,6BAA6B;AAC7B,4BAA4B;AAC5B,2BAA2B;AAC3B,+BAA+B;AAC/B,yBAAyB;AACzB,0BAA0B;AAC1B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA,aAAa,EAAE;AACf,wBAAwB,YAAY;AACpC,2BAA2B,YAAY;AACvC,sBAAsB;AACtB,yBAAyB;AACzB,4BAA4B;AAC5B,yBAAyB;AACzB,4BAA4B;AAC5B,0BAA0B;AAC1B,8BAA8B;AAC9B,gCAAgC;AAChC,iCAAiC;AACjC,oCAAoC;AACpC;AACA,aAAa,EAAE;AACf,yBAAyB,YAAY;AACrC,4BAA4B,YAAY;AACxC,2BAA2B;AAC3B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,aAAa,EAAE;AACf;AACA,yBAAyB;AACzB,yBAAyB;AACzB,4BAA4B;AAC5B,yBAAyB;AACzB;AACA,aAAa;AACb,KAAK;AACL;AACA,kBAAkB,6BAA6B;AAC/C,kBAAkB,aAAa;AAC/B,eAAe,aAAa;AAC5B,gBAAgB,aAAa;AAC7B,cAAc,cAAc;AAC5B,sBAAsB;AACtB,KAAK;AACL;AACA,kBAAkB,6BAA6B;AAC/C,kBAAkB,aAAa;AAC/B,iBAAiB,+BAA+B;AAChD,mBAAmB,aAAa;AAChC,cAAc,cAAc;AAC5B,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,2BAA2B,6BAA6B;AACxD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,4BAA4B,aAAa;AACzC,4BAA4B,aAAa;AACzC,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,2BAA2B,WAAW;AACtC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,uBAAuB;AACjD,kBAAkB,cAAc;AAChC,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,oBAAoB,YAAY;AAChC,sBAAsB;AACtB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,cAAc;AACtC,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D,+BAA+B,WAAW;AAC1C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD,0BAA0B;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yLAAyL;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,uCAAuC;AACvC,uCAAuC;AACvC,uCAAuC;AACvC;AACA,uCAAuC;AACvC,yCAAyC;AACzC,uCAAuC;AACvC,8CAA8C;AAC9C;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C,6CAA6C;AAC7C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2DAA2D,EAAE;AAClH;AACA;AACA;AACA,qDAAqD,sDAAsD,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAoD,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,YAAY,aAAa,eAAe,GAAG;AAC9G;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0CAA0C;AAC1C,2CAA2C;AAC3C,qCAAqC;AACrC,uCAAuC;AACvC,yCAAyC;AACzC,qCAAqC;AACrC,mCAAmC;AACnC,+BAA+B;AAC/B;AACA,qCAAqC;AACrC;AACA;AACA,mCAAmC;AACnC;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA,kDAAkD,oBAAoB;AACtE,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAA2C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,6EAA6E;AAC7E,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,6BAA6B,qCAAqC;AAClE;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kCAAkC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,kCAAkC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAmD;AAC9E;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D,+BAA+B,OAAO;AACtC;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,iDAAiD;AACjD,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA,uCAAuC,0CAA0C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,qCAAqC;AACrC,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK,yBAAyB;AACnD,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA,KAAK;AACL;AACA,oCAAoC;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA,uDAAuD,aAAa;AACpE;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA,+CAA+C,sCAAsC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC,iCAAiC,EAAE;AACnC,iCAAiC,EAAE;AACnC;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,sDAAsD;AACtD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,+DAA+D;AAC/D;AACA,8DAA8D;AAC9D;AACA,KAAK;AACL;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA,KAAK;AACL;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA,KAAK;AACL;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,wCAAwC,EAAE;AAC1C,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA,aAAa;AACb;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAwD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kCAAkC;AAClC,yCAAyC,SAAS;AAClD;AACA;AACA,qBAAqB;AACrB,2BAA2B,aAAa;AACxC,wBAAwB;AACxB,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,4BAA4B;AAC5B,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wBAAwB;AACxB,wBAAwB;AACxB,mCAAmC;AACnC,iCAAiC;AACjC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB,6BAA6B;AAC7B,+BAA+B;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,yCAAyC;AACzC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,mDAAmD;AACnD,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iCAAiC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qFAAqF;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gFAAgF;;AAEzI;AACA;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6BAA6B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAyC;AAC1D,wBAAwB;AACxB,SAAS;AACT;AACA,kCAAkC;AAClC,0BAA0B;AAC1B,2DAA2D;AAC3D,uFAAuF;AACvF,cAAc;AACd;AACA;AACA;AACA,+EAA+E;AAC/E;AACA,uEAAuE;AACvE,cAAc;AACd,+CAA+C;AAC/C;AACA,oEAAoE;AACpE;AACA,wBAAwB;AACxB;AACA,cAAc;AACd;AACA,oFAAoF;AACpF;AACA,6DAA6D;AAC7D;AACA,2DAA2D;AAC3D;AACA,iEAAiE;AACjE,iEAAiE;AACjE,iEAAiE;AACjE;AACA,qEAAqE;AACrE,qEAAqE;AACrE,8EAA8E;AAC9E,qEAAqE;AACrE,2EAA2E;AAC3E,4BAA4B;AAC5B,cAAc;AACd,kCAAkC;AAClC,qCAAqC;AACrC,kCAAkC;AAClC,0BAA0B;AAC1B,iDAAiD;AACjD,iFAAiF;AACjF,qEAAqE;AACrE,0EAA0E;AAC1E,8DAA8D;AAC9D,wDAAwD;AACxD,cAAc;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iCAAiC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,wDAAwD,mEAAmE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wEAAwE,6CAA6C;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,4CAA4C;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,4CAA4C;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6DAA6D,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,kBAAkB,mFAAmF,kDAAkD,GAAG,EAAE;AACnT,2DAA2D,kBAAkB,mDAAmD,+EAA+E,GAAG,EAAE;AACpN;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC,+BAA+B,aAAa;AAC5C,8BAA8B,YAAY;AAC1C,+BAA+B,aAAa;AAC5C,oCAAoC,kBAAkB;AACtD,iDAAiD,sCAAsC;AACvF;AACA;AACA,oBAAoB,aAAa;AACjC,oBAAoB,eAAe;AACnC,oBAAoB,cAAc;AAClC,oBAAoB,eAAe;AACnC,oBAAoB;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA,gBAAgB,iBAAiB;AACjC,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,iBAAiB,iBAAiB;AAClC,qBAAqB,8BAA8B;AACnD,mBAAmB,eAAe;AAClC,iBAAiB,iBAAiB;AAClC,gBAAgB,iBAAiB;AACjC,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sDAAsD,+CAA+C;AACrG,KAAK;AACL;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E,KAAK;AACL;AACA;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,yBAAyB,6BAA6B;AACtD,2BAA2B,6BAA6B;AACxD,qBAAqB,8BAA8B;AACnD,gBAAgB,6BAA6B;AAC7C,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B,EAAE;AAChC;AACA,oCAAoC,EAAE;AACtC;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,yBAAyB,iBAAiB;AAC1C,uBAAuB,mCAAmC;AAC1D,uBAAuB,mCAAmC;AAC1D,qBAAqB,8BAA8B;AACnD,wBAAwB;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B,EAAE;AAChC;AACA,oCAAoC,EAAE;AACtC;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY,EAAE;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC,kCAAkC;AAClC,mCAAmC;AACnC,sCAAsC;AACtC;AACA,qCAAqC;AACrC,qCAAqC;AACrC,gCAAgC;AAChC,mCAAmC;AACnC,2CAA2C;AAC3C;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,qCAAqC;AACrC;AACA,+CAA+C;AAC/C;AACA,uCAAuC;AACvC,iCAAiC;AACjC,oCAAoC;AACpC,4BAA4B;AAC5B;AACA,cAAc;AACd;AACA,0BAA0B;AAC1B;AACA,4DAA4D;AAC5D;AACA,iDAAiD;AACjD,0BAA0B;AAC1B;AACA,6DAA6D;AAC7D,gEAAgE;AAChE,0DAA0D;AAC1D,sDAAsD;AACtD;AACA,8DAA8D;AAC9D,qDAAqD;AACrD,qDAAqD;AACrD;AACA,6CAA6C;AAC7C;AACA,0BAA0B;AAC1B,6EAA6E;AAC7E,kFAAkF;AAClF,uBAAuB;AACvB,+DAA+D;AAC/D,+DAA+D;AAC/D,oDAAoD;AACpD;AACA,yDAAyD;AACzD,wDAAwD;AACxD,uFAAuF;AACvF;AACA,kBAAkB;AAClB;AACA,qFAAqF;AACrF,6DAA6D;AAC7D,qCAAqC;AACrC,4CAA4C;AAC5C,8CAA8C;AAC9C,kDAAkD;AAClD,uFAAuF;AACvF,kBAAkB;AAClB;AACA,sDAAsD;AACtD;AACA,6CAA6C;AAC7C;AACA;AACA,2GAA2G;AAC3G;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,wCAAwC;AACxC,kCAAkC;AAClC,uCAAuC;AACvC,mCAAmC;AACnC,qCAAqC;AACrC,sCAAsC;AACtC,qCAAqC;AACrC,sCAAsC;AACtC,qCAAqC;AACrC,iCAAiC;AACjC;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,qCAAqC;AACrC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iCAAiC;AACjC,wEAAwE;AACxE,sFAAsF;AACtF,+CAA+C;AAC/C,qCAAqC;AACrC,mGAAmG;AACnG,kBAAkB;AAClB,kCAAkC;AAClC,+DAA+D;AAC/D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,0CAA0C;AAC1C,gCAAgC,WAAW;AAC3C,0BAA0B,cAAc;AACxC,6BAA6B,WAAW;AACxC,+BAA+B,cAAc;AAC7C,kCAAkC,WAAW;AAC7C,4BAA4B,mCAAmC;AAC/D,8BAA8B,WAAW;AACzC,iCAAiC,iCAAiC;AAClE,sCAAsC,WAAW;AACjD,gCAAgC,WAAW;AAC3C,iCAAiC,WAAW;AAC5C,gCAAgC,aAAa;AAC7C,8BAA8B,WAAW;AACzC,iCAAiC,WAAW;AAC5C,gCAAgC,WAAW;AAC3C,6BAA6B,iCAAiC;AAC9D,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,gBAAgB,kCAAkC;AAClD,gBAAgB,iBAAiB;AACjC,kBAAkB,iCAAiC;AACnD,8BAA8B;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,EAAE;AAChC,oCAAoC,EAAE;AACtC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAsC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAsC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAsC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,gBAAgB,kCAAkC;AAClD,uBAAuB,mCAAmC;AAC1D,yBAAyB,+BAA+B;AACxD,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,EAAE;AAChC,oCAAoC,EAAE;AACtC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,EAAE;AACzB,yBAAyB;AACzB,CAAC;AACD;AACA;AACA,YAAY,qCAAqC;AACjD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,oBAAoB,wCAAwC;AAC5D,iBAAiB,2DAA2D;AAC5E,2BAA2B,iBAAiB;AAC5C,uBAAuB,6BAA6B;AACpD,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,0CAA0C,EAAE;AACxH,iFAAiF,uCAAuC,EAAE;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,yCAAyC,EAAE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC,eAAe,0CAA0C;AACzD,sBAAsB,wBAAwB;AAC9C,mCAAmC,gBAAgB;AACnD,mBAAmB,cAAc;AACjC,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,iBAAiB,iBAAiB;AAClC,qBAAqB,8BAA8B;AACnD,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;AAC/B,oBAAoB,iBAAiB;AACrC,iBAAiB,iBAAiB;AAClC,gBAAgB,iBAAiB;AACjC,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D,8CAA8C;AACxG;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E,KAAK;AACL;AACA;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C,2BAA2B;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,EAAE;AAChC,oCAAoC,EAAE;AACtC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,uBAAuB,kBAAkB;AACzC,qBAAqB,8BAA8B;AACnD,gBAAgB,6BAA6B;AAC7C,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D,8CAA8C;AACxG;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,uBAAuB,kBAAkB;AACzC,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,iDAAiD,cAAc;AAC/D,KAAK;AACL;AACA;AACA,iDAAiD,eAAe;AAChE,KAAK;AACL;AACA;AACA,4DAA4D;AAC5D;AACA,KAAK;AACL;AACA;AACA,0DAA0D;AAC1D;AACA,KAAK;AACL;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD,qBAAqB,kBAAkB;AACvC,0BAA0B,aAAa;AACvC,0BAA0B,eAAe;AACzC,wBAAwB,eAAe;AACvC,wBAAwB,eAAe;AACvC,kBAAkB,gBAAgB;AAClC,wBAAwB,gBAAgB;AACxC,qBAAqB,gBAAgB;AACrC,oBAAoB,gBAAgB;AACpC,uBAAuB,gBAAgB;AACvC,qBAAqB,gBAAgB;AACrC,sBAAsB,aAAa;AACnC,0BAA0B,oCAAoC;AAC9D,sBAAsB,gBAAgB;AACtC,2BAA2B,qDAAqD;AAChF,wBAAwB,cAAc;AACtC,0BAA0B,qCAAqC;AAC/D,sBAAsB,aAAa;AACnC,qBAAqB,8BAA8B;AACnD,wBAAwB,aAAa;AACrC,mBAAmB,aAAa;AAChC,sBAAsB,gBAAgB;AACtC,6BAA6B,iBAAiB;AAC9C,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,8BAA8B,EAAE;AAChC;AACA,oCAAoC,EAAE;AACtC;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B,EAAE;AAChC;AACA,oCAAoC,EAAE;AACtC;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD,0BAA0B,eAAe;AACzC,wBAAwB,eAAe;AACvC,+BAA+B,eAAe;AAC9C,kBAAkB,iCAAiC;AACnD,sBAAsB,gCAAgC;AACtD,sBAAsB,6BAA6B;AACnD,gBAAgB,kCAAkC;AAClD,mBAAmB,kCAAkC;AACrD,iBAAiB,kCAAkC;AACnD,mBAAmB,+BAA+B;AAClD,sBAAsB,+BAA+B;AACrD,uBAAuB,6BAA6B;AACpD,qBAAqB,6BAA6B;AAClD,oBAAoB,6BAA6B;AACjD,sBAAsB,6BAA6B;AACnD,uBAAuB,iCAAiC;AACxD,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC,sBAAsB,iBAAiB;AACvC,qBAAqB,8BAA8B;AACnD,sBAAsB,iBAAiB;AACvC,4BAA4B,iBAAiB;AAC7C,cAAc,iBAAiB;AAC/B,oBAAoB,kBAAkB;AACtC,sBAAsB,iBAAiB;AACvC,6BAA6B,iBAAiB;AAC9C,4BAA4B;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,8IAA8I,gEAAgE;AAC9M;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,kBAAkB;AAClB,2BAA2B;AAC3B,2BAA2B;AAC3B,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC,oCAAoC;AACpC;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,2BAA2B;AAC3B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB,oBAAoB;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wBAAwB,2DAAC,cAAc,0DAA0D,EAAE,2DAAC,cAAc,sJAAsJ,oFAAoF,8GAA8G,iBAAiB,EAAE,2DAAC,cAAc,yEAAyE,iCAAiC,kCAAkC,qCAAqC,mCAAmC,oPAAoP,+DAA+D,8EAA8E,iDAAiD,IAAI,2DAAC,cAAc,gJAAgJ,yEAAyE,yEAAyE,yEAAyE,yCAAyC,yCAAyC,uCAAuC,6CAA6C,mBAAmB;AACzqD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAC,cAAc,+JAA+J,qCAAqC,oDAAoD,wFAAwF,sCAAsC,gBAAgB,EAAE,EAAE;AACjb;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAC,cAAc,qIAAqI,qCAAqC,oDAAoD,sCAAsC,gBAAgB,EAAE,EAAE;AAC/T;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAC,cAAc,qIAAqI,qCAAqC,oDAAoD,sCAAsC,gBAAgB,EAAE,EAAE;AAC/T;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAC,cAAc,yDAAyD,EAAE,2DAAC,cAAc,kJAAkJ,oFAAoF,2GAA2G,iBAAiB,EAAE,2DAAC,cAAc,wEAAwE,iCAAiC,kCAAkC,qCAAqC,mCAAmC,mPAAmP,6DAA6D,4EAA4E,iDAAiD,IAAI,2DAAC,cAAc,yIAAyI,gDAAgD,gDAAgD,0DAA0D,yCAAyC,2CAA2C,6CAA6C,mBAAmB;AAC9iD;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,YAAY,2DAAC,cAAc,4CAA4C,kCAAkC,uCAAuC;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,cAAc,yDAAyD,EAAE,2DAAC,cAAc,4HAA4H,oFAAoF,qIAAqI,iBAAiB,EAAE,2DAAC,cAAc,oDAAoD,+BAA+B,gCAAgC,mCAAmC,iCAAiC,iEAAiE,6CAA6C,4NAA4N,4EAA4E,wFAAwF,GAAG,IAAI,2DAAC,cAAc,sHAAsH,wDAAwD,mDAAmD,sFAAsF,GAAG;AACz9C,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,iBAAiB,qPAAqP,mDAAmD,+CAA+C,mDAAmD,uCAAuC,+CAA+C,2CAA2C,kCAAkC,mDAAmD,mDAAmD,uDAAuD,uCAAuC,2CAA2C,uGAAuG,gBAAgB,EAAE,EAAE;AAC77B;AACA;AACA,oBAAoB,2DAAC,iBAAiB,0KAA0K,mDAAmD,+CAA+C,mDAAmD,uCAAuC,+CAA+C,2CAA2C,kCAAkC,mDAAmD,mDAAmD,uDAAuD,uCAAuC,2CAA2C,uGAAuG,gBAAgB,EAAE,EAAE;AACl3B;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,2DAAC,aAAa,0DAA0D,0BAA0B,iCAAiC,wBAAwB,8DAA8D,gBAAgB,EAAE,EAAE;AACzP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAC,cAAc,oGAAoG,6EAA6E,6DAA6D,sGAAsG,2EAA2E,gBAAgB,EAAE,EAAE;AAC9d;AACA;AACA,4BAA4B,2DAAC,cAAc,yHAAyH,sFAAsF,mDAAmD,mDAAmD,yDAAyD,mCAAmC,+CAA+C,mDAAmD,iEAAiE,+DAA+D,2DAA2D,gBAAgB,EAAE,EAAE;AAC7uB;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,4BAA4B,2DAAC,cAAc,yFAAyF,mDAAmD,mDAAmD,yDAAyD,mCAAmC,+CAA+C,mDAAmD,iEAAiE,+DAA+D,2DAA2D,gBAAgB,EAAE,EAAE;AACvnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAC,iBAAiB,8OAA8O,mCAAmC,+CAA+C,iDAAiD,+CAA+C,2CAA2C,yCAAyC,+CAA+C,0DAA0D,mDAAmD,uDAAuD,uCAAuC,yGAAyG,gBAAgB,EAAE,EAAE;AACj5B;AACA;AACA,oBAAoB,2DAAC,iBAAiB,mKAAmK,mCAAmC,+CAA+C,iDAAiD,+CAA+C,2CAA2C,yCAAyC,+CAA+C,0DAA0D,mDAAmD,uDAAuD,uCAAuC,yGAAyG,gBAAgB,EAAE,EAAE;AACt0B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,qCAAqC,wCAAwC;AAC7E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,qCAAqC,wCAAwC;AAC7E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,mDAAmD,wCAAwC;AAC3F;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,4CAA4C,wCAAwC;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,4CAA4C,wCAAwC;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,8CAA8C,wCAAwC;AACtF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,4CAA4C,wCAAwC;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,+CAA+C,wCAAwC;AACvF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,4CAA4C,wCAAwC;AACpF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,kDAAkD,wCAAwC;AAC1F;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,mDAAmD,wCAAwC;AAC3F;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,uCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,gDAAgD,wCAAwC;AACxF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL,CAAC,EAAE,GAAG;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAA6B;AACtC;AACA;AACA,KAAK,EAEJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,SAAS;AACtB;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,4BAA4B;AAC5B;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC,UAAU,iGAAiG;AAC9I;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,mCAAmC,UAAU,2BAA2B;AACxE;AACA;AACA,mCAAmC,UAAU,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC,UAAU,iGAAiG;AAC9I;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,mCAAmC,UAAU,2BAA2B;AACxE;AACA;AACA,mCAAmC,UAAU,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,mCAAmC,UAAU,mGAAmG;AAChJ;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,mCAAmC,UAAU,2BAA2B;AACxE;AACA;AACA,mCAAmC,UAAU,oBAAoB;AACjE;AACA;AACA;AACA;AACA,mCAAmC,UAAU,wGAAwG;AACrJ;AACA;AACA,mCAAmC,UAAU,gDAAgD;AAC7F;AACA;AACA,mCAAmC,UAAU,2BAA2B;AACxE;AACA;AACA,mCAAmC,UAAU,+BAA+B;AAC5E;AACA;AACA,mCAAmC,UAAU,qCAAqC;AAClF;AACA;AACA,mCAAmC,UAAU,gCAAgC;AAC7E;AACA;AACA;AACA;AACA,mCAAmC,UAAU,8BAA8B;AAC3E;AACA;AACA,mCAAmC,UAAU,iCAAiC;AAC9E;AACA;AACA,mCAAmC,UAAU,wBAAwB;AACrE;AACA;AACA,mCAAmC,UAAU,8BAA8B;AAC3E;AACA;AACA,mCAAmC,UAAU,oCAAoC;AACjF;AACA;AACA,mCAAmC,UAAU,qCAAqC;AAClF;AACA;AACA;AACA;AACA,mCAAmC,UAAU,yBAAyB,iCAAiC;AACvG;AACA;AACA,mCAAmC,UAAU,kCAAkC;AAC/E;AACA;AACA,mCAAmC,UAAU,+BAA+B;AAC5E;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,gDAAgD,qFAAqF;AACrI,kDAAkD,SAAS,2DAAC,cAAc,wBAAwB,aAAa;AAC/G;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAW;AACjC,sBAAsB,2DAAW;AACjC,qBAAqB,2DAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,2DAAC,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,4BAA4B,EAAE,2DAAC,uBAAuB,2DAAC,OAAO;AAC3E;AACA,aAAa,wYAAwY,GAAG,2DAAC,eAAe;AACxa;AACA,aAAa,kQAAkQ,IAAI,2DAAC,SAAS,iTAAiT,GAAG,2DAAC,SAAS,kXAAkX,GAAG,2DAAC,UAAU,qVAAqV;AAChzC;AACA;AACA,4BAA4B,2DAAC,mBAAmB;AAChD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8TAA8T;AAC9T;AACA;AACA,4BAA4B,2DAAC,eAAe;AAC5C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAiJ;AACjJ;AACA;AACA;AACA;AACA;AACA,SAAS,KAAK,2DAAC,UAAU,uHAAuH;AAChJ;AACA;AACA,gBAAgB,2DAAC,SAAS;AAC1B;AACA;AACA,aAAa,EAAE,EAAE,2DAAC,SAAS,sBAAsB,EAAE,2DAAC,SAAS,gBAAgB,UAAU,2DAAC,SAAS,qBAAqB,GAAG,2DAAC,SAAS,gBAAgB,gEAAgE,2DAAC,SAAS,gBAAgB,EAAE,2DAAC,SAAS,kBAAkB;AAC3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uBAAuB;AAC9F;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB,kBAAkB,uBAAuB,sBAAsB,cAAc,WAAW,YAAY,2BAA2B,0DAA0D,6BAA6B,4DAA4D,6BAA6B,4DAA4D,6BAA6B,aAAa,kCAAkC,kBAAkB,mBAAmB,mBAAmB,mGAAmG,sBAAsB,qBAAqB,2DAA2D,uBAAuB,kBAAkB,SAAS,qBAAqB,+BAA+B,mBAAmB,WAAW,YAAY,2DAA2D,wDAAwD,mDAAmD,gHAAgH,2CAA2C,mCAAmC,GAAG,qCAAqC,IAAI,qDAAqD,GAAG,sEAAsE,2BAA2B,GAAG,yDAAyD,iEAAiE,IAAI,8DAA8D,sEAAsE,GAAG,iEAAiE,0EAA0E,EAAE,EAAE;AACzzD;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,+BAA+B,2DAAU;AACzC,qBAAqB,mDAAM;AAC3B,oBAAoB,yLAAiC,yBAAyB,6BAA6B,mDAAM,EAAE,EAAE;AACrH;AACA,oBAAoB,mDAAM;AAC1B,oBAAoB,2LAAkC,yBAAyB,gCAAgC,EAAE;AACjH;AACA,oBAAoB,mDAAM;AAC1B,oBAAoB,6LAAmC,yBAAyB,+BAA+B,mDAAM,EAAE,EAAE;AACzH;AACA,oBAAoB,mDAAM;AAC1B,oBAAoB,8MAA4C,yBAAyB,yCAAyC,EAAE;AACpI;AACA,gBAAgB,gMAAqC,yBAAyB,mCAAmC,EAAE;AACnH,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,gBAAgB;AACzC;AACA;AACA,gDAAgD,mDAAM;AACtD,qBAAqB;AACrB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,iCAAiC,yBAAyB,sBAAsB,qBAAqB,iBAAiB,gCAAgC,yBAAyB,EAAE,EAAE;AAC7M;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,WAAW,2DAAU,mBAAmB,2DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAO;AACvB;AACA,qBAAqB,8DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAW;AACnC,uBAAuB,2DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,4GAA4G,EAAE,4DAAoB,kBAAkB,qaAAqa,EAAE,2DAAC,0BAA0B,UAAU,yFAAyF,GAAG,2DAAC,UAAU,wBAAwB,EAAE,2DAAC,UAAU,oBAAoB,GAAG,2DAAC,UAAU,gBAAgB,GAAG,2DAAC,gBAAgB,2DAAC,UAAU,cAAc,qBAAqB,2DAAC,uBAAuB,wBAAwB;AACz6B;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,kBAAkB,4BAA4B,uBAAuB,uBAAuB,uBAAuB,sBAAsB,kBAAkB,qBAAqB,WAAW,mBAAmB,2CAA2C,kBAAkB,qBAAqB,uBAAuB,mBAAmB,yBAAyB,sBAAsB,qBAAqB,iBAAiB,mBAAmB,uCAAuC,oBAAoB,0BAA0B,kBAAkB,wBAAwB,aAAa,oBAAoB,uCAAuC,eAAe,oBAAoB,qBAAqB,8CAA8C,4DAA4D,yDAAyD,+CAA+C,yDAAyD,uDAAuD,8CAA8C,iCAAiC,gCAAgC,0DAA0D,kCAAkC,uBAAuB,gDAAgD,yBAAyB,yCAAyC,iDAAiD,gDAAgD,mCAAmC,uBAAuB,4BAA4B,4DAA4D,8CAA8C,4BAA4B,qBAAqB,iBAAiB,yBAAyB,yCAAyC,8CAA8C,uBAAuB,4BAA4B,0DAA0D,8CAA8C,4BAA4B,wDAAwD,uBAAuB,qBAAqB,cAAc,oCAAoC,cAAc,eAAe,cAAc,WAAW,WAAW,gBAAgB,0CAA0C,WAAW,oBAAoB,cAAc,mCAAmC,cAAc,eAAe,cAAc,WAAW,gBAAgB,sDAAsD,gBAAgB,qBAAqB,oBAAoB,eAAe,mCAAmC,kCAAkC,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,kCAAkC,iCAAiC,+BAA+B,qCAAqC,oBAAoB,kBAAkB,mBAAmB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,uBAAuB,mBAAmB,oBAAoB,cAAc,cAAc,kBAAkB,WAAW,YAAY,qCAAqC,6BAA6B,iCAAiC,iCAAiC,iCAAiC,aAAa,6BAA6B,cAAc,qCAAqC,6BAA6B,qBAAqB,eAAe,uBAAuB,yBAAyB,UAAU,8BAA8B,sBAAsB,wBAAwB,qBAAqB,gBAAgB,6FAA6F,eAAe,mBAAmB,oBAAoB,2CAA2C,0CAA0C,uCAAuC,uCAAuC,iCAAiC,SAAS,cAAc,oBAAoB,aAAa,yBAAyB,qBAAqB,oBAAoB,cAAc,sBAAsB,mBAAmB,qBAAqB,uBAAuB,WAAW,YAAY,oBAAoB,gBAAgB,oBAAoB,gCAAgC,kBAAkB,kBAAkB,aAAa,gBAAgB,6FAA6F,gCAAgC,kBAAkB,mBAAmB,2BAA2B,0BAA0B,wBAAwB,wBAAwB,8BAA8B,iBAAiB,mBAAmB,aAAa,gBAAgB,6FAA6F,8BAA8B,kBAAkB,mBAAmB,0BAA0B,yBAAyB,yBAAyB,yBAAyB,oCAAoC,gBAAgB,kBAAkB,0BAA0B,mCAAmC,qCAAqC,2BAA2B,iCAAiC,uCAAuC,6BAA6B,0BAA0B,6BAA6B,mCAAmC,0BAA0B,MAAM,qBAAqB,gBAAgB,mBAAmB,oBAAoB,kBAAkB,mDAAmD,gBAAgB,iBAAiB,eAAe,kBAAkB,aAAa,eAAe,gBAAgB,sBAAsB,6FAA6F,MAAM,kBAAkB,mBAAmB,yBAAyB,wBAAwB,uBAAuB,uBAAuB,qBAAqB,8DAA8D,+BAA+B,YAAY,wDAAwD,kCAAkC,uBAAuB,qBAAqB,mBAAmB,qBAAqB,wDAAwD,uEAAuE,yDAAyD,0DAA0D,iCAAiC,gCAAgC,+BAA+B,cAAc,qBAAqB,mCAAmC,uEAAuE,mDAAmD,iDAAiD,qBAAqB,qBAAqB,gBAAgB,oBAAoB,kBAAkB,mBAAmB,aAAa,eAAe,qBAAqB,oBAAoB,gBAAgB,sBAAsB,oBAAoB,mBAAmB,aAAa,eAAe,qBAAqB,qBAAqB,gBAAgB,qBAAqB,mBAAmB,mBAAmB,sBAAsB,gBAAgB,0BAA0B,2BAA2B,cAAc,wDAAwD,cAAc,0BAA0B,6CAA6C,mCAAmC,wBAAwB,+CAA+C,sCAAsC,EAAE,EAAE;AACv8O;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8BAA8B,oCAAoC,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wCAAwC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,2CAA2C,gEAAgE,kHAAkH;AACtP,cAAc,2DAAC,SAAS,kDAAkD;AAC1E,cAAc,2DAAC,SAAS,sBAAsB;AAC9C;AACA;AACA,0BAA0B,gBAAgB,EAAE;AAC5C;AACA;AACA,KAAK;AACL;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,qBAAqB,UAAU,WAAW,eAAe,kBAAkB,yCAAyC,iCAAiC,gBAAgB,cAAc,YAAY,WAAW,6BAA6B,6BAA6B,qBAAqB,mBAAmB,yBAAyB,mBAAmB,yBAAyB,kBAAkB,sCAAsC,0BAA0B,kDAAkD,4BAA4B,oDAAoD,2BAA2B,mDAAmD,0BAA0B,kDAAkD,0BAA0B,kDAAkD,yBAAyB,iDAAiD,wBAAwB,gDAAgD,yBAAyB,iDAAiD,uBAAuB,+CAA+C,EAAE,EAAE;AAC1nC;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,WAAW,2DAAO;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAW;AACnC,yBAAyB,2DAAW;AACpC,uBAAuB,2DAAW;AAClC,wBAAwB,2DAAW;AACnC,+BAA+B,2DAAW;AAC1C,iCAAiC,2DAAW;AAC5C,wBAAwB,2DAAW;AACnC;AACA;AACA,yBAAyB,8DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA,oBAAoB,8DAAa;AACjC;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sFAAsF,EAAE,4DAAoB,uBAAuB,6FAA6F,EAAE,2DAAC,WAAW,+CAA+C,oCAAoC,EAAE,+oBAA+oB,4DAA4D,2DAAC,YAAY,iIAAiI;AACrrC;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,6BAA6B,4BAA4B,iCAAiC,kCAAkC,yBAAyB,gBAAgB,gBAAgB,mBAAmB,yBAAyB,gBAAgB,oBAAoB,aAAa,kBAAkB,WAAW,OAAO,sBAAsB,mBAAmB,WAAW,oBAAoB,6BAA6B,mBAAmB,2CAA2C,UAAU,4FAA4F,kBAAkB,8BAA8B,4BAA4B,+BAA+B,mCAAmC,kCAAkC,iCAAiC,+BAA+B,qCAAqC,oBAAoB,kBAAkB,mBAAmB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,uBAAuB,mBAAmB,oBAAoB,cAAc,qBAAqB,WAAW,OAAO,WAAW,eAAe,gBAAgB,SAAS,aAAa,uBAAuB,8BAA8B,sBAAsB,wBAAwB,qBAAqB,gBAAgB,6FAA6F,+BAA+B,mBAAmB,oBAAoB,2CAA2C,0CAA0C,uCAAuC,uCAAuC,0DAA0D,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,iDAAiD,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,qDAAqD,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,sDAAsD,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,4CAA4C,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,gDAAgD,6BAA6B,uCAAuC,wBAAwB,gBAAgB,0CAA0C,aAAa,yCAAyC,WAAW,+BAA+B,OAAO,MAAM,kBAAkB,oBAAoB,qLAAqL,WAAW,YAAY,QAAQ,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,eAAe,gBAAgB,cAAc,iBAAiB,wBAAwB,SAAS,aAAa,6BAA6B,4BAA4B,kBAAkB,wBAAwB,qBAAqB,gBAAgB,2EAA2E,mBAAmB,8BAA8B,oBAAoB,8JAA8J,oBAAoB,oBAAoB,mBAAmB,kBAAkB,sBAAsB,kBAAkB,kBAAkB,mKAAmK,kBAAkB,qBAAqB,oBAAoB,mCAAmC,0CAA0C,2ZAA2Z,WAAW,YAAY,qBAAqB,EAAE,EAAE;AAC9vJ;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,+FAA+F,gBAAgB,4DAAoB,sBAAsB,eAAe,oHAAoH,4DAAW,gJAAgJ,EAAE,2DAAC,0BAA0B,UAAU,mEAAmE,QAAQ,4DAAO,4BAA4B,EAAE,EAAE,GAAG,2DAAC,UAAU,gBAAgB,GAAG,2DAAC,SAAS,sBAAsB,EAAE,2DAAC,SAAS,yBAAyB,EAAE,2DAAC,iBAAiB,2DAAC,UAAU,cAAc,iBAAiB,2DAAC,cAAc,2DAA2D,GAAG,2DAAC,SAAS,gCAAgC,oCAAoC,2DAAC,8BAA8B,2DAAC,SAAS,0BAA0B;AAC3+B;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,oBAAoB,mBAAmB,qBAAqB,kBAAkB,qBAAqB,kBAAkB,oBAAoB,kBAAkB,yBAAyB,wBAAwB,2BAA2B,0BAA0B,wBAAwB,wBAAwB,wBAAwB,yBAAyB,4BAA4B,6BAA6B,2BAA2B,+BAA+B,6BAA6B,2BAA2B,iEAAiE,kCAAkC,mCAAmC,cAAc,kBAAkB,aAAa,mBAAmB,2CAA2C,mBAAmB,qBAAqB,8BAA8B,sBAAsB,gBAAgB,+BAA+B,iCAAiC,gCAAgC,6DAA6D,oCAAoC,iCAAiC,qCAAqC,2BAA2B,2CAA2C,kCAAkC,gCAAgC,0BAA0B,2CAA2C,mCAAmC,yBAAyB,qDAAqD,iCAAiC,iCAAiC,+BAA+B,uCAAuC,6BAA6B,mFAAmF,eAAe,oBAAoB,sBAAsB,WAAW,aAAa,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,yEAAyE,iCAAiC,+BAA+B,qCAAqC,oBAAoB,kBAAkB,mBAAmB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,uBAAuB,mBAAmB,oBAAoB,cAAc,oBAAoB,aAAa,kBAAkB,sBAAsB,mBAAmB,sBAAsB,8BAA8B,WAAW,6BAA6B,qCAAqC,6BAA6B,iCAAiC,iCAAiC,iCAAiC,aAAa,6BAA6B,qCAAqC,6BAA6B,iBAAiB,8BAA8B,sBAAsB,6FAA6F,aAAa,mBAAmB,oBAAoB,kFAAkF,iFAAiF,uCAAuC,uCAAuC,+BAA+B,SAAS,SAAS,eAAe,yBAAyB,sBAAsB,qBAAqB,iBAAiB,uBAAuB,YAAY,cAAc,eAAe,aAAa,gBAAgB,wCAAwC,+EAA+E,qCAAqC,2CAA2C,oBAAoB,aAAa,kBAAkB,WAAW,OAAO,2BAA2B,uBAAuB,uBAAuB,oBAAoB,4BAA4B,mBAAmB,mBAAmB,uCAAuC,iCAAiC,iCAAiC,2CAA2C,mCAAmC,iBAAiB,8BAA8B,sBAAsB,6FAA6F,YAAY,mBAAmB,oBAAoB,iDAAiD,gDAAgD,qFAAqF,qFAAqF,kBAAkB,+BAA+B,uCAAuC,mCAAmC,oBAAoB,gBAAgB,sBAAsB,eAAe,kBAAkB,iBAAiB,eAAe,UAAU,qBAAqB,WAAW,OAAO,+CAA+C,qBAAqB,uBAAuB,eAAe,oBAAoB,aAAa,WAAW,OAAO,2BAA2B,uBAAuB,uBAAuB,oBAAoB,4BAA4B,mBAAmB,uBAAuB,gBAAgB,8BAA8B,sBAAsB,iFAAiF,qBAAqB,kBAAkB,qFAAqF,WAAW,OAAO,0BAA0B,sBAAsB,sCAAsC,OAAO,QAAQ,SAAS,kBAAkB,uCAAuC,gBAAgB,oCAAoC,sBAAsB,qCAAqC,yFAAyF,mFAAmF,qFAAqF,wCAAwC,sDAAsD,mCAAmC,oDAAoD,qCAAqC,sDAAsD,mGAAmG,kBAAkB,4BAA4B,mBAAmB,WAAW,eAAe,uGAAuG,kBAAkB,WAAW,+MAA+M,kBAAkB,sBAAsB,uBAAuB,oBAAoB,6BAA6B,aAAa,gBAAgB,kBAAkB,0BAA0B,MAAM,kBAAkB,2CAA2C,qBAAqB,wBAAwB,wCAAwC,yEAAyE,8FAA8F,0FAA0F,+FAA+F,sGAAsG,yDAAyD,qBAAqB,2DAA2D,yDAAyD,0DAA0D,eAAe,kBAAkB,kBAAkB,yCAAyC,kCAAkC,gCAAgC,0BAA0B,qDAAqD,uCAAuC,6BAA6B,+DAA+D,kCAAkC,iCAAiC,yBAAyB,wBAAwB,yBAAyB,wBAAwB,kCAAkC,wBAAwB,yBAAyB,yBAAyB,wCAAwC,wBAAwB,yBAAyB,iDAAiD,mBAAmB,wBAAwB,gDAAgD,yBAAyB,yBAAyB,wBAAwB,cAAc,kBAAkB,eAAe,kBAAkB,6FAA6F,wBAAwB,kBAAkB,mBAAmB,uBAAuB,sBAAsB,wBAAwB,wBAAwB,sBAAsB,gBAAgB,iBAAiB,6FAA6F,sBAAsB,kBAAkB,mBAAmB,yBAAyB,wBAAwB,uBAAuB,uBAAuB,8DAA8D,cAAc,eAAe,kBAAkB,6FAA6F,8DAA8D,kBAAkB,uBAAuB,uBAAuB,kEAAkE,cAAc,eAAe,aAAa,gBAAgB,mGAAmG,eAAe,kBAAkB,yBAAyB,kBAAkB,qBAAqB,qBAAqB,mBAAmB,YAAY,eAAe,sBAAsB,WAAW,YAAY,yBAAyB,WAAW,YAAY,mEAAmE,gBAAgB,iBAAiB,eAAe,kBAAkB,6FAA6F,mEAAmE,kBAAkB,mBAAmB,yBAAyB,wBAAwB,uBAAuB,uBAAuB,iFAAiF,cAAc,6FAA6F,iFAAiF,kBAAkB,uBAAuB,uBAAuB,qBAAqB,cAAc,iBAAiB,gBAAgB,mBAAmB,6FAA6F,qBAAqB,kBAAkB,mBAAmB,uBAAuB,sBAAsB,uBAAuB,uBAAuB,uDAAuD,kBAAkB,mGAAmG,kBAAkB,qBAAqB,oBAAoB,EAAE,EAAE;AAC3wW;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sCAAsC,EAAE,4DAAoB,uBAAuB,qFAAqF,EAAE,2DAAC,UAAU,gBAAgB,GAAG,2DAAC,SAAS,8BAA8B,EAAE,2DAAC,SAAS,gCAAgC,EAAE,2DAAC,iBAAiB,2DAAC,UAAU,cAAc;AAClW;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,kBAAkB,kBAAkB,qBAAqB,oBAAoB,wBAAwB,wBAAwB,2BAA2B,0BAA0B,kCAAkC,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,yEAAyE,iCAAiC,+BAA+B,qCAAqC,oBAAoB,aAAa,sBAAsB,mBAAmB,sBAAsB,8BAA8B,WAAW,gBAAgB,6BAA6B,mBAAmB,2CAA2C,gBAAgB,YAAY,8BAA8B,sBAAsB,6FAA6F,MAAM,mBAAmB,oBAAoB,kFAAkF,iFAAiF,uCAAuC,uCAAuC,kBAAkB,iCAAiC,gCAAgC,4BAA4B,wBAAwB,gBAAgB,MAAM,oBAAoB,cAAc,eAAe,aAAa,gBAAgB,wCAAwC,+EAA+E,qCAAqC,2CAA2C,oBAAoB,aAAa,WAAW,OAAO,2BAA2B,uBAAuB,uBAAuB,oBAAoB,4BAA4B,mBAAmB,mBAAmB,SAAS,gBAAgB,6FAA6F,oBAAoB,mBAAmB,oBAAoB,iDAAiD,gDAAgD,qFAAqF,qFAAqF,sBAAsB,oBAAoB,aAAa,WAAW,OAAO,2BAA2B,uBAAuB,uBAAuB,oBAAoB,4BAA4B,mBAAmB,uBAAuB,gBAAgB,MAAM,8CAA8C,0CAA0C,qBAAqB,wBAAwB,gBAAgB,kBAAkB,eAAe,oBAAoB,cAAc,kBAAkB,eAAe,kBAAkB,6FAA6F,oBAAoB,kBAAkB,mBAAmB,uBAAuB,sBAAsB,wBAAwB,wBAAwB,kBAAkB,gBAAgB,iBAAiB,6FAA6F,kBAAkB,kBAAkB,mBAAmB,yBAAyB,wBAAwB,uBAAuB,uBAAuB,8DAA8D,cAAc,eAAe,kBAAkB,6FAA6F,8DAA8D,kBAAkB,uBAAuB,uBAAuB,qBAAqB,cAAc,iBAAiB,gBAAgB,mBAAmB,6FAA6F,qBAAqB,kBAAkB,mBAAmB,uBAAuB,sBAAsB,uBAAuB,uBAAuB,cAAc,eAAe,4BAA4B,cAAc,eAAe,aAAa,kBAAkB,gBAAgB,cAAc,eAAe,wDAAwD,kBAAkB,gBAAgB,qEAAqE,cAAc,eAAe,aAAa,eAAe,mBAAmB,aAAa,kBAAkB,+CAA+C,sBAAsB,iBAAiB,qJAAqJ,gBAAgB,EAAE,EAAE;AACzmJ;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sCAAsC,EAAE,4DAAoB,uBAAuB,sHAAsH;AAClO;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,6DAA6D,gBAAgB,cAAc,mBAAmB,2CAA2C,kBAAkB,uBAAuB,mBAAmB,gBAAgB,8BAA8B,sBAAsB,8BAA8B,4BAA4B,kEAAkE,mBAAmB,oJAAoJ,eAAe,WAAW,oBAAoB,gEAAgE,iBAAiB,aAAa,gBAAgB,oBAAoB,sEAAsE,6BAA6B,oBAAoB,gCAAgC,mBAAmB,eAAe,YAAY,gBAAgB,gBAAgB,sEAAsE,gBAAgB,4BAA4B,mBAAmB,WAAW,eAAe,oDAAoD,wBAAwB,gBAAgB,kEAAkE,eAAe,gBAAgB,kCAAkC,kBAAkB,iBAAiB,mCAAmC,gBAAgB,wCAAwC,gCAAgC,kCAAkC,0BAA0B,sDAAsD,8CAA8C,sCAAsC,yEAAyE,yPAAyP,mCAAmC,2BAA2B,gUAAgU,0CAA0C,kCAAkC,yBAAyB,eAAe,mDAAmD,cAAc,eAAe,aAAa,kBAAkB,gBAAgB,yBAAyB,eAAe,uGAAuG,cAAc,eAAe,aAAa,kBAAkB,eAAe,gBAAgB,mBAAmB,wBAAwB,cAAc,eAAe,aAAa,kBAAkB,eAAe,mBAAmB,sBAAsB,iBAAiB,wBAAwB,+CAA+C,4GAA4G,cAAc,4NAA4N,gBAAgB,EAAE,EAAE;AAC38G;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,kBAAkB,cAAc,eAAe,aAAa,gBAAgB,eAAe,gBAAgB,cAAc,iBAAiB,cAAc,gBAAgB,qBAAqB,oBAAoB,gCAAgC,wBAAwB,gBAAgB,UAAU,cAAc,eAAe,gBAAgB,mBAAmB,uEAAuE,qBAAqB,iBAAiB,kBAAkB,gBAAgB,mBAAmB,kBAAkB,6FAA6F,qBAAqB,kBAAkB,mBAAmB,0BAA0B,yBAAyB,wBAAwB,wBAAwB,8BAA8B,yBAAyB,uBAAuB,yCAAyC,iBAAiB,uBAAuB,yCAAyC,aAAa,2BAA2B,iBAAiB,uBAAuB,sDAAsD,4BAA4B,2BAA2B,uBAAuB,wDAAwD,kCAAkC,4BAA4B,iBAAiB,2BAA2B,uBAAuB,2BAA2B,iBAAiB,uBAAuB,EAAE,EAAE;AACv8C;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sCAAsC,EAAE,4DAAoB,uBAAuB,yBAAyB,EAAE,2DAAC;AACxI;AACA;AACA,0BAA0B,eAAe,kCAAkC,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,eAAe,gBAAgB,cAAc,iBAAiB,oBAAoB,aAAa,sBAAsB,mBAAmB,sBAAsB,8BAA8B,WAAW,gBAAgB,6BAA6B,mBAAmB,gBAAgB,kBAAkB,iCAAiC,gCAAgC,MAAM,yBAAyB,0CAA0C,yDAAyD,kBAAkB,eAAe,gBAAgB,mBAAmB,yBAAyB,6FAA6F,MAAM,mBAAmB,kEAAkE,kEAAkE,EAAE,EAAE;AAC/+B;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAK;AACtC;AACA;AACA,iCAAiC,8DAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAW;AACpC,wBAAwB,2DAAW;AACnC,wBAAwB,2DAAW;AACnC,uBAAuB,2DAAW;AAClC;AACA;AACA,yBAAyB,8DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gLAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B,EAAE;AAClF,mDAAmD,2BAA2B,EAAE;AAChF,kDAAkD,0BAA0B,EAAE;AAC9E,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,wFAAwF,EAAE,4DAAoB,uBAAuB,mCAAmC,4DAAW,qIAAqI,EAAE,2DAAC,UAAU,gBAAgB,GAAG,2DAAC,SAAS,iDAAiD,sCAAsC,EAAE,EAAE,6BAA6B,SAAS,2DAAC,SAAS;AACtgB;AACA;AACA,aAAa,EAAE,GAAG,EAAE,GAAG,2DAAC,SAAS,2CAA2C,GAAG,2DAAC,SAAS,6EAA6E;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,2DAAC,UAAU,cAAc;AACtC;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,8CAA8C,oBAAoB,aAAa,kBAAkB,WAAW,OAAO,sBAAsB,mBAAmB,2CAA2C,yBAAyB,sBAAsB,qBAAqB,iBAAiB,UAAU,uBAAuB,oBAAoB,qBAAqB,iBAAiB,aAAa,0BAA0B,eAAe,cAAc,kBAAkB,WAAW,OAAO,WAAW,qBAAqB,0BAA0B,oBAAoB,YAAY,uBAAuB,mBAAmB,oCAAoC,wBAAwB,gBAAgB,WAAW,kBAAkB,iCAAiC,gCAAgC,8BAA8B,sBAAsB,mBAAmB,OAAO,wDAAwD,oDAAoD,kBAAkB,8BAA8B,+BAA+B,kBAAkB,yEAAyE,YAAY,QAAQ,6FAA6F,mBAAmB,kBAAkB,6DAA6D,6DAA6D,yEAAyE,WAAW,mDAAmD,aAAa,WAAW,uCAAuC,OAAO,kDAAkD,kBAAkB,WAAW,yBAAyB,iCAAiC,oBAAoB,yDAAyD,YAAY,QAAQ,WAAW,YAAY,wCAAwC,sCAAsC,qCAAqC,kBAAkB,uBAAuB,wBAAwB,kCAAkC,0CAA0C,kCAAkC,UAAU,oBAAoB,2DAA2D,YAAY,uCAAuC,WAAW,wCAAwC,uBAAuB,gBAAgB,WAAW,qCAAqC,2BAA2B,kBAAkB,MAAM,yBAAyB,uBAAuB,kGAAkG,iBAAiB,iBAAiB,2DAA2D,yDAAyD,sBAAsB,cAAc,kBAAkB,mBAAmB,gBAAgB,mBAAmB,6FAA6F,MAAM,mBAAmB,oBAAoB,2BAA2B,0BAA0B,yBAAyB,yBAAyB,yEAAyE,iCAAiC,wBAAwB,cAAc,kBAAkB,aAAa,gBAAgB,6FAA6F,wBAAwB,kBAAkB,mBAAmB,uBAAuB,sBAAsB,wBAAwB,wBAAwB,sBAAsB,iBAAiB,eAAe,aAAa,gBAAgB,6FAA6F,sBAAsB,kBAAkB,mBAAmB,0BAA0B,yBAAyB,qBAAqB,qBAAqB,sBAAsB,iBAAiB,kBAAkB,SAAS,WAAW,wCAAwC,YAAY,iBAAiB,gBAAgB,kBAAkB,SAAS,UAAU,WAAW,oDAAoD,oBAAoB,6FAA6F,YAAY,kBAAkB,0BAA0B,0BAA0B,mBAAmB,wCAAwC,WAAW,mDAAmD,2CAA2C,iBAAiB,kBAAkB,gBAAgB,mBAAmB,qBAAqB,kBAAkB,UAAU,eAAe,+CAA+C,uCAAuC,+BAA+B,2DAA2D,uBAAuB,iCAAiC,eAAe,kBAAkB,6FAA6F,WAAW,mBAAmB,oBAAoB,0BAA0B,yBAAyB,wBAAwB,wBAAwB,+BAA+B,yCAAyC,iCAAiC,uBAAuB,WAAW,EAAE,EAAE;AACnuK;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAC,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kLAAkL,SAAS,2DAAC,SAAS,2CAA2C,sBAAsB,2DAAC,SAAS,4CAA4C;AACrU;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAK;AAChB;AACA;AACA,WAAW,8DAAK;AAChB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sCAAsC;AAC/D;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,OAAO,QAAQ,MAAM,SAAS,kBAAkB,eAAe,oBAAoB,kBAAkB,0BAA0B,eAAe,kBAAkB,kBAAkB,8BAA8B,cAAc,eAAe,UAAU,+EAA+E,uEAAuE,8BAA8B,oBAAoB,UAAU,8EAA8E,sEAAsE,iDAAiD,yCAAyC,oCAAoC,GAAG,0DAA0D,kDAAkD,2BAA2B,mBAAmB,GAAG,8EAA8E,uEAAuE,4BAA4B,GAAG,0DAA0D,kDAAkD,2BAA2B,mBAAmB,GAAG,8EAA8E,uEAAuE,oCAAoC,GAAG,yCAAyC,iCAAiC,UAAU,GAAG,aAAa,4BAA4B,GAAG,yCAAyC,iCAAiC,UAAU,GAAG,aAAa,qCAAqC,GAAG,yCAAyC,iCAAiC,YAAY,GAAG,WAAW,6BAA6B,GAAG,yCAAyC,iCAAiC,YAAY,GAAG,WAAW,EAAE,EAAE;AAC56D;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAW;AACpC,yBAAyB,2DAAW;AACpC,wBAAwB,2DAAW;AACnC,uBAAuB,2DAAW;AAClC,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,mBAAmB,EAAE;AAC3F,+DAA+D,0BAA0B,EAAE;AAC3F;AACA;AACA,oEAAoE,mBAAmB,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oEAAe,4CAA4C;AAC5F;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,EAAE,EAAE;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC,2DAA2D,aAAa,sBAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE;AACvB,sCAAsC,uDAAiB;AACvD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC;AACA,+DAA+D,aAAa,sBAAsB,uHAAuH;AACzN,sCAAsC,uDAAqB;AAC3D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC,yDAAyD,aAAa,sBAAsB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,sCAAsC,uDAAe;AACrD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA,oBAAoB,8DAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,6LAA6L;AACtN;AACA,gCAAgC,4DAAW;AAC3C;AACA,qBAAqB,EAAE,2DAAC,SAAS,2BAA2B,eAAe,2DAAC,SAAS,6CAA6C,EAAE,2DAAC,SAAS,6BAA6B,IAAI,2DAAC,YAAY,yGAAyG,iCAAiC,EAAE,GAAG;AAC3U;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,kCAAkC,iCAAiC,+BAA+B,qCAAqC,oBAAoB,aAAa,kBAAkB,2CAA2C,gBAAgB,UAAU,6FAA6F,MAAM,mBAAmB,oBAAoB,2CAA2C,0CAA0C,uCAAuC,uCAAuC,gBAAgB,gBAAgB,cAAc,wBAAwB,WAAW,oBAAoB,2BAA2B,yBAAyB,oBAAoB,mBAAmB,YAAY,OAAO,OAAO,MAAM,cAAc,eAAe,aAAa,gBAAgB,kBAAkB,WAAW,YAAY,SAAS,uBAAuB,eAAe,wBAAwB,qBAAqB,gBAAgB,aAAa,iDAAiD,WAAW,YAAY,QAAQ,yBAAyB,SAAS,aAAa,kBAAkB,aAAa,WAAW,OAAO,eAAe,kBAAkB,uBAAuB,mBAAmB,gBAAgB,mBAAmB,SAAS,QAAQ,gBAAgB,kBAAkB,QAAQ,SAAS,qBAAqB,mCAAmC,kCAAkC,mBAAmB,YAAY,oBAAoB,yEAAyE,WAAW,YAAY,UAAU,MAAM,mBAAmB,kBAAkB,sBAAsB,qBAAqB,aAAa,WAAW,YAAY,EAAE,EAAE;AACxuD;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uDAAuD,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAA2C,EAAE;AAC5E,oCAAoC,qBAAqB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,0CAA0C,2DAAY,QAAQ;AACvF;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,aAAa,EAAE,EAAE;AAC1D;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG;AACzB;AACA;AACA,aAAa,EAAE,EAAE,2DAAC;AAClB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,4BAA4B,uBAAuB,EAAE,EAAE;AACjF;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAW;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,uGAAuG,EAAE,4DAAoB,kBAAkB,0GAA0G,EAAE,2DAAC;AACrR;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,uCAAuC,yCAAyC,oBAAoB,aAAa,sBAAsB,mBAAmB,qBAAqB,uBAAuB,WAAW,6CAA6C,yBAAyB,6BAA6B,mBAAmB,kBAAkB,eAAe,yBAAyB,sBAAsB,qBAAqB,iBAAiB,WAAW,yCAAyC,iCAAiC,6FAA6F,MAAM,mBAAmB,oBAAoB,gDAAgD,+CAA+C,+CAA+C,+CAA+C,4CAA4C,4CAA4C,2CAA2C,2CAA2C,gCAAgC,8DAA8D,6CAA6C,iCAAiC,0HAA0H,qCAAqC,sDAAsD,uBAAuB,kBAAkB,iBAAiB,aAAa,4BAA4B,uBAAuB,uBAAuB,MAAM,4EAA4E,mEAAmE,wHAAwH,mEAAmE,qFAAqF,YAAY,4EAA4E,4BAA4B,mEAAmE,kDAAkD,0CAA0C,sCAAsC,8CAA8C,kEAAkE,iEAAiE,EAAE,EAAE;AACr9E;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,8LAA8L;AACvN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,2DAAC,sBAAsB,UAAU,eAAe,GAAG,2DAAC,iCAAiC,2DAAC,uBAAuB,oBAAoB;AACxJ;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,qCAAqC,WAAW,OAAO,0BAA0B,sBAAsB,sBAAsB,mBAAmB,qBAAqB,uBAAuB,6BAA6B,mBAAmB,QAAQ,YAAY,aAAa,EAAE,cAAc,eAAe,aAAa,gBAAgB,kCAAkC,iCAAiC,+BAA+B,qCAAqC,oBAAoB,kBAAkB,mBAAmB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,uBAAuB,mBAAmB,oBAAoB,cAAc,oBAAoB,aAAa,kBAAkB,2BAA2B,uBAAuB,uBAAuB,oBAAoB,sBAAsB,wBAAwB,WAAW,SAAS,uBAAuB,qBAAqB,eAAe,gBAAgB,8BAA8B,sBAAsB,uBAAuB,6FAA6F,EAAE,mBAAmB,oBAAoB,2CAA2C,0CAA0C,uCAAuC,uCAAuC,oBAAoB,qCAAqC,0BAA0B,QAAQ,6BAA6B,qBAAqB,4BAA4B,mBAAmB,uBAAuB,qBAAqB,oBAAoB,WAAW,yCAAyC,cAAc,2BAA2B,kBAAkB,eAAe,uBAAuB,mBAAmB,gBAAgB,8BAA8B,sBAAsB,qBAAqB,iBAAiB,QAAQ,oBAAoB,kBAAkB,SAAS,WAAW,gDAAgD,mBAAmB,qBAAqB,8BAA8B,sBAAsB,kBAAkB,UAAU,8BAA8B,uBAAuB,mBAAmB,4BAA4B,+BAA+B,2BAA2B,+BAA+B,kCAAkC,8BAA8B,oGAAoG,aAAa,kBAAkB,0BAA0B,MAAM,gBAAgB,kBAAkB,mBAAmB,oBAAoB,gBAAgB,eAAe,gDAAgD,cAAc,eAAe,eAAe,kBAAkB,eAAe,eAAe,gBAAgB,qBAAqB,iBAAiB,kBAAkB,gBAAgB,mBAAmB,qBAAqB,QAAQ,YAAY,eAAe,iBAAiB,6FAA6F,qBAAqB,mBAAmB,oBAAoB,0BAA0B,yBAAyB,wBAAwB,wBAAwB,6EAA6E,WAAW,YAAY,sBAAsB,oBAAoB,eAAe,eAAe,2BAA2B,mBAAmB,qBAAqB,aAAa,kBAAkB,gBAAgB,sJAAsJ,eAAe,kBAAkB,eAAe,gBAAgB,kGAAkG,eAAe,YAAY,eAAe,kBAAkB,eAAe,oDAAoD,sBAAsB,iJAAiJ,WAAW,YAAY,uBAAuB,mDAAmD,aAAa,kBAAkB,oDAAoD,eAAe,oGAAoG,sBAAsB,SAAS,0RAA0R,WAAW,YAAY,uBAAuB,kGAAkG,sBAAsB,SAAS,sRAAsR,WAAW,YAAY,uBAAuB,kGAAkG,SAAS,kDAAkD,cAAc,eAAe,aAAa,gBAAgB,EAAE,EAAE;AAC90K;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAW;AACpC,wBAAwB,2DAAW;AACnC,wBAAwB,2DAAW;AACnC,uBAAuB,2DAAW;AAClC,wBAAwB,2DAAW;AACnC;AACA;AACA,yBAAyB,8DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAQ;AACpB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA;AACA,oBAAoB,8DAAa;AACjC;AACA;AACA;AACA,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,sFAAsF,EAAE,4DAAoB,uBAAuB,yBAAyB,EAAE,2DAAC,cAAc,+CAA+C,iCAAiC,EAAE,uaAAua;AAC/rB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,gCAAgC,qBAAqB,gBAAgB,4BAA4B,iCAAiC,kCAAkC,yBAAyB,gBAAgB,gBAAgB,mBAAmB,kBAAkB,cAAc,kBAAkB,WAAW,OAAO,WAAW,8BAA8B,sBAAsB,6BAA6B,mBAAmB,2CAA2C,qBAAqB,UAAU,iCAAiC,mBAAmB,4BAA4B,gEAAgE,6BAA6B,oBAAoB,kGAAkG,kBAAkB,qCAAqC,mCAAmC,cAAc,eAAe,aAAa,gBAAgB,kCAAkC,iCAAiC,+BAA+B,qCAAqC,oBAAoB,kBAAkB,mBAAmB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,uBAAuB,mBAAmB,oBAAoB,cAAc,cAAc,WAAW,eAAe,gBAAgB,SAAS,aAAa,uBAAuB,8BAA8B,sBAAsB,YAAY,wBAAwB,qBAAqB,gBAAgB,6FAA6F,qCAAqC,mBAAmB,oBAAoB,2CAA2C,0CAA0C,uCAAuC,uCAAuC,gEAAgE,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,uDAAuD,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,2DAA2D,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,4DAA4D,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,kDAAkD,+BAA+B,oBAAoB,yCAAyC,2CAA2C,mCAAmC,+CAA+C,WAAW,kCAAkC,OAAO,MAAM,kBAAkB,oBAAoB,uMAAuM,WAAW,YAAY,QAAQ,uBAAuB,mBAAmB,kBAAkB,sBAAsB,kBAAkB,kBAAkB,+KAA+K,kBAAkB,qBAAqB,oBAAoB,EAAE,EAAE;AAC5pH;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAW;AACpC,wBAAwB,2DAAW;AACnC,uBAAuB,2DAAW;AAClC,wBAAwB,2DAAW;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gLAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0BAA0B,EAAE;AAC9E,mDAAmD,2BAA2B,EAAE;AAChF,kDAAkD,0BAA0B,EAAE;AAC9E,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B;AACA,oBAAoB,8DAAa;AACjC;AACA;AACA;AACA;AACA,QAAQ,8DAAiB;AACzB,gBAAgB,2DAAC,CAAC,mDAAI,GAAG,oLAAoL,EAAE,4DAAoB,kBAAkB,mCAAmC,4DAAW,wJAAwJ,EAAE,2DAAC,SAAS,uBAAuB,EAAE,2DAAC,SAAS,wBAAwB,IAAI,2DAAC,YAAY,wGAAwG,iCAAiC,EAAE,EAAE;AAChqB;AACA;AACA,0BAA0B,QAAQ,2DAAU,OAAO,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,0BAA0B,eAAe,yCAAyC,iCAAiC,qBAAqB,aAAa,gBAAgB,eAAe,sBAAsB,kBAAkB,yBAAyB,sBAAsB,qBAAqB,iBAAiB,UAAU,0BAA0B,yBAAyB,wBAAwB,oBAAoB,OAAO,OAAO,MAAM,cAAc,eAAe,aAAa,gBAAgB,kBAAkB,WAAW,YAAY,SAAS,uBAAuB,eAAe,wBAAwB,qBAAqB,gBAAgB,aAAa,iDAAiD,WAAW,YAAY,QAAQ,yBAAyB,SAAS,MAAM,yDAAyD,sDAAsD,yBAAyB,iCAAiC,+BAA+B,uBAAuB,kBAAkB,WAAW,YAAY,eAAe,8CAA8C,iCAAiC,aAAa,mBAAmB,cAAc,kBAAkB,WAAW,YAAY,gCAAgC,wBAAwB,wCAAwC,gCAAgC,6BAA6B,gBAAgB,oBAAoB,cAAc,SAAS,QAAQ,mBAAmB,kBAAkB,WAAW,YAAY,4HAA4H,oHAAoH,4GAA4G,kIAAkI,oCAAoC,uEAAuE,+DAA+D,sBAAsB,eAAe,+DAA+D,WAAW,YAAY,UAAU,oCAAoC,qCAAqC,wFAAwF,iCAAiC,yBAAyB,qCAAqC,wCAAwC,gCAAgC,4CAA4C,mHAAmH,mDAAmD,2CAA2C,6DAA6D,iCAAiC,yBAAyB,uCAAuC,WAAW,sDAAsD,UAAU,qJAAqJ,WAAW,YAAY,WAAW,wBAAwB,WAAW,sBAAsB,cAAc,eAAe,aAAa,gBAAgB,kBAAkB,kBAAkB,gBAAgB,mBAAmB,6FAA6F,sBAAsB,mBAAmB,oBAAoB,2BAA2B,0BAA0B,wBAAwB,wBAAwB,4BAA4B,eAAe,mBAAmB,gBAAgB,mBAAmB,6FAA6F,4BAA4B,mBAAmB,oBAAoB,wBAAwB,uBAAuB,yBAAyB,yBAAyB,EAAE,EAAE;AAC5+H;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgzB","file":"99.3b747e1da67d4bc7e5a1.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar _this_1 = this;\r\nimport { r as registerInstance, c as createEvent, h, d as getElement, H as Host, e as getContext, f as getIonMode$1, i as config, j as isPlatform, k as getAssetPath, l as getMode, m as readTask, w as writeTask } from './core-684c60cc.js';\r\nimport { h as hasShadowDom, d as debounceEvent, f as findItemLabel, c as clamp, r as renderHiddenInput } from './helpers-1644482e.js';\r\nimport { o as openURL, c as createColorClasses$1, h as hostContext } from './theme-955ba954.js';\r\nimport { p as popoverController, a as actionSheetController, b as alertController } from './overlays-84052d05.js';\r\nimport { w as watchForOptions } from './watch-options-52f82652.js';\r\nimport { a as attachComponent } from './framework-delegate-8aba239f.js';\r\nimport { h as hapticSelection } from './haptic-e2bb9344.js';\r\nvar img = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik05NiAyMzVoMzIwdjQySDk2eiI+PC9wYXRoPjwvc3ZnPgo=';\r\nvar img$1 = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik0xODYuMzAxIDMzOS44OTNMOTYgMjQ5LjQ2MWwtMzIgMzAuNTA3TDE4Ni4zMDEgNDAyIDQ0OCAxNDAuNTA2IDQxNiAxMTB6Ij48L3BhdGg+PC9zdmc+Cg==';\r\nvar description = \"Description\";\r\nvar title = \"Title\";\r\nvar update = \"Update\";\r\nvar i18n = {\r\n    \"delete\": \"Delete\",\r\n    description: description,\r\n    title: title,\r\n    update: update\r\n};\r\nvar AlAngleEditor = /** @class */ (function () {\r\n    function class_1(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n;\r\n        this.deleteAngle = createEvent(this, \"deleteAngle\", 7);\r\n        this.saveAngle = createEvent(this, \"saveAngle\", 7);\r\n    }\r\n    class_1.prototype.render = function () {\r\n        var _this_1 = this;\r\n        if (this.angle) {\r\n            var _b = this.angle, angleId_1 = _b[0], angle_1 = _b[1];\r\n            return (h(\"form\", { onSubmit: function (e) { return e.preventDefault(); } }, h(\"ion-item\", null, h(\"ion-input\", { id: \"title\", value: angle_1.title, placeholder: this._contentStrings.title, required: true, onIonChange: function (e) { return (angle_1.title = e.detail.value); }, maxlength: 20 })), h(\"ion-item\", null, h(\"ion-textarea\", { id: \"description\", value: angle_1.description, placeholder: this._contentStrings.description, rows: 5, onIonChange: function (e) { return (angle_1.description = e.detail.value); }, maxlength: 280 })), h(\"ion-item\", null, h(\"ion-button\", { size: \"small\", onClick: function () {\r\n                    _this_1.deleteAngle.emit(angleId_1);\r\n                    _this_1.angle = null;\r\n                } }, h(\"ion-icon\", { src: img }), \"\\u00A0\", this._contentStrings.delete), h(\"ion-button\", { size: \"small\", type: \"submit\", onClick: function () {\r\n                    if (angle_1.title) {\r\n                        _this_1.saveAngle.emit([angleId_1, angle_1]);\r\n                    }\r\n                } }, h(\"ion-icon\", { src: img$1 }), \"\\u00A0\", this._contentStrings.update))));\r\n        }\r\n        return null;\r\n    };\r\n    Object.defineProperty(class_1, \"style\", {\r\n        get: function () { return \"#title{--background:var(--al-input-background-color);--color:var(--al-input-color);--padding-bottom:var(--al-input-padding-bottom);--padding-end:var(--al-input-padding-end);--padding-start:var(--al-input-padding-start);--padding-top:var(--al-input-padding-top);font-size:var(--al-input-font-size)}#description{--background:var(--al-textarea-background-color);--color:var(--al-textarea-color);--padding-bottom:var(--al-textarea-padding-bottom);--padding-end:var(--al-textarea-padding-end);--padding-start:var(--al-textarea-padding-start);--padding-top:var(--al-textarea-padding-top);font-size:var(--al-textarea-font-size)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_1;\r\n}());\r\nvar img$2 = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik0xOTIgMTI4bDEyOCAxMjgtMTI4IDEyOHoiPjwvcGF0aD48L3N2Zz4K';\r\nvar update$1 = \"Update\";\r\nvar i18n$1 = {\r\n    update: update$1\r\n};\r\nvar AlConsole = /** @class */ (function () {\r\n    function class_2(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$1;\r\n        this.graph = null;\r\n        this.tabSize = 2;\r\n        this.graphSubmitted = createEvent(this, \"graphSubmitted\", 7);\r\n    }\r\n    class_2.prototype._getGraphJson = function () {\r\n        var json = \"\";\r\n        try {\r\n            json = JSON.stringify(JSON.parse(this.graph), undefined, this.tabSize);\r\n        }\r\n        catch (_a) {\r\n            // do nothing\r\n        }\r\n        return json;\r\n    };\r\n    class_2.prototype.render = function () {\r\n        var _this_1 = this;\r\n        return (h(\"form\", { onSubmit: function (e) { return e.preventDefault(); } }, h(\"ion-item\", null, h(\"ion-textarea\", { id: \"graph\", value: this._getGraphJson(), rows: 10, required: true, onIonChange: function (e) { return (_this_1.graph = e.detail.value); }, maxlength: 5000, ref: function (el) { return (_this_1._graph = el); } })), h(\"ion-item\", null, h(\"ion-button\", { size: \"small\", type: \"submit\", onClick: function () {\r\n                if (_this_1.graph) {\r\n                    _this_1.graphSubmitted.emit(_this_1._graph.value);\r\n                }\r\n            } }, h(\"ion-icon\", { src: img$2 }), \"\\u00A0\", this._contentStrings.update))));\r\n    };\r\n    Object.defineProperty(class_2, \"style\", {\r\n        get: function () { return \"#graph{--background:var(--al-textarea-background-color);--color:var(--al-textarea-color);--padding-bottom:var(--al-textarea-padding-bottom);--padding-end:var(--al-textarea-padding-end);--padding-start:var(--al-textarea-padding-start);--padding-top:var(--al-textarea-padding-top);font-size:var(--al-console-font-size)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_2;\r\n}());\r\nvar img$3 = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik00MjQsNjRIODhjLTI2LjYsMC00OCwyMS42LTQ4LDQ4djI4OGMwLDI2LjQsMjEuNCw0OCw0OCw0OGgzMzZjMjYuNCwwLDQ4LTIxLjYsNDgtNDhWMTEyQzQ3Miw4NS42LDQ1MC42LDY0LDQyNCw2NHoKCSBNNDI0LDQwMEg4OFYxNzZoMzM2VjQwMHoiLz4KPHBhdGggZD0iTTIwMi42LDI4Ni40bC01OC4zLDU4LjNjLTIuOCwyLjgtNy40LDIuOC0xMC4yLDBsLTYuOC02LjhjLTIuOC0yLjgtMi44LTcuNCwwLTEwLjJsNDYuMi00Ni40bC00Ni4yLTQ2LjQKCWMtMi44LTIuOC0yLjgtNy40LDAtMTAuMmw2LjgtNi44YzIuOC0yLjgsNy40LTIuOCwxMC4yLDBsNTguMyw1OC4zQzIwNS40LDI3OSwyMDUuNCwyODMuNiwyMDIuNiwyODYuNHogTTM0My4yLDM0MS4zdi05LjYKCWMwLTQtMy4yLTcuMi03LjItNy4yaC05MS4yYy00LDAtNy4yLDMuMi03LjIsNy4ydjkuNmMwLDQsMy4yLDcuMiw3LjIsNy4ySDMzNkMzMzkuOSwzNDguNSwzNDMuMiwzNDUuMywzNDMuMiwzNDEuM3oiLz4KPC9zdmc+Cg==';\r\nvar img$4 = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik0yNTYgNDhDMTQxLjEyNSA0OCA0OCAxNDEuMTI1IDQ4IDI1NnM5My4xMjUgMjA4IDIwOCAyMDggMjA4LTkzLjEyNSAyMDgtMjA4UzM3MC44NzUgNDggMjU2IDQ4em0xMDcgMjI5aC04NnY4NmgtNDJ2LTg2aC04NnYtNDJoODZ2LTg2aDQydjg2aDg2djQyeiI+PC9wYXRoPjwvc3ZnPgo=';\r\nvar img$5 = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMzIgMzg0aDI3MnYzMkgzMnpNNDAwIDM4NGg4MHYzMmgtODB6TTM4NCA0NDcuNWMwIDE3Ljk0OS0xNC4zMjcgMzIuNS0zMiAzMi41LTE3LjY3MyAwLTMyLTE0LjU1MS0zMi0zMi41di05NWMwLTE3Ljk0OSAxNC4zMjctMzIuNSAzMi0zMi41IDE3LjY3MyAwIDMyIDE0LjU1MSAzMiAzMi41djk1eiIvPjxnPjxwYXRoIGQ9Ik0zMiAyNDBoODB2MzJIMzJ6TTIwOCAyNDBoMjcydjMySDIwOHpNMTkyIDMwMy41YzAgMTcuOTQ5LTE0LjMyNyAzMi41LTMyIDMyLjUtMTcuNjczIDAtMzItMTQuNTUxLTMyLTMyLjV2LTk1YzAtMTcuOTQ5IDE0LjMyNy0zMi41IDMyLTMyLjUgMTcuNjczIDAgMzIgMTQuNTUxIDMyIDMyLjV2OTV6Ii8+PC9nPjxnPjxwYXRoIGQ9Ik0zMiA5NmgyNzJ2MzJIMzJ6TTQwMCA5Nmg4MHYzMmgtODB6TTM4NCAxNTkuNWMwIDE3Ljk0OS0xNC4zMjcgMzIuNS0zMiAzMi41LTE3LjY3MyAwLTMyLTE0LjU1MS0zMi0zMi41di05NWMwLTE3Ljk0OSAxNC4zMjctMzIuNSAzMi0zMi41IDE3LjY3MyAwIDMyIDE0LjU1MSAzMiAzMi41djk1eiIvPjwvZz48L3N2Zz4=';\r\nvar img$6 = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNNDAzLjAwMiAyMTcuMDAxQzM4OC45OTggMTQ4LjAwMiAzMjguOTk4IDk2IDI1NiA5NmMtNTcuOTk4IDAtMTA3Ljk5OCAzMi45OTgtMTMyLjk5OCA4MS4wMDFDNjMuMDAyIDE4My4wMDIgMTYgMjMzLjk5OCAxNiAyOTZjMCA2NS45OTYgNTMuOTk5IDEyMCAxMjAgMTIwaDI2MGM1NSAwIDEwMC00NSAxMDAtMTAwIDAtNTIuOTk4LTQwLjk5Ni05Ni4wMDEtOTIuOTk4LTk4Ljk5OXpNMjg4IDI3NnY3NmgtNjR2LTc2aC02OGwxMDAtMTAwIDEwMCAxMDBoLTY4eiIvPjwvc3ZnPg==';\r\nvar Scroll = function (props, children) { return (h(\"div\", { style: {\r\n        \"overflow-y\": \"auto\",\r\n        width: \"100%\",\r\n        \"min-height\": \"0\",\r\n        \"max-height\": \"100%\",\r\n        height: props.height\r\n    } }, children)); };\r\nvar console$1 = \"Console\";\r\nvar graph = \"Nodes\";\r\nvar settings = \"Settings\";\r\nvar src = \"Source\";\r\nvar i18n$2 = {\r\n    console: console$1,\r\n    graph: graph,\r\n    settings: settings,\r\n    src: src\r\n};\r\nvar Constants = /** @class */ (function () {\r\n    function Constants() {\r\n    }\r\n    return Constants;\r\n}());\r\nConstants.boundingBoxWidth = 2;\r\nConstants.controllerName = \"-controller\";\r\nConstants.edgeSize = 0.005;\r\nConstants.fov = 45;\r\nConstants.fontSizeLarge = 1;\r\nConstants.fontSizeMedium = 0.7;\r\nConstants.fontSizeSmall = 0.4;\r\nConstants.frustrumScaleFactor = 0.7;\r\nConstants.lightIntensity = 0.5;\r\nConstants.maxAnimationSteps = 50;\r\nConstants.minLoadingMS = 500;\r\nConstants.minNodeSize = 0.0001;\r\nConstants.movedEventName = \"-moved\";\r\nConstants.movingStepCount = 2;\r\nConstants.nodeSizeRatio = 100;\r\nConstants.stackSpaceMultiplier = { x: 10, y: 10, z: 10 };\r\nConstants.stepPowerMinMax = [1, 10];\r\nConstants.targetFrameTime = 1000 / 24; // 24 FPS\r\nConstants.titleIdName = \"-title\";\r\nConstants.topLayerRenderOrder = 999;\r\nConstants.unitsDecimalPlaces = 6;\r\nConstants.zoomFactor = 3;\r\nConstants.volumeRaycastSensitivity = 0.05;\r\nConstants.volumeStepsDelay = 800;\r\nConstants.textPadding = {\r\n    width: 0.03,\r\n    height: 0.03\r\n};\r\nConstants.minFrameMS = 15; // Should never be higher than the returned frame time\r\nConstants.minTimeForThrottle = Constants.minFrameMS * 5;\r\nConstants.buttonColors = {\r\n    active: \"#f50057\",\r\n    hover: \"#f50057\",\r\n    up: \"#00b0ff\"\r\n};\r\nConstants.colors = {\r\n    red: \"#f50057\",\r\n    blue: \"#00b0ff\",\r\n    black: \"#000000\",\r\n    grey: \"#222222\",\r\n    white: \"#ffffff\",\r\n    yellow: \"#ffeb3b\",\r\n    green: \"#76ff03\",\r\n    lightRed: \"#f77777\"\r\n};\r\nConstants.lights = {\r\n    ambientLightColor: 0xd0d0d0,\r\n    ambientLightIntensity: 0.25,\r\n    directionalLight1Color: 0xffffff,\r\n    directionalLight1Intensity: 0.75,\r\n    directionalLight2Color: 0x002958,\r\n    directionalLight2Intensity: 0.5\r\n};\r\nConstants.camera = {\r\n    dampingFactor: 0.25,\r\n    far: 10000,\r\n    fov: Constants.fov,\r\n    maxDistance: 8000,\r\n    maxPolarAngle: 175,\r\n    minDistance: 0,\r\n    minPolarAngle: 5,\r\n    near: 0.05,\r\n    nearFactor: 0.9,\r\n    orbitPanSpeed: 0.3,\r\n    orbitRotateSpeed: 0.5,\r\n    orbitZoomSpeed: 1,\r\n    panSpeed: 0.9,\r\n    trackballRotateSpeed: 2.5,\r\n    trackballZoomSpeed: 5\r\n};\r\nvar AlGraphEntryType;\r\n(function (AlGraphEntryType) {\r\n    AlGraphEntryType[\"NODE\"] = \"node\";\r\n    AlGraphEntryType[\"EDGE\"] = \"edge\";\r\n    AlGraphEntryType[\"ANGLE\"] = \"angle\";\r\n})(AlGraphEntryType || (AlGraphEntryType = {}));\r\nvar ControlsType;\r\n(function (ControlsType) {\r\n    ControlsType[\"ORBIT\"] = \"orbit\";\r\n    ControlsType[\"TRACKBALL\"] = \"trackball\";\r\n})(ControlsType || (ControlsType = {}));\r\nvar DisplayMode;\r\n(function (DisplayMode) {\r\n    DisplayMode[\"SLICES\"] = \"slices\";\r\n    DisplayMode[\"VOLUME\"] = \"volume\";\r\n    DisplayMode[\"MESH\"] = \"mesh\";\r\n})(DisplayMode || (DisplayMode = {}));\r\nvar Material;\r\n(function (Material) {\r\n    Material[\"DEFAULT\"] = \"default\";\r\n    Material[\"CLAY\"] = \"clay\";\r\n    Material[\"XRAY\"] = \"xray\";\r\n    Material[\"NORMALS\"] = \"normals\";\r\n    Material[\"WIREFRAME\"] = \"wireframe\";\r\n})(Material || (Material = {}));\r\nvar MeshFileType;\r\n(function (MeshFileType) {\r\n    MeshFileType[\"GLTF\"] = \"gltf\";\r\n    MeshFileType[\"GLB\"] = \"glb\";\r\n})(MeshFileType || (MeshFileType = {}));\r\nvar Orientation;\r\n(function (Orientation) {\r\n    Orientation[\"CORONAL\"] = \"coronal\";\r\n    Orientation[\"SAGGITAL\"] = \"saggital\";\r\n    Orientation[\"AXIAL\"] = \"axial\";\r\n})(Orientation || (Orientation = {}));\r\nvar RayType;\r\n(function (RayType) {\r\n    RayType[\"LOCK\"] = \"LOCK\";\r\n    RayType[\"MESH\"] = \"MESH\";\r\n})(RayType || (RayType = {}));\r\nvar Units;\r\n(function (Units) {\r\n    Units[\"MILLIMETERS\"] = \"mm\";\r\n    Units[\"METERS\"] = \"m\";\r\n})(Units || (Units = {}));\r\nvar VolumeFileType;\r\n(function (VolumeFileType) {\r\n    VolumeFileType[\"DCM\"] = \"dcm\";\r\n    VolumeFileType[\"DICOM\"] = \"dicom\";\r\n})(VolumeFileType || (VolumeFileType = {}));\r\nvar ThreeUtils = /** @class */ (function () {\r\n    function ThreeUtils() {\r\n    }\r\n    ThreeUtils.isWebGL2Available = function () {\r\n        try {\r\n            // tslint:disable-next-line: no-any\r\n            var canvas = document.createElement(\"canvas\");\r\n            return !!(window.WebGL2RenderingContext && canvas.getContext(\"webgl2\"));\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n    // Must use setAttribute, otherwise THREE.OrbitControls onMouseUp doesn't always pick up the change :-(\r\n    ThreeUtils.enableControls = function (camEntity, enabled, type) {\r\n        type === ControlsType.TRACKBALL\r\n            ? camEntity.setAttribute(\"al-trackball-control\", \"enabled: \" + enabled)\r\n            : camEntity.setAttribute(\"al-orbit-control\", \"enabled: \" + enabled);\r\n    };\r\n    ThreeUtils.waitOneFrame = function (func) {\r\n        window.setTimeout(function () {\r\n            func();\r\n        }, Constants.minFrameMS);\r\n    };\r\n    ThreeUtils.objectToVector3 = function (vec) {\r\n        var res = new THREE.Vector3();\r\n        res.x = vec.x;\r\n        res.y = vec.y;\r\n        res.z = vec.z;\r\n        return res;\r\n    };\r\n    ThreeUtils.worldToScreen = function (worldCoordinate, camera, \r\n    // tslint:disable-next-line: no-any\r\n    container) {\r\n        var screenCoordinates = worldCoordinate.clone();\r\n        screenCoordinates.project(camera);\r\n        screenCoordinates.x = Math.round(((screenCoordinates.x + 1) * container.offsetWidth) / 2);\r\n        screenCoordinates.y = Math.round(((-screenCoordinates.y + 1) * container.offsetHeight) / 2);\r\n        screenCoordinates.z = 0;\r\n        return screenCoordinates;\r\n    };\r\n    ThreeUtils.normaliseNumber = function (x) {\r\n        return Number(x.toFixed(Constants.unitsDecimalPlaces));\r\n    };\r\n    ThreeUtils.vector3ToString = function (vec) {\r\n        return vec.toArray().join(\" \");\r\n    };\r\n    ThreeUtils.vector3ToNormalisedString = function (vec) {\r\n        var x = ThreeUtils.normaliseNumber(vec.x);\r\n        var y = ThreeUtils.normaliseNumber(vec.y);\r\n        var z = ThreeUtils.normaliseNumber(vec.z);\r\n        return x + \" \" + y + \" \" + z;\r\n    };\r\n    ThreeUtils.stringToVector3 = function (vec) {\r\n        var res = vec.split(\" \");\r\n        var vect = new THREE.Vector3();\r\n        vect.x = Number(res[0]);\r\n        vect.y = Number(res[1]);\r\n        vect.z = Number(res[2]);\r\n        return vect;\r\n    };\r\n    ThreeUtils.normaliseStringVector3 = function (vec) {\r\n        return ThreeUtils.vector3ToNormalisedString(ThreeUtils.stringToVector3(vec));\r\n    };\r\n    // https://en.wikipedia.org/wiki/Slerp\r\n    ThreeUtils.slerp = function (start, end, percent) {\r\n        var t = percent;\r\n        var p0 = start;\r\n        var p1 = end;\r\n        var theta = p0.angleTo(p1);\r\n        if (theta) {\r\n            theta = THREE.Math.clamp(theta, -0.99, 0.99);\r\n            var topP0 = Math.sin(1 - t) * theta;\r\n            var topP1 = Math.sin(t * theta);\r\n            var bot = Math.sin(theta);\r\n            var p0Const = topP0 / bot;\r\n            var p1Const = topP1 / bot;\r\n            var left = p0.clone().multiplyScalar(p0Const);\r\n            var right = p1.clone().multiplyScalar(p1Const);\r\n            var result_1 = left.add(right);\r\n            return result_1;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    ThreeUtils.easeInOutCubic = function (t) {\r\n        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n    };\r\n    ThreeUtils.getSlerpCameraPath = function (start, end, positionChange, targetChange) {\r\n        var path = [];\r\n        // add epsilon to avoid NaN due to divide by 0 in the atan in angleTo\r\n        var sp = start.position.clone().addScalar(Number.EPSILON);\r\n        var st = start.target.clone().addScalar(Number.EPSILON);\r\n        var ep = end.position.clone().addScalar(Number.EPSILON);\r\n        var et = end.target.clone().addScalar(Number.EPSILON);\r\n        for (var frame = 0; frame <= Constants.maxAnimationSteps; frame++) {\r\n            var percent = this.easeInOutCubic(frame / Constants.maxAnimationSteps);\r\n            path.push({\r\n                position: positionChange\r\n                    ? ThreeUtils.slerp(sp.clone(), ep.clone(), percent)\r\n                    : ep,\r\n                target: targetChange\r\n                    ? ThreeUtils.slerp(st.clone(), et.clone(), percent)\r\n                    : et\r\n            });\r\n        }\r\n        return path;\r\n    };\r\n    ThreeUtils.getSlerp3Path = function (start, end) {\r\n        var path = [];\r\n        // add epsilon to avoid NaN due to divide by 0 in the atan in angleTo\r\n        var sp = start.clone().addScalar(Number.EPSILON);\r\n        var ep = end.clone().addScalar(Number.EPSILON);\r\n        for (var frame = 0; frame <= Constants.maxAnimationSteps; frame++) {\r\n            var percent = this.easeInOutCubic(frame / Constants.maxAnimationSteps);\r\n            path.push(ThreeUtils.slerp(sp.clone(), ep.clone(), percent));\r\n        }\r\n        return path;\r\n    };\r\n    ThreeUtils.lookToFrustrumSpace = function (object, camera, worldPosition, cameraPosition) {\r\n        var cameraDirection = new THREE.Vector3();\r\n        camera.getWorldDirection(cameraDirection);\r\n        var distance = cameraPosition.distanceTo(new THREE.Vector3(0, 0, 0));\r\n        var lookPlane = new THREE.Plane(cameraDirection, distance);\r\n        var frustrumDirection = new THREE.Vector3();\r\n        lookPlane.projectPoint(worldPosition, frustrumDirection);\r\n        object.lookAt(frustrumDirection);\r\n    };\r\n    ThreeUtils.getFrustrumSpaceDistance = function (camera, worldPosition, cameraPosition) {\r\n        var cameraDirection = new THREE.Vector3();\r\n        camera.getWorldDirection(cameraDirection);\r\n        var distance = cameraPosition.distanceTo(new THREE.Vector3(0, 0, 0));\r\n        var lookPlane = new THREE.Plane(cameraDirection, distance);\r\n        var frustrumDirection = new THREE.Vector3();\r\n        lookPlane.projectPoint(worldPosition, frustrumDirection);\r\n        var ray = new THREE.Ray(worldPosition);\r\n        ray.lookAt(frustrumDirection);\r\n        var dist = ray.distanceToPlane(lookPlane);\r\n        return dist;\r\n    };\r\n    return ThreeUtils;\r\n}());\r\nvar AMIUtils = /** @class */ (function () {\r\n    function AMIUtils() {\r\n    }\r\n    AMIUtils._traceDataRay = function (stackHelper, px, py, pz, dx, dy, dz, maxDistance, \r\n    // tslint:disable-next-line: no-any\r\n    hitPosition, hitNormal) {\r\n        // consider raycast vector to be parametrized by t\r\n        //   vec = [px,py,pz] + t * [dx,dy,dz]\r\n        // algo below is as described by this paper:\r\n        // http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\r\n        var t = 0.0;\r\n        var floor = Math.floor;\r\n        // tslint:disable-next-line: no-bitwise\r\n        var ix = floor(px) | 0;\r\n        // tslint:disable-next-line: no-bitwise\r\n        var iy = floor(py) | 0;\r\n        // tslint:disable-next-line: no-bitwise\r\n        var iz = floor(pz) | 0;\r\n        var stepx = dx > 0 ? 1 : -1;\r\n        var stepy = dy > 0 ? 1 : -1;\r\n        var stepz = dz > 0 ? 1 : -1;\r\n        // dx,dy,dz are already normalized\r\n        var txDelta = Math.abs(1 / dx);\r\n        var tyDelta = Math.abs(1 / dy);\r\n        var tzDelta = Math.abs(1 / dz);\r\n        var xdist = stepx > 0 ? ix + 1 - px : px - ix;\r\n        var ydist = stepy > 0 ? iy + 1 - py : py - iy;\r\n        var zdist = stepz > 0 ? iz + 1 - pz : pz - iz;\r\n        // location of nearest voxel boundary, in units of t\r\n        var txMax = txDelta < Infinity ? txDelta * xdist : Infinity;\r\n        var tyMax = tyDelta < Infinity ? tyDelta * ydist : Infinity;\r\n        var tzMax = tzDelta < Infinity ? tzDelta * zdist : Infinity;\r\n        // FROM DATA SHADER\r\n        // float windowMin = uWindowCenterWidth[0] - uWindowCenterWidth[1] * 0.5;\r\n        // float normalizedIntensity = ( realIntensity - windowMin ) / uWindowCenterWidth[1];\r\n        // console.log(\r\n        //   \"WindowCenter: \",\r\n        //   stackHelper.windowCenter,\r\n        //   \" WindowWidth: \",\r\n        //   stackHelper.windowWidth\r\n        // );\r\n        var windowMin = stackHelper.windowCenter - stackHelper.windowWidth * 0.5;\r\n        // Reduce windowMin by the sensitivity, to prevent floating nodes\r\n        windowMin -= windowMin * Constants.volumeRaycastSensitivity;\r\n        var steppedIndex = -1;\r\n        // main loop along raycast vector\r\n        while (t <= maxDistance) {\r\n            // exit check in data space\r\n            var b = void 0;\r\n            var pixelPosition = new THREE.Vector3(ix, iy, iz);\r\n            var dataPixelPosition = AMI.CoreUtils.worldToData(stackHelper.stack.lps2IJK, pixelPosition);\r\n            var currentPixel = AMI.CoreUtils.getPixelData(stackHelper.stack, dataPixelPosition);\r\n            if (currentPixel !== null && currentPixel > windowMin) {\r\n                b = 1;\r\n            }\r\n            else {\r\n                b = 0;\r\n            }\r\n            if (b) {\r\n                if (hitPosition) {\r\n                    hitPosition.x = px + t * dx;\r\n                    hitPosition.y = py + t * dy;\r\n                    hitPosition.z = pz + t * dz;\r\n                }\r\n                if (hitNormal) {\r\n                    hitNormal.x = hitNormal.y = hitNormal.z = 0;\r\n                    if (steppedIndex === 0) {\r\n                        hitNormal.x = -stepx;\r\n                    }\r\n                    if (steppedIndex === 1) {\r\n                        hitNormal.y = -stepy;\r\n                    }\r\n                    if (steppedIndex === 2) {\r\n                        hitNormal.z = -stepz;\r\n                    }\r\n                }\r\n                return b;\r\n            }\r\n            // advance t to next nearest voxel boundary\r\n            if (txMax < tyMax) {\r\n                if (txMax < tzMax) {\r\n                    ix += stepx;\r\n                    t = txMax;\r\n                    txMax += txDelta;\r\n                    steppedIndex = 0;\r\n                }\r\n                else {\r\n                    iz += stepz;\r\n                    t = tzMax;\r\n                    tzMax += tzDelta;\r\n                    steppedIndex = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (tyMax < tzMax) {\r\n                    iy += stepy;\r\n                    t = tyMax;\r\n                    tyMax += tyDelta;\r\n                    steppedIndex = 1;\r\n                }\r\n                else {\r\n                    iz += stepz;\r\n                    t = tzMax;\r\n                    tzMax += tzDelta;\r\n                    steppedIndex = 2;\r\n                }\r\n            }\r\n        }\r\n        // no voxel hit found\r\n        if (hitPosition) {\r\n            hitPosition.x = px + t * dx;\r\n            hitPosition.y = py + t * dy;\r\n            hitPosition.z = pz + t * dz;\r\n        }\r\n        if (hitNormal) {\r\n            hitNormal.x = hitNormal.y = hitNormal.z = 0;\r\n        }\r\n        return 0;\r\n    };\r\n    // Trace an AMI ray through dataSpace voxels\r\n    AMIUtils.volumeRay = function (\r\n    // tslint:disable-next-line: no-any\r\n    stack, \r\n    // tslint:disable-next-line: no-any\r\n    origin, \r\n    // tslint:disable-next-line: no-any\r\n    direction, \r\n    // tslint:disable-next-line: no-any\r\n    maxDistance, \r\n    // tslint:disable-next-line: no-any\r\n    hitPosition, \r\n    // tslint:disable-next-line: no-any\r\n    hitNormal) {\r\n        var px = +origin.x;\r\n        var py = +origin.y;\r\n        var pz = +origin.z;\r\n        var dx = +direction.x;\r\n        var dy = +direction.y;\r\n        var dz = +direction.z;\r\n        var ds = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n        if (ds === 0) {\r\n            throw new Error(\"Can't raycast along a zero vector\");\r\n        }\r\n        dx /= ds;\r\n        dy /= ds;\r\n        dz /= ds;\r\n        if (typeof maxDistance === \"undefined\") {\r\n            maxDistance = 64.0;\r\n        }\r\n        else {\r\n            maxDistance = +maxDistance;\r\n        }\r\n        return this._traceDataRay(stack, px, py, pz, dx, dy, dz, maxDistance, hitPosition, hitNormal);\r\n    };\r\n    /**\r\n     * Convert a vector3 from (mm) world space values to (m) world space values\r\n     * @param vector Vector in AMI World Space (mm)\r\n     */\r\n    AMIUtils.toAframeSpace = function (vector) {\r\n        return vector.divide(ThreeUtils.objectToVector3(Constants.stackSpaceMultiplier));\r\n    };\r\n    return AMIUtils;\r\n}());\r\nvar EventUtils = /** @class */ (function () {\r\n    function EventUtils() {\r\n    }\r\n    // the A-Frame debounce util doesn't work with ionic\r\n    EventUtils.debounce = function (fn, debounceDuration) {\r\n        // summary:\r\n        //      Returns a debounced function that will make sure the given\r\n        //      function is not triggered too much.\r\n        // fn: Function\r\n        //      Function to debounce.\r\n        // debounceDuration: Number\r\n        //      OPTIONAL. The amount of time in milliseconds for which we\r\n        //      will debounce the function. (defaults to 100ms)\r\n        debounceDuration = debounceDuration || 100;\r\n        return function () {\r\n            if (!fn.debouncing) {\r\n                // tslint:disable-next-line: no-any\r\n                var args = Array.prototype.slice.apply(arguments);\r\n                fn.lastReturnVal = fn.apply(this, args);\r\n                fn.debouncing = true;\r\n            }\r\n            clearTimeout(fn.debounceTimeout);\r\n            fn.debounceTimeout = setTimeout(function () {\r\n                fn.debouncing = false;\r\n            }, debounceDuration);\r\n            return fn.lastReturnVal;\r\n        };\r\n    };\r\n    return EventUtils;\r\n}());\r\nvar AlGraphEvents = /** @class */ (function () {\r\n    function AlGraphEvents() {\r\n    }\r\n    return AlGraphEvents;\r\n}());\r\nAlGraphEvents.SELECTED = \"al-graph-selected\";\r\nAlGraphEvents.POINTER_OVER = \"al-graph-pointer-over\";\r\nAlGraphEvents.POINTER_OUT = \"al-graph-pointer-out\";\r\nAlGraphEvents.DRAGGED = \"al-graph-dragged\";\r\nAlGraphEvents.POINTER_DOWN = \"al-graph-pointer-down\";\r\nAlGraphEvents.POINTER_UP = \"al-graph-pointer-up\";\r\n// tslint:disable-next-line: max-classes-per-file\r\nvar GraphUtils = /** @class */ (function () {\r\n    function GraphUtils() {\r\n    }\r\n    GraphUtils.getEntryWithHighestId = function (entries) {\r\n        if (entries.size) {\r\n            return Math.max.apply(Math, Array.from(entries).map(function (_b) {\r\n                var id = _b[0];\r\n                return Number(id.split(\"-\")[1]);\r\n            }));\r\n        }\r\n        return -1;\r\n    };\r\n    GraphUtils.getNextId = function (type, entries) {\r\n        return type + \"-\" + Number(this.getEntryWithHighestId(entries) + 1);\r\n    };\r\n    return GraphUtils;\r\n}());\r\n// import { Mesh } from \"three\";\r\nvar Utils = /** @class */ (function () {\r\n    function Utils() {\r\n    }\r\n    Utils.addCssUnits = function (d) {\r\n        if (!this.cssUnits.some(function (u) {\r\n            return d.includes(u);\r\n        })) {\r\n            d += \"px\"; // default to px\r\n        }\r\n        return d;\r\n    };\r\n    Utils.getFileExtension = function (file) {\r\n        return file.substring(file.lastIndexOf(\".\") + 1);\r\n    };\r\n    Utils.getFileEndCharacters = function (file, n) {\r\n        return file.slice(file.length - n);\r\n    };\r\n    Utils.getGeometryCenter = function (geometry) {\r\n        var geom;\r\n        if (geometry instanceof THREE.BufferGeometry) {\r\n            geom = new THREE.Geometry().fromBufferGeometry(geometry);\r\n        }\r\n        else {\r\n            geom = geometry;\r\n        }\r\n        geom.computeBoundingSphere();\r\n        return geom.boundingSphere.center;\r\n    };\r\n    Utils.getSceneDistanceFromMesh = function (mesh, zoomFactor, fov) {\r\n        if (mesh) {\r\n            var sphere = mesh.geometry.boundingSphere;\r\n            return (zoomFactor * sphere.radius) / Math.tan((fov * Math.PI) / 180);\r\n        }\r\n        return null;\r\n    };\r\n    Utils.getSceneDistanceFromModel = function (model, zoomFactor, fov) {\r\n        if (model) {\r\n            var box = Utils.getBoundingBox(model);\r\n            var sphere = new THREE.Sphere();\r\n            box.getBoundingSphere(sphere);\r\n            return (zoomFactor * sphere.radius) / Math.tan((fov * Math.PI) / 180);\r\n        }\r\n        return null;\r\n    };\r\n    Utils.getCameraStateFromMesh = function (mesh, sceneDistance) {\r\n        if (mesh) {\r\n            var geom = mesh.geometry;\r\n            var meshCenter = this.getGeometryCenter(geom);\r\n            var position = new THREE.Vector3();\r\n            position.copy(meshCenter);\r\n            position.z += sceneDistance;\r\n            return {\r\n                target: meshCenter,\r\n                position: position\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    Utils.getCameraStateFromModel = function (model, sceneDistance) {\r\n        if (model) {\r\n            var box = Utils.getBoundingBox(model);\r\n            var center = new THREE.Vector3();\r\n            box.getCenter(center);\r\n            var position = new THREE.Vector3();\r\n            position.y = center.y;\r\n            position.z += sceneDistance;\r\n            return {\r\n                target: center,\r\n                position: position\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    Utils.getCameraPositionFromNode = function (node, radius, cameraTarget) {\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        var pos = new THREE.Vector3();\r\n        pos.copy(AFRAME.utils.coordinates.parse(node.position));\r\n        // (Position -> Target)\r\n        var dir = pos\r\n            .clone()\r\n            .sub(cameraTarget.clone())\r\n            .normalize();\r\n        var camPos = new THREE.Vector3();\r\n        camPos.copy(pos);\r\n        // Add {defaultZoom} intervals of dir to camPos\r\n        camPos.add(dir.clone().multiplyScalar(radius * Constants.zoomFactor));\r\n        return camPos;\r\n    };\r\n    Utils.getNearFromSceneDistance = function (sceneDistance) {\r\n        if (sceneDistance) {\r\n            return sceneDistance * (1.0 - Constants.camera.nearFactor);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Utils.getFarFromSceneDistance = function (sceneDistance) {\r\n        if (sceneDistance) {\r\n            return sceneDistance * 100;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    Utils.getBoundingBox = function (obj) {\r\n        return new THREE.Box3().setFromObject(obj);\r\n    };\r\n    Utils.normalise = function (num, min, max) {\r\n        return (num - min) / (max - min);\r\n    };\r\n    Utils.reverseNumber = function (num, min, max) {\r\n        return max + min - num;\r\n    };\r\n    return Utils;\r\n}());\r\nUtils.cssUnits = [\r\n    \"%\",\r\n    \"ch\",\r\n    \"cm\",\r\n    \"em\",\r\n    \"ex\",\r\n    \"in\",\r\n    \"mm\",\r\n    \"pc\",\r\n    \"pt\",\r\n    \"px\",\r\n    \"rem\",\r\n    \"vh\",\r\n    \"vmax\",\r\n    \"vmin\",\r\n    \"vw\"\r\n];\r\nvar AlSettings = /** @class */ (function () {\r\n    function class_3(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$2;\r\n        this.angles = null;\r\n        this.consoleTabEnabled = true;\r\n        this.edges = null;\r\n        this.graphTabEnabled = true;\r\n        this.nodes = null;\r\n        this.selected = null;\r\n        this.settingsTabEnabled = true;\r\n        this.srcTabEnabled = true;\r\n        this.tabContentHeight = null;\r\n        this.url = null;\r\n        this.urls = null;\r\n    }\r\n    class_3.prototype._getGraphJson = function () {\r\n        if (this.nodes && this.edges && this.angles) {\r\n            var nodes = Array.from(this.nodes);\r\n            var graph_1 = {\r\n                nodes: nodes.map(function (n) {\r\n                    var id = n[0];\r\n                    var node = n[1];\r\n                    return [\r\n                        id,\r\n                        {\r\n                            normal: node.normal\r\n                                ? ThreeUtils.normaliseStringVector3(node.normal)\r\n                                : new THREE.Vector3(),\r\n                            position: ThreeUtils.normaliseStringVector3(node.position),\r\n                            scale: ThreeUtils.normaliseNumber(node.scale),\r\n                            targetId: node.targetId,\r\n                            title: node.title,\r\n                            description: node.description\r\n                        }\r\n                    ];\r\n                }),\r\n                edges: Array.from(this.edges),\r\n                angles: Array.from(this.angles)\r\n            };\r\n            return JSON.stringify(graph_1);\r\n        }\r\n        return \"\";\r\n    };\r\n    class_3.prototype.render = function () {\r\n        var tabContentHeight = this.tabContentHeight || this.el.parentElement.clientHeight + \"px\";\r\n        var numTabsEnabled = [\r\n            this.consoleTabEnabled,\r\n            this.graphTabEnabled,\r\n            this.settingsTabEnabled,\r\n            this.srcTabEnabled\r\n        ].filter(Boolean).length;\r\n        return (h(\"ion-app\", null, h(\"al-tabs\", null, numTabsEnabled > 1 ? (h(\"ion-tab-bar\", null, this.srcTabEnabled ? (h(\"ion-tab-button\", { tab: \"src\" }, h(\"ion-icon\", { src: img$6 }), h(\"ion-label\", null, this._contentStrings.src))) : null, this.settingsTabEnabled ? (h(\"ion-tab-button\", { tab: \"settings\" }, h(\"ion-icon\", { src: img$5 }), h(\"ion-label\", null, this._contentStrings.settings))) : null, this.graphTabEnabled ? (h(\"ion-tab-button\", { tab: \"graph\" }, h(\"ion-icon\", { src: img$4 }), h(\"ion-label\", null, this._contentStrings.graph))) : null, this.consoleTabEnabled ? (h(\"ion-tab-button\", { tab: \"console\" }, h(\"ion-icon\", { src: img$3 }), h(\"ion-label\", null, this._contentStrings.console))) : null)) : null, this.srcTabEnabled ? (h(\"ion-tab\", { tab: \"src\" }, h(\"al-view-controls\", { \"bounding-box-enabled\": this.boundingBoxEnabled, \"controls-type\": this.controlsType }), h(\"al-url-picker\", { urls: this.urls, url: this.url }))) : null, this.settingsTabEnabled ? (h(\"ion-tab\", { tab: \"settings\" }, h(Scroll, { height: tabContentHeight }, h(\"al-view-controls\", { \"bounding-box-enabled\": this.boundingBoxEnabled, \"controls-type\": this.controlsType }), h(\"al-settings\", { \"display-mode\": this.displayMode, orientation: this.orientation, \"slices-index\": this.slicesIndex, \"slices-max-index\": this.slicesMaxIndex, \"slices-brightness\": this.slicesBrightness, \"slices-contrast\": this.slicesContrast, \"volume-brightness\": this.volumeBrightness, \"volume-contrast\": this.volumeContrast, \"volume-steps\": this.volumeSteps, \"volume-steps-high-enabled\": this.volumeStepsHighEnabled })))) : null, this.graphTabEnabled ? (h(\"ion-tab\", { tab: \"graph\" }, h(Scroll, { height: tabContentHeight }, h(\"al-view-controls\", { \"bounding-box-enabled\": this.boundingBoxEnabled, \"controls-type\": this.controlsType }), h(\"al-graph-editor\", { selected: this.selected, nodes: this.nodes, angles: this.angles, edges: this.edges, \"graph-enabled\": this.graphEnabled, \"graph-visible\": this.graphTabEnabled, units: this.units })))) : null, this.consoleTabEnabled ? (h(\"ion-tab\", { tab: \"console\" }, h(Scroll, { height: tabContentHeight }, h(\"al-view-controls\", { \"bounding-box-enabled\": this.boundingBoxEnabled, \"controls-type\": this.controlsType }), h(\"al-console\", { graph: this._getGraphJson() })))) : null)));\r\n    };\r\n    Object.defineProperty(class_3.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_3, \"style\", {\r\n        get: function () { return \"al-tabs{--ion-tab-bar-border-color:var(--al-item-border-color)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_3;\r\n}());\r\nvar description$1 = \"Description\";\r\nvar title$1 = \"Title\";\r\nvar update$2 = \"Update\";\r\nvar i18n$3 = {\r\n    \"delete\": \"Delete\",\r\n    description: description$1,\r\n    title: title$1,\r\n    update: update$2\r\n};\r\nvar AlEdgeEditor = /** @class */ (function () {\r\n    function class_4(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$3;\r\n        this.deleteEdge = createEvent(this, \"deleteEdge\", 7);\r\n        this.saveEdge = createEvent(this, \"saveEdge\", 7);\r\n    }\r\n    class_4.prototype.render = function () {\r\n        var _this_1 = this;\r\n        if (this.edge) {\r\n            var _b = this.edge, edgeId_1 = _b[0], edge_1 = _b[1];\r\n            return (h(\"form\", { onSubmit: function (e) { return e.preventDefault(); } }, h(\"ion-item\", null, h(\"ion-input\", { id: \"title\", value: edge_1.title, placeholder: this._contentStrings.title, required: true, onIonChange: function (e) { return (edge_1.title = e.detail.value); }, maxlength: 20 })), h(\"ion-item\", null, h(\"ion-textarea\", { id: \"description\", value: edge_1.description, placeholder: this._contentStrings.description, rows: 5, onIonChange: function (e) { return (edge_1.description = e.detail.value); }, maxlength: 280 })), h(\"ion-item\", null, h(\"ion-button\", { size: \"small\", onClick: function () {\r\n                    _this_1.deleteEdge.emit(edgeId_1);\r\n                    _this_1.edge = null;\r\n                } }, h(\"ion-icon\", { src: img }), \"\\u00A0\", this._contentStrings.delete), h(\"ion-button\", { size: \"small\", type: \"submit\", onClick: function () {\r\n                    if (edge_1.title) {\r\n                        _this_1.saveEdge.emit([edgeId_1, edge_1]);\r\n                    }\r\n                } }, h(\"ion-icon\", { src: img$1 }), \"\\u00A0\", this._contentStrings.update))));\r\n        }\r\n        return null;\r\n    };\r\n    Object.defineProperty(class_4, \"style\", {\r\n        get: function () { return \"#title{--background:var(--al-input-background-color);--color:var(--al-input-color);--padding-bottom:var(--al-input-padding-bottom);--padding-end:var(--al-input-padding-end);--padding-start:var(--al-input-padding-start);--padding-top:var(--al-input-padding-top);font-size:var(--al-input-font-size)}#description{--background:var(--al-textarea-background-color);--color:var(--al-textarea-color);--padding-bottom:var(--al-textarea-padding-bottom);--padding-end:var(--al-textarea-padding-end);--padding-start:var(--al-textarea-padding-start);--padding-top:var(--al-textarea-padding-top);font-size:var(--al-textarea-font-size)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_4;\r\n}());\r\nvar AlGraphEditor = /** @class */ (function () {\r\n    function class_5(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.nodes = null;\r\n        this.angles = null;\r\n        this.edges = null;\r\n        this.selected = null;\r\n    }\r\n    class_5.prototype._getSelectedNode = function () {\r\n        if (this.selected && this.nodes) {\r\n            var n = this.nodes.get(this.selected);\r\n            if (n) {\r\n                return [this.selected, n];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    class_5.prototype._getSelectedEdge = function () {\r\n        if (this.selected && this.edges) {\r\n            var e = this.edges.get(this.selected);\r\n            if (e) {\r\n                return [this.selected, e];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    class_5.prototype._getSelectedAngle = function () {\r\n        if (this.selected && this.angles) {\r\n            var a = this.angles.get(this.selected);\r\n            if (a) {\r\n                return [this.selected, a];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    class_5.prototype.render = function () {\r\n        return [\r\n            h(\"al-graph-settings\", { \"graph-enabled\": this.graphEnabled, \"graph-visible\": this.graphVisible, units: this.units }),\r\n            h(\"al-node-list\", { nodes: this.nodes, selected: this.selected }),\r\n            h(\"ion-item-divider\", null),\r\n            h(\"al-node-editor\", { node: this._getSelectedNode() }),\r\n            h(\"al-edge-editor\", { edge: this._getSelectedEdge() }),\r\n            h(\"al-angle-editor\", { angle: this._getSelectedAngle() })\r\n        ];\r\n    };\r\n    Object.defineProperty(class_5, \"style\", {\r\n        get: function () { return \"\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_5;\r\n}());\r\nvar graphEnabled = \"Enable Nodes\";\r\nvar units = \"Units\";\r\nvar meters = \"Meters\";\r\nvar millimeters = \"Millimeters\";\r\nvar i18n$4 = {\r\n    graphEnabled: graphEnabled,\r\n    units: units,\r\n    meters: meters,\r\n    millimeters: millimeters\r\n};\r\nvar AlSettings$1 = /** @class */ (function () {\r\n    function class_6(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$4;\r\n        this.unitsChange = createEvent(this, \"unitsChange\", 7);\r\n        this.graphEnabledChange = createEvent(this, \"graphEnabledChange\", 7);\r\n    }\r\n    class_6.prototype._graphEnabled = function (enabled) {\r\n        this.graphEnabled = enabled;\r\n        this.graphEnabledChange.emit(enabled);\r\n    };\r\n    class_6.prototype._units = function (units) {\r\n        this.units = units;\r\n        this.unitsChange.emit(this.units);\r\n    };\r\n    class_6.prototype.renderGraphEnabled = function () {\r\n        var _this_1 = this;\r\n        if (this.graphVisible) {\r\n            return (h(\"div\", null, h(\"ion-item\", { style: {\r\n                    display: \"var(--graph-enabled-display, block)\"\r\n                } }, h(\"span\", { title: this._contentStrings.graphEnabled }, this._contentStrings.graphEnabled), h(\"ion-toggle\", { slot: \"end\", checked: this.graphEnabled, onIonChange: function (e) { return _this_1._graphEnabled(e.detail.checked); } })), h(\"ion-item\", { style: {\r\n                    display: \"var(--units-display, block)\"\r\n                } }, h(\"span\", { title: this._contentStrings.units }, this._contentStrings.units), h(\"select\", { slot: \"end\", onChange: function (e) { return _this_1._units(e.srcElement.value); } }, h(\"option\", { selected: this.units === Units.MILLIMETERS, value: Units.MILLIMETERS }, this._contentStrings.millimeters), h(\"option\", { selected: this.units === Units.METERS, value: Units.METERS }, this._contentStrings.meters)))));\r\n        }\r\n        else {\r\n            return h(\"span\", null, \"hello world\");\r\n        }\r\n    };\r\n    class_6.prototype.render = function () {\r\n        return (h(\"div\", { style: {\r\n                \"max-width\": \"100%\",\r\n                \"overflow-x\": \"hidden\"\r\n            } }, this.renderGraphEnabled()));\r\n    };\r\n    Object.defineProperty(class_6, \"style\", {\r\n        get: function () { return \"select{padding:5px;min-width:100px;background-color:var(--al-select-background-color);color:var(--al-item-color);border:none}\\@supports (-moz-appearance:none){select{background-color:#fff!important;color:#000!important}}ion-label{color:var(--al-item-color)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_6;\r\n}());\r\nvar description$2 = \"Description\";\r\nvar title$2 = \"Title\";\r\nvar update$3 = \"Update\";\r\nvar i18n$5 = {\r\n    \"delete\": \"Delete\",\r\n    description: description$2,\r\n    title: title$2,\r\n    update: update$3\r\n};\r\nvar AlNodeEditor = /** @class */ (function () {\r\n    function class_7(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$5;\r\n        this.deleteNode = createEvent(this, \"deleteNode\", 7);\r\n        this.saveNode = createEvent(this, \"saveNode\", 7);\r\n    }\r\n    class_7.prototype.render = function () {\r\n        var _this_1 = this;\r\n        if (this.node) {\r\n            var _b = this.node, nodeId_1 = _b[0], node_1 = _b[1];\r\n            return (h(\"form\", { onSubmit: function (e) { return e.preventDefault(); } }, h(\"ion-item\", null, h(\"ion-input\", { id: \"title\", value: node_1.title, placeholder: this._contentStrings.title, required: true, onIonChange: function (e) { return (node_1.title = e.detail.value); }, maxlength: 128 })), h(\"ion-item\", null, h(\"ion-textarea\", { id: \"description\", value: node_1.description, placeholder: this._contentStrings.description, rows: 5, onIonChange: function (e) { return (node_1.description = e.detail.value); }, maxlength: 1024 })), h(\"ion-item\", null, h(\"ion-button\", { size: \"small\", onClick: function () {\r\n                    _this_1.deleteNode.emit(nodeId_1);\r\n                    _this_1.node = null;\r\n                } }, h(\"ion-icon\", { src: img }), \"\\u00A0\", this._contentStrings.delete), h(\"ion-button\", { size: \"small\", type: \"submit\", onClick: function () {\r\n                    if (node_1.title) {\r\n                        _this_1.saveNode.emit([nodeId_1, node_1]);\r\n                    }\r\n                } }, h(\"ion-icon\", { src: img$1 }), \"\\u00A0\", this._contentStrings.update))));\r\n        }\r\n        return null;\r\n    };\r\n    Object.defineProperty(class_7, \"style\", {\r\n        get: function () { return \"#title{--background:var(--al-input-background-color);--color:var(--al-input-color);--padding-bottom:var(--al-input-padding-bottom);--padding-end:var(--al-input-padding-end);--padding-start:var(--al-input-padding-start);--padding-top:var(--al-input-padding-top);font-size:var(--al-input-font-size)}#description{--background:var(--al-textarea-background-color);--color:var(--al-textarea-color);--padding-bottom:var(--al-textarea-padding-bottom);--padding-end:var(--al-textarea-padding-end);--padding-start:var(--al-textarea-padding-start);--padding-top:var(--al-textarea-padding-top);font-size:var(--al-textarea-font-size)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_7;\r\n}());\r\nvar graphEmpty = \"No nodes have been placed.\";\r\nvar i18n$6 = {\r\n    graphEmpty: graphEmpty\r\n};\r\nvar AlNodeList = /** @class */ (function () {\r\n    function class_8(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$6;\r\n        this.nodes = null;\r\n        this.selected = null;\r\n        this.selectedChange = createEvent(this, \"selectedChange\", 7);\r\n    }\r\n    class_8.prototype.render = function () {\r\n        var _this_1 = this;\r\n        if (this.nodes && this.nodes.size) {\r\n            return (h(\"ion-list\", { style: {\r\n                    color: \"var(--al-item-color)\",\r\n                    \"border-width\": \"1px 0 0 0\",\r\n                    \"border-color\": \"var(--ion-list-header-border-color)\",\r\n                    \"border-style\": \"solid\",\r\n                    \"margin-top\": \"10px\"\r\n                } }, Array.from(this.nodes).map(function (_b) {\r\n                var nodeId = _b[0], node = _b[1];\r\n                return (h(\"ion-item\", { \"data-selected\": _this_1.selected === nodeId ? true : false, onClick: function () { return _this_1.selectedChange.emit(nodeId); } }, node.title));\r\n            })));\r\n        }\r\n        return (h(\"ion-item\", { style: {\r\n                color: \"var(--al-item-color)\",\r\n                \"border-width\": \"1px 0 0 0\",\r\n                \"border-color\": \"var(--ion-list-header-border-color)\",\r\n                \"border-style\": \"solid\",\r\n                \"margin-top\": \"10px\"\r\n            } }, h(\"p\", null, this._contentStrings.graphEmpty)));\r\n    };\r\n    Object.defineProperty(class_8, \"style\", {\r\n        get: function () { return \"ion-item{--color:var(--al-item-color);--border-color:var(--al-item-border-color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item[data-selected]{--color:var(--al-item-selected-color)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_8;\r\n}());\r\nvar img$7 = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBkPSJNMzIgNDY0aDQ0OEwyNTYgNDggMzIgNDY0em0yNDgtNjRoLTQ4di00OGg0OHY0OHptMC04MGgtNDh2LTk2aDQ4djk2eiIvPjwvc3ZnPg==';\r\nvar axial = \"Axial\";\r\nvar bounds = \"Bounds\";\r\nvar boundingBoxEnabled = \"Bounding Box\";\r\nvar brightness = \"Level\";\r\nvar clay = \"Clay\";\r\nvar contrast = \"Width\";\r\nvar controlsType = \"Controls Type\";\r\nvar coronal = \"Coronal\";\r\nvar displayMode = \"Display Mode\";\r\nvar graphEnabled$1 = \"Enable Node Placement\";\r\nvar material = \"Material\";\r\nvar normals = \"Normals\";\r\nvar orbit = \"Orbit\";\r\nvar orientation = \"Orientation\";\r\nvar recenter = \"Origin\";\r\nvar renderSteps = \"Render Steps\";\r\nvar rotate = \"Rotate\";\r\nvar saggital = \"Saggital\";\r\nvar sliceIndex = \"Slice Index\";\r\nvar slices = \"Slices\";\r\nvar slice = \"Slice\";\r\nvar trackball = \"Trackball\";\r\nvar units$1 = \"Units\";\r\nvar volume = \"Volume\";\r\nvar volumeSteps = \"Render Detail (only increase if you know your device is capable!)\";\r\nvar volumeStepsHighEnabled = \"Enable High Res\";\r\nvar volumeStepsHighEnabledWarning = \"Activate High Resolution Mode (Computationally Intensive!)\";\r\nvar windowingTitle = \"Windowing (Brightness/Contrast)\";\r\nvar wireframe = \"Wireframe\";\r\nvar xray = \"XRay\";\r\nvar i18n$7 = {\r\n    axial: axial,\r\n    bounds: bounds,\r\n    boundingBoxEnabled: boundingBoxEnabled,\r\n    brightness: brightness,\r\n    clay: clay,\r\n    contrast: contrast,\r\n    controlsType: controlsType,\r\n    coronal: coronal,\r\n    \"default\": \"Default\",\r\n    displayMode: displayMode,\r\n    graphEnabled: graphEnabled$1,\r\n    material: material,\r\n    normals: normals,\r\n    orbit: orbit,\r\n    orientation: orientation,\r\n    recenter: recenter,\r\n    renderSteps: renderSteps,\r\n    rotate: rotate,\r\n    saggital: saggital,\r\n    sliceIndex: sliceIndex,\r\n    slices: slices,\r\n    slice: slice,\r\n    trackball: trackball,\r\n    units: units$1,\r\n    volume: volume,\r\n    volumeSteps: volumeSteps,\r\n    volumeStepsHighEnabled: volumeStepsHighEnabled,\r\n    volumeStepsHighEnabledWarning: volumeStepsHighEnabledWarning,\r\n    windowingTitle: windowingTitle,\r\n    wireframe: wireframe,\r\n    xray: xray\r\n};\r\nvar AlSettings$2 = /** @class */ (function () {\r\n    function class_9(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$7;\r\n        this.displayModeChange = createEvent(this, \"displayModeChange\", 7);\r\n        this.orientationChange = createEvent(this, \"orientationChange\", 7);\r\n        this.slicesIndexChange = createEvent(this, \"slicesIndexChange\", 7);\r\n        this.slicesBrightnessChange = createEvent(this, \"slicesBrightnessChange\", 7);\r\n        this.slicesContrastChange = createEvent(this, \"slicesContrastChange\", 7);\r\n        this.volumeBrightnessChange = createEvent(this, \"volumeBrightnessChange\", 7);\r\n        this.volumeContrastChange = createEvent(this, \"volumeContrastChange\", 7);\r\n        this.volumeStepsChange = createEvent(this, \"volumeStepsChange\", 7);\r\n        this.volumeStepsHighEnabledChange = createEvent(this, \"volumeStepsHighEnabledChange\", 7);\r\n    }\r\n    class_9.prototype._displayMode = function (displayMode) {\r\n        this.displayMode = displayMode;\r\n        this.displayModeChange.emit(displayMode);\r\n    };\r\n    class_9.prototype._orientation = function (orientation) {\r\n        this.orientation = orientation;\r\n        this.orientationChange.emit(orientation);\r\n    };\r\n    class_9.prototype._slicesIndex = function (index) {\r\n        this.slicesIndex = index;\r\n        this.slicesIndexChange.emit(index);\r\n    };\r\n    class_9.prototype._slicesBrightness = function (brightness) {\r\n        this.slicesBrightness = brightness;\r\n        this.slicesBrightnessChange.emit(brightness);\r\n    };\r\n    class_9.prototype._slicesContrast = function (contrast) {\r\n        this.slicesContrast = contrast;\r\n        this.slicesContrastChange.emit(contrast);\r\n    };\r\n    class_9.prototype._volumeBrightness = function (brightness) {\r\n        this.volumeBrightness = brightness;\r\n        this.volumeBrightnessChange.emit(brightness);\r\n    };\r\n    class_9.prototype._volumeContrast = function (contrast) {\r\n        this.volumeContrast = contrast;\r\n        this.volumeContrastChange.emit(contrast);\r\n    };\r\n    class_9.prototype._volumeSteps = function (steps) {\r\n        steps = Math.round(steps * 10) / 10; // 1 decimal place.\r\n        this.volumeSteps = steps;\r\n        this.volumeStepsChange.emit(steps);\r\n    };\r\n    class_9.prototype._volumeStepsHighEnabled = function (enabled) {\r\n        if (enabled) {\r\n            this._volumeSteps(this.volumeSteps + 0.2);\r\n        }\r\n        else {\r\n            this._volumeSteps(this.volumeSteps - 0.2);\r\n        }\r\n    };\r\n    class_9.prototype.renderDisplayModeToggle = function () {\r\n        var _this_1 = this;\r\n        if (this.displayMode !== DisplayMode.MESH) {\r\n            return (h(\"ion-item\", { style: {\r\n                    display: \"var(--display-mode-display, block)\",\r\n                    \"margin-top\": \"10px\"\r\n                } }, h(\"span\", { title: this._contentStrings.displayMode }, \"Mode\"), h(\"select\", { slot: \"end\", onChange: function (e) { return _this_1._displayMode(e.srcElement\r\n                    .value); } }, h(\"option\", { selected: this.displayMode === DisplayMode.SLICES, value: DisplayMode.SLICES }, this._contentStrings.slices), h(\"option\", { selected: this.displayMode === DisplayMode.VOLUME, value: DisplayMode.VOLUME }, this._contentStrings.volume))));\r\n        }\r\n        return null;\r\n    };\r\n    class_9.prototype.renderHiResEnabled = function () {\r\n        var _this_1 = this;\r\n        return (h(\"ion-item\", { style: {\r\n                display: \"var(--volume-steps-high-display, block)\"\r\n            } }, h(\"span\", { title: this._contentStrings.volumeStepsHighEnabledWarning }, this._contentStrings.volumeStepsHighEnabled, \" \", h(\"ion-icon\", { src: img$7 })), h(\"ion-toggle\", { slot: \"end\", checked: this.volumeStepsHighEnabled, onIonChange: function (e) { return _this_1._volumeStepsHighEnabled(e.detail.checked); } })));\r\n    };\r\n    class_9.prototype.renderSlicesControls = function () {\r\n        var _this_1 = this;\r\n        return (h(\"div\", null, h(\"ion-item\", { style: {\r\n                display: \"var(--slices-orientation-display, block)\"\r\n            } }, h(\"span\", { color: \"primary\" }, \"Plane\"), h(\"select\", { slot: \"end\", onChange: function (e) { return _this_1._orientation(e.srcElement\r\n                .value); } }, h(\"option\", { selected: this.orientation === Orientation.CORONAL, value: Orientation.CORONAL }, this._contentStrings.coronal), h(\"option\", { selected: this.orientation === Orientation.SAGGITAL, value: Orientation.SAGGITAL }, this._contentStrings.saggital), h(\"option\", { selected: this.orientation === Orientation.AXIAL, value: Orientation.AXIAL }, this._contentStrings.axial))), h(\"ion-item\", { style: {\r\n                display: \"var(--slices-index-display, block)\"\r\n            } }, h(\"span\", null, this._contentStrings.slice), h(\"ion-range\", { slot: \"end\", min: 0, max: 1, step: 1 / this.slicesMaxIndex, value: this.slicesIndex, onIonChange: function (e) { return _this_1._slicesIndex(e.detail.value); } }))));\r\n    };\r\n    class_9.prototype.renderSlicesWindowingControls = function () {\r\n        var _this_1 = this;\r\n        return (h(\"div\", null, h(\"ion-list-header\", { style: {\r\n                color: \"var(--al-item-color)\",\r\n                \"border-width\": \"1px 0 0 0\",\r\n                \"border-color\": \"var(--ion-list-header-border-color)\",\r\n                \"border-style\": \"solid\",\r\n                \"margin-top\": \"10px\"\r\n            } }, h(\"span\", null, this._contentStrings.windowingTitle)), h(\"ion-item\", { style: {\r\n                display: \"var(--slices-brightness-display, block)\"\r\n            } }, h(\"span\", null, this._contentStrings.brightness), h(\"ion-range\", { slot: \"end\", min: 0, max: 1, step: 0.05, snaps: true, ticks: false, value: this.slicesBrightness, onIonChange: function (e) {\r\n                _this_1._slicesBrightness(e.detail.value);\r\n            } })), h(\"ion-item\", { style: {\r\n                display: \"var(--slices-contrast-display, block)\"\r\n            } }, h(\"span\", null, this._contentStrings.contrast), h(\"ion-range\", { slot: \"end\", min: 0, max: 1, step: 0.05, snaps: true, ticks: false, value: this.slicesContrast, onIonChange: function (e) { return _this_1._slicesContrast(e.detail.value); } }))));\r\n    };\r\n    class_9.prototype.renderVolumeWindowingControls = function () {\r\n        var _this_1 = this;\r\n        return (h(\"div\", null, h(\"ion-list-header\", { style: {\r\n                color: \"var(--al-item-color)\",\r\n                \"border-width\": \"1px 0 0 0\",\r\n                \"border-color\": \"var(--ion-list-header-border-color)\",\r\n                \"border-style\": \"solid\",\r\n                \"margin-top\": \"10px\"\r\n            } }, h(\"span\", null, this._contentStrings.windowingTitle)), h(\"ion-item\", { style: {\r\n                display: \"var(--volume-brightness-display, block)\"\r\n            } }, h(\"span\", null, this._contentStrings.brightness), h(\"ion-range\", { slot: \"end\", min: 0, max: 1, step: 0.05, snaps: true, ticks: false, value: this.volumeBrightness, onIonChange: function (e) {\r\n                _this_1._volumeBrightness(e.detail.value);\r\n            } })), h(\"ion-item\", { style: {\r\n                display: \"var(--volume-contrast-display, block)\"\r\n            } }, h(\"span\", null, this._contentStrings.contrast), h(\"ion-range\", { slot: \"end\", min: 0, max: 1, step: 0.05, snaps: true, ticks: false, value: this.volumeContrast, onIonChange: function (e) { return _this_1._volumeContrast(e.detail.value); } }))));\r\n    };\r\n    class_9.prototype.renderOptions = function () {\r\n        switch (this.displayMode) {\r\n            case DisplayMode.SLICES: {\r\n                return (h(\"div\", null, this.renderSlicesControls(), this.renderSlicesWindowingControls()));\r\n            }\r\n            case DisplayMode.VOLUME: {\r\n                return (h(\"div\", null, this.renderHiResEnabled(), this.renderVolumeWindowingControls()));\r\n            }\r\n            default: {\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    class_9.prototype.render = function () {\r\n        return (h(\"div\", { style: {\r\n                \"max-width\": \"100%\",\r\n                \"overflow-x\": \"hidden\"\r\n            } }, this.renderDisplayModeToggle(), this.renderOptions()));\r\n    };\r\n    Object.defineProperty(class_9, \"style\", {\r\n        get: function () { return \"select{padding:5px;min-width:100px;background-color:var(--al-select-background-color);color:var(--al-item-color);border:none}\\@supports (-moz-appearance:none){select{background-color:#fff!important;color:#000!important}}ion-label{color:var(--al-item-color)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_9;\r\n}());\r\nvar Tabs = /** @class */ (function () {\r\n    function class_10(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.transitioning = false;\r\n        this.onTabClicked = function (ev) {\r\n            var tab = ev.detail.tab;\r\n            _this_1.select(tab);\r\n        };\r\n        this.ionNavWillLoad = createEvent(this, \"ionNavWillLoad\", 7);\r\n        this.ionTabsWillChange = createEvent(this, \"ionTabsWillChange\", 3);\r\n        this.ionTabsDidChange = createEvent(this, \"ionTabsDidChange\", 3);\r\n    }\r\n    class_10.prototype.componentWillLoad = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var tabs;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        tabs = this.tabs;\r\n                        return [4 /*yield*/, this.select(tabs[0])];\r\n                    case 1:\r\n                        _b.sent();\r\n                        this.ionNavWillLoad.emit();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    class_10.prototype.componentWillRender = function () {\r\n        var tabBar = this.el.querySelector(\"ion-tab-bar\");\r\n        if (tabBar) {\r\n            var tab = this.selectedTab ? this.selectedTab.tab : undefined;\r\n            tabBar.selectedTab = tab;\r\n        }\r\n    };\r\n    /**\r\n     * Select a tab by the value of its `tab` property or an element reference.\r\n     *\r\n     * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.\r\n     */\r\n    class_10.prototype.select = function (tab) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var selectedTab;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.getTab(tab)];\r\n                    case 1:\r\n                        selectedTab = _b.sent();\r\n                        if (selectedTab) {\r\n                            if (!this.shouldSwitch(selectedTab)) {\r\n                                return [2 /*return*/, false];\r\n                            }\r\n                            this.setActive(selectedTab);\r\n                            this.tabSwitch();\r\n                            return [2 /*return*/, true];\r\n                        }\r\n                        return [2 /*return*/, false];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get a specific tab by the value of its `tab` property or an element reference.\r\n     *\r\n     * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.\r\n     */\r\n    class_10.prototype.getTab = function (tab) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var tabEl;\r\n            return __generator(this, function (_b) {\r\n                tabEl = typeof tab === \"string\" ? this.tabs.find(function (t) { return t.tab === tab; }) : tab;\r\n                return [2 /*return*/, tabEl];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get the currently selected tab.\r\n     */\r\n    class_10.prototype.getSelected = function () {\r\n        return Promise.resolve(this.selectedTab ? this.selectedTab.tab : undefined);\r\n    };\r\n    class_10.prototype.setActive = function (selectedTab) {\r\n        if (this.transitioning) {\r\n            return Promise.reject(\"transitioning already happening\");\r\n        }\r\n        this.transitioning = true;\r\n        this.leavingTab = this.selectedTab;\r\n        this.selectedTab = selectedTab;\r\n        this.ionTabsWillChange.emit({ tab: selectedTab.tab });\r\n        try {\r\n            selectedTab.setActive();\r\n        }\r\n        catch (e) {\r\n            // do nothing\r\n        }\r\n        return true;\r\n    };\r\n    class_10.prototype.tabSwitch = function () {\r\n        var selectedTab = this.selectedTab;\r\n        var leavingTab = this.leavingTab;\r\n        this.leavingTab = undefined;\r\n        this.transitioning = false;\r\n        if (!selectedTab) {\r\n            return;\r\n        }\r\n        if (leavingTab !== selectedTab) {\r\n            if (leavingTab) {\r\n                leavingTab.active = false;\r\n            }\r\n            this.ionTabsDidChange.emit({ tab: selectedTab.tab });\r\n        }\r\n    };\r\n    class_10.prototype.shouldSwitch = function (selectedTab) {\r\n        var leavingTab = this.selectedTab;\r\n        return (selectedTab !== undefined &&\r\n            selectedTab !== leavingTab &&\r\n            !this.transitioning);\r\n    };\r\n    Object.defineProperty(class_10.prototype, \"tabs\", {\r\n        get: function () {\r\n            return Array.from(this.el.querySelectorAll(\"ion-tab\"));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_10.prototype.render = function () {\r\n        return (h(Host, { onIonTabButtonClick: this.onTabClicked }, h(\"slot\", { name: \"top\" }), h(\"div\", { class: \"tabs-inner\" }, h(\"slot\", null)), h(\"slot\", { name: \"bottom\" })));\r\n    };\r\n    Object.defineProperty(class_10.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_10, \"style\", {\r\n        get: function () { return \":host{z-index:var(--z-index-page-container);--ion-tab-bar-color:var(--al-item-color)}.tabs-inner{position:relative}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_10;\r\n}());\r\nvar img$8 = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik0yNTYgMzg4Yy03Mi41OTcgMC0xMzItNTkuNDA1LTEzMi0xMzIgMC03Mi42MDEgNTkuNDAzLTEzMiAxMzItMTMyIDM2LjMgMCA2OS4yOTkgMTUuNCA5Mi40MDYgMzkuNjAxTDI3OCAyMzRoMTU0VjgwbC01MS42OTggNTEuNzAyQzM0OC40MDYgOTkuNzk4IDMwNC40MDYgODAgMjU2IDgwYy05Ni43OTcgMC0xNzYgNzkuMjAzLTE3NiAxNzZzNzguMDk0IDE3NiAxNzYgMTc2YzgxLjA0NSAwIDE0OC4yODctNTQuMTM0IDE2OS40MDEtMTI4SDM3OC44NWMtMTguNzQ1IDQ5LjU2MS02Ny4xMzggODQtMTIyLjg1IDg0eiI+PC9wYXRoPjwvc3ZnPgo=';\r\nvar AlUrlPicker = /** @class */ (function () {\r\n    function class_11(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.urls = null;\r\n        this.url = null;\r\n        this.urlChange = createEvent(this, \"urlChange\", 7);\r\n    }\r\n    class_11.prototype.render = function () {\r\n        var _this_1 = this;\r\n        if (this.urls) {\r\n            return (h(\"form\", { onSubmit: function (e) { return e.preventDefault(); } }, h(\"ion-item\", null, h(\"ion-select\", { id: \"select\", value: this.url, interface: \"popover\", placeholder: \"\", onIonChange: function (e) { return _this_1.urlChange.emit(e.detail.value); } }, Array.from(this.urls).map(function (_b) {\r\n                var url = _b[0], title = _b[1];\r\n                return (h(\"ion-select-option\", { value: url }, title));\r\n            }))), h(\"ion-item\", null, h(\"ion-input\", { id: \"input\", type: \"url\", size: 100, placeholder: \"src\", required: true, value: this.url, ref: function (el) { return (_this_1._input = el); } })), h(\"ion-item\", null, h(\"ion-button\", { id: \"submit\", size: \"small\", type: \"submit\", onClick: function () { return _this_1.urlChange.emit(_this_1._input.value); } }, h(\"ion-icon\", { src: img$8 }), \"\\u00A0Load\"))));\r\n        }\r\n        return null;\r\n    };\r\n    Object.defineProperty(class_11, \"style\", {\r\n        get: function () { return \"#select{--padding-start:0px;width:100%;max-width:100%!important}#input{--background:var(--al-input-background-color);--color:var(--al-input-color);--padding-start:var(--al-input-padding-start)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_11;\r\n}());\r\nvar img$9 = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzNjAgMzYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzNjAgMzYwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0xOTcuNSwzNTIuNGgtMzVWMTgwLjlMOC40LDEwM2MtOC42LTQuNC0xMi4xLTE0LjktNy43LTIzLjVjNC40LTguNiwxNC45LTEyLjEsMjMuNS03LjdMMTgwLDE1MC41bDE1Ni43LTc4LjhsMTUuNywzMS4zCglsLTE1NC45LDc3LjlWMzUyLjR6Ii8+CjxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE4MCIgY3k9IjE4MCIgcj0iNzUuOSIvPgo8cGF0aCBkPSJNMTgwLDM2OS45Yy0yLjcsMC01LjQtMC42LTcuOS0xLjlMOC40LDI4NS4zYy01LjktMy05LjYtOS05LjYtMTUuNlY4Ny40YzAtNi43LDMuOC0xMi44LDkuOS0xNS43TDE3Mi40LTcuOQoJYzQuOC0yLjMsMTAuNC0yLjMsMTUuMywwbDE2NC42LDc5LjVjNiwyLjksOS45LDksOS45LDE1Ljh2MTgxLjhjMCw2LjYtMy43LDEyLjYtOS42LDE1LjZsLTE2NC42LDgzLjMKCUMxODUuNCwzNjkuMywxODIuNywzNjkuOSwxODAsMzY5Ljl6IE0zMy44LDI1OC45TDE4MCwzMzIuOGwxNDcuMS03NC41di0xNjBMMTgwLDI3LjNsLTE0Ni4zLDcxVjI1OC45eiIvPgo8cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA0LjEsMTMxLjgiLz4KPHBhdGggY2xhc3M9InN0MiIgZD0iTTkyLjEsMTM5LjUiLz4KPC9zdmc+Cg==';\r\nvar img$a = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDM2MCAzNjAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM2MCAzNjA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGNpcmNsZSBjbGFzcz0ic3QwIiBjeD0iMTgwIiBjeT0iMTgwIiByPSIxMDEuMiIvPgo8L3N2Zz4K';\r\nvar img$b = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0zOTMuMSwzMzcuN3YtNTljMC05LjMtNy44LTE2LjgtMTcuMy0xNi44SDE2Ni41Yy05LjUsMC0xNy4zLDcuNi0xNy4zLDE2Ljh2MTY4LjZjMCw5LjMsNy44LDE2LjksMTcuMywxNi45aDIwOS40CgljOS41LDAsMTcuMy03LjYsMTcuMy0xNi44di01OWw2Ni41LDY3LjRWMjcwLjNMMzkzLjEsMzM3Ljd6Ii8+CjxwYXRoIGQ9Ik05OS41LDMwNC4zYzAtODEuMyw2NS4zLTE0Ny44LDE0NS4yLTE0Ny44djczLjlsOTYuOC05OC42bC05Ni44LTk4LjZ2NzMuOWMtMTA2LjUsMC0xOTMuNiw4OC43LTE5My42LDE5Ny4xIi8+Cjwvc3ZnPgo=';\r\nvar img$c = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgY2xhc3M9InMtaW9uLWljb24iPjxwYXRoIGQ9Ik0yNTYgNDhjLTQyLjkgMC04NC4yIDEzLTExOS4yIDM3LjUtMzQuMiAyNC02MC4yIDU3LjItNzUuMSA5Ni4xTDU4IDE5Mmg0NS43bDEuOS01YzguMi0xNy44IDE5LjQtMzMuOSAzMy41LTQ4IDMxLjItMzEuMiA3Mi43LTQ4LjQgMTE2LjktNDguNHM4NS43IDE3LjIgMTE2LjkgNDguNGMzMS4yIDMxLjIgNDguNCA3Mi43IDQ4LjQgMTE2LjkgMCA0NC4xLTE3LjIgODUuNy00OC40IDExNi45LTMxLjIgMzEuMi03Mi43IDQ4LjQtMTE2LjkgNDguNC00NC4xIDAtODUuNi0xNy4yLTExNi45LTQ4LjQtMTQtMTQtMjUuMy0zMC4xLTMzLjUtNDcuOWwtMS45LTVINThsMy42IDEwLjRjMTQuOSAzOC45IDQwLjkgNzIuMSA3NS4xIDk2LjFDMTcxLjggNDUxLjEgMjEzIDQ2NCAyNTYgNDY0YzExNC43IDAgMjA4LTkzLjMgMjA4LTIwOFMzNzAuNyA0OCAyNTYgNDh6Ij48L3BhdGg+PHBhdGggZD0iTTQ4IDI3Ny40aDE4OS43bC00My42IDQ0LjdMMjI0IDM1Mmw5Ni05Ni05Ni05Ni0zMSAyOS45IDQ0LjcgNDQuN0g0OHY0Mi44eiI+PC9wYXRoPjwvc3ZnPgo=';\r\nvar img$d = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuNiwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0xMDguMSwyODYuNGMwLTgxLjMsNjUuMy0xNDcuOCwxNDUuMi0xNDcuOHY3My45bDk2LjgtOTguNmwtOTYuOC05OC42djczLjlDMTQ2LjgsODkuMiw1OS43LDE3OCw1OS43LDI4Ni40Ii8+CjxjaXJjbGUgY3g9IjMwMyIgY3k9IjM1MS40IiByPSIxMDQiLz4KPC9zdmc+Cg==';\r\nvar axial$1 = \"Axial\";\r\nvar bounds$1 = \"Bounds\";\r\nvar boundingBoxEnabled$1 = \"Bounding Box\";\r\nvar brightness$1 = \"Level\";\r\nvar clay$1 = \"Clay\";\r\nvar contrast$1 = \"Width\";\r\nvar controlsType$1 = \"Controls Type\";\r\nvar coronal$1 = \"Coronal\";\r\nvar displayMode$1 = \"Display Mode\";\r\nvar graphEnabled$2 = \"Enable Node Placement\";\r\nvar material$1 = \"Material\";\r\nvar meters$1 = \"Meters\";\r\nvar millimeters$1 = \"Millimeters\";\r\nvar normals$1 = \"Normals\";\r\nvar orbit$1 = \"Orbit\";\r\nvar orientation$1 = \"Orientation\";\r\nvar recenter$1 = \"Origin\";\r\nvar renderSteps$1 = \"Render Steps\";\r\nvar rotate$1 = \"Rotate\";\r\nvar saggital$1 = \"Saggital\";\r\nvar sliceIndex$1 = \"Slice Index\";\r\nvar slices$1 = \"Slices\";\r\nvar slice$1 = \"Slice\";\r\nvar trackball$1 = \"Trackball\";\r\nvar units$2 = \"Units\";\r\nvar volume$1 = \"Volume\";\r\nvar volumeSteps$1 = \"Render Detail (only increase if you know your device is capable!)\";\r\nvar volumeStepsHighEnabled$1 = \"Enable High Res\";\r\nvar volumeStepsHighEnabledWarning$1 = \"Activate High Resolution Mode (Computationally Intensive!)\";\r\nvar windowingTitle$1 = \"Windowing (Brightness/Contrast)\";\r\nvar wireframe$1 = \"Wireframe\";\r\nvar xray$1 = \"XRay\";\r\nvar i18n$8 = {\r\n    axial: axial$1,\r\n    bounds: bounds$1,\r\n    boundingBoxEnabled: boundingBoxEnabled$1,\r\n    brightness: brightness$1,\r\n    clay: clay$1,\r\n    contrast: contrast$1,\r\n    controlsType: controlsType$1,\r\n    coronal: coronal$1,\r\n    \"default\": \"Default\",\r\n    displayMode: displayMode$1,\r\n    graphEnabled: graphEnabled$2,\r\n    material: material$1,\r\n    meters: meters$1,\r\n    millimeters: millimeters$1,\r\n    normals: normals$1,\r\n    orbit: orbit$1,\r\n    orientation: orientation$1,\r\n    recenter: recenter$1,\r\n    renderSteps: renderSteps$1,\r\n    rotate: rotate$1,\r\n    saggital: saggital$1,\r\n    sliceIndex: sliceIndex$1,\r\n    slices: slices$1,\r\n    slice: slice$1,\r\n    trackball: trackball$1,\r\n    units: units$2,\r\n    volume: volume$1,\r\n    volumeSteps: volumeSteps$1,\r\n    volumeStepsHighEnabled: volumeStepsHighEnabled$1,\r\n    volumeStepsHighEnabledWarning: volumeStepsHighEnabledWarning$1,\r\n    windowingTitle: windowingTitle$1,\r\n    wireframe: wireframe$1,\r\n    xray: xray$1\r\n};\r\nvar AlSettings$3 = /** @class */ (function () {\r\n    function class_12(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._contentStrings = i18n$8;\r\n        this.boundingBoxEnabledChange = createEvent(this, \"boundingBoxEnabledChange\", 7);\r\n        this.controlsTypeChange = createEvent(this, \"controlsTypeChange\", 7);\r\n        this.recenter = createEvent(this, \"recenter\", 7);\r\n    }\r\n    class_12.prototype._boundingBoxEnabled = function (enabled) {\r\n        this.boundingBoxEnabled = enabled;\r\n        this.boundingBoxEnabledChange.emit(enabled);\r\n    };\r\n    class_12.prototype._controlsType = function (controlsType) {\r\n        this.controlsType = controlsType;\r\n        this.controlsTypeChange.emit(controlsType);\r\n    };\r\n    class_12.prototype._switchBoundingBoxEnabled = function () {\r\n        if (this.boundingBoxEnabled) {\r\n            this._boundingBoxEnabled(false);\r\n        }\r\n        else {\r\n            this._boundingBoxEnabled(true);\r\n        }\r\n    };\r\n    class_12.prototype._switchControls = function () {\r\n        if (this.controlsType === ControlsType.ORBIT) {\r\n            this._controlsType(ControlsType.TRACKBALL);\r\n        }\r\n        else if (this.controlsType === ControlsType.TRACKBALL) {\r\n            this._controlsType(ControlsType.ORBIT);\r\n        }\r\n    };\r\n    class_12.prototype.renderControlsTypeSelect = function () {\r\n        var _this_1 = this;\r\n        var cameraIcon;\r\n        var cameraLabel;\r\n        if (this.controlsType === ControlsType.ORBIT) {\r\n            cameraIcon = img$b;\r\n            cameraLabel = this._contentStrings.orbit;\r\n        }\r\n        else if (this.controlsType === ControlsType.TRACKBALL) {\r\n            cameraIcon = img$d;\r\n            cameraLabel = this._contentStrings.rotate;\r\n        }\r\n        var boundingBoxEnabledIcon;\r\n        if (this.boundingBoxEnabled) {\r\n            boundingBoxEnabledIcon = img$9;\r\n        }\r\n        else {\r\n            boundingBoxEnabledIcon = img$a;\r\n        }\r\n        return (h(\"div\", { style: {\r\n                \"margin-top\": \"10px\",\r\n                \"text-align\": \"center\"\r\n            } }, h(\"ion-button\", { style: {\r\n                width: \"28%\",\r\n                height: \"45px\",\r\n                \"margin-left\": \"5px\",\r\n                \"margin-right\": \"5px\"\r\n            }, size: \"small\", onClick: function () {\r\n                _this_1._switchControls();\r\n            } }, h(\"div\", { style: {\r\n                \"font-size\": \"10px\",\r\n                color: \"white\",\r\n                \"margin-bottom\": \"2px\"\r\n            } }, h(\"ion-icon\", { style: {\r\n                \"min-width\": \"20px\",\r\n                \"min-height\": \"20px\",\r\n                \"margin-bottom\": \"2px\"\r\n            }, src: cameraIcon, title: cameraLabel }), h(\"br\", null), cameraLabel)), h(\"ion-button\", { style: {\r\n                width: \"28%\",\r\n                height: \"45px\",\r\n                \"margin-left\": \"5px\",\r\n                \"margin-right\": \"5px\"\r\n            }, size: \"small\", onClick: function () {\r\n                _this_1.recenter.emit();\r\n            } }, h(\"div\", { style: {\r\n                \"font-size\": \"10px\",\r\n                color: \"white\",\r\n                \"margin-bottom\": \"2px\"\r\n            } }, h(\"ion-icon\", { style: {\r\n                \"min-width\": \"20px\",\r\n                \"min-height\": \"20px\",\r\n                \"margin-bottom\": \"2px\"\r\n            }, src: img$c, title: this._contentStrings.recenter }), h(\"br\", null), this._contentStrings.recenter)), h(\"ion-button\", { style: {\r\n                width: \"28%\",\r\n                height: \"45px\",\r\n                \"margin-left\": \"5px\",\r\n                \"margin-right\": \"5px\"\r\n            }, size: \"small\", onClick: function () {\r\n                _this_1._switchBoundingBoxEnabled();\r\n            } }, h(\"div\", { style: {\r\n                \"font-size\": \"10px\",\r\n                color: \"white\",\r\n                \"margin-bottom\": \"2px\"\r\n            } }, h(\"ion-icon\", { style: {\r\n                \"min-width\": \"20px\",\r\n                \"min-height\": \"20px\",\r\n                \"margin-bottom\": \"2px\"\r\n            }, src: boundingBoxEnabledIcon, title: this._contentStrings.bounds }), h(\"br\", null), this._contentStrings.bounds))));\r\n    };\r\n    class_12.prototype.render = function () {\r\n        return (h(\"div\", { style: {\r\n                \"max-width\": \"100%\",\r\n                \"overflow-x\": \"hidden\",\r\n                \"border-width\": \"0 0 1px 0\",\r\n                \"border-color\": \"var(--ion-list-header-border-color)\",\r\n                \"border-style\": \"solid\",\r\n                \"padding-bottom\": \"10px\",\r\n                \"margin-bottom\": \"10px\"\r\n            } }, this.renderControlsTypeSelect()));\r\n    };\r\n    Object.defineProperty(class_12, \"style\", {\r\n        get: function () { return \"select{padding:5px;min-width:100px;background-color:var(--al-select-background-color);color:var(--al-item-color);border:none}\\@supports (-moz-appearance:none){select{background-color:#fff!important;color:#000!important}}ion-label{color:var(--al-item-color)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_12;\r\n}());\r\nvar KeyDown;\r\n(function (KeyDown) {\r\n    KeyDown[KeyDown[\"Backspace\"] = 8] = \"Backspace\";\r\n    KeyDown[KeyDown[\"Tab\"] = 9] = \"Tab\";\r\n    KeyDown[KeyDown[\"Enter\"] = 13] = \"Enter\";\r\n    KeyDown[KeyDown[\"Shift\"] = 16] = \"Shift\";\r\n    KeyDown[KeyDown[\"Ctrl\"] = 17] = \"Ctrl\";\r\n    KeyDown[KeyDown[\"Alt\"] = 18] = \"Alt\";\r\n    KeyDown[KeyDown[\"PauseBreak\"] = 19] = \"PauseBreak\";\r\n    KeyDown[KeyDown[\"CapsLock\"] = 20] = \"CapsLock\";\r\n    KeyDown[KeyDown[\"Escape\"] = 27] = \"Escape\";\r\n    KeyDown[KeyDown[\"Spacebar\"] = 32] = \"Spacebar\";\r\n    KeyDown[KeyDown[\"PageUp\"] = 33] = \"PageUp\";\r\n    KeyDown[KeyDown[\"PageDown\"] = 34] = \"PageDown\";\r\n    KeyDown[KeyDown[\"End\"] = 35] = \"End\";\r\n    KeyDown[KeyDown[\"Home\"] = 36] = \"Home\";\r\n    KeyDown[KeyDown[\"LeftArrow\"] = 37] = \"LeftArrow\";\r\n    KeyDown[KeyDown[\"UpArrow\"] = 38] = \"UpArrow\";\r\n    KeyDown[KeyDown[\"RightArrow\"] = 39] = \"RightArrow\";\r\n    KeyDown[KeyDown[\"DownArrow\"] = 40] = \"DownArrow\";\r\n    KeyDown[KeyDown[\"PrintScrn\"] = 44] = \"PrintScrn\";\r\n    KeyDown[KeyDown[\"Insert\"] = 45] = \"Insert\";\r\n    KeyDown[KeyDown[\"Delete\"] = 46] = \"Delete\";\r\n    KeyDown[KeyDown[\"Zero\"] = 48] = \"Zero\";\r\n    KeyDown[KeyDown[\"One\"] = 49] = \"One\";\r\n    KeyDown[KeyDown[\"Two\"] = 50] = \"Two\";\r\n    KeyDown[KeyDown[\"Three\"] = 51] = \"Three\";\r\n    KeyDown[KeyDown[\"Four\"] = 52] = \"Four\";\r\n    KeyDown[KeyDown[\"Five\"] = 53] = \"Five\";\r\n    KeyDown[KeyDown[\"Six\"] = 54] = \"Six\";\r\n    KeyDown[KeyDown[\"Seven\"] = 55] = \"Seven\";\r\n    KeyDown[KeyDown[\"Eight\"] = 56] = \"Eight\";\r\n    KeyDown[KeyDown[\"Nine\"] = 57] = \"Nine\";\r\n    KeyDown[KeyDown[\"a\"] = 65] = \"a\";\r\n    KeyDown[KeyDown[\"b\"] = 66] = \"b\";\r\n    KeyDown[KeyDown[\"c\"] = 67] = \"c\";\r\n    KeyDown[KeyDown[\"d\"] = 68] = \"d\";\r\n    KeyDown[KeyDown[\"e\"] = 69] = \"e\";\r\n    KeyDown[KeyDown[\"f\"] = 70] = \"f\";\r\n    KeyDown[KeyDown[\"g\"] = 71] = \"g\";\r\n    KeyDown[KeyDown[\"h\"] = 72] = \"h\";\r\n    KeyDown[KeyDown[\"i\"] = 73] = \"i\";\r\n    KeyDown[KeyDown[\"j\"] = 74] = \"j\";\r\n    KeyDown[KeyDown[\"k\"] = 75] = \"k\";\r\n    KeyDown[KeyDown[\"l\"] = 76] = \"l\";\r\n    KeyDown[KeyDown[\"m\"] = 77] = \"m\";\r\n    KeyDown[KeyDown[\"n\"] = 78] = \"n\";\r\n    KeyDown[KeyDown[\"o\"] = 79] = \"o\";\r\n    KeyDown[KeyDown[\"p\"] = 80] = \"p\";\r\n    KeyDown[KeyDown[\"q\"] = 81] = \"q\";\r\n    KeyDown[KeyDown[\"r\"] = 82] = \"r\";\r\n    KeyDown[KeyDown[\"s\"] = 83] = \"s\";\r\n    KeyDown[KeyDown[\"t\"] = 84] = \"t\";\r\n    KeyDown[KeyDown[\"u\"] = 85] = \"u\";\r\n    KeyDown[KeyDown[\"v\"] = 86] = \"v\";\r\n    KeyDown[KeyDown[\"w\"] = 87] = \"w\";\r\n    KeyDown[KeyDown[\"x\"] = 88] = \"x\";\r\n    KeyDown[KeyDown[\"y\"] = 89] = \"y\";\r\n    KeyDown[KeyDown[\"z\"] = 90] = \"z\";\r\n    KeyDown[KeyDown[\"LeftWindowKey\"] = 91] = \"LeftWindowKey\";\r\n    KeyDown[KeyDown[\"RightWindowKey\"] = 92] = \"RightWindowKey\";\r\n    KeyDown[KeyDown[\"SelectKey\"] = 93] = \"SelectKey\";\r\n    KeyDown[KeyDown[\"Numpad0\"] = 96] = \"Numpad0\";\r\n    KeyDown[KeyDown[\"Numpad1\"] = 97] = \"Numpad1\";\r\n    KeyDown[KeyDown[\"Numpad2\"] = 98] = \"Numpad2\";\r\n    KeyDown[KeyDown[\"Numpad3\"] = 99] = \"Numpad3\";\r\n    KeyDown[KeyDown[\"Numpad4\"] = 100] = \"Numpad4\";\r\n    KeyDown[KeyDown[\"Numpad5\"] = 101] = \"Numpad5\";\r\n    KeyDown[KeyDown[\"Numpad6\"] = 102] = \"Numpad6\";\r\n    KeyDown[KeyDown[\"Numpad7\"] = 103] = \"Numpad7\";\r\n    KeyDown[KeyDown[\"Numpad8\"] = 104] = \"Numpad8\";\r\n    KeyDown[KeyDown[\"Numpad9\"] = 105] = \"Numpad9\";\r\n    KeyDown[KeyDown[\"Multiply\"] = 106] = \"Multiply\";\r\n    KeyDown[KeyDown[\"NumpadPlus\"] = 107] = \"NumpadPlus\";\r\n    KeyDown[KeyDown[\"NumpadMinus\"] = 109] = \"NumpadMinus\";\r\n    KeyDown[KeyDown[\"DecimalPoint\"] = 110] = \"DecimalPoint\";\r\n    KeyDown[KeyDown[\"Divide\"] = 111] = \"Divide\";\r\n    KeyDown[KeyDown[\"F1\"] = 112] = \"F1\";\r\n    KeyDown[KeyDown[\"F2\"] = 113] = \"F2\";\r\n    KeyDown[KeyDown[\"F3\"] = 114] = \"F3\";\r\n    KeyDown[KeyDown[\"F4\"] = 115] = \"F4\";\r\n    KeyDown[KeyDown[\"F5\"] = 116] = \"F5\";\r\n    KeyDown[KeyDown[\"F6\"] = 117] = \"F6\";\r\n    KeyDown[KeyDown[\"F7\"] = 118] = \"F7\";\r\n    KeyDown[KeyDown[\"F8\"] = 119] = \"F8\";\r\n    KeyDown[KeyDown[\"F9\"] = 120] = \"F9\";\r\n    KeyDown[KeyDown[\"F10\"] = 121] = \"F10\";\r\n    KeyDown[KeyDown[\"F11\"] = 122] = \"F11\";\r\n    KeyDown[KeyDown[\"F12\"] = 123] = \"F12\";\r\n    KeyDown[KeyDown[\"NumLock\"] = 144] = \"NumLock\";\r\n    KeyDown[KeyDown[\"ScrollLock\"] = 145] = \"ScrollLock\";\r\n    KeyDown[KeyDown[\"Semicolon\"] = 186] = \"Semicolon\";\r\n    KeyDown[KeyDown[\"Equals\"] = 187] = \"Equals\";\r\n    KeyDown[KeyDown[\"Comma\"] = 188] = \"Comma\";\r\n    KeyDown[KeyDown[\"LessThan\"] = 188] = \"LessThan\";\r\n    KeyDown[KeyDown[\"Dash\"] = 189] = \"Dash\";\r\n    KeyDown[KeyDown[\"Period\"] = 190] = \"Period\";\r\n    KeyDown[KeyDown[\"GreaterThan\"] = 190] = \"GreaterThan\";\r\n    KeyDown[KeyDown[\"ForwardSlash\"] = 191] = \"ForwardSlash\";\r\n    KeyDown[KeyDown[\"QuestionMark\"] = 191] = \"QuestionMark\";\r\n    KeyDown[KeyDown[\"GraveAccent\"] = 192] = \"GraveAccent\";\r\n    KeyDown[KeyDown[\"Tilde\"] = 192] = \"Tilde\";\r\n    KeyDown[KeyDown[\"OpenCurlyBracket\"] = 219] = \"OpenCurlyBracket\";\r\n    KeyDown[KeyDown[\"OpenSquareBracket\"] = 219] = \"OpenSquareBracket\";\r\n    KeyDown[KeyDown[\"BackSlash\"] = 220] = \"BackSlash\";\r\n    KeyDown[KeyDown[\"VerticalPipe\"] = 220] = \"VerticalPipe\";\r\n    KeyDown[KeyDown[\"CloseCurlyBracket\"] = 221] = \"CloseCurlyBracket\";\r\n    KeyDown[KeyDown[\"CloseSquareBracket\"] = 221] = \"CloseSquareBracket\";\r\n    KeyDown[KeyDown[\"Quote\"] = 222] = \"Quote\";\r\n    KeyDown[KeyDown[\"CommandFF\"] = 224] = \"CommandFF\";\r\n})(KeyDown || (KeyDown = {}));\r\nvar KeyPress;\r\n(function (KeyPress) {\r\n    KeyPress[KeyPress[\"Backspace\"] = 8] = \"Backspace\";\r\n    KeyPress[KeyPress[\"Enter\"] = 13] = \"Enter\";\r\n    KeyPress[KeyPress[\"Spacebar\"] = 32] = \"Spacebar\";\r\n    KeyPress[KeyPress[\"Hash\"] = 35] = \"Hash\";\r\n    KeyPress[KeyPress[\"GraveAccent\"] = 39] = \"GraveAccent\";\r\n    KeyPress[KeyPress[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\r\n    KeyPress[KeyPress[\"Asterisk\"] = 42] = \"Asterisk\";\r\n    KeyPress[KeyPress[\"Plus\"] = 43] = \"Plus\";\r\n    KeyPress[KeyPress[\"Comma\"] = 44] = \"Comma\";\r\n    KeyPress[KeyPress[\"Minus\"] = 45] = \"Minus\";\r\n    KeyPress[KeyPress[\"Period\"] = 46] = \"Period\";\r\n    KeyPress[KeyPress[\"ForwardSlash\"] = 47] = \"ForwardSlash\";\r\n    KeyPress[KeyPress[\"Zero\"] = 48] = \"Zero\";\r\n    KeyPress[KeyPress[\"One\"] = 49] = \"One\";\r\n    KeyPress[KeyPress[\"Two\"] = 50] = \"Two\";\r\n    KeyPress[KeyPress[\"Three\"] = 51] = \"Three\";\r\n    KeyPress[KeyPress[\"Four\"] = 52] = \"Four\";\r\n    KeyPress[KeyPress[\"Five\"] = 53] = \"Five\";\r\n    KeyPress[KeyPress[\"Six\"] = 54] = \"Six\";\r\n    KeyPress[KeyPress[\"Seven\"] = 55] = \"Seven\";\r\n    KeyPress[KeyPress[\"Eight\"] = 56] = \"Eight\";\r\n    KeyPress[KeyPress[\"Nine\"] = 57] = \"Nine\";\r\n    KeyPress[KeyPress[\"Colon\"] = 58] = \"Colon\";\r\n    KeyPress[KeyPress[\"Semicolon\"] = 59] = \"Semicolon\";\r\n    KeyPress[KeyPress[\"LessThan\"] = 60] = \"LessThan\";\r\n    KeyPress[KeyPress[\"Equals\"] = 61] = \"Equals\";\r\n    KeyPress[KeyPress[\"GreaterThan\"] = 62] = \"GreaterThan\";\r\n    KeyPress[KeyPress[\"QuestionMark\"] = 63] = \"QuestionMark\";\r\n    KeyPress[KeyPress[\"At\"] = 64] = \"At\";\r\n    KeyPress[KeyPress[\"OpenSquareBracket\"] = 91] = \"OpenSquareBracket\";\r\n    KeyPress[KeyPress[\"BackSlash\"] = 92] = \"BackSlash\";\r\n    KeyPress[KeyPress[\"CloseSquareBracket\"] = 93] = \"CloseSquareBracket\";\r\n    KeyPress[KeyPress[\"a\"] = 97] = \"a\";\r\n    KeyPress[KeyPress[\"b\"] = 98] = \"b\";\r\n    KeyPress[KeyPress[\"c\"] = 99] = \"c\";\r\n    KeyPress[KeyPress[\"d\"] = 100] = \"d\";\r\n    KeyPress[KeyPress[\"e\"] = 101] = \"e\";\r\n    KeyPress[KeyPress[\"f\"] = 102] = \"f\";\r\n    KeyPress[KeyPress[\"g\"] = 103] = \"g\";\r\n    KeyPress[KeyPress[\"h\"] = 104] = \"h\";\r\n    KeyPress[KeyPress[\"i\"] = 105] = \"i\";\r\n    KeyPress[KeyPress[\"j\"] = 106] = \"j\";\r\n    KeyPress[KeyPress[\"k\"] = 107] = \"k\";\r\n    KeyPress[KeyPress[\"l\"] = 108] = \"l\";\r\n    KeyPress[KeyPress[\"m\"] = 109] = \"m\";\r\n    KeyPress[KeyPress[\"n\"] = 110] = \"n\";\r\n    KeyPress[KeyPress[\"o\"] = 111] = \"o\";\r\n    KeyPress[KeyPress[\"p\"] = 112] = \"p\";\r\n    KeyPress[KeyPress[\"q\"] = 113] = \"q\";\r\n    KeyPress[KeyPress[\"r\"] = 114] = \"r\";\r\n    KeyPress[KeyPress[\"s\"] = 115] = \"s\";\r\n    KeyPress[KeyPress[\"t\"] = 116] = \"t\";\r\n    KeyPress[KeyPress[\"u\"] = 117] = \"u\";\r\n    KeyPress[KeyPress[\"v\"] = 118] = \"v\";\r\n    KeyPress[KeyPress[\"w\"] = 119] = \"w\";\r\n    KeyPress[KeyPress[\"x\"] = 120] = \"x\";\r\n    KeyPress[KeyPress[\"y\"] = 121] = \"y\";\r\n    KeyPress[KeyPress[\"z\"] = 122] = \"z\";\r\n    KeyPress[KeyPress[\"OpenCurlyBracket\"] = 123] = \"OpenCurlyBracket\";\r\n    KeyPress[KeyPress[\"VerticalPipe\"] = 124] = \"VerticalPipe\";\r\n    KeyPress[KeyPress[\"CloseCurlyBracket\"] = 125] = \"CloseCurlyBracket\";\r\n    KeyPress[KeyPress[\"Tilde\"] = 126] = \"Tilde\";\r\n})(KeyPress || (KeyPress = {}));\r\n// Polyfills\r\nif (Number.EPSILON === undefined) {\r\n    Number.EPSILON = Math.pow(2, -52);\r\n}\r\nif (Number.isInteger === undefined) {\r\n    // Missing in IE\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\r\n    Number.isInteger = function (value) {\r\n        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\r\n    };\r\n}\r\n//\r\nif (Math.sign === undefined) {\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n    Math.sign = function (x) {\r\n        return (x < 0) ? -1 : (x > 0) ? 1 : +x;\r\n    };\r\n}\r\nif ('name' in Function.prototype === false) {\r\n    // Missing in IE\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n    Object.defineProperty(Function.prototype, 'name', {\r\n        get: function () {\r\n            return this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1];\r\n        }\r\n    });\r\n}\r\nif (Object.assign === undefined) {\r\n    // Missing in IE\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n    (function () {\r\n        Object.assign = function (target) {\r\n            if (target === undefined || target === null) {\r\n                throw new TypeError('Cannot convert undefined or null to object');\r\n            }\r\n            var output = Object(target);\r\n            for (var index = 1; index < arguments.length; index++) {\r\n                var source = arguments[index];\r\n                if (source !== undefined && source !== null) {\r\n                    for (var nextKey in source) {\r\n                        if (Object.prototype.hasOwnProperty.call(source, nextKey)) {\r\n                            output[nextKey] = source[nextKey];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return output;\r\n        };\r\n    })();\r\n}\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\nfunction EventDispatcher() { }\r\nObject.assign(EventDispatcher.prototype, {\r\n    addEventListener: function (type, listener) {\r\n        if (this._listeners === undefined)\r\n            this._listeners = {};\r\n        var listeners = this._listeners;\r\n        if (listeners[type] === undefined) {\r\n            listeners[type] = [];\r\n        }\r\n        if (listeners[type].indexOf(listener) === -1) {\r\n            listeners[type].push(listener);\r\n        }\r\n    },\r\n    hasEventListener: function (type, listener) {\r\n        if (this._listeners === undefined)\r\n            return false;\r\n        var listeners = this._listeners;\r\n        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\r\n    },\r\n    removeEventListener: function (type, listener) {\r\n        if (this._listeners === undefined)\r\n            return;\r\n        var listeners = this._listeners;\r\n        var listenerArray = listeners[type];\r\n        if (listenerArray !== undefined) {\r\n            var index = listenerArray.indexOf(listener);\r\n            if (index !== -1) {\r\n                listenerArray.splice(index, 1);\r\n            }\r\n        }\r\n    },\r\n    dispatchEvent: function (event) {\r\n        if (this._listeners === undefined)\r\n            return;\r\n        var listeners = this._listeners;\r\n        var listenerArray = listeners[event.type];\r\n        if (listenerArray !== undefined) {\r\n            event.target = this;\r\n            var array = listenerArray.slice(0);\r\n            for (var i = 0, l = array.length; i < l; i++) {\r\n                array[i].call(this, event);\r\n            }\r\n        }\r\n    }\r\n});\r\nvar REVISION = '107';\r\nvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\r\nvar TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\r\nvar CullFaceNone = 0;\r\nvar CullFaceBack = 1;\r\nvar CullFaceFront = 2;\r\nvar CullFaceFrontBack = 3;\r\nvar FrontFaceDirectionCW = 0;\r\nvar FrontFaceDirectionCCW = 1;\r\nvar BasicShadowMap = 0;\r\nvar PCFShadowMap = 1;\r\nvar PCFSoftShadowMap = 2;\r\nvar FrontSide = 0;\r\nvar BackSide = 1;\r\nvar DoubleSide = 2;\r\nvar FlatShading = 1;\r\nvar SmoothShading = 2;\r\nvar NoColors = 0;\r\nvar FaceColors = 1;\r\nvar VertexColors = 2;\r\nvar NoBlending = 0;\r\nvar NormalBlending = 1;\r\nvar AdditiveBlending = 2;\r\nvar SubtractiveBlending = 3;\r\nvar MultiplyBlending = 4;\r\nvar CustomBlending = 5;\r\nvar AddEquation = 100;\r\nvar SubtractEquation = 101;\r\nvar ReverseSubtractEquation = 102;\r\nvar MinEquation = 103;\r\nvar MaxEquation = 104;\r\nvar ZeroFactor = 200;\r\nvar OneFactor = 201;\r\nvar SrcColorFactor = 202;\r\nvar OneMinusSrcColorFactor = 203;\r\nvar SrcAlphaFactor = 204;\r\nvar OneMinusSrcAlphaFactor = 205;\r\nvar DstAlphaFactor = 206;\r\nvar OneMinusDstAlphaFactor = 207;\r\nvar DstColorFactor = 208;\r\nvar OneMinusDstColorFactor = 209;\r\nvar SrcAlphaSaturateFactor = 210;\r\nvar NeverDepth = 0;\r\nvar AlwaysDepth = 1;\r\nvar LessDepth = 2;\r\nvar LessEqualDepth = 3;\r\nvar EqualDepth = 4;\r\nvar GreaterEqualDepth = 5;\r\nvar GreaterDepth = 6;\r\nvar NotEqualDepth = 7;\r\nvar MultiplyOperation = 0;\r\nvar MixOperation = 1;\r\nvar AddOperation = 2;\r\nvar NoToneMapping = 0;\r\nvar LinearToneMapping = 1;\r\nvar ReinhardToneMapping = 2;\r\nvar Uncharted2ToneMapping = 3;\r\nvar CineonToneMapping = 4;\r\nvar ACESFilmicToneMapping = 5;\r\nvar UVMapping = 300;\r\nvar CubeReflectionMapping = 301;\r\nvar CubeRefractionMapping = 302;\r\nvar EquirectangularReflectionMapping = 303;\r\nvar EquirectangularRefractionMapping = 304;\r\nvar SphericalReflectionMapping = 305;\r\nvar CubeUVReflectionMapping = 306;\r\nvar CubeUVRefractionMapping = 307;\r\nvar RepeatWrapping = 1000;\r\nvar ClampToEdgeWrapping = 1001;\r\nvar MirroredRepeatWrapping = 1002;\r\nvar NearestFilter = 1003;\r\nvar NearestMipmapNearestFilter = 1004;\r\nvar NearestMipMapNearestFilter = 1004;\r\nvar NearestMipmapLinearFilter = 1005;\r\nvar NearestMipMapLinearFilter = 1005;\r\nvar LinearFilter = 1006;\r\nvar LinearMipmapNearestFilter = 1007;\r\nvar LinearMipMapNearestFilter = 1007;\r\nvar LinearMipmapLinearFilter = 1008;\r\nvar LinearMipMapLinearFilter = 1008;\r\nvar UnsignedByteType = 1009;\r\nvar ByteType = 1010;\r\nvar ShortType = 1011;\r\nvar UnsignedShortType = 1012;\r\nvar IntType = 1013;\r\nvar UnsignedIntType = 1014;\r\nvar FloatType = 1015;\r\nvar HalfFloatType = 1016;\r\nvar UnsignedShort4444Type = 1017;\r\nvar UnsignedShort5551Type = 1018;\r\nvar UnsignedShort565Type = 1019;\r\nvar UnsignedInt248Type = 1020;\r\nvar AlphaFormat = 1021;\r\nvar RGBFormat = 1022;\r\nvar RGBAFormat = 1023;\r\nvar LuminanceFormat = 1024;\r\nvar LuminanceAlphaFormat = 1025;\r\nvar RGBEFormat = RGBAFormat;\r\nvar DepthFormat = 1026;\r\nvar DepthStencilFormat = 1027;\r\nvar RedFormat = 1028;\r\nvar RGB_S3TC_DXT1_Format = 33776;\r\nvar RGBA_S3TC_DXT1_Format = 33777;\r\nvar RGBA_S3TC_DXT3_Format = 33778;\r\nvar RGBA_S3TC_DXT5_Format = 33779;\r\nvar RGB_PVRTC_4BPPV1_Format = 35840;\r\nvar RGB_PVRTC_2BPPV1_Format = 35841;\r\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\r\nvar RGBA_PVRTC_2BPPV1_Format = 35843;\r\nvar RGB_ETC1_Format = 36196;\r\nvar RGBA_ASTC_4x4_Format = 37808;\r\nvar RGBA_ASTC_5x4_Format = 37809;\r\nvar RGBA_ASTC_5x5_Format = 37810;\r\nvar RGBA_ASTC_6x5_Format = 37811;\r\nvar RGBA_ASTC_6x6_Format = 37812;\r\nvar RGBA_ASTC_8x5_Format = 37813;\r\nvar RGBA_ASTC_8x6_Format = 37814;\r\nvar RGBA_ASTC_8x8_Format = 37815;\r\nvar RGBA_ASTC_10x5_Format = 37816;\r\nvar RGBA_ASTC_10x6_Format = 37817;\r\nvar RGBA_ASTC_10x8_Format = 37818;\r\nvar RGBA_ASTC_10x10_Format = 37819;\r\nvar RGBA_ASTC_12x10_Format = 37820;\r\nvar RGBA_ASTC_12x12_Format = 37821;\r\nvar LoopOnce = 2200;\r\nvar LoopRepeat = 2201;\r\nvar LoopPingPong = 2202;\r\nvar InterpolateDiscrete = 2300;\r\nvar InterpolateLinear = 2301;\r\nvar InterpolateSmooth = 2302;\r\nvar ZeroCurvatureEnding = 2400;\r\nvar ZeroSlopeEnding = 2401;\r\nvar WrapAroundEnding = 2402;\r\nvar TrianglesDrawMode = 0;\r\nvar TriangleStripDrawMode = 1;\r\nvar TriangleFanDrawMode = 2;\r\nvar LinearEncoding = 3000;\r\nvar sRGBEncoding = 3001;\r\nvar GammaEncoding = 3007;\r\nvar RGBEEncoding = 3002;\r\nvar LogLuvEncoding = 3003;\r\nvar RGBM7Encoding = 3004;\r\nvar RGBM16Encoding = 3005;\r\nvar RGBDEncoding = 3006;\r\nvar BasicDepthPacking = 3200;\r\nvar RGBADepthPacking = 3201;\r\nvar TangentSpaceNormalMap = 0;\r\nvar ObjectSpaceNormalMap = 1;\r\nvar ZeroStencilOp = 0;\r\nvar KeepStencilOp = 7680;\r\nvar ReplaceStencilOp = 7681;\r\nvar IncrementStencilOp = 7682;\r\nvar DecrementStencilOp = 7683;\r\nvar IncrementWrapStencilOp = 34055;\r\nvar DecrementWrapStencilOp = 34056;\r\nvar InvertStencilOp = 5386;\r\nvar NeverStencilFunc = 512;\r\nvar LessStencilFunc = 513;\r\nvar EqualStencilFunc = 514;\r\nvar LessEqualStencilFunc = 515;\r\nvar GreaterStencilFunc = 516;\r\nvar NotEqualStencilFunc = 517;\r\nvar GreaterEqualStencilFunc = 518;\r\nvar AlwaysStencilFunc = 519;\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar _Math = {\r\n    DEG2RAD: Math.PI / 180,\r\n    RAD2DEG: 180 / Math.PI,\r\n    generateUUID: (function () {\r\n        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\n        var lut = [];\r\n        for (var i = 0; i < 256; i++) {\r\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\r\n        }\r\n        return function generateUUID() {\r\n            var d0 = Math.random() * 0xffffffff | 0;\r\n            var d1 = Math.random() * 0xffffffff | 0;\r\n            var d2 = Math.random() * 0xffffffff | 0;\r\n            var d3 = Math.random() * 0xffffffff | 0;\r\n            var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +\r\n                lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +\r\n                lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +\r\n                lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\r\n            // .toUpperCase() here flattens concatenated strings to save heap memory space.\r\n            return uuid.toUpperCase();\r\n        };\r\n    })(),\r\n    clamp: function (value, min, max) {\r\n        return Math.max(min, Math.min(max, value));\r\n    },\r\n    // compute euclidian modulo of m % n\r\n    // https://en.wikipedia.org/wiki/Modulo_operation\r\n    euclideanModulo: function (n, m) {\r\n        return ((n % m) + m) % m;\r\n    },\r\n    // Linear mapping from range <a1, a2> to range <b1, b2>\r\n    mapLinear: function (x, a1, a2, b1, b2) {\r\n        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\r\n    },\r\n    // https://en.wikipedia.org/wiki/Linear_interpolation\r\n    lerp: function (x, y, t) {\r\n        return (1 - t) * x + t * y;\r\n    },\r\n    // http://en.wikipedia.org/wiki/Smoothstep\r\n    smoothstep: function (x, min, max) {\r\n        if (x <= min)\r\n            return 0;\r\n        if (x >= max)\r\n            return 1;\r\n        x = (x - min) / (max - min);\r\n        return x * x * (3 - 2 * x);\r\n    },\r\n    smootherstep: function (x, min, max) {\r\n        if (x <= min)\r\n            return 0;\r\n        if (x >= max)\r\n            return 1;\r\n        x = (x - min) / (max - min);\r\n        return x * x * x * (x * (x * 6 - 15) + 10);\r\n    },\r\n    // Random integer from <low, high> interval\r\n    randInt: function (low, high) {\r\n        return low + Math.floor(Math.random() * (high - low + 1));\r\n    },\r\n    // Random float from <low, high> interval\r\n    randFloat: function (low, high) {\r\n        return low + Math.random() * (high - low);\r\n    },\r\n    // Random float from <-range/2, range/2> interval\r\n    randFloatSpread: function (range) {\r\n        return range * (0.5 - Math.random());\r\n    },\r\n    degToRad: function (degrees) {\r\n        return degrees * _Math.DEG2RAD;\r\n    },\r\n    radToDeg: function (radians) {\r\n        return radians * _Math.RAD2DEG;\r\n    },\r\n    isPowerOfTwo: function (value) {\r\n        return (value & (value - 1)) === 0 && value !== 0;\r\n    },\r\n    ceilPowerOfTwo: function (value) {\r\n        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\r\n    },\r\n    floorPowerOfTwo: function (value) {\r\n        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\r\n    }\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\nfunction Vector2(x, y) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n}\r\nObject.defineProperties(Vector2.prototype, {\r\n    \"width\": {\r\n        get: function () {\r\n            return this.x;\r\n        },\r\n        set: function (value) {\r\n            this.x = value;\r\n        }\r\n    },\r\n    \"height\": {\r\n        get: function () {\r\n            return this.y;\r\n        },\r\n        set: function (value) {\r\n            this.y = value;\r\n        }\r\n    }\r\n});\r\nObject.assign(Vector2.prototype, {\r\n    isVector2: true,\r\n    set: function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    },\r\n    setScalar: function (scalar) {\r\n        this.x = scalar;\r\n        this.y = scalar;\r\n        return this;\r\n    },\r\n    setX: function (x) {\r\n        this.x = x;\r\n        return this;\r\n    },\r\n    setY: function (y) {\r\n        this.y = y;\r\n        return this;\r\n    },\r\n    setComponent: function (index, value) {\r\n        switch (index) {\r\n            case 0:\r\n                this.x = value;\r\n                break;\r\n            case 1:\r\n                this.y = value;\r\n                break;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n        return this;\r\n    },\r\n    getComponent: function (index) {\r\n        switch (index) {\r\n            case 0: return this.x;\r\n            case 1: return this.y;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.x, this.y);\r\n    },\r\n    copy: function (v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    },\r\n    add: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\r\n            return this.addVectors(v, w);\r\n        }\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        return this;\r\n    },\r\n    addScalar: function (s) {\r\n        this.x += s;\r\n        this.y += s;\r\n        return this;\r\n    },\r\n    addVectors: function (a, b) {\r\n        this.x = a.x + b.x;\r\n        this.y = a.y + b.y;\r\n        return this;\r\n    },\r\n    addScaledVector: function (v, s) {\r\n        this.x += v.x * s;\r\n        this.y += v.y * s;\r\n        return this;\r\n    },\r\n    sub: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\r\n            return this.subVectors(v, w);\r\n        }\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    },\r\n    subScalar: function (s) {\r\n        this.x -= s;\r\n        this.y -= s;\r\n        return this;\r\n    },\r\n    subVectors: function (a, b) {\r\n        this.x = a.x - b.x;\r\n        this.y = a.y - b.y;\r\n        return this;\r\n    },\r\n    multiply: function (v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (scalar) {\r\n        this.x *= scalar;\r\n        this.y *= scalar;\r\n        return this;\r\n    },\r\n    divide: function (v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    },\r\n    divideScalar: function (scalar) {\r\n        return this.multiplyScalar(1 / scalar);\r\n    },\r\n    applyMatrix3: function (m) {\r\n        var x = this.x, y = this.y;\r\n        var e = m.elements;\r\n        this.x = e[0] * x + e[3] * y + e[6];\r\n        this.y = e[1] * x + e[4] * y + e[7];\r\n        return this;\r\n    },\r\n    min: function (v) {\r\n        this.x = Math.min(this.x, v.x);\r\n        this.y = Math.min(this.y, v.y);\r\n        return this;\r\n    },\r\n    max: function (v) {\r\n        this.x = Math.max(this.x, v.x);\r\n        this.y = Math.max(this.y, v.y);\r\n        return this;\r\n    },\r\n    clamp: function (min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        return this;\r\n    },\r\n    clampScalar: function (minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        return this;\r\n    },\r\n    clampLength: function (min, max) {\r\n        var length = this.length();\r\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\r\n    },\r\n    floor: function () {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        return this;\r\n    },\r\n    ceil: function () {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        return this;\r\n    },\r\n    round: function () {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    },\r\n    roundToZero: function () {\r\n        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);\r\n        return this;\r\n    },\r\n    negate: function () {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    },\r\n    dot: function (v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    },\r\n    cross: function (v) {\r\n        return this.x * v.y - this.y * v.x;\r\n    },\r\n    lengthSq: function () {\r\n        return this.x * this.x + this.y * this.y;\r\n    },\r\n    length: function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    },\r\n    manhattanLength: function () {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    },\r\n    normalize: function () {\r\n        return this.divideScalar(this.length() || 1);\r\n    },\r\n    angle: function () {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n        var angle = Math.atan2(this.y, this.x);\r\n        if (angle < 0)\r\n            angle += 2 * Math.PI;\r\n        return angle;\r\n    },\r\n    distanceTo: function (v) {\r\n        return Math.sqrt(this.distanceToSquared(v));\r\n    },\r\n    distanceToSquared: function (v) {\r\n        var dx = this.x - v.x, dy = this.y - v.y;\r\n        return dx * dx + dy * dy;\r\n    },\r\n    manhattanDistanceTo: function (v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n    },\r\n    setLength: function (length) {\r\n        return this.normalize().multiplyScalar(length);\r\n    },\r\n    lerp: function (v, alpha) {\r\n        this.x += (v.x - this.x) * alpha;\r\n        this.y += (v.y - this.y) * alpha;\r\n        return this;\r\n    },\r\n    lerpVectors: function (v1, v2, alpha) {\r\n        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n    },\r\n    equals: function (v) {\r\n        return ((v.x === this.x) && (v.y === this.y));\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.x = array[offset];\r\n        this.y = array[offset + 1];\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this.x;\r\n        array[offset + 1] = this.y;\r\n        return array;\r\n    },\r\n    fromBufferAttribute: function (attribute, index, offset) {\r\n        if (offset !== undefined) {\r\n            console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\r\n        }\r\n        this.x = attribute.getX(index);\r\n        this.y = attribute.getY(index);\r\n        return this;\r\n    },\r\n    rotateAround: function (center, angle) {\r\n        var c = Math.cos(angle), s = Math.sin(angle);\r\n        var x = this.x - center.x;\r\n        var y = this.y - center.y;\r\n        this.x = x * c - y * s + center.x;\r\n        this.y = x * s + y * c + center.y;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\nfunction Quaternion(x, y, z, w) {\r\n    this._x = x || 0;\r\n    this._y = y || 0;\r\n    this._z = z || 0;\r\n    this._w = (w !== undefined) ? w : 1;\r\n}\r\nObject.assign(Quaternion, {\r\n    slerp: function (qa, qb, qm, t) {\r\n        return qm.copy(qa).slerp(qb, t);\r\n    },\r\n    slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\r\n        // fuzz-free, array-based Quaternion SLERP operation\r\n        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\r\n        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\r\n            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;\r\n            // Skip the Slerp for tiny steps to avoid numeric problems:\r\n            if (sqrSin > Number.EPSILON) {\r\n                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\r\n                s = Math.sin(s * len) / sin;\r\n                t = Math.sin(t * len) / sin;\r\n            }\r\n            var tDir = t * dir;\r\n            x0 = x0 * s + x1 * tDir;\r\n            y0 = y0 * s + y1 * tDir;\r\n            z0 = z0 * s + z1 * tDir;\r\n            w0 = w0 * s + w1 * tDir;\r\n            // Normalize in case we just did a lerp:\r\n            if (s === 1 - t) {\r\n                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\r\n                x0 *= f;\r\n                y0 *= f;\r\n                z0 *= f;\r\n                w0 *= f;\r\n            }\r\n        }\r\n        dst[dstOffset] = x0;\r\n        dst[dstOffset + 1] = y0;\r\n        dst[dstOffset + 2] = z0;\r\n        dst[dstOffset + 3] = w0;\r\n    }\r\n});\r\nObject.defineProperties(Quaternion.prototype, {\r\n    x: {\r\n        get: function () {\r\n            return this._x;\r\n        },\r\n        set: function (value) {\r\n            this._x = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    y: {\r\n        get: function () {\r\n            return this._y;\r\n        },\r\n        set: function (value) {\r\n            this._y = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    z: {\r\n        get: function () {\r\n            return this._z;\r\n        },\r\n        set: function (value) {\r\n            this._z = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    w: {\r\n        get: function () {\r\n            return this._w;\r\n        },\r\n        set: function (value) {\r\n            this._w = value;\r\n            this._onChangeCallback();\r\n        }\r\n    }\r\n});\r\nObject.assign(Quaternion.prototype, {\r\n    isQuaternion: true,\r\n    set: function (x, y, z, w) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._w = w;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this._x, this._y, this._z, this._w);\r\n    },\r\n    copy: function (quaternion) {\r\n        this._x = quaternion.x;\r\n        this._y = quaternion.y;\r\n        this._z = quaternion.z;\r\n        this._w = quaternion.w;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromEuler: function (euler, update) {\r\n        if (!(euler && euler.isEuler)) {\r\n            throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\r\n        }\r\n        var x = euler._x, y = euler._y, z = euler._z, order = euler.order;\r\n        // http://www.mathworks.com/matlabcentral/fileexchange/\r\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n        //\tcontent/SpinCalc.m\r\n        var cos = Math.cos;\r\n        var sin = Math.sin;\r\n        var c1 = cos(x / 2);\r\n        var c2 = cos(y / 2);\r\n        var c3 = cos(z / 2);\r\n        var s1 = sin(x / 2);\r\n        var s2 = sin(y / 2);\r\n        var s3 = sin(z / 2);\r\n        if (order === 'XYZ') {\r\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n        }\r\n        else if (order === 'YXZ') {\r\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n        }\r\n        else if (order === 'ZXY') {\r\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n        }\r\n        else if (order === 'ZYX') {\r\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n        }\r\n        else if (order === 'YZX') {\r\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n        }\r\n        else if (order === 'XZY') {\r\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n        }\r\n        if (update !== false)\r\n            this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromAxisAngle: function (axis, angle) {\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n        // assumes axis is normalized\r\n        var halfAngle = angle / 2, s = Math.sin(halfAngle);\r\n        this._x = axis.x * s;\r\n        this._y = axis.y * s;\r\n        this._z = axis.z * s;\r\n        this._w = Math.cos(halfAngle);\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromRotationMatrix: function (m) {\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;\r\n        if (trace > 0) {\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n            this._w = 0.25 / s;\r\n            this._x = (m32 - m23) * s;\r\n            this._y = (m13 - m31) * s;\r\n            this._z = (m21 - m12) * s;\r\n        }\r\n        else if (m11 > m22 && m11 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n            this._w = (m32 - m23) / s;\r\n            this._x = 0.25 * s;\r\n            this._y = (m12 + m21) / s;\r\n            this._z = (m13 + m31) / s;\r\n        }\r\n        else if (m22 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n            this._w = (m13 - m31) / s;\r\n            this._x = (m12 + m21) / s;\r\n            this._y = 0.25 * s;\r\n            this._z = (m23 + m32) / s;\r\n        }\r\n        else {\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n            this._w = (m21 - m12) / s;\r\n            this._x = (m13 + m31) / s;\r\n            this._y = (m23 + m32) / s;\r\n            this._z = 0.25 * s;\r\n        }\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromUnitVectors: function (vFrom, vTo) {\r\n        // assumes direction vectors vFrom and vTo are normalized\r\n        var EPS = 0.000001;\r\n        var r = vFrom.dot(vTo) + 1;\r\n        if (r < EPS) {\r\n            r = 0;\r\n            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\r\n                this._x = -vFrom.y;\r\n                this._y = vFrom.x;\r\n                this._z = 0;\r\n                this._w = r;\r\n            }\r\n            else {\r\n                this._x = 0;\r\n                this._y = -vFrom.z;\r\n                this._z = vFrom.y;\r\n                this._w = r;\r\n            }\r\n        }\r\n        else {\r\n            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\r\n            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\r\n            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\r\n            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\r\n            this._w = r;\r\n        }\r\n        return this.normalize();\r\n    },\r\n    angleTo: function (q) {\r\n        return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));\r\n    },\r\n    rotateTowards: function (q, step) {\r\n        var angle = this.angleTo(q);\r\n        if (angle === 0)\r\n            return this;\r\n        var t = Math.min(1, step / angle);\r\n        this.slerp(q, t);\r\n        return this;\r\n    },\r\n    inverse: function () {\r\n        // quaternion is assumed to have unit length\r\n        return this.conjugate();\r\n    },\r\n    conjugate: function () {\r\n        this._x *= -1;\r\n        this._y *= -1;\r\n        this._z *= -1;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    dot: function (v) {\r\n        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n    },\r\n    lengthSq: function () {\r\n        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n    },\r\n    length: function () {\r\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\r\n    },\r\n    normalize: function () {\r\n        var l = this.length();\r\n        if (l === 0) {\r\n            this._x = 0;\r\n            this._y = 0;\r\n            this._z = 0;\r\n            this._w = 1;\r\n        }\r\n        else {\r\n            l = 1 / l;\r\n            this._x = this._x * l;\r\n            this._y = this._y * l;\r\n            this._z = this._z * l;\r\n            this._w = this._w * l;\r\n        }\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    multiply: function (q, p) {\r\n        if (p !== undefined) {\r\n            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\r\n            return this.multiplyQuaternions(q, p);\r\n        }\r\n        return this.multiplyQuaternions(this, q);\r\n    },\r\n    premultiply: function (q) {\r\n        return this.multiplyQuaternions(q, this);\r\n    },\r\n    multiplyQuaternions: function (a, b) {\r\n        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    slerp: function (qb, t) {\r\n        if (t === 0)\r\n            return this;\r\n        if (t === 1)\r\n            return this.copy(qb);\r\n        var x = this._x, y = this._y, z = this._z, w = this._w;\r\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n        if (cosHalfTheta < 0) {\r\n            this._w = -qb._w;\r\n            this._x = -qb._x;\r\n            this._y = -qb._y;\r\n            this._z = -qb._z;\r\n            cosHalfTheta = -cosHalfTheta;\r\n        }\r\n        else {\r\n            this.copy(qb);\r\n        }\r\n        if (cosHalfTheta >= 1.0) {\r\n            this._w = w;\r\n            this._x = x;\r\n            this._y = y;\r\n            this._z = z;\r\n            return this;\r\n        }\r\n        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n        if (sqrSinHalfTheta <= Number.EPSILON) {\r\n            var s = 1 - t;\r\n            this._w = s * w + t * this._w;\r\n            this._x = s * x + t * this._x;\r\n            this._y = s * y + t * this._y;\r\n            this._z = s * z + t * this._z;\r\n            this.normalize();\r\n            this._onChangeCallback();\r\n            return this;\r\n        }\r\n        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\r\n        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\r\n        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\r\n        this._w = (w * ratioA + this._w * ratioB);\r\n        this._x = (x * ratioA + this._x * ratioB);\r\n        this._y = (y * ratioA + this._y * ratioB);\r\n        this._z = (z * ratioA + this._z * ratioB);\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    equals: function (quaternion) {\r\n        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this._x = array[offset];\r\n        this._y = array[offset + 1];\r\n        this._z = array[offset + 2];\r\n        this._w = array[offset + 3];\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this._x;\r\n        array[offset + 1] = this._y;\r\n        array[offset + 2] = this._z;\r\n        array[offset + 3] = this._w;\r\n        return array;\r\n    },\r\n    _onChange: function (callback) {\r\n        this._onChangeCallback = callback;\r\n        return this;\r\n    },\r\n    _onChangeCallback: function () { }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction Vector3(x, y, z) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n}\r\nObject.assign(Vector3.prototype, {\r\n    isVector3: true,\r\n    set: function (x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    },\r\n    setScalar: function (scalar) {\r\n        this.x = scalar;\r\n        this.y = scalar;\r\n        this.z = scalar;\r\n        return this;\r\n    },\r\n    setX: function (x) {\r\n        this.x = x;\r\n        return this;\r\n    },\r\n    setY: function (y) {\r\n        this.y = y;\r\n        return this;\r\n    },\r\n    setZ: function (z) {\r\n        this.z = z;\r\n        return this;\r\n    },\r\n    setComponent: function (index, value) {\r\n        switch (index) {\r\n            case 0:\r\n                this.x = value;\r\n                break;\r\n            case 1:\r\n                this.y = value;\r\n                break;\r\n            case 2:\r\n                this.z = value;\r\n                break;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n        return this;\r\n    },\r\n    getComponent: function (index) {\r\n        switch (index) {\r\n            case 0: return this.x;\r\n            case 1: return this.y;\r\n            case 2: return this.z;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.x, this.y, this.z);\r\n    },\r\n    copy: function (v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    },\r\n    add: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\r\n            return this.addVectors(v, w);\r\n        }\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        return this;\r\n    },\r\n    addScalar: function (s) {\r\n        this.x += s;\r\n        this.y += s;\r\n        this.z += s;\r\n        return this;\r\n    },\r\n    addVectors: function (a, b) {\r\n        this.x = a.x + b.x;\r\n        this.y = a.y + b.y;\r\n        this.z = a.z + b.z;\r\n        return this;\r\n    },\r\n    addScaledVector: function (v, s) {\r\n        this.x += v.x * s;\r\n        this.y += v.y * s;\r\n        this.z += v.z * s;\r\n        return this;\r\n    },\r\n    sub: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\r\n            return this.subVectors(v, w);\r\n        }\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z;\r\n        return this;\r\n    },\r\n    subScalar: function (s) {\r\n        this.x -= s;\r\n        this.y -= s;\r\n        this.z -= s;\r\n        return this;\r\n    },\r\n    subVectors: function (a, b) {\r\n        this.x = a.x - b.x;\r\n        this.y = a.y - b.y;\r\n        this.z = a.z - b.z;\r\n        return this;\r\n    },\r\n    multiply: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\r\n            return this.multiplyVectors(v, w);\r\n        }\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (scalar) {\r\n        this.x *= scalar;\r\n        this.y *= scalar;\r\n        this.z *= scalar;\r\n        return this;\r\n    },\r\n    multiplyVectors: function (a, b) {\r\n        this.x = a.x * b.x;\r\n        this.y = a.y * b.y;\r\n        this.z = a.z * b.z;\r\n        return this;\r\n    },\r\n    applyEuler: function () {\r\n        var quaternion = new Quaternion();\r\n        return function applyEuler(euler) {\r\n            if (!(euler && euler.isEuler)) {\r\n                console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\r\n            }\r\n            return this.applyQuaternion(quaternion.setFromEuler(euler));\r\n        };\r\n    }(),\r\n    applyAxisAngle: function () {\r\n        var quaternion = new Quaternion();\r\n        return function applyAxisAngle(axis, angle) {\r\n            return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\r\n        };\r\n    }(),\r\n    applyMatrix3: function (m) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var e = m.elements;\r\n        this.x = e[0] * x + e[3] * y + e[6] * z;\r\n        this.y = e[1] * x + e[4] * y + e[7] * z;\r\n        this.z = e[2] * x + e[5] * y + e[8] * z;\r\n        return this;\r\n    },\r\n    applyMatrix4: function (m) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var e = m.elements;\r\n        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\r\n        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\r\n        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\r\n        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\r\n        return this;\r\n    },\r\n    applyQuaternion: function (q) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n        // calculate quat * vector\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return this;\r\n    },\r\n    project: function (camera) {\r\n        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\r\n    },\r\n    unproject: function (camera) {\r\n        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\r\n    },\r\n    transformDirection: function (m) {\r\n        // input: THREE.Matrix4 affine matrix\r\n        // vector interpreted as a direction\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var e = m.elements;\r\n        this.x = e[0] * x + e[4] * y + e[8] * z;\r\n        this.y = e[1] * x + e[5] * y + e[9] * z;\r\n        this.z = e[2] * x + e[6] * y + e[10] * z;\r\n        return this.normalize();\r\n    },\r\n    divide: function (v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z;\r\n        return this;\r\n    },\r\n    divideScalar: function (scalar) {\r\n        return this.multiplyScalar(1 / scalar);\r\n    },\r\n    min: function (v) {\r\n        this.x = Math.min(this.x, v.x);\r\n        this.y = Math.min(this.y, v.y);\r\n        this.z = Math.min(this.z, v.z);\r\n        return this;\r\n    },\r\n    max: function (v) {\r\n        this.x = Math.max(this.x, v.x);\r\n        this.y = Math.max(this.y, v.y);\r\n        this.z = Math.max(this.z, v.z);\r\n        return this;\r\n    },\r\n    clamp: function (min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        this.z = Math.max(min.z, Math.min(max.z, this.z));\r\n        return this;\r\n    },\r\n    clampScalar: function (minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        this.z = Math.max(minVal, Math.min(maxVal, this.z));\r\n        return this;\r\n    },\r\n    clampLength: function (min, max) {\r\n        var length = this.length();\r\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\r\n    },\r\n    floor: function () {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        this.z = Math.floor(this.z);\r\n        return this;\r\n    },\r\n    ceil: function () {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        this.z = Math.ceil(this.z);\r\n        return this;\r\n    },\r\n    round: function () {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        this.z = Math.round(this.z);\r\n        return this;\r\n    },\r\n    roundToZero: function () {\r\n        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);\r\n        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);\r\n        return this;\r\n    },\r\n    negate: function () {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        return this;\r\n    },\r\n    dot: function (v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n    // TODO lengthSquared?\r\n    lengthSq: function () {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z;\r\n    },\r\n    length: function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    },\r\n    manhattanLength: function () {\r\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n    },\r\n    normalize: function () {\r\n        return this.divideScalar(this.length() || 1);\r\n    },\r\n    setLength: function (length) {\r\n        return this.normalize().multiplyScalar(length);\r\n    },\r\n    lerp: function (v, alpha) {\r\n        this.x += (v.x - this.x) * alpha;\r\n        this.y += (v.y - this.y) * alpha;\r\n        this.z += (v.z - this.z) * alpha;\r\n        return this;\r\n    },\r\n    lerpVectors: function (v1, v2, alpha) {\r\n        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n    },\r\n    cross: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\r\n            return this.crossVectors(v, w);\r\n        }\r\n        return this.crossVectors(this, v);\r\n    },\r\n    crossVectors: function (a, b) {\r\n        var ax = a.x, ay = a.y, az = a.z;\r\n        var bx = b.x, by = b.y, bz = b.z;\r\n        this.x = ay * bz - az * by;\r\n        this.y = az * bx - ax * bz;\r\n        this.z = ax * by - ay * bx;\r\n        return this;\r\n    },\r\n    projectOnVector: function (vector) {\r\n        var scalar = vector.dot(this) / vector.lengthSq();\r\n        return this.copy(vector).multiplyScalar(scalar);\r\n    },\r\n    projectOnPlane: function () {\r\n        var v1 = new Vector3();\r\n        return function projectOnPlane(planeNormal) {\r\n            v1.copy(this).projectOnVector(planeNormal);\r\n            return this.sub(v1);\r\n        };\r\n    }(),\r\n    reflect: function () {\r\n        // reflect incident vector off plane orthogonal to normal\r\n        // normal is assumed to have unit length\r\n        var v1 = new Vector3();\r\n        return function reflect(normal) {\r\n            return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\r\n        };\r\n    }(),\r\n    angleTo: function (v) {\r\n        var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));\r\n        // clamp, to handle numerical problems\r\n        return Math.acos(_Math.clamp(theta, -1, 1));\r\n    },\r\n    distanceTo: function (v) {\r\n        return Math.sqrt(this.distanceToSquared(v));\r\n    },\r\n    distanceToSquared: function (v) {\r\n        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n        return dx * dx + dy * dy + dz * dz;\r\n    },\r\n    manhattanDistanceTo: function (v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n    },\r\n    setFromSpherical: function (s) {\r\n        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\r\n    },\r\n    setFromSphericalCoords: function (radius, phi, theta) {\r\n        var sinPhiRadius = Math.sin(phi) * radius;\r\n        this.x = sinPhiRadius * Math.sin(theta);\r\n        this.y = Math.cos(phi) * radius;\r\n        this.z = sinPhiRadius * Math.cos(theta);\r\n        return this;\r\n    },\r\n    setFromCylindrical: function (c) {\r\n        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\r\n    },\r\n    setFromCylindricalCoords: function (radius, theta, y) {\r\n        this.x = radius * Math.sin(theta);\r\n        this.y = y;\r\n        this.z = radius * Math.cos(theta);\r\n        return this;\r\n    },\r\n    setFromMatrixPosition: function (m) {\r\n        var e = m.elements;\r\n        this.x = e[12];\r\n        this.y = e[13];\r\n        this.z = e[14];\r\n        return this;\r\n    },\r\n    setFromMatrixScale: function (m) {\r\n        var sx = this.setFromMatrixColumn(m, 0).length();\r\n        var sy = this.setFromMatrixColumn(m, 1).length();\r\n        var sz = this.setFromMatrixColumn(m, 2).length();\r\n        this.x = sx;\r\n        this.y = sy;\r\n        this.z = sz;\r\n        return this;\r\n    },\r\n    setFromMatrixColumn: function (m, index) {\r\n        return this.fromArray(m.elements, index * 4);\r\n    },\r\n    equals: function (v) {\r\n        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.x = array[offset];\r\n        this.y = array[offset + 1];\r\n        this.z = array[offset + 2];\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this.x;\r\n        array[offset + 1] = this.y;\r\n        array[offset + 2] = this.z;\r\n        return array;\r\n    },\r\n    fromBufferAttribute: function (attribute, index, offset) {\r\n        if (offset !== undefined) {\r\n            console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\r\n        }\r\n        this.x = attribute.getX(index);\r\n        this.y = attribute.getY(index);\r\n        this.z = attribute.getZ(index);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\nvar _vector;\r\nfunction Matrix3() {\r\n    this.elements = [\r\n        1, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 1\r\n    ];\r\n    if (arguments.length > 0) {\r\n        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\r\n    }\r\n}\r\nObject.assign(Matrix3.prototype, {\r\n    isMatrix3: true,\r\n    set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {\r\n        var te = this.elements;\r\n        te[0] = n11;\r\n        te[1] = n21;\r\n        te[2] = n31;\r\n        te[3] = n12;\r\n        te[4] = n22;\r\n        te[5] = n32;\r\n        te[6] = n13;\r\n        te[7] = n23;\r\n        te[8] = n33;\r\n        return this;\r\n    },\r\n    identity: function () {\r\n        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().fromArray(this.elements);\r\n    },\r\n    copy: function (m) {\r\n        var te = this.elements;\r\n        var me = m.elements;\r\n        te[0] = me[0];\r\n        te[1] = me[1];\r\n        te[2] = me[2];\r\n        te[3] = me[3];\r\n        te[4] = me[4];\r\n        te[5] = me[5];\r\n        te[6] = me[6];\r\n        te[7] = me[7];\r\n        te[8] = me[8];\r\n        return this;\r\n    },\r\n    setFromMatrix4: function (m) {\r\n        var me = m.elements;\r\n        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\r\n        return this;\r\n    },\r\n    applyToBufferAttribute: function (attribute) {\r\n        if (_vector === undefined)\r\n            _vector = new Vector3();\r\n        for (var i = 0, l = attribute.count; i < l; i++) {\r\n            _vector.x = attribute.getX(i);\r\n            _vector.y = attribute.getY(i);\r\n            _vector.z = attribute.getZ(i);\r\n            _vector.applyMatrix3(this);\r\n            attribute.setXYZ(i, _vector.x, _vector.y, _vector.z);\r\n        }\r\n        return attribute;\r\n    },\r\n    multiply: function (m) {\r\n        return this.multiplyMatrices(this, m);\r\n    },\r\n    premultiply: function (m) {\r\n        return this.multiplyMatrices(m, this);\r\n    },\r\n    multiplyMatrices: function (a, b) {\r\n        var ae = a.elements;\r\n        var be = b.elements;\r\n        var te = this.elements;\r\n        var a11 = ae[0], a12 = ae[3], a13 = ae[6];\r\n        var a21 = ae[1], a22 = ae[4], a23 = ae[7];\r\n        var a31 = ae[2], a32 = ae[5], a33 = ae[8];\r\n        var b11 = be[0], b12 = be[3], b13 = be[6];\r\n        var b21 = be[1], b22 = be[4], b23 = be[7];\r\n        var b31 = be[2], b32 = be[5], b33 = be[8];\r\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31;\r\n        te[3] = a11 * b12 + a12 * b22 + a13 * b32;\r\n        te[6] = a11 * b13 + a12 * b23 + a13 * b33;\r\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31;\r\n        te[4] = a21 * b12 + a22 * b22 + a23 * b32;\r\n        te[7] = a21 * b13 + a22 * b23 + a23 * b33;\r\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31;\r\n        te[5] = a31 * b12 + a32 * b22 + a33 * b32;\r\n        te[8] = a31 * b13 + a32 * b23 + a33 * b33;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (s) {\r\n        var te = this.elements;\r\n        te[0] *= s;\r\n        te[3] *= s;\r\n        te[6] *= s;\r\n        te[1] *= s;\r\n        te[4] *= s;\r\n        te[7] *= s;\r\n        te[2] *= s;\r\n        te[5] *= s;\r\n        te[8] *= s;\r\n        return this;\r\n    },\r\n    determinant: function () {\r\n        var te = this.elements;\r\n        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];\r\n        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n    },\r\n    getInverse: function (matrix, throwOnDegenerate) {\r\n        if (matrix && matrix.isMatrix4) {\r\n            console.error(\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\");\r\n        }\r\n        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\r\n        if (det === 0) {\r\n            var msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\r\n            if (throwOnDegenerate === true) {\r\n                throw new Error(msg);\r\n            }\r\n            else {\r\n                console.warn(msg);\r\n            }\r\n            return this.identity();\r\n        }\r\n        var detInv = 1 / det;\r\n        te[0] = t11 * detInv;\r\n        te[1] = (n31 * n23 - n33 * n21) * detInv;\r\n        te[2] = (n32 * n21 - n31 * n22) * detInv;\r\n        te[3] = t12 * detInv;\r\n        te[4] = (n33 * n11 - n31 * n13) * detInv;\r\n        te[5] = (n31 * n12 - n32 * n11) * detInv;\r\n        te[6] = t13 * detInv;\r\n        te[7] = (n21 * n13 - n23 * n11) * detInv;\r\n        te[8] = (n22 * n11 - n21 * n12) * detInv;\r\n        return this;\r\n    },\r\n    transpose: function () {\r\n        var tmp, m = this.elements;\r\n        tmp = m[1];\r\n        m[1] = m[3];\r\n        m[3] = tmp;\r\n        tmp = m[2];\r\n        m[2] = m[6];\r\n        m[6] = tmp;\r\n        tmp = m[5];\r\n        m[5] = m[7];\r\n        m[7] = tmp;\r\n        return this;\r\n    },\r\n    getNormalMatrix: function (matrix4) {\r\n        return this.setFromMatrix4(matrix4).getInverse(this).transpose();\r\n    },\r\n    transposeIntoArray: function (r) {\r\n        var m = this.elements;\r\n        r[0] = m[0];\r\n        r[1] = m[3];\r\n        r[2] = m[6];\r\n        r[3] = m[1];\r\n        r[4] = m[4];\r\n        r[5] = m[7];\r\n        r[6] = m[2];\r\n        r[7] = m[5];\r\n        r[8] = m[8];\r\n        return this;\r\n    },\r\n    setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {\r\n        var c = Math.cos(rotation);\r\n        var s = Math.sin(rotation);\r\n        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\r\n    },\r\n    scale: function (sx, sy) {\r\n        var te = this.elements;\r\n        te[0] *= sx;\r\n        te[3] *= sx;\r\n        te[6] *= sx;\r\n        te[1] *= sy;\r\n        te[4] *= sy;\r\n        te[7] *= sy;\r\n        return this;\r\n    },\r\n    rotate: function (theta) {\r\n        var c = Math.cos(theta);\r\n        var s = Math.sin(theta);\r\n        var te = this.elements;\r\n        var a11 = te[0], a12 = te[3], a13 = te[6];\r\n        var a21 = te[1], a22 = te[4], a23 = te[7];\r\n        te[0] = c * a11 + s * a21;\r\n        te[3] = c * a12 + s * a22;\r\n        te[6] = c * a13 + s * a23;\r\n        te[1] = -s * a11 + c * a21;\r\n        te[4] = -s * a12 + c * a22;\r\n        te[7] = -s * a13 + c * a23;\r\n        return this;\r\n    },\r\n    translate: function (tx, ty) {\r\n        var te = this.elements;\r\n        te[0] += tx * te[2];\r\n        te[3] += tx * te[5];\r\n        te[6] += tx * te[8];\r\n        te[1] += ty * te[2];\r\n        te[4] += ty * te[5];\r\n        te[7] += ty * te[8];\r\n        return this;\r\n    },\r\n    equals: function (matrix) {\r\n        var te = this.elements;\r\n        var me = matrix.elements;\r\n        for (var i = 0; i < 9; i++) {\r\n            if (te[i] !== me[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        for (var i = 0; i < 9; i++) {\r\n            this.elements[i] = array[i + offset];\r\n        }\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        var te = this.elements;\r\n        array[offset] = te[0];\r\n        array[offset + 1] = te[1];\r\n        array[offset + 2] = te[2];\r\n        array[offset + 3] = te[3];\r\n        array[offset + 4] = te[4];\r\n        array[offset + 5] = te[5];\r\n        array[offset + 6] = te[6];\r\n        array[offset + 7] = te[7];\r\n        array[offset + 8] = te[8];\r\n        return array;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\nvar _canvas;\r\nvar ImageUtils = {\r\n    getDataURL: function (image) {\r\n        var canvas;\r\n        if (typeof HTMLCanvasElement == 'undefined') {\r\n            return image.src;\r\n        }\r\n        else if (image instanceof HTMLCanvasElement) {\r\n            canvas = image;\r\n        }\r\n        else {\r\n            if (_canvas === undefined)\r\n                _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\r\n            _canvas.width = image.width;\r\n            _canvas.height = image.height;\r\n            var context = _canvas.getContext('2d');\r\n            if (image instanceof ImageData) {\r\n                context.putImageData(image, 0, 0);\r\n            }\r\n            else {\r\n                context.drawImage(image, 0, 0, image.width, image.height);\r\n            }\r\n            canvas = _canvas;\r\n        }\r\n        if (canvas.width > 2048 || canvas.height > 2048) {\r\n            return canvas.toDataURL('image/jpeg', 0.6);\r\n        }\r\n        else {\r\n            return canvas.toDataURL('image/png');\r\n        }\r\n    }\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\nvar textureId = 0;\r\nfunction Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\r\n    Object.defineProperty(this, 'id', { value: textureId++ });\r\n    this.uuid = _Math.generateUUID();\r\n    this.name = '';\r\n    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\r\n    this.mipmaps = [];\r\n    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\r\n    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\r\n    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\r\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\r\n    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\r\n    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n    this.format = format !== undefined ? format : RGBAFormat;\r\n    this.type = type !== undefined ? type : UnsignedByteType;\r\n    this.offset = new Vector2(0, 0);\r\n    this.repeat = new Vector2(1, 1);\r\n    this.center = new Vector2(0, 0);\r\n    this.rotation = 0;\r\n    this.matrixAutoUpdate = true;\r\n    this.matrix = new Matrix3();\r\n    this.generateMipmaps = true;\r\n    this.premultiplyAlpha = false;\r\n    this.flipY = true;\r\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n    //\r\n    // Also changing the encoding after already used by a Material will not automatically make the Material\r\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n    this.encoding = encoding !== undefined ? encoding : LinearEncoding;\r\n    this.version = 0;\r\n    this.onUpdate = null;\r\n}\r\nTexture.DEFAULT_IMAGE = undefined;\r\nTexture.DEFAULT_MAPPING = UVMapping;\r\nTexture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: Texture,\r\n    isTexture: true,\r\n    updateMatrix: function () {\r\n        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        this.name = source.name;\r\n        this.image = source.image;\r\n        this.mipmaps = source.mipmaps.slice(0);\r\n        this.mapping = source.mapping;\r\n        this.wrapS = source.wrapS;\r\n        this.wrapT = source.wrapT;\r\n        this.magFilter = source.magFilter;\r\n        this.minFilter = source.minFilter;\r\n        this.anisotropy = source.anisotropy;\r\n        this.format = source.format;\r\n        this.type = source.type;\r\n        this.offset.copy(source.offset);\r\n        this.repeat.copy(source.repeat);\r\n        this.center.copy(source.center);\r\n        this.rotation = source.rotation;\r\n        this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n        this.matrix.copy(source.matrix);\r\n        this.generateMipmaps = source.generateMipmaps;\r\n        this.premultiplyAlpha = source.premultiplyAlpha;\r\n        this.flipY = source.flipY;\r\n        this.unpackAlignment = source.unpackAlignment;\r\n        this.encoding = source.encoding;\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var isRootObject = (meta === undefined || typeof meta === 'string');\r\n        if (!isRootObject && meta.textures[this.uuid] !== undefined) {\r\n            return meta.textures[this.uuid];\r\n        }\r\n        var output = {\r\n            metadata: {\r\n                version: 4.5,\r\n                type: 'Texture',\r\n                generator: 'Texture.toJSON'\r\n            },\r\n            uuid: this.uuid,\r\n            name: this.name,\r\n            mapping: this.mapping,\r\n            repeat: [this.repeat.x, this.repeat.y],\r\n            offset: [this.offset.x, this.offset.y],\r\n            center: [this.center.x, this.center.y],\r\n            rotation: this.rotation,\r\n            wrap: [this.wrapS, this.wrapT],\r\n            format: this.format,\r\n            type: this.type,\r\n            encoding: this.encoding,\r\n            minFilter: this.minFilter,\r\n            magFilter: this.magFilter,\r\n            anisotropy: this.anisotropy,\r\n            flipY: this.flipY,\r\n            premultiplyAlpha: this.premultiplyAlpha,\r\n            unpackAlignment: this.unpackAlignment\r\n        };\r\n        if (this.image !== undefined) {\r\n            // TODO: Move to THREE.Image\r\n            var image = this.image;\r\n            if (image.uuid === undefined) {\r\n                image.uuid = _Math.generateUUID(); // UGH\r\n            }\r\n            if (!isRootObject && meta.images[image.uuid] === undefined) {\r\n                var url;\r\n                if (Array.isArray(image)) {\r\n                    // process array of images e.g. CubeTexture\r\n                    url = [];\r\n                    for (var i = 0, l = image.length; i < l; i++) {\r\n                        url.push(ImageUtils.getDataURL(image[i]));\r\n                    }\r\n                }\r\n                else {\r\n                    // process single image\r\n                    url = ImageUtils.getDataURL(image);\r\n                }\r\n                meta.images[image.uuid] = {\r\n                    uuid: image.uuid,\r\n                    url: url\r\n                };\r\n            }\r\n            output.image = image.uuid;\r\n        }\r\n        if (!isRootObject) {\r\n            meta.textures[this.uuid] = output;\r\n        }\r\n        return output;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    },\r\n    transformUv: function (uv) {\r\n        if (this.mapping !== UVMapping)\r\n            return uv;\r\n        uv.applyMatrix3(this.matrix);\r\n        if (uv.x < 0 || uv.x > 1) {\r\n            switch (this.wrapS) {\r\n                case RepeatWrapping:\r\n                    uv.x = uv.x - Math.floor(uv.x);\r\n                    break;\r\n                case ClampToEdgeWrapping:\r\n                    uv.x = uv.x < 0 ? 0 : 1;\r\n                    break;\r\n                case MirroredRepeatWrapping:\r\n                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {\r\n                        uv.x = Math.ceil(uv.x) - uv.x;\r\n                    }\r\n                    else {\r\n                        uv.x = uv.x - Math.floor(uv.x);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        if (uv.y < 0 || uv.y > 1) {\r\n            switch (this.wrapT) {\r\n                case RepeatWrapping:\r\n                    uv.y = uv.y - Math.floor(uv.y);\r\n                    break;\r\n                case ClampToEdgeWrapping:\r\n                    uv.y = uv.y < 0 ? 0 : 1;\r\n                    break;\r\n                case MirroredRepeatWrapping:\r\n                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {\r\n                        uv.y = Math.ceil(uv.y) - uv.y;\r\n                    }\r\n                    else {\r\n                        uv.y = uv.y - Math.floor(uv.y);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        if (this.flipY) {\r\n            uv.y = 1 - uv.y;\r\n        }\r\n        return uv;\r\n    }\r\n});\r\nObject.defineProperty(Texture.prototype, \"needsUpdate\", {\r\n    set: function (value) {\r\n        if (value === true)\r\n            this.version++;\r\n    }\r\n});\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction Vector4(x, y, z, w) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = (w !== undefined) ? w : 1;\r\n}\r\nObject.defineProperties(Vector4.prototype, {\r\n    \"width\": {\r\n        get: function () {\r\n            return this.z;\r\n        },\r\n        set: function (value) {\r\n            this.z = value;\r\n        }\r\n    },\r\n    \"height\": {\r\n        get: function () {\r\n            return this.w;\r\n        },\r\n        set: function (value) {\r\n            this.w = value;\r\n        }\r\n    }\r\n});\r\nObject.assign(Vector4.prototype, {\r\n    isVector4: true,\r\n    set: function (x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    },\r\n    setScalar: function (scalar) {\r\n        this.x = scalar;\r\n        this.y = scalar;\r\n        this.z = scalar;\r\n        this.w = scalar;\r\n        return this;\r\n    },\r\n    setX: function (x) {\r\n        this.x = x;\r\n        return this;\r\n    },\r\n    setY: function (y) {\r\n        this.y = y;\r\n        return this;\r\n    },\r\n    setZ: function (z) {\r\n        this.z = z;\r\n        return this;\r\n    },\r\n    setW: function (w) {\r\n        this.w = w;\r\n        return this;\r\n    },\r\n    setComponent: function (index, value) {\r\n        switch (index) {\r\n            case 0:\r\n                this.x = value;\r\n                break;\r\n            case 1:\r\n                this.y = value;\r\n                break;\r\n            case 2:\r\n                this.z = value;\r\n                break;\r\n            case 3:\r\n                this.w = value;\r\n                break;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n        return this;\r\n    },\r\n    getComponent: function (index) {\r\n        switch (index) {\r\n            case 0: return this.x;\r\n            case 1: return this.y;\r\n            case 2: return this.z;\r\n            case 3: return this.w;\r\n            default: throw new Error('index is out of range: ' + index);\r\n        }\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.x, this.y, this.z, this.w);\r\n    },\r\n    copy: function (v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        this.w = (v.w !== undefined) ? v.w : 1;\r\n        return this;\r\n    },\r\n    add: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\r\n            return this.addVectors(v, w);\r\n        }\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        this.w += v.w;\r\n        return this;\r\n    },\r\n    addScalar: function (s) {\r\n        this.x += s;\r\n        this.y += s;\r\n        this.z += s;\r\n        this.w += s;\r\n        return this;\r\n    },\r\n    addVectors: function (a, b) {\r\n        this.x = a.x + b.x;\r\n        this.y = a.y + b.y;\r\n        this.z = a.z + b.z;\r\n        this.w = a.w + b.w;\r\n        return this;\r\n    },\r\n    addScaledVector: function (v, s) {\r\n        this.x += v.x * s;\r\n        this.y += v.y * s;\r\n        this.z += v.z * s;\r\n        this.w += v.w * s;\r\n        return this;\r\n    },\r\n    sub: function (v, w) {\r\n        if (w !== undefined) {\r\n            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\r\n            return this.subVectors(v, w);\r\n        }\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z;\r\n        this.w -= v.w;\r\n        return this;\r\n    },\r\n    subScalar: function (s) {\r\n        this.x -= s;\r\n        this.y -= s;\r\n        this.z -= s;\r\n        this.w -= s;\r\n        return this;\r\n    },\r\n    subVectors: function (a, b) {\r\n        this.x = a.x - b.x;\r\n        this.y = a.y - b.y;\r\n        this.z = a.z - b.z;\r\n        this.w = a.w - b.w;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (scalar) {\r\n        this.x *= scalar;\r\n        this.y *= scalar;\r\n        this.z *= scalar;\r\n        this.w *= scalar;\r\n        return this;\r\n    },\r\n    applyMatrix4: function (m) {\r\n        var x = this.x, y = this.y, z = this.z, w = this.w;\r\n        var e = m.elements;\r\n        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n        return this;\r\n    },\r\n    divideScalar: function (scalar) {\r\n        return this.multiplyScalar(1 / scalar);\r\n    },\r\n    setAxisAngleFromQuaternion: function (q) {\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n        // q is assumed to be normalized\r\n        this.w = 2 * Math.acos(q.w);\r\n        var s = Math.sqrt(1 - q.w * q.w);\r\n        if (s < 0.0001) {\r\n            this.x = 1;\r\n            this.y = 0;\r\n            this.z = 0;\r\n        }\r\n        else {\r\n            this.x = q.x / s;\r\n            this.y = q.y / s;\r\n            this.z = q.z / s;\r\n        }\r\n        return this;\r\n    },\r\n    setAxisAngleFromRotationMatrix: function (m) {\r\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n        var angle, x, y, z, // variables for result\r\n        epsilon = 0.01, // margin to allow for rounding errors\r\n        epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees\r\n        te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\r\n        if ((Math.abs(m12 - m21) < epsilon) &&\r\n            (Math.abs(m13 - m31) < epsilon) &&\r\n            (Math.abs(m23 - m32) < epsilon)) {\r\n            // singularity found\r\n            // first check for identity matrix which must have +1 for all terms\r\n            // in leading diagonal and zero in other terms\r\n            if ((Math.abs(m12 + m21) < epsilon2) &&\r\n                (Math.abs(m13 + m31) < epsilon2) &&\r\n                (Math.abs(m23 + m32) < epsilon2) &&\r\n                (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {\r\n                // this singularity is identity matrix so angle = 0\r\n                this.set(1, 0, 0, 0);\r\n                return this; // zero angle, arbitrary axis\r\n            }\r\n            // otherwise this singularity is angle = 180\r\n            angle = Math.PI;\r\n            var xx = (m11 + 1) / 2;\r\n            var yy = (m22 + 1) / 2;\r\n            var zz = (m33 + 1) / 2;\r\n            var xy = (m12 + m21) / 4;\r\n            var xz = (m13 + m31) / 4;\r\n            var yz = (m23 + m32) / 4;\r\n            if ((xx > yy) && (xx > zz)) {\r\n                // m11 is the largest diagonal term\r\n                if (xx < epsilon) {\r\n                    x = 0;\r\n                    y = 0.707106781;\r\n                    z = 0.707106781;\r\n                }\r\n                else {\r\n                    x = Math.sqrt(xx);\r\n                    y = xy / x;\r\n                    z = xz / x;\r\n                }\r\n            }\r\n            else if (yy > zz) {\r\n                // m22 is the largest diagonal term\r\n                if (yy < epsilon) {\r\n                    x = 0.707106781;\r\n                    y = 0;\r\n                    z = 0.707106781;\r\n                }\r\n                else {\r\n                    y = Math.sqrt(yy);\r\n                    x = xy / y;\r\n                    z = yz / y;\r\n                }\r\n            }\r\n            else {\r\n                // m33 is the largest diagonal term so base result on this\r\n                if (zz < epsilon) {\r\n                    x = 0.707106781;\r\n                    y = 0.707106781;\r\n                    z = 0;\r\n                }\r\n                else {\r\n                    z = Math.sqrt(zz);\r\n                    x = xz / z;\r\n                    y = yz / z;\r\n                }\r\n            }\r\n            this.set(x, y, z, angle);\r\n            return this; // return 180 deg rotation\r\n        }\r\n        // as we have reached here there are no singularities so we can handle normally\r\n        var s = Math.sqrt((m32 - m23) * (m32 - m23) +\r\n            (m13 - m31) * (m13 - m31) +\r\n            (m21 - m12) * (m21 - m12)); // used to normalize\r\n        if (Math.abs(s) < 0.001)\r\n            s = 1;\r\n        // prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n        // caught by singularity test above, but I've left it in just in case\r\n        this.x = (m32 - m23) / s;\r\n        this.y = (m13 - m31) / s;\r\n        this.z = (m21 - m12) / s;\r\n        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\r\n        return this;\r\n    },\r\n    min: function (v) {\r\n        this.x = Math.min(this.x, v.x);\r\n        this.y = Math.min(this.y, v.y);\r\n        this.z = Math.min(this.z, v.z);\r\n        this.w = Math.min(this.w, v.w);\r\n        return this;\r\n    },\r\n    max: function (v) {\r\n        this.x = Math.max(this.x, v.x);\r\n        this.y = Math.max(this.y, v.y);\r\n        this.z = Math.max(this.z, v.z);\r\n        this.w = Math.max(this.w, v.w);\r\n        return this;\r\n    },\r\n    clamp: function (min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        this.z = Math.max(min.z, Math.min(max.z, this.z));\r\n        this.w = Math.max(min.w, Math.min(max.w, this.w));\r\n        return this;\r\n    },\r\n    clampScalar: function (minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        this.z = Math.max(minVal, Math.min(maxVal, this.z));\r\n        this.w = Math.max(minVal, Math.min(maxVal, this.w));\r\n        return this;\r\n    },\r\n    clampLength: function (min, max) {\r\n        var length = this.length();\r\n        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\r\n    },\r\n    floor: function () {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        this.z = Math.floor(this.z);\r\n        this.w = Math.floor(this.w);\r\n        return this;\r\n    },\r\n    ceil: function () {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        this.z = Math.ceil(this.z);\r\n        this.w = Math.ceil(this.w);\r\n        return this;\r\n    },\r\n    round: function () {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        this.z = Math.round(this.z);\r\n        this.w = Math.round(this.w);\r\n        return this;\r\n    },\r\n    roundToZero: function () {\r\n        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);\r\n        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);\r\n        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);\r\n        return this;\r\n    },\r\n    negate: function () {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        this.w = -this.w;\r\n        return this;\r\n    },\r\n    dot: function (v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n    lengthSq: function () {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n    },\r\n    length: function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    },\r\n    manhattanLength: function () {\r\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\r\n    },\r\n    normalize: function () {\r\n        return this.divideScalar(this.length() || 1);\r\n    },\r\n    setLength: function (length) {\r\n        return this.normalize().multiplyScalar(length);\r\n    },\r\n    lerp: function (v, alpha) {\r\n        this.x += (v.x - this.x) * alpha;\r\n        this.y += (v.y - this.y) * alpha;\r\n        this.z += (v.z - this.z) * alpha;\r\n        this.w += (v.w - this.w) * alpha;\r\n        return this;\r\n    },\r\n    lerpVectors: function (v1, v2, alpha) {\r\n        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\r\n    },\r\n    equals: function (v) {\r\n        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.x = array[offset];\r\n        this.y = array[offset + 1];\r\n        this.z = array[offset + 2];\r\n        this.w = array[offset + 3];\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this.x;\r\n        array[offset + 1] = this.y;\r\n        array[offset + 2] = this.z;\r\n        array[offset + 3] = this.w;\r\n        return array;\r\n    },\r\n    fromBufferAttribute: function (attribute, index, offset) {\r\n        if (offset !== undefined) {\r\n            console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\r\n        }\r\n        this.x = attribute.getX(index);\r\n        this.y = attribute.getY(index);\r\n        this.z = attribute.getZ(index);\r\n        this.w = attribute.getW(index);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Marius Kintel / https://github.com/kintel\r\n */\r\n/*\r\n In options, we can specify:\r\n * Texture parameters for an auto-generated target texture\r\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n*/\r\nfunction WebGLRenderTarget(width, height, options) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.scissor = new Vector4(0, 0, width, height);\r\n    this.scissorTest = false;\r\n    this.viewport = new Vector4(0, 0, width, height);\r\n    options = options || {};\r\n    this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\r\n    this.texture.image = {};\r\n    this.texture.image.width = width;\r\n    this.texture.image.height = height;\r\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\r\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\r\n    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\r\n}\r\nWebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: WebGLRenderTarget,\r\n    isWebGLRenderTarget: true,\r\n    setSize: function (width, height) {\r\n        if (this.width !== width || this.height !== height) {\r\n            this.width = width;\r\n            this.height = height;\r\n            this.texture.image.width = width;\r\n            this.texture.image.height = height;\r\n            this.dispose();\r\n        }\r\n        this.viewport.set(0, 0, width, height);\r\n        this.scissor.set(0, 0, width, height);\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        this.width = source.width;\r\n        this.height = source.height;\r\n        this.viewport.copy(source.viewport);\r\n        this.texture = source.texture.clone();\r\n        this.depthBuffer = source.depthBuffer;\r\n        this.stencilBuffer = source.stencilBuffer;\r\n        this.depthTexture = source.depthTexture;\r\n        return this;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    }\r\n});\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * @author Matt DesLauriers / @mattdesl\r\n */\r\nfunction WebGLMultisampleRenderTarget(width, height, options) {\r\n    WebGLRenderTarget.call(this, width, height, options);\r\n    this.samples = 4;\r\n}\r\nWebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {\r\n    constructor: WebGLMultisampleRenderTarget,\r\n    isWebGLMultisampleRenderTarget: true,\r\n    copy: function (source) {\r\n        WebGLRenderTarget.prototype.copy.call(this, source);\r\n        this.samples = source.samples;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction Matrix4() {\r\n    this.elements = [\r\n        1, 0, 0, 0,\r\n        0, 1, 0, 0,\r\n        0, 0, 1, 0,\r\n        0, 0, 0, 1\r\n    ];\r\n    if (arguments.length > 0) {\r\n        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\r\n    }\r\n}\r\nObject.assign(Matrix4.prototype, {\r\n    isMatrix4: true,\r\n    set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\r\n        var te = this.elements;\r\n        te[0] = n11;\r\n        te[4] = n12;\r\n        te[8] = n13;\r\n        te[12] = n14;\r\n        te[1] = n21;\r\n        te[5] = n22;\r\n        te[9] = n23;\r\n        te[13] = n24;\r\n        te[2] = n31;\r\n        te[6] = n32;\r\n        te[10] = n33;\r\n        te[14] = n34;\r\n        te[3] = n41;\r\n        te[7] = n42;\r\n        te[11] = n43;\r\n        te[15] = n44;\r\n        return this;\r\n    },\r\n    identity: function () {\r\n        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new Matrix4().fromArray(this.elements);\r\n    },\r\n    copy: function (m) {\r\n        var te = this.elements;\r\n        var me = m.elements;\r\n        te[0] = me[0];\r\n        te[1] = me[1];\r\n        te[2] = me[2];\r\n        te[3] = me[3];\r\n        te[4] = me[4];\r\n        te[5] = me[5];\r\n        te[6] = me[6];\r\n        te[7] = me[7];\r\n        te[8] = me[8];\r\n        te[9] = me[9];\r\n        te[10] = me[10];\r\n        te[11] = me[11];\r\n        te[12] = me[12];\r\n        te[13] = me[13];\r\n        te[14] = me[14];\r\n        te[15] = me[15];\r\n        return this;\r\n    },\r\n    copyPosition: function (m) {\r\n        var te = this.elements, me = m.elements;\r\n        te[12] = me[12];\r\n        te[13] = me[13];\r\n        te[14] = me[14];\r\n        return this;\r\n    },\r\n    extractBasis: function (xAxis, yAxis, zAxis) {\r\n        xAxis.setFromMatrixColumn(this, 0);\r\n        yAxis.setFromMatrixColumn(this, 1);\r\n        zAxis.setFromMatrixColumn(this, 2);\r\n        return this;\r\n    },\r\n    makeBasis: function (xAxis, yAxis, zAxis) {\r\n        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    extractRotation: function () {\r\n        var v1 = new Vector3();\r\n        return function extractRotation(m) {\r\n            // this method does not support reflection matrices\r\n            var te = this.elements;\r\n            var me = m.elements;\r\n            var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();\r\n            var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();\r\n            var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();\r\n            te[0] = me[0] * scaleX;\r\n            te[1] = me[1] * scaleX;\r\n            te[2] = me[2] * scaleX;\r\n            te[3] = 0;\r\n            te[4] = me[4] * scaleY;\r\n            te[5] = me[5] * scaleY;\r\n            te[6] = me[6] * scaleY;\r\n            te[7] = 0;\r\n            te[8] = me[8] * scaleZ;\r\n            te[9] = me[9] * scaleZ;\r\n            te[10] = me[10] * scaleZ;\r\n            te[11] = 0;\r\n            te[12] = 0;\r\n            te[13] = 0;\r\n            te[14] = 0;\r\n            te[15] = 1;\r\n            return this;\r\n        };\r\n    }(),\r\n    makeRotationFromEuler: function (euler) {\r\n        if (!(euler && euler.isEuler)) {\r\n            console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\r\n        }\r\n        var te = this.elements;\r\n        var x = euler.x, y = euler.y, z = euler.z;\r\n        var a = Math.cos(x), b = Math.sin(x);\r\n        var c = Math.cos(y), d = Math.sin(y);\r\n        var e = Math.cos(z), f = Math.sin(z);\r\n        if (euler.order === 'XYZ') {\r\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n            te[0] = c * e;\r\n            te[4] = -c * f;\r\n            te[8] = d;\r\n            te[1] = af + be * d;\r\n            te[5] = ae - bf * d;\r\n            te[9] = -b * c;\r\n            te[2] = bf - ae * d;\r\n            te[6] = be + af * d;\r\n            te[10] = a * c;\r\n        }\r\n        else if (euler.order === 'YXZ') {\r\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n            te[0] = ce + df * b;\r\n            te[4] = de * b - cf;\r\n            te[8] = a * d;\r\n            te[1] = a * f;\r\n            te[5] = a * e;\r\n            te[9] = -b;\r\n            te[2] = cf * b - de;\r\n            te[6] = df + ce * b;\r\n            te[10] = a * c;\r\n        }\r\n        else if (euler.order === 'ZXY') {\r\n            var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n            te[0] = ce - df * b;\r\n            te[4] = -a * f;\r\n            te[8] = de + cf * b;\r\n            te[1] = cf + de * b;\r\n            te[5] = a * e;\r\n            te[9] = df - ce * b;\r\n            te[2] = -a * d;\r\n            te[6] = b;\r\n            te[10] = a * c;\r\n        }\r\n        else if (euler.order === 'ZYX') {\r\n            var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n            te[0] = c * e;\r\n            te[4] = be * d - af;\r\n            te[8] = ae * d + bf;\r\n            te[1] = c * f;\r\n            te[5] = bf * d + ae;\r\n            te[9] = af * d - be;\r\n            te[2] = -d;\r\n            te[6] = b * c;\r\n            te[10] = a * c;\r\n        }\r\n        else if (euler.order === 'YZX') {\r\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n            te[0] = c * e;\r\n            te[4] = bd - ac * f;\r\n            te[8] = bc * f + ad;\r\n            te[1] = f;\r\n            te[5] = a * e;\r\n            te[9] = -b * e;\r\n            te[2] = -d * e;\r\n            te[6] = ad * f + bc;\r\n            te[10] = ac - bd * f;\r\n        }\r\n        else if (euler.order === 'XZY') {\r\n            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n            te[0] = c * e;\r\n            te[4] = -f;\r\n            te[8] = d * e;\r\n            te[1] = ac * f + bd;\r\n            te[5] = a * e;\r\n            te[9] = ad * f - bc;\r\n            te[2] = bc * f - ad;\r\n            te[6] = b * e;\r\n            te[10] = bd * f + ac;\r\n        }\r\n        // bottom row\r\n        te[3] = 0;\r\n        te[7] = 0;\r\n        te[11] = 0;\r\n        // last column\r\n        te[12] = 0;\r\n        te[13] = 0;\r\n        te[14] = 0;\r\n        te[15] = 1;\r\n        return this;\r\n    },\r\n    makeRotationFromQuaternion: function () {\r\n        var zero = new Vector3(0, 0, 0);\r\n        var one = new Vector3(1, 1, 1);\r\n        return function makeRotationFromQuaternion(q) {\r\n            return this.compose(zero, q, one);\r\n        };\r\n    }(),\r\n    lookAt: function () {\r\n        var x = new Vector3();\r\n        var y = new Vector3();\r\n        var z = new Vector3();\r\n        return function lookAt(eye, target, up) {\r\n            var te = this.elements;\r\n            z.subVectors(eye, target);\r\n            if (z.lengthSq() === 0) {\r\n                // eye and target are in the same position\r\n                z.z = 1;\r\n            }\r\n            z.normalize();\r\n            x.crossVectors(up, z);\r\n            if (x.lengthSq() === 0) {\r\n                // up and z are parallel\r\n                if (Math.abs(up.z) === 1) {\r\n                    z.x += 0.0001;\r\n                }\r\n                else {\r\n                    z.z += 0.0001;\r\n                }\r\n                z.normalize();\r\n                x.crossVectors(up, z);\r\n            }\r\n            x.normalize();\r\n            y.crossVectors(z, x);\r\n            te[0] = x.x;\r\n            te[4] = y.x;\r\n            te[8] = z.x;\r\n            te[1] = x.y;\r\n            te[5] = y.y;\r\n            te[9] = z.y;\r\n            te[2] = x.z;\r\n            te[6] = y.z;\r\n            te[10] = z.z;\r\n            return this;\r\n        };\r\n    }(),\r\n    multiply: function (m, n) {\r\n        if (n !== undefined) {\r\n            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\r\n            return this.multiplyMatrices(m, n);\r\n        }\r\n        return this.multiplyMatrices(this, m);\r\n    },\r\n    premultiply: function (m) {\r\n        return this.multiplyMatrices(m, this);\r\n    },\r\n    multiplyMatrices: function (a, b) {\r\n        var ae = a.elements;\r\n        var be = b.elements;\r\n        var te = this.elements;\r\n        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\r\n        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\r\n        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\r\n        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\r\n        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\r\n        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\r\n        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\r\n        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\r\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (s) {\r\n        var te = this.elements;\r\n        te[0] *= s;\r\n        te[4] *= s;\r\n        te[8] *= s;\r\n        te[12] *= s;\r\n        te[1] *= s;\r\n        te[5] *= s;\r\n        te[9] *= s;\r\n        te[13] *= s;\r\n        te[2] *= s;\r\n        te[6] *= s;\r\n        te[10] *= s;\r\n        te[14] *= s;\r\n        te[3] *= s;\r\n        te[7] *= s;\r\n        te[11] *= s;\r\n        te[15] *= s;\r\n        return this;\r\n    },\r\n    applyToBufferAttribute: function () {\r\n        var v1 = new Vector3();\r\n        return function applyToBufferAttribute(attribute) {\r\n            for (var i = 0, l = attribute.count; i < l; i++) {\r\n                v1.x = attribute.getX(i);\r\n                v1.y = attribute.getY(i);\r\n                v1.z = attribute.getZ(i);\r\n                v1.applyMatrix4(this);\r\n                attribute.setXYZ(i, v1.x, v1.y, v1.z);\r\n            }\r\n            return attribute;\r\n        };\r\n    }(),\r\n    determinant: function () {\r\n        var te = this.elements;\r\n        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\r\n        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\r\n        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\r\n        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\r\n        //TODO: make this more efficient\r\n        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n        return (n41 * (+n14 * n23 * n32\r\n            - n13 * n24 * n32\r\n            - n14 * n22 * n33\r\n            + n12 * n24 * n33\r\n            + n13 * n22 * n34\r\n            - n12 * n23 * n34) +\r\n            n42 * (+n11 * n23 * n34\r\n                - n11 * n24 * n33\r\n                + n14 * n21 * n33\r\n                - n13 * n21 * n34\r\n                + n13 * n24 * n31\r\n                - n14 * n23 * n31) +\r\n            n43 * (+n11 * n24 * n32\r\n                - n11 * n22 * n34\r\n                - n14 * n21 * n32\r\n                + n12 * n21 * n34\r\n                + n14 * n22 * n31\r\n                - n12 * n24 * n31) +\r\n            n44 * (-n13 * n22 * n31\r\n                - n11 * n23 * n32\r\n                + n11 * n22 * n33\r\n                + n13 * n21 * n32\r\n                - n12 * n21 * n33\r\n                + n12 * n23 * n31));\r\n    },\r\n    transpose: function () {\r\n        var te = this.elements;\r\n        var tmp;\r\n        tmp = te[1];\r\n        te[1] = te[4];\r\n        te[4] = tmp;\r\n        tmp = te[2];\r\n        te[2] = te[8];\r\n        te[8] = tmp;\r\n        tmp = te[6];\r\n        te[6] = te[9];\r\n        te[9] = tmp;\r\n        tmp = te[3];\r\n        te[3] = te[12];\r\n        te[12] = tmp;\r\n        tmp = te[7];\r\n        te[7] = te[13];\r\n        te[13] = tmp;\r\n        tmp = te[11];\r\n        te[11] = te[14];\r\n        te[14] = tmp;\r\n        return this;\r\n    },\r\n    setPosition: function (x, y, z) {\r\n        var te = this.elements;\r\n        if (x.isVector3) {\r\n            te[12] = x.x;\r\n            te[13] = x.y;\r\n            te[14] = x.z;\r\n        }\r\n        else {\r\n            te[12] = x;\r\n            te[13] = y;\r\n            te[14] = z;\r\n        }\r\n        return this;\r\n    },\r\n    getInverse: function (m, throwOnDegenerate) {\r\n        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n        if (det === 0) {\r\n            var msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\r\n            if (throwOnDegenerate === true) {\r\n                throw new Error(msg);\r\n            }\r\n            else {\r\n                console.warn(msg);\r\n            }\r\n            return this.identity();\r\n        }\r\n        var detInv = 1 / det;\r\n        te[0] = t11 * detInv;\r\n        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\r\n        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\r\n        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\r\n        te[4] = t12 * detInv;\r\n        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\r\n        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\r\n        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\r\n        te[8] = t13 * detInv;\r\n        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\r\n        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\r\n        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\r\n        te[12] = t14 * detInv;\r\n        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\r\n        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\r\n        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\r\n        return this;\r\n    },\r\n    scale: function (v) {\r\n        var te = this.elements;\r\n        var x = v.x, y = v.y, z = v.z;\r\n        te[0] *= x;\r\n        te[4] *= y;\r\n        te[8] *= z;\r\n        te[1] *= x;\r\n        te[5] *= y;\r\n        te[9] *= z;\r\n        te[2] *= x;\r\n        te[6] *= y;\r\n        te[10] *= z;\r\n        te[3] *= x;\r\n        te[7] *= y;\r\n        te[11] *= z;\r\n        return this;\r\n    },\r\n    getMaxScaleOnAxis: function () {\r\n        var te = this.elements;\r\n        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\r\n    },\r\n    makeTranslation: function (x, y, z) {\r\n        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeRotationX: function (theta) {\r\n        var c = Math.cos(theta), s = Math.sin(theta);\r\n        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeRotationY: function (theta) {\r\n        var c = Math.cos(theta), s = Math.sin(theta);\r\n        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeRotationZ: function (theta) {\r\n        var c = Math.cos(theta), s = Math.sin(theta);\r\n        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeRotationAxis: function (axis, angle) {\r\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n        var c = Math.cos(angle);\r\n        var s = Math.sin(angle);\r\n        var t = 1 - c;\r\n        var x = axis.x, y = axis.y, z = axis.z;\r\n        var tx = t * x, ty = t * y;\r\n        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeScale: function (x, y, z) {\r\n        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    makeShear: function (x, y, z) {\r\n        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\r\n        return this;\r\n    },\r\n    compose: function (position, quaternion, scale) {\r\n        var te = this.elements;\r\n        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\r\n        var x2 = x + x, y2 = y + y, z2 = z + z;\r\n        var xx = x * x2, xy = x * y2, xz = x * z2;\r\n        var yy = y * y2, yz = y * z2, zz = z * z2;\r\n        var wx = w * x2, wy = w * y2, wz = w * z2;\r\n        var sx = scale.x, sy = scale.y, sz = scale.z;\r\n        te[0] = (1 - (yy + zz)) * sx;\r\n        te[1] = (xy + wz) * sx;\r\n        te[2] = (xz - wy) * sx;\r\n        te[3] = 0;\r\n        te[4] = (xy - wz) * sy;\r\n        te[5] = (1 - (xx + zz)) * sy;\r\n        te[6] = (yz + wx) * sy;\r\n        te[7] = 0;\r\n        te[8] = (xz + wy) * sz;\r\n        te[9] = (yz - wx) * sz;\r\n        te[10] = (1 - (xx + yy)) * sz;\r\n        te[11] = 0;\r\n        te[12] = position.x;\r\n        te[13] = position.y;\r\n        te[14] = position.z;\r\n        te[15] = 1;\r\n        return this;\r\n    },\r\n    decompose: function () {\r\n        var vector = new Vector3();\r\n        var matrix = new Matrix4();\r\n        return function decompose(position, quaternion, scale) {\r\n            var te = this.elements;\r\n            var sx = vector.set(te[0], te[1], te[2]).length();\r\n            var sy = vector.set(te[4], te[5], te[6]).length();\r\n            var sz = vector.set(te[8], te[9], te[10]).length();\r\n            // if determine is negative, we need to invert one scale\r\n            var det = this.determinant();\r\n            if (det < 0)\r\n                sx = -sx;\r\n            position.x = te[12];\r\n            position.y = te[13];\r\n            position.z = te[14];\r\n            // scale the rotation part\r\n            matrix.copy(this);\r\n            var invSX = 1 / sx;\r\n            var invSY = 1 / sy;\r\n            var invSZ = 1 / sz;\r\n            matrix.elements[0] *= invSX;\r\n            matrix.elements[1] *= invSX;\r\n            matrix.elements[2] *= invSX;\r\n            matrix.elements[4] *= invSY;\r\n            matrix.elements[5] *= invSY;\r\n            matrix.elements[6] *= invSY;\r\n            matrix.elements[8] *= invSZ;\r\n            matrix.elements[9] *= invSZ;\r\n            matrix.elements[10] *= invSZ;\r\n            quaternion.setFromRotationMatrix(matrix);\r\n            scale.x = sx;\r\n            scale.y = sy;\r\n            scale.z = sz;\r\n            return this;\r\n        };\r\n    }(),\r\n    makePerspective: function (left, right, top, bottom, near, far) {\r\n        if (far === undefined) {\r\n            console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\r\n        }\r\n        var te = this.elements;\r\n        var x = 2 * near / (right - left);\r\n        var y = 2 * near / (top - bottom);\r\n        var a = (right + left) / (right - left);\r\n        var b = (top + bottom) / (top - bottom);\r\n        var c = -(far + near) / (far - near);\r\n        var d = -2 * far * near / (far - near);\r\n        te[0] = x;\r\n        te[4] = 0;\r\n        te[8] = a;\r\n        te[12] = 0;\r\n        te[1] = 0;\r\n        te[5] = y;\r\n        te[9] = b;\r\n        te[13] = 0;\r\n        te[2] = 0;\r\n        te[6] = 0;\r\n        te[10] = c;\r\n        te[14] = d;\r\n        te[3] = 0;\r\n        te[7] = 0;\r\n        te[11] = -1;\r\n        te[15] = 0;\r\n        return this;\r\n    },\r\n    makeOrthographic: function (left, right, top, bottom, near, far) {\r\n        var te = this.elements;\r\n        var w = 1.0 / (right - left);\r\n        var h = 1.0 / (top - bottom);\r\n        var p = 1.0 / (far - near);\r\n        var x = (right + left) * w;\r\n        var y = (top + bottom) * h;\r\n        var z = (far + near) * p;\r\n        te[0] = 2 * w;\r\n        te[4] = 0;\r\n        te[8] = 0;\r\n        te[12] = -x;\r\n        te[1] = 0;\r\n        te[5] = 2 * h;\r\n        te[9] = 0;\r\n        te[13] = -y;\r\n        te[2] = 0;\r\n        te[6] = 0;\r\n        te[10] = -2 * p;\r\n        te[14] = -z;\r\n        te[3] = 0;\r\n        te[7] = 0;\r\n        te[11] = 0;\r\n        te[15] = 1;\r\n        return this;\r\n    },\r\n    equals: function (matrix) {\r\n        var te = this.elements;\r\n        var me = matrix.elements;\r\n        for (var i = 0; i < 16; i++) {\r\n            if (te[i] !== me[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        for (var i = 0; i < 16; i++) {\r\n            this.elements[i] = array[i + offset];\r\n        }\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        var te = this.elements;\r\n        array[offset] = te[0];\r\n        array[offset + 1] = te[1];\r\n        array[offset + 2] = te[2];\r\n        array[offset + 3] = te[3];\r\n        array[offset + 4] = te[4];\r\n        array[offset + 5] = te[5];\r\n        array[offset + 6] = te[6];\r\n        array[offset + 7] = te[7];\r\n        array[offset + 8] = te[8];\r\n        array[offset + 9] = te[9];\r\n        array[offset + 10] = te[10];\r\n        array[offset + 11] = te[11];\r\n        array[offset + 12] = te[12];\r\n        array[offset + 13] = te[13];\r\n        array[offset + 14] = te[14];\r\n        array[offset + 15] = te[15];\r\n        return array;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\nvar _matrix, _quaternion;\r\nfunction Euler(x, y, z, order) {\r\n    this._x = x || 0;\r\n    this._y = y || 0;\r\n    this._z = z || 0;\r\n    this._order = order || Euler.DefaultOrder;\r\n}\r\nEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\r\nEuler.DefaultOrder = 'XYZ';\r\nObject.defineProperties(Euler.prototype, {\r\n    x: {\r\n        get: function () {\r\n            return this._x;\r\n        },\r\n        set: function (value) {\r\n            this._x = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    y: {\r\n        get: function () {\r\n            return this._y;\r\n        },\r\n        set: function (value) {\r\n            this._y = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    z: {\r\n        get: function () {\r\n            return this._z;\r\n        },\r\n        set: function (value) {\r\n            this._z = value;\r\n            this._onChangeCallback();\r\n        }\r\n    },\r\n    order: {\r\n        get: function () {\r\n            return this._order;\r\n        },\r\n        set: function (value) {\r\n            this._order = value;\r\n            this._onChangeCallback();\r\n        }\r\n    }\r\n});\r\nObject.assign(Euler.prototype, {\r\n    isEuler: true,\r\n    set: function (x, y, z, order) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._order = order || this._order;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this._x, this._y, this._z, this._order);\r\n    },\r\n    copy: function (euler) {\r\n        this._x = euler._x;\r\n        this._y = euler._y;\r\n        this._z = euler._z;\r\n        this._order = euler._order;\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromRotationMatrix: function (m, order, update) {\r\n        var clamp = _Math.clamp;\r\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n        var te = m.elements;\r\n        var m11 = te[0], m12 = te[4], m13 = te[8];\r\n        var m21 = te[1], m22 = te[5], m23 = te[9];\r\n        var m31 = te[2], m32 = te[6], m33 = te[10];\r\n        order = order || this._order;\r\n        if (order === 'XYZ') {\r\n            this._y = Math.asin(clamp(m13, -1, 1));\r\n            if (Math.abs(m13) < 0.99999) {\r\n                this._x = Math.atan2(-m23, m33);\r\n                this._z = Math.atan2(-m12, m11);\r\n            }\r\n            else {\r\n                this._x = Math.atan2(m32, m22);\r\n                this._z = 0;\r\n            }\r\n        }\r\n        else if (order === 'YXZ') {\r\n            this._x = Math.asin(-clamp(m23, -1, 1));\r\n            if (Math.abs(m23) < 0.99999) {\r\n                this._y = Math.atan2(m13, m33);\r\n                this._z = Math.atan2(m21, m22);\r\n            }\r\n            else {\r\n                this._y = Math.atan2(-m31, m11);\r\n                this._z = 0;\r\n            }\r\n        }\r\n        else if (order === 'ZXY') {\r\n            this._x = Math.asin(clamp(m32, -1, 1));\r\n            if (Math.abs(m32) < 0.99999) {\r\n                this._y = Math.atan2(-m31, m33);\r\n                this._z = Math.atan2(-m12, m22);\r\n            }\r\n            else {\r\n                this._y = 0;\r\n                this._z = Math.atan2(m21, m11);\r\n            }\r\n        }\r\n        else if (order === 'ZYX') {\r\n            this._y = Math.asin(-clamp(m31, -1, 1));\r\n            if (Math.abs(m31) < 0.99999) {\r\n                this._x = Math.atan2(m32, m33);\r\n                this._z = Math.atan2(m21, m11);\r\n            }\r\n            else {\r\n                this._x = 0;\r\n                this._z = Math.atan2(-m12, m22);\r\n            }\r\n        }\r\n        else if (order === 'YZX') {\r\n            this._z = Math.asin(clamp(m21, -1, 1));\r\n            if (Math.abs(m21) < 0.99999) {\r\n                this._x = Math.atan2(-m23, m22);\r\n                this._y = Math.atan2(-m31, m11);\r\n            }\r\n            else {\r\n                this._x = 0;\r\n                this._y = Math.atan2(m13, m33);\r\n            }\r\n        }\r\n        else if (order === 'XZY') {\r\n            this._z = Math.asin(-clamp(m12, -1, 1));\r\n            if (Math.abs(m12) < 0.99999) {\r\n                this._x = Math.atan2(m32, m22);\r\n                this._y = Math.atan2(m13, m11);\r\n            }\r\n            else {\r\n                this._x = Math.atan2(-m23, m33);\r\n                this._y = 0;\r\n            }\r\n        }\r\n        else {\r\n            console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);\r\n        }\r\n        this._order = order;\r\n        if (update !== false)\r\n            this._onChangeCallback();\r\n        return this;\r\n    },\r\n    setFromQuaternion: function (q, order, update) {\r\n        if (_matrix === undefined)\r\n            _matrix = new Matrix4();\r\n        _matrix.makeRotationFromQuaternion(q);\r\n        return this.setFromRotationMatrix(_matrix, order, update);\r\n    },\r\n    setFromVector3: function (v, order) {\r\n        return this.set(v.x, v.y, v.z, order || this._order);\r\n    },\r\n    reorder: function (newOrder) {\r\n        // WARNING: this discards revolution information -bhouston\r\n        if (_quaternion === undefined)\r\n            _quaternion = new Quaternion();\r\n        _quaternion.setFromEuler(this);\r\n        return this.setFromQuaternion(_quaternion, newOrder);\r\n    },\r\n    equals: function (euler) {\r\n        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);\r\n    },\r\n    fromArray: function (array) {\r\n        this._x = array[0];\r\n        this._y = array[1];\r\n        this._z = array[2];\r\n        if (array[3] !== undefined)\r\n            this._order = array[3];\r\n        this._onChangeCallback();\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this._x;\r\n        array[offset + 1] = this._y;\r\n        array[offset + 2] = this._z;\r\n        array[offset + 3] = this._order;\r\n        return array;\r\n    },\r\n    toVector3: function (optionalResult) {\r\n        if (optionalResult) {\r\n            return optionalResult.set(this._x, this._y, this._z);\r\n        }\r\n        else {\r\n            return new Vector3(this._x, this._y, this._z);\r\n        }\r\n    },\r\n    _onChange: function (callback) {\r\n        this._onChangeCallback = callback;\r\n        return this;\r\n    },\r\n    _onChangeCallback: function () { }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Layers() {\r\n    this.mask = 1 | 0;\r\n}\r\nObject.assign(Layers.prototype, {\r\n    set: function (channel) {\r\n        this.mask = 1 << channel | 0;\r\n    },\r\n    enable: function (channel) {\r\n        this.mask |= 1 << channel | 0;\r\n    },\r\n    toggle: function (channel) {\r\n        this.mask ^= 1 << channel | 0;\r\n    },\r\n    disable: function (channel) {\r\n        this.mask &= ~(1 << channel | 0);\r\n    },\r\n    test: function (layers) {\r\n        return (this.mask & layers.mask) !== 0;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\nvar object3DId = 0;\r\nfunction Object3D() {\r\n    Object.defineProperty(this, 'id', { value: object3DId++ });\r\n    this.uuid = _Math.generateUUID();\r\n    this.name = '';\r\n    this.type = 'Object3D';\r\n    this.parent = null;\r\n    this.children = [];\r\n    this.up = Object3D.DefaultUp.clone();\r\n    var position = new Vector3();\r\n    var rotation = new Euler();\r\n    var quaternion = new Quaternion();\r\n    var scale = new Vector3(1, 1, 1);\r\n    function onRotationChange() {\r\n        quaternion.setFromEuler(rotation, false);\r\n    }\r\n    function onQuaternionChange() {\r\n        rotation.setFromQuaternion(quaternion, undefined, false);\r\n    }\r\n    rotation._onChange(onRotationChange);\r\n    quaternion._onChange(onQuaternionChange);\r\n    Object.defineProperties(this, {\r\n        position: {\r\n            configurable: true,\r\n            enumerable: true,\r\n            value: position\r\n        },\r\n        rotation: {\r\n            configurable: true,\r\n            enumerable: true,\r\n            value: rotation\r\n        },\r\n        quaternion: {\r\n            configurable: true,\r\n            enumerable: true,\r\n            value: quaternion\r\n        },\r\n        scale: {\r\n            configurable: true,\r\n            enumerable: true,\r\n            value: scale\r\n        },\r\n        modelViewMatrix: {\r\n            value: new Matrix4()\r\n        },\r\n        normalMatrix: {\r\n            value: new Matrix3()\r\n        }\r\n    });\r\n    this.matrix = new Matrix4();\r\n    this.matrixWorld = new Matrix4();\r\n    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\r\n    this.matrixWorldNeedsUpdate = false;\r\n    this.layers = new Layers();\r\n    this.visible = true;\r\n    this.castShadow = false;\r\n    this.receiveShadow = false;\r\n    this.frustumCulled = true;\r\n    this.renderOrder = 0;\r\n    this.userData = {};\r\n}\r\nObject3D.DefaultUp = new Vector3(0, 1, 0);\r\nObject3D.DefaultMatrixAutoUpdate = true;\r\nObject3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: Object3D,\r\n    isObject3D: true,\r\n    onBeforeRender: function () { },\r\n    onAfterRender: function () { },\r\n    applyMatrix: function (matrix) {\r\n        if (this.matrixAutoUpdate)\r\n            this.updateMatrix();\r\n        this.matrix.premultiply(matrix);\r\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\r\n    },\r\n    applyQuaternion: function (q) {\r\n        this.quaternion.premultiply(q);\r\n        return this;\r\n    },\r\n    setRotationFromAxisAngle: function (axis, angle) {\r\n        // assumes axis is normalized\r\n        this.quaternion.setFromAxisAngle(axis, angle);\r\n    },\r\n    setRotationFromEuler: function (euler) {\r\n        this.quaternion.setFromEuler(euler, true);\r\n    },\r\n    setRotationFromMatrix: function (m) {\r\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n        this.quaternion.setFromRotationMatrix(m);\r\n    },\r\n    setRotationFromQuaternion: function (q) {\r\n        // assumes q is normalized\r\n        this.quaternion.copy(q);\r\n    },\r\n    rotateOnAxis: function () {\r\n        // rotate object on axis in object space\r\n        // axis is assumed to be normalized\r\n        var q1 = new Quaternion();\r\n        return function rotateOnAxis(axis, angle) {\r\n            q1.setFromAxisAngle(axis, angle);\r\n            this.quaternion.multiply(q1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateOnWorldAxis: function () {\r\n        // rotate object on axis in world space\r\n        // axis is assumed to be normalized\r\n        // method assumes no rotated parent\r\n        var q1 = new Quaternion();\r\n        return function rotateOnWorldAxis(axis, angle) {\r\n            q1.setFromAxisAngle(axis, angle);\r\n            this.quaternion.premultiply(q1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateX: function () {\r\n        var v1 = new Vector3(1, 0, 0);\r\n        return function rotateX(angle) {\r\n            return this.rotateOnAxis(v1, angle);\r\n        };\r\n    }(),\r\n    rotateY: function () {\r\n        var v1 = new Vector3(0, 1, 0);\r\n        return function rotateY(angle) {\r\n            return this.rotateOnAxis(v1, angle);\r\n        };\r\n    }(),\r\n    rotateZ: function () {\r\n        var v1 = new Vector3(0, 0, 1);\r\n        return function rotateZ(angle) {\r\n            return this.rotateOnAxis(v1, angle);\r\n        };\r\n    }(),\r\n    translateOnAxis: function () {\r\n        // translate object by distance along axis in object space\r\n        // axis is assumed to be normalized\r\n        var v1 = new Vector3();\r\n        return function translateOnAxis(axis, distance) {\r\n            v1.copy(axis).applyQuaternion(this.quaternion);\r\n            this.position.add(v1.multiplyScalar(distance));\r\n            return this;\r\n        };\r\n    }(),\r\n    translateX: function () {\r\n        var v1 = new Vector3(1, 0, 0);\r\n        return function translateX(distance) {\r\n            return this.translateOnAxis(v1, distance);\r\n        };\r\n    }(),\r\n    translateY: function () {\r\n        var v1 = new Vector3(0, 1, 0);\r\n        return function translateY(distance) {\r\n            return this.translateOnAxis(v1, distance);\r\n        };\r\n    }(),\r\n    translateZ: function () {\r\n        var v1 = new Vector3(0, 0, 1);\r\n        return function translateZ(distance) {\r\n            return this.translateOnAxis(v1, distance);\r\n        };\r\n    }(),\r\n    localToWorld: function (vector) {\r\n        return vector.applyMatrix4(this.matrixWorld);\r\n    },\r\n    worldToLocal: function () {\r\n        var m1 = new Matrix4();\r\n        return function worldToLocal(vector) {\r\n            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));\r\n        };\r\n    }(),\r\n    lookAt: function () {\r\n        // This method does not support objects having non-uniformly-scaled parent(s)\r\n        var q1 = new Quaternion();\r\n        var m1 = new Matrix4();\r\n        var target = new Vector3();\r\n        var position = new Vector3();\r\n        return function lookAt(x, y, z) {\r\n            if (x.isVector3) {\r\n                target.copy(x);\r\n            }\r\n            else {\r\n                target.set(x, y, z);\r\n            }\r\n            var parent = this.parent;\r\n            this.updateWorldMatrix(true, false);\r\n            position.setFromMatrixPosition(this.matrixWorld);\r\n            if (this.isCamera || this.isLight) {\r\n                m1.lookAt(position, target, this.up);\r\n            }\r\n            else {\r\n                m1.lookAt(target, position, this.up);\r\n            }\r\n            this.quaternion.setFromRotationMatrix(m1);\r\n            if (parent) {\r\n                m1.extractRotation(parent.matrixWorld);\r\n                q1.setFromRotationMatrix(m1);\r\n                this.quaternion.premultiply(q1.inverse());\r\n            }\r\n        };\r\n    }(),\r\n    add: function (object) {\r\n        if (arguments.length > 1) {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                this.add(arguments[i]);\r\n            }\r\n            return this;\r\n        }\r\n        if (object === this) {\r\n            console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\r\n            return this;\r\n        }\r\n        if ((object && object.isObject3D)) {\r\n            if (object.parent !== null) {\r\n                object.parent.remove(object);\r\n            }\r\n            object.parent = this;\r\n            this.children.push(object);\r\n            object.dispatchEvent({ type: 'added' });\r\n        }\r\n        else {\r\n            console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\r\n        }\r\n        return this;\r\n    },\r\n    remove: function (object) {\r\n        if (arguments.length > 1) {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                this.remove(arguments[i]);\r\n            }\r\n            return this;\r\n        }\r\n        var index = this.children.indexOf(object);\r\n        if (index !== -1) {\r\n            object.parent = null;\r\n            this.children.splice(index, 1);\r\n            object.dispatchEvent({ type: 'removed' });\r\n        }\r\n        return this;\r\n    },\r\n    attach: function () {\r\n        // adds object as a child of this, while maintaining the object's world transform\r\n        var m = new Matrix4();\r\n        return function attach(object) {\r\n            this.updateWorldMatrix(true, false);\r\n            m.getInverse(this.matrixWorld);\r\n            if (object.parent !== null) {\r\n                object.parent.updateWorldMatrix(true, false);\r\n                m.multiply(object.parent.matrixWorld);\r\n            }\r\n            object.applyMatrix(m);\r\n            object.updateWorldMatrix(false, false);\r\n            this.add(object);\r\n            return this;\r\n        };\r\n    }(),\r\n    getObjectById: function (id) {\r\n        return this.getObjectByProperty('id', id);\r\n    },\r\n    getObjectByName: function (name) {\r\n        return this.getObjectByProperty('name', name);\r\n    },\r\n    getObjectByProperty: function (name, value) {\r\n        if (this[name] === value)\r\n            return this;\r\n        for (var i = 0, l = this.children.length; i < l; i++) {\r\n            var child = this.children[i];\r\n            var object = child.getObjectByProperty(name, value);\r\n            if (object !== undefined) {\r\n                return object;\r\n            }\r\n        }\r\n        return undefined;\r\n    },\r\n    getWorldPosition: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Object3D: .getWorldPosition() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        this.updateMatrixWorld(true);\r\n        return target.setFromMatrixPosition(this.matrixWorld);\r\n    },\r\n    getWorldQuaternion: function () {\r\n        var position = new Vector3();\r\n        var scale = new Vector3();\r\n        return function getWorldQuaternion(target) {\r\n            if (target === undefined) {\r\n                console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\r\n                target = new Quaternion();\r\n            }\r\n            this.updateMatrixWorld(true);\r\n            this.matrixWorld.decompose(position, target, scale);\r\n            return target;\r\n        };\r\n    }(),\r\n    getWorldScale: function () {\r\n        var position = new Vector3();\r\n        var quaternion = new Quaternion();\r\n        return function getWorldScale(target) {\r\n            if (target === undefined) {\r\n                console.warn('THREE.Object3D: .getWorldScale() target is now required');\r\n                target = new Vector3();\r\n            }\r\n            this.updateMatrixWorld(true);\r\n            this.matrixWorld.decompose(position, quaternion, target);\r\n            return target;\r\n        };\r\n    }(),\r\n    getWorldDirection: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Object3D: .getWorldDirection() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        this.updateMatrixWorld(true);\r\n        var e = this.matrixWorld.elements;\r\n        return target.set(e[8], e[9], e[10]).normalize();\r\n    },\r\n    raycast: function () { },\r\n    traverse: function (callback) {\r\n        callback(this);\r\n        var children = this.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            children[i].traverse(callback);\r\n        }\r\n    },\r\n    traverseVisible: function (callback) {\r\n        if (this.visible === false)\r\n            return;\r\n        callback(this);\r\n        var children = this.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            children[i].traverseVisible(callback);\r\n        }\r\n    },\r\n    traverseAncestors: function (callback) {\r\n        var parent = this.parent;\r\n        if (parent !== null) {\r\n            callback(parent);\r\n            parent.traverseAncestors(callback);\r\n        }\r\n    },\r\n    updateMatrix: function () {\r\n        this.matrix.compose(this.position, this.quaternion, this.scale);\r\n        this.matrixWorldNeedsUpdate = true;\r\n    },\r\n    updateMatrixWorld: function (force) {\r\n        if (this.matrixAutoUpdate)\r\n            this.updateMatrix();\r\n        if (this.matrixWorldNeedsUpdate || force) {\r\n            if (this.parent === null) {\r\n                this.matrixWorld.copy(this.matrix);\r\n            }\r\n            else {\r\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\r\n            }\r\n            this.matrixWorldNeedsUpdate = false;\r\n            force = true;\r\n        }\r\n        // update children\r\n        var children = this.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            children[i].updateMatrixWorld(force);\r\n        }\r\n    },\r\n    updateWorldMatrix: function (updateParents, updateChildren) {\r\n        var parent = this.parent;\r\n        if (updateParents === true && parent !== null) {\r\n            parent.updateWorldMatrix(true, false);\r\n        }\r\n        if (this.matrixAutoUpdate)\r\n            this.updateMatrix();\r\n        if (this.parent === null) {\r\n            this.matrixWorld.copy(this.matrix);\r\n        }\r\n        else {\r\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\r\n        }\r\n        // update children\r\n        if (updateChildren === true) {\r\n            var children = this.children;\r\n            for (var i = 0, l = children.length; i < l; i++) {\r\n                children[i].updateWorldMatrix(false, true);\r\n            }\r\n        }\r\n    },\r\n    toJSON: function (meta) {\r\n        // meta is a string when called from JSON.stringify\r\n        var isRootObject = (meta === undefined || typeof meta === 'string');\r\n        var output = {};\r\n        // meta is a hash used to collect geometries, materials.\r\n        // not providing it implies that this is the root object\r\n        // being serialized.\r\n        if (isRootObject) {\r\n            // initialize meta obj\r\n            meta = {\r\n                geometries: {},\r\n                materials: {},\r\n                textures: {},\r\n                images: {},\r\n                shapes: {}\r\n            };\r\n            output.metadata = {\r\n                version: 4.5,\r\n                type: 'Object',\r\n                generator: 'Object3D.toJSON'\r\n            };\r\n        }\r\n        // standard Object3D serialization\r\n        var object = {};\r\n        object.uuid = this.uuid;\r\n        object.type = this.type;\r\n        if (this.name !== '')\r\n            object.name = this.name;\r\n        if (this.castShadow === true)\r\n            object.castShadow = true;\r\n        if (this.receiveShadow === true)\r\n            object.receiveShadow = true;\r\n        if (this.visible === false)\r\n            object.visible = false;\r\n        if (this.frustumCulled === false)\r\n            object.frustumCulled = false;\r\n        if (this.renderOrder !== 0)\r\n            object.renderOrder = this.renderOrder;\r\n        if (JSON.stringify(this.userData) !== '{}')\r\n            object.userData = this.userData;\r\n        object.layers = this.layers.mask;\r\n        object.matrix = this.matrix.toArray();\r\n        if (this.matrixAutoUpdate === false)\r\n            object.matrixAutoUpdate = false;\r\n        // object specific properties\r\n        if (this.isMesh && this.drawMode !== TrianglesDrawMode)\r\n            object.drawMode = this.drawMode;\r\n        //\r\n        function serialize(library, element) {\r\n            if (library[element.uuid] === undefined) {\r\n                library[element.uuid] = element.toJSON(meta);\r\n            }\r\n            return element.uuid;\r\n        }\r\n        if (this.isMesh || this.isLine || this.isPoints) {\r\n            object.geometry = serialize(meta.geometries, this.geometry);\r\n            var parameters = this.geometry.parameters;\r\n            if (parameters !== undefined && parameters.shapes !== undefined) {\r\n                var shapes = parameters.shapes;\r\n                if (Array.isArray(shapes)) {\r\n                    for (var i = 0, l = shapes.length; i < l; i++) {\r\n                        var shape = shapes[i];\r\n                        serialize(meta.shapes, shape);\r\n                    }\r\n                }\r\n                else {\r\n                    serialize(meta.shapes, shapes);\r\n                }\r\n            }\r\n        }\r\n        if (this.material !== undefined) {\r\n            if (Array.isArray(this.material)) {\r\n                var uuids = [];\r\n                for (var i = 0, l = this.material.length; i < l; i++) {\r\n                    uuids.push(serialize(meta.materials, this.material[i]));\r\n                }\r\n                object.material = uuids;\r\n            }\r\n            else {\r\n                object.material = serialize(meta.materials, this.material);\r\n            }\r\n        }\r\n        //\r\n        if (this.children.length > 0) {\r\n            object.children = [];\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                object.children.push(this.children[i].toJSON(meta).object);\r\n            }\r\n        }\r\n        if (isRootObject) {\r\n            var geometries = extractFromCache(meta.geometries);\r\n            var materials = extractFromCache(meta.materials);\r\n            var textures = extractFromCache(meta.textures);\r\n            var images = extractFromCache(meta.images);\r\n            var shapes = extractFromCache(meta.shapes);\r\n            if (geometries.length > 0)\r\n                output.geometries = geometries;\r\n            if (materials.length > 0)\r\n                output.materials = materials;\r\n            if (textures.length > 0)\r\n                output.textures = textures;\r\n            if (images.length > 0)\r\n                output.images = images;\r\n            if (shapes.length > 0)\r\n                output.shapes = shapes;\r\n        }\r\n        output.object = object;\r\n        return output;\r\n        // extract data from the cache hash\r\n        // remove metadata on each item\r\n        // and return as array\r\n        function extractFromCache(cache) {\r\n            var values = [];\r\n            for (var key in cache) {\r\n                var data = cache[key];\r\n                delete data.metadata;\r\n                values.push(data);\r\n            }\r\n            return values;\r\n        }\r\n    },\r\n    clone: function (recursive) {\r\n        return new this.constructor().copy(this, recursive);\r\n    },\r\n    copy: function (source, recursive) {\r\n        if (recursive === undefined)\r\n            recursive = true;\r\n        this.name = source.name;\r\n        this.up.copy(source.up);\r\n        this.position.copy(source.position);\r\n        this.quaternion.copy(source.quaternion);\r\n        this.scale.copy(source.scale);\r\n        this.matrix.copy(source.matrix);\r\n        this.matrixWorld.copy(source.matrixWorld);\r\n        this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n        this.layers.mask = source.layers.mask;\r\n        this.visible = source.visible;\r\n        this.castShadow = source.castShadow;\r\n        this.receiveShadow = source.receiveShadow;\r\n        this.frustumCulled = source.frustumCulled;\r\n        this.renderOrder = source.renderOrder;\r\n        this.userData = JSON.parse(JSON.stringify(source.userData));\r\n        if (recursive === true) {\r\n            for (var i = 0; i < source.children.length; i++) {\r\n                var child = source.children[i];\r\n                this.add(child.clone());\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Scene() {\r\n    Object3D.call(this);\r\n    this.type = 'Scene';\r\n    this.background = null;\r\n    this.fog = null;\r\n    this.overrideMaterial = null;\r\n    this.autoUpdate = true; // checked by the renderer\r\n    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\r\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef\r\n    }\r\n}\r\nScene.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Scene,\r\n    isScene: true,\r\n    copy: function (source, recursive) {\r\n        Object3D.prototype.copy.call(this, source, recursive);\r\n        if (source.background !== null)\r\n            this.background = source.background.clone();\r\n        if (source.fog !== null)\r\n            this.fog = source.fog.clone();\r\n        if (source.overrideMaterial !== null)\r\n            this.overrideMaterial = source.overrideMaterial.clone();\r\n        this.autoUpdate = source.autoUpdate;\r\n        this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Object3D.prototype.toJSON.call(this, meta);\r\n        if (this.background !== null)\r\n            data.object.background = this.background.toJSON(meta);\r\n        if (this.fog !== null)\r\n            data.object.fog = this.fog.toJSON();\r\n        return data;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction Box3(min, max) {\r\n    this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);\r\n    this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);\r\n}\r\nObject.assign(Box3.prototype, {\r\n    isBox3: true,\r\n    set: function (min, max) {\r\n        this.min.copy(min);\r\n        this.max.copy(max);\r\n        return this;\r\n    },\r\n    setFromArray: function (array) {\r\n        var minX = +Infinity;\r\n        var minY = +Infinity;\r\n        var minZ = +Infinity;\r\n        var maxX = -Infinity;\r\n        var maxY = -Infinity;\r\n        var maxZ = -Infinity;\r\n        for (var i = 0, l = array.length; i < l; i += 3) {\r\n            var x = array[i];\r\n            var y = array[i + 1];\r\n            var z = array[i + 2];\r\n            if (x < minX)\r\n                minX = x;\r\n            if (y < minY)\r\n                minY = y;\r\n            if (z < minZ)\r\n                minZ = z;\r\n            if (x > maxX)\r\n                maxX = x;\r\n            if (y > maxY)\r\n                maxY = y;\r\n            if (z > maxZ)\r\n                maxZ = z;\r\n        }\r\n        this.min.set(minX, minY, minZ);\r\n        this.max.set(maxX, maxY, maxZ);\r\n        return this;\r\n    },\r\n    setFromBufferAttribute: function (attribute) {\r\n        var minX = +Infinity;\r\n        var minY = +Infinity;\r\n        var minZ = +Infinity;\r\n        var maxX = -Infinity;\r\n        var maxY = -Infinity;\r\n        var maxZ = -Infinity;\r\n        for (var i = 0, l = attribute.count; i < l; i++) {\r\n            var x = attribute.getX(i);\r\n            var y = attribute.getY(i);\r\n            var z = attribute.getZ(i);\r\n            if (x < minX)\r\n                minX = x;\r\n            if (y < minY)\r\n                minY = y;\r\n            if (z < minZ)\r\n                minZ = z;\r\n            if (x > maxX)\r\n                maxX = x;\r\n            if (y > maxY)\r\n                maxY = y;\r\n            if (z > maxZ)\r\n                maxZ = z;\r\n        }\r\n        this.min.set(minX, minY, minZ);\r\n        this.max.set(maxX, maxY, maxZ);\r\n        return this;\r\n    },\r\n    setFromPoints: function (points) {\r\n        this.makeEmpty();\r\n        for (var i = 0, il = points.length; i < il; i++) {\r\n            this.expandByPoint(points[i]);\r\n        }\r\n        return this;\r\n    },\r\n    setFromCenterAndSize: function () {\r\n        var v1 = new Vector3();\r\n        return function setFromCenterAndSize(center, size) {\r\n            var halfSize = v1.copy(size).multiplyScalar(0.5);\r\n            this.min.copy(center).sub(halfSize);\r\n            this.max.copy(center).add(halfSize);\r\n            return this;\r\n        };\r\n    }(),\r\n    setFromObject: function (object) {\r\n        this.makeEmpty();\r\n        return this.expandByObject(object);\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (box) {\r\n        this.min.copy(box.min);\r\n        this.max.copy(box.max);\r\n        return this;\r\n    },\r\n    makeEmpty: function () {\r\n        this.min.x = this.min.y = this.min.z = +Infinity;\r\n        this.max.x = this.max.y = this.max.z = -Infinity;\r\n        return this;\r\n    },\r\n    isEmpty: function () {\r\n        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);\r\n    },\r\n    getCenter: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box3: .getCenter() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\r\n    },\r\n    getSize: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box3: .getSize() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\r\n    },\r\n    expandByPoint: function (point) {\r\n        this.min.min(point);\r\n        this.max.max(point);\r\n        return this;\r\n    },\r\n    expandByVector: function (vector) {\r\n        this.min.sub(vector);\r\n        this.max.add(vector);\r\n        return this;\r\n    },\r\n    expandByScalar: function (scalar) {\r\n        this.min.addScalar(-scalar);\r\n        this.max.addScalar(scalar);\r\n        return this;\r\n    },\r\n    expandByObject: function () {\r\n        // Computes the world-axis-aligned bounding box of an object (including its children),\r\n        // accounting for both the object's, and children's, world transforms\r\n        var scope, i, l;\r\n        var v1 = new Vector3();\r\n        function traverse(node) {\r\n            var geometry = node.geometry;\r\n            if (geometry !== undefined) {\r\n                if (geometry.isGeometry) {\r\n                    var vertices = geometry.vertices;\r\n                    for (i = 0, l = vertices.length; i < l; i++) {\r\n                        v1.copy(vertices[i]);\r\n                        v1.applyMatrix4(node.matrixWorld);\r\n                        scope.expandByPoint(v1);\r\n                    }\r\n                }\r\n                else if (geometry.isBufferGeometry) {\r\n                    var attribute = geometry.attributes.position;\r\n                    if (attribute !== undefined) {\r\n                        for (i = 0, l = attribute.count; i < l; i++) {\r\n                            v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\r\n                            scope.expandByPoint(v1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return function expandByObject(object) {\r\n            scope = this;\r\n            object.updateMatrixWorld(true);\r\n            object.traverse(traverse);\r\n            return this;\r\n        };\r\n    }(),\r\n    containsPoint: function (point) {\r\n        return point.x < this.min.x || point.x > this.max.x ||\r\n            point.y < this.min.y || point.y > this.max.y ||\r\n            point.z < this.min.z || point.z > this.max.z ? false : true;\r\n    },\r\n    containsBox: function (box) {\r\n        return this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n            this.min.y <= box.min.y && box.max.y <= this.max.y &&\r\n            this.min.z <= box.min.z && box.max.z <= this.max.z;\r\n    },\r\n    getParameter: function (point, target) {\r\n        // This can potentially have a divide by zero if the box\r\n        // has a size dimension of 0.\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box3: .getParameter() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\r\n    },\r\n    intersectsBox: function (box) {\r\n        // using 6 splitting planes to rule out intersections.\r\n        return box.max.x < this.min.x || box.min.x > this.max.x ||\r\n            box.max.y < this.min.y || box.min.y > this.max.y ||\r\n            box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\r\n    },\r\n    intersectsSphere: (function () {\r\n        var closestPoint = new Vector3();\r\n        return function intersectsSphere(sphere) {\r\n            // Find the point on the AABB closest to the sphere center.\r\n            this.clampPoint(sphere.center, closestPoint);\r\n            // If that point is inside the sphere, the AABB and sphere intersect.\r\n            return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);\r\n        };\r\n    })(),\r\n    intersectsPlane: function (plane) {\r\n        // We compute the minimum and maximum dot product values. If those values\r\n        // are on the same side (back or front) of the plane, then there is no intersection.\r\n        var min, max;\r\n        if (plane.normal.x > 0) {\r\n            min = plane.normal.x * this.min.x;\r\n            max = plane.normal.x * this.max.x;\r\n        }\r\n        else {\r\n            min = plane.normal.x * this.max.x;\r\n            max = plane.normal.x * this.min.x;\r\n        }\r\n        if (plane.normal.y > 0) {\r\n            min += plane.normal.y * this.min.y;\r\n            max += plane.normal.y * this.max.y;\r\n        }\r\n        else {\r\n            min += plane.normal.y * this.max.y;\r\n            max += plane.normal.y * this.min.y;\r\n        }\r\n        if (plane.normal.z > 0) {\r\n            min += plane.normal.z * this.min.z;\r\n            max += plane.normal.z * this.max.z;\r\n        }\r\n        else {\r\n            min += plane.normal.z * this.max.z;\r\n            max += plane.normal.z * this.min.z;\r\n        }\r\n        return (min <= -plane.constant && max >= -plane.constant);\r\n    },\r\n    intersectsTriangle: (function () {\r\n        // triangle centered vertices\r\n        var v0 = new Vector3();\r\n        var v1 = new Vector3();\r\n        var v2 = new Vector3();\r\n        // triangle edge vectors\r\n        var f0 = new Vector3();\r\n        var f1 = new Vector3();\r\n        var f2 = new Vector3();\r\n        var testAxis = new Vector3();\r\n        var center = new Vector3();\r\n        var extents = new Vector3();\r\n        var triangleNormal = new Vector3();\r\n        function satForAxes(axes) {\r\n            var i, j;\r\n            for (i = 0, j = axes.length - 3; i <= j; i += 3) {\r\n                testAxis.fromArray(axes, i);\r\n                // project the aabb onto the seperating axis\r\n                var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);\r\n                // project all 3 vertices of the triangle onto the seperating axis\r\n                var p0 = v0.dot(testAxis);\r\n                var p1 = v1.dot(testAxis);\r\n                var p2 = v2.dot(testAxis);\r\n                // actual test, basically see if either of the most extreme of the triangle points intersects r\r\n                if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\r\n                    // points of the projected triangle are outside the projected half-length of the aabb\r\n                    // the axis is seperating and we can exit\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return function intersectsTriangle(triangle) {\r\n            if (this.isEmpty()) {\r\n                return false;\r\n            }\r\n            // compute box center and extents\r\n            this.getCenter(center);\r\n            extents.subVectors(this.max, center);\r\n            // translate triangle to aabb origin\r\n            v0.subVectors(triangle.a, center);\r\n            v1.subVectors(triangle.b, center);\r\n            v2.subVectors(triangle.c, center);\r\n            // compute edge vectors for triangle\r\n            f0.subVectors(v1, v0);\r\n            f1.subVectors(v2, v1);\r\n            f2.subVectors(v0, v2);\r\n            // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\r\n            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\r\n            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\r\n            var axes = [\r\n                0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,\r\n                f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,\r\n                -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0\r\n            ];\r\n            if (!satForAxes(axes)) {\r\n                return false;\r\n            }\r\n            // test 3 face normals from the aabb\r\n            axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n            if (!satForAxes(axes)) {\r\n                return false;\r\n            }\r\n            // finally testing the face normal of the triangle\r\n            // use already existing triangle edge vectors here\r\n            triangleNormal.crossVectors(f0, f1);\r\n            axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];\r\n            return satForAxes(axes);\r\n        };\r\n    })(),\r\n    clampPoint: function (point, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box3: .clampPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.copy(point).clamp(this.min, this.max);\r\n    },\r\n    distanceToPoint: function () {\r\n        var v1 = new Vector3();\r\n        return function distanceToPoint(point) {\r\n            var clampedPoint = v1.copy(point).clamp(this.min, this.max);\r\n            return clampedPoint.sub(point).length();\r\n        };\r\n    }(),\r\n    getBoundingSphere: function () {\r\n        var v1 = new Vector3();\r\n        return function getBoundingSphere(target) {\r\n            if (target === undefined) {\r\n                console.error('THREE.Box3: .getBoundingSphere() target is now required');\r\n                //target = new Sphere(); // removed to avoid cyclic dependency\r\n            }\r\n            this.getCenter(target.center);\r\n            target.radius = this.getSize(v1).length() * 0.5;\r\n            return target;\r\n        };\r\n    }(),\r\n    intersect: function (box) {\r\n        this.min.max(box.min);\r\n        this.max.min(box.max);\r\n        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n        if (this.isEmpty())\r\n            this.makeEmpty();\r\n        return this;\r\n    },\r\n    union: function (box) {\r\n        this.min.min(box.min);\r\n        this.max.max(box.max);\r\n        return this;\r\n    },\r\n    applyMatrix4: function () {\r\n        var points = [\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3(),\r\n            new Vector3()\r\n        ];\r\n        return function applyMatrix4(matrix) {\r\n            // transform of empty box is an empty box.\r\n            if (this.isEmpty())\r\n                return this;\r\n            // NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\r\n            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\r\n            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\r\n            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\r\n            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\r\n            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\r\n            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\r\n            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\r\n            this.setFromPoints(points);\r\n            return this;\r\n        };\r\n    }(),\r\n    translate: function (offset) {\r\n        this.min.add(offset);\r\n        this.max.add(offset);\r\n        return this;\r\n    },\r\n    equals: function (box) {\r\n        return box.min.equals(this.min) && box.max.equals(this.max);\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar _box;\r\nfunction Sphere(center, radius) {\r\n    this.center = (center !== undefined) ? center : new Vector3();\r\n    this.radius = (radius !== undefined) ? radius : 0;\r\n}\r\nObject.assign(Sphere.prototype, {\r\n    set: function (center, radius) {\r\n        this.center.copy(center);\r\n        this.radius = radius;\r\n        return this;\r\n    },\r\n    setFromPoints: function (points, optionalCenter) {\r\n        if (_box === undefined)\r\n            _box = new Box3();\r\n        var center = this.center;\r\n        if (optionalCenter !== undefined) {\r\n            center.copy(optionalCenter);\r\n        }\r\n        else {\r\n            _box.setFromPoints(points).getCenter(center);\r\n        }\r\n        var maxRadiusSq = 0;\r\n        for (var i = 0, il = points.length; i < il; i++) {\r\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\r\n        }\r\n        this.radius = Math.sqrt(maxRadiusSq);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (sphere) {\r\n        this.center.copy(sphere.center);\r\n        this.radius = sphere.radius;\r\n        return this;\r\n    },\r\n    empty: function () {\r\n        return (this.radius <= 0);\r\n    },\r\n    containsPoint: function (point) {\r\n        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));\r\n    },\r\n    distanceToPoint: function (point) {\r\n        return (point.distanceTo(this.center) - this.radius);\r\n    },\r\n    intersectsSphere: function (sphere) {\r\n        var radiusSum = this.radius + sphere.radius;\r\n        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);\r\n    },\r\n    intersectsBox: function (box) {\r\n        return box.intersectsSphere(this);\r\n    },\r\n    intersectsPlane: function (plane) {\r\n        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\r\n    },\r\n    clampPoint: function (point, target) {\r\n        var deltaLengthSq = this.center.distanceToSquared(point);\r\n        if (target === undefined) {\r\n            console.warn('THREE.Sphere: .clampPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        target.copy(point);\r\n        if (deltaLengthSq > (this.radius * this.radius)) {\r\n            target.sub(this.center).normalize();\r\n            target.multiplyScalar(this.radius).add(this.center);\r\n        }\r\n        return target;\r\n    },\r\n    getBoundingBox: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Sphere: .getBoundingBox() target is now required');\r\n            target = new Box3();\r\n        }\r\n        target.set(this.center, this.center);\r\n        target.expandByScalar(this.radius);\r\n        return target;\r\n    },\r\n    applyMatrix4: function (matrix) {\r\n        this.center.applyMatrix4(matrix);\r\n        this.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n        return this;\r\n    },\r\n    translate: function (offset) {\r\n        this.center.add(offset);\r\n        return this;\r\n    },\r\n    equals: function (sphere) {\r\n        return sphere.center.equals(this.center) && (sphere.radius === this.radius);\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\nfunction Ray(origin, direction) {\r\n    this.origin = (origin !== undefined) ? origin : new Vector3();\r\n    this.direction = (direction !== undefined) ? direction : new Vector3();\r\n}\r\nObject.assign(Ray.prototype, {\r\n    set: function (origin, direction) {\r\n        this.origin.copy(origin);\r\n        this.direction.copy(direction);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (ray) {\r\n        this.origin.copy(ray.origin);\r\n        this.direction.copy(ray.direction);\r\n        return this;\r\n    },\r\n    at: function (t, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Ray: .at() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.copy(this.direction).multiplyScalar(t).add(this.origin);\r\n    },\r\n    lookAt: function (v) {\r\n        this.direction.copy(v).sub(this.origin).normalize();\r\n        return this;\r\n    },\r\n    recast: function () {\r\n        var v1 = new Vector3();\r\n        return function recast(t) {\r\n            this.origin.copy(this.at(t, v1));\r\n            return this;\r\n        };\r\n    }(),\r\n    closestPointToPoint: function (point, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Ray: .closestPointToPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        target.subVectors(point, this.origin);\r\n        var directionDistance = target.dot(this.direction);\r\n        if (directionDistance < 0) {\r\n            return target.copy(this.origin);\r\n        }\r\n        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\r\n    },\r\n    distanceToPoint: function (point) {\r\n        return Math.sqrt(this.distanceSqToPoint(point));\r\n    },\r\n    distanceSqToPoint: function () {\r\n        var v1 = new Vector3();\r\n        return function distanceSqToPoint(point) {\r\n            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);\r\n            // point behind the ray\r\n            if (directionDistance < 0) {\r\n                return this.origin.distanceToSquared(point);\r\n            }\r\n            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\r\n            return v1.distanceToSquared(point);\r\n        };\r\n    }(),\r\n    distanceSqToSegment: function () {\r\n        var segCenter = new Vector3();\r\n        var segDir = new Vector3();\r\n        var diff = new Vector3();\r\n        return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\r\n            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n            // It returns the min distance between the ray and the segment\r\n            // defined by v0 and v1\r\n            // It can also set two optional targets :\r\n            // - The closest point on the ray\r\n            // - The closest point on the segment\r\n            segCenter.copy(v0).add(v1).multiplyScalar(0.5);\r\n            segDir.copy(v1).sub(v0).normalize();\r\n            diff.copy(this.origin).sub(segCenter);\r\n            var segExtent = v0.distanceTo(v1) * 0.5;\r\n            var a01 = -this.direction.dot(segDir);\r\n            var b0 = diff.dot(this.direction);\r\n            var b1 = -diff.dot(segDir);\r\n            var c = diff.lengthSq();\r\n            var det = Math.abs(1 - a01 * a01);\r\n            var s0, s1, sqrDist, extDet;\r\n            if (det > 0) {\r\n                // The ray and segment are not parallel.\r\n                s0 = a01 * b1 - b0;\r\n                s1 = a01 * b0 - b1;\r\n                extDet = segExtent * det;\r\n                if (s0 >= 0) {\r\n                    if (s1 >= -extDet) {\r\n                        if (s1 <= extDet) {\r\n                            // region 0\r\n                            // Minimum at interior points of ray and segment.\r\n                            var invDet = 1 / det;\r\n                            s0 *= invDet;\r\n                            s1 *= invDet;\r\n                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\r\n                        }\r\n                        else {\r\n                            // region 1\r\n                            s1 = segExtent;\r\n                            s0 = Math.max(0, -(a01 * s1 + b0));\r\n                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // region 5\r\n                        s1 = -segExtent;\r\n                        s0 = Math.max(0, -(a01 * s1 + b0));\r\n                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\r\n                    }\r\n                }\r\n                else {\r\n                    if (s1 <= -extDet) {\r\n                        // region 4\r\n                        s0 = Math.max(0, -(-a01 * segExtent + b0));\r\n                        s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\r\n                    }\r\n                    else if (s1 <= extDet) {\r\n                        // region 3\r\n                        s0 = 0;\r\n                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\r\n                        sqrDist = s1 * (s1 + 2 * b1) + c;\r\n                    }\r\n                    else {\r\n                        // region 2\r\n                        s0 = Math.max(0, -(a01 * segExtent + b0));\r\n                        s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\r\n                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Ray and segment are parallel.\r\n                s1 = (a01 > 0) ? -segExtent : segExtent;\r\n                s0 = Math.max(0, -(a01 * s1 + b0));\r\n                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\r\n            }\r\n            if (optionalPointOnRay) {\r\n                optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\r\n            }\r\n            if (optionalPointOnSegment) {\r\n                optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\r\n            }\r\n            return sqrDist;\r\n        };\r\n    }(),\r\n    intersectSphere: function () {\r\n        var v1 = new Vector3();\r\n        return function intersectSphere(sphere, target) {\r\n            v1.subVectors(sphere.center, this.origin);\r\n            var tca = v1.dot(this.direction);\r\n            var d2 = v1.dot(v1) - tca * tca;\r\n            var radius2 = sphere.radius * sphere.radius;\r\n            if (d2 > radius2)\r\n                return null;\r\n            var thc = Math.sqrt(radius2 - d2);\r\n            // t0 = first intersect point - entrance on front of sphere\r\n            var t0 = tca - thc;\r\n            // t1 = second intersect point - exit point on back of sphere\r\n            var t1 = tca + thc;\r\n            // test to see if both t0 and t1 are behind the ray - if so, return null\r\n            if (t0 < 0 && t1 < 0)\r\n                return null;\r\n            // test to see if t0 is behind the ray:\r\n            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n            // in order to always return an intersect point that is in front of the ray.\r\n            if (t0 < 0)\r\n                return this.at(t1, target);\r\n            // else t0 is in front of the ray, so return the first collision point scaled by t0\r\n            return this.at(t0, target);\r\n        };\r\n    }(),\r\n    intersectsSphere: function (sphere) {\r\n        return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);\r\n    },\r\n    distanceToPlane: function (plane) {\r\n        var denominator = plane.normal.dot(this.direction);\r\n        if (denominator === 0) {\r\n            // line is coplanar, return origin\r\n            if (plane.distanceToPoint(this.origin) === 0) {\r\n                return 0;\r\n            }\r\n            // Null is preferable to undefined since undefined means.... it is undefined\r\n            return null;\r\n        }\r\n        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\r\n        // Return if the ray never intersects the plane\r\n        return t >= 0 ? t : null;\r\n    },\r\n    intersectPlane: function (plane, target) {\r\n        var t = this.distanceToPlane(plane);\r\n        if (t === null) {\r\n            return null;\r\n        }\r\n        return this.at(t, target);\r\n    },\r\n    intersectsPlane: function (plane) {\r\n        // check if the ray lies on the plane first\r\n        var distToPoint = plane.distanceToPoint(this.origin);\r\n        if (distToPoint === 0) {\r\n            return true;\r\n        }\r\n        var denominator = plane.normal.dot(this.direction);\r\n        if (denominator * distToPoint < 0) {\r\n            return true;\r\n        }\r\n        // ray origin is behind the plane (and is pointing behind it)\r\n        return false;\r\n    },\r\n    intersectBox: function (box, target) {\r\n        var tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\r\n        var origin = this.origin;\r\n        if (invdirx >= 0) {\r\n            tmin = (box.min.x - origin.x) * invdirx;\r\n            tmax = (box.max.x - origin.x) * invdirx;\r\n        }\r\n        else {\r\n            tmin = (box.max.x - origin.x) * invdirx;\r\n            tmax = (box.min.x - origin.x) * invdirx;\r\n        }\r\n        if (invdiry >= 0) {\r\n            tymin = (box.min.y - origin.y) * invdiry;\r\n            tymax = (box.max.y - origin.y) * invdiry;\r\n        }\r\n        else {\r\n            tymin = (box.max.y - origin.y) * invdiry;\r\n            tymax = (box.min.y - origin.y) * invdiry;\r\n        }\r\n        if ((tmin > tymax) || (tymin > tmax))\r\n            return null;\r\n        // These lines also handle the case where tmin or tmax is NaN\r\n        // (result of 0 * Infinity). x !== x returns true if x is NaN\r\n        if (tymin > tmin || tmin !== tmin)\r\n            tmin = tymin;\r\n        if (tymax < tmax || tmax !== tmax)\r\n            tmax = tymax;\r\n        if (invdirz >= 0) {\r\n            tzmin = (box.min.z - origin.z) * invdirz;\r\n            tzmax = (box.max.z - origin.z) * invdirz;\r\n        }\r\n        else {\r\n            tzmin = (box.max.z - origin.z) * invdirz;\r\n            tzmax = (box.min.z - origin.z) * invdirz;\r\n        }\r\n        if ((tmin > tzmax) || (tzmin > tmax))\r\n            return null;\r\n        if (tzmin > tmin || tmin !== tmin)\r\n            tmin = tzmin;\r\n        if (tzmax < tmax || tmax !== tmax)\r\n            tmax = tzmax;\r\n        //return point closest to the ray (positive side)\r\n        if (tmax < 0)\r\n            return null;\r\n        return this.at(tmin >= 0 ? tmin : tmax, target);\r\n    },\r\n    intersectsBox: (function () {\r\n        var v = new Vector3();\r\n        return function intersectsBox(box) {\r\n            return this.intersectBox(box, v) !== null;\r\n        };\r\n    })(),\r\n    intersectTriangle: function () {\r\n        // Compute the offset origin, edges, and normal.\r\n        var diff = new Vector3();\r\n        var edge1 = new Vector3();\r\n        var edge2 = new Vector3();\r\n        var normal = new Vector3();\r\n        return function intersectTriangle(a, b, c, backfaceCulling, target) {\r\n            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n            edge1.subVectors(b, a);\r\n            edge2.subVectors(c, a);\r\n            normal.crossVectors(edge1, edge2);\r\n            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n            var DdN = this.direction.dot(normal);\r\n            var sign;\r\n            if (DdN > 0) {\r\n                if (backfaceCulling)\r\n                    return null;\r\n                sign = 1;\r\n            }\r\n            else if (DdN < 0) {\r\n                sign = -1;\r\n                DdN = -DdN;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n            diff.subVectors(this.origin, a);\r\n            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));\r\n            // b1 < 0, no intersection\r\n            if (DdQxE2 < 0) {\r\n                return null;\r\n            }\r\n            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));\r\n            // b2 < 0, no intersection\r\n            if (DdE1xQ < 0) {\r\n                return null;\r\n            }\r\n            // b1+b2 > 1, no intersection\r\n            if (DdQxE2 + DdE1xQ > DdN) {\r\n                return null;\r\n            }\r\n            // Line intersects triangle, check if ray does.\r\n            var QdN = -sign * diff.dot(normal);\r\n            // t < 0, no intersection\r\n            if (QdN < 0) {\r\n                return null;\r\n            }\r\n            // Ray intersects triangle.\r\n            return this.at(QdN / DdN, target);\r\n        };\r\n    }(),\r\n    applyMatrix4: function (matrix4) {\r\n        this.origin.applyMatrix4(matrix4);\r\n        this.direction.transformDirection(matrix4);\r\n        return this;\r\n    },\r\n    equals: function (ray) {\r\n        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Triangle(a, b, c) {\r\n    this.a = (a !== undefined) ? a : new Vector3();\r\n    this.b = (b !== undefined) ? b : new Vector3();\r\n    this.c = (c !== undefined) ? c : new Vector3();\r\n}\r\nObject.assign(Triangle, {\r\n    getNormal: function () {\r\n        var v0 = new Vector3();\r\n        return function getNormal(a, b, c, target) {\r\n            if (target === undefined) {\r\n                console.warn('THREE.Triangle: .getNormal() target is now required');\r\n                target = new Vector3();\r\n            }\r\n            target.subVectors(c, b);\r\n            v0.subVectors(a, b);\r\n            target.cross(v0);\r\n            var targetLengthSq = target.lengthSq();\r\n            if (targetLengthSq > 0) {\r\n                return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\r\n            }\r\n            return target.set(0, 0, 0);\r\n        };\r\n    }(),\r\n    // static/instance method to calculate barycentric coordinates\r\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n    getBarycoord: function () {\r\n        var v0 = new Vector3();\r\n        var v1 = new Vector3();\r\n        var v2 = new Vector3();\r\n        return function getBarycoord(point, a, b, c, target) {\r\n            v0.subVectors(c, a);\r\n            v1.subVectors(b, a);\r\n            v2.subVectors(point, a);\r\n            var dot00 = v0.dot(v0);\r\n            var dot01 = v0.dot(v1);\r\n            var dot02 = v0.dot(v2);\r\n            var dot11 = v1.dot(v1);\r\n            var dot12 = v1.dot(v2);\r\n            var denom = (dot00 * dot11 - dot01 * dot01);\r\n            if (target === undefined) {\r\n                console.warn('THREE.Triangle: .getBarycoord() target is now required');\r\n                target = new Vector3();\r\n            }\r\n            // collinear or singular triangle\r\n            if (denom === 0) {\r\n                // arbitrary location outside of triangle?\r\n                // not sure if this is the best idea, maybe should be returning undefined\r\n                return target.set(-2, -1, -1);\r\n            }\r\n            var invDenom = 1 / denom;\r\n            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\r\n            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\r\n            // barycentric coordinates must always sum to 1\r\n            return target.set(1 - u - v, v, u);\r\n        };\r\n    }(),\r\n    containsPoint: function () {\r\n        var v1 = new Vector3();\r\n        return function containsPoint(point, a, b, c) {\r\n            Triangle.getBarycoord(point, a, b, c, v1);\r\n            return (v1.x >= 0) && (v1.y >= 0) && ((v1.x + v1.y) <= 1);\r\n        };\r\n    }(),\r\n    getUV: function () {\r\n        var barycoord = new Vector3();\r\n        return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\r\n            this.getBarycoord(point, p1, p2, p3, barycoord);\r\n            target.set(0, 0);\r\n            target.addScaledVector(uv1, barycoord.x);\r\n            target.addScaledVector(uv2, barycoord.y);\r\n            target.addScaledVector(uv3, barycoord.z);\r\n            return target;\r\n        };\r\n    }(),\r\n    isFrontFacing: function () {\r\n        var v0 = new Vector3();\r\n        var v1 = new Vector3();\r\n        return function isFrontFacing(a, b, c, direction) {\r\n            v0.subVectors(c, b);\r\n            v1.subVectors(a, b);\r\n            // strictly front facing\r\n            return (v0.cross(v1).dot(direction) < 0) ? true : false;\r\n        };\r\n    }()\r\n});\r\nObject.assign(Triangle.prototype, {\r\n    set: function (a, b, c) {\r\n        this.a.copy(a);\r\n        this.b.copy(b);\r\n        this.c.copy(c);\r\n        return this;\r\n    },\r\n    setFromPointsAndIndices: function (points, i0, i1, i2) {\r\n        this.a.copy(points[i0]);\r\n        this.b.copy(points[i1]);\r\n        this.c.copy(points[i2]);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (triangle) {\r\n        this.a.copy(triangle.a);\r\n        this.b.copy(triangle.b);\r\n        this.c.copy(triangle.c);\r\n        return this;\r\n    },\r\n    getArea: function () {\r\n        var v0 = new Vector3();\r\n        var v1 = new Vector3();\r\n        return function getArea() {\r\n            v0.subVectors(this.c, this.b);\r\n            v1.subVectors(this.a, this.b);\r\n            return v0.cross(v1).length() * 0.5;\r\n        };\r\n    }(),\r\n    getMidpoint: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Triangle: .getMidpoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\r\n    },\r\n    getNormal: function (target) {\r\n        return Triangle.getNormal(this.a, this.b, this.c, target);\r\n    },\r\n    getPlane: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Triangle: .getPlane() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.setFromCoplanarPoints(this.a, this.b, this.c);\r\n    },\r\n    getBarycoord: function (point, target) {\r\n        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\r\n    },\r\n    getUV: function (point, uv1, uv2, uv3, target) {\r\n        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\r\n    },\r\n    containsPoint: function (point) {\r\n        return Triangle.containsPoint(point, this.a, this.b, this.c);\r\n    },\r\n    isFrontFacing: function (direction) {\r\n        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\r\n    },\r\n    intersectsBox: function (box) {\r\n        return box.intersectsTriangle(this);\r\n    },\r\n    closestPointToPoint: function () {\r\n        var vab = new Vector3();\r\n        var vac = new Vector3();\r\n        var vbc = new Vector3();\r\n        var vap = new Vector3();\r\n        var vbp = new Vector3();\r\n        var vcp = new Vector3();\r\n        return function closestPointToPoint(p, target) {\r\n            if (target === undefined) {\r\n                console.warn('THREE.Triangle: .closestPointToPoint() target is now required');\r\n                target = new Vector3();\r\n            }\r\n            var a = this.a, b = this.b, c = this.c;\r\n            var v, w;\r\n            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\r\n            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\r\n            // under the accompanying license; see chapter 5.1.5 for detailed explanation.\r\n            // basically, we're distinguishing which of the voronoi regions of the triangle\r\n            // the point lies in with the minimum amount of redundant computation.\r\n            vab.subVectors(b, a);\r\n            vac.subVectors(c, a);\r\n            vap.subVectors(p, a);\r\n            var d1 = vab.dot(vap);\r\n            var d2 = vac.dot(vap);\r\n            if (d1 <= 0 && d2 <= 0) {\r\n                // vertex region of A; barycentric coords (1, 0, 0)\r\n                return target.copy(a);\r\n            }\r\n            vbp.subVectors(p, b);\r\n            var d3 = vab.dot(vbp);\r\n            var d4 = vac.dot(vbp);\r\n            if (d3 >= 0 && d4 <= d3) {\r\n                // vertex region of B; barycentric coords (0, 1, 0)\r\n                return target.copy(b);\r\n            }\r\n            var vc = d1 * d4 - d3 * d2;\r\n            if (vc <= 0 && d1 >= 0 && d3 <= 0) {\r\n                v = d1 / (d1 - d3);\r\n                // edge region of AB; barycentric coords (1-v, v, 0)\r\n                return target.copy(a).addScaledVector(vab, v);\r\n            }\r\n            vcp.subVectors(p, c);\r\n            var d5 = vab.dot(vcp);\r\n            var d6 = vac.dot(vcp);\r\n            if (d6 >= 0 && d5 <= d6) {\r\n                // vertex region of C; barycentric coords (0, 0, 1)\r\n                return target.copy(c);\r\n            }\r\n            var vb = d5 * d2 - d1 * d6;\r\n            if (vb <= 0 && d2 >= 0 && d6 <= 0) {\r\n                w = d2 / (d2 - d6);\r\n                // edge region of AC; barycentric coords (1-w, 0, w)\r\n                return target.copy(a).addScaledVector(vac, w);\r\n            }\r\n            var va = d3 * d6 - d5 * d4;\r\n            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {\r\n                vbc.subVectors(c, b);\r\n                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));\r\n                // edge region of BC; barycentric coords (0, 1-w, w)\r\n                return target.copy(b).addScaledVector(vbc, w); // edge region of BC\r\n            }\r\n            // face region\r\n            var denom = 1 / (va + vb + vc);\r\n            // u = va * denom\r\n            v = vb * denom;\r\n            w = vc * denom;\r\n            return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);\r\n        };\r\n    }(),\r\n    equals: function (triangle) {\r\n        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\nfunction Color(r, g, b) {\r\n    if (g === undefined && b === undefined) {\r\n        // r is THREE.Color, hex or string\r\n        return this.set(r);\r\n    }\r\n    return this.setRGB(r, g, b);\r\n}\r\nfunction hue2rgb(p, q, t) {\r\n    if (t < 0)\r\n        t += 1;\r\n    if (t > 1)\r\n        t -= 1;\r\n    if (t < 1 / 6)\r\n        return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2)\r\n        return q;\r\n    if (t < 2 / 3)\r\n        return p + (q - p) * 6 * (2 / 3 - t);\r\n    return p;\r\n}\r\nfunction SRGBToLinear(c) {\r\n    return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\r\n}\r\nfunction LinearToSRGB(c) {\r\n    return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;\r\n}\r\nObject.assign(Color.prototype, {\r\n    isColor: true,\r\n    r: 1, g: 1, b: 1,\r\n    set: function (value) {\r\n        if (value && value.isColor) {\r\n            this.copy(value);\r\n        }\r\n        else if (typeof value === 'number') {\r\n            this.setHex(value);\r\n        }\r\n        else if (typeof value === 'string') {\r\n            this.setStyle(value);\r\n        }\r\n        return this;\r\n    },\r\n    setScalar: function (scalar) {\r\n        this.r = scalar;\r\n        this.g = scalar;\r\n        this.b = scalar;\r\n        return this;\r\n    },\r\n    setHex: function (hex) {\r\n        hex = Math.floor(hex);\r\n        this.r = (hex >> 16 & 255) / 255;\r\n        this.g = (hex >> 8 & 255) / 255;\r\n        this.b = (hex & 255) / 255;\r\n        return this;\r\n    },\r\n    setRGB: function (r, g, b) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        return this;\r\n    },\r\n    setHSL: function (h, s, l) {\r\n        // h,s,l ranges are in 0.0 - 1.0\r\n        h = _Math.euclideanModulo(h, 1);\r\n        s = _Math.clamp(s, 0, 1);\r\n        l = _Math.clamp(l, 0, 1);\r\n        if (s === 0) {\r\n            this.r = this.g = this.b = l;\r\n        }\r\n        else {\r\n            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);\r\n            var q = (2 * l) - p;\r\n            this.r = hue2rgb(q, p, h + 1 / 3);\r\n            this.g = hue2rgb(q, p, h);\r\n            this.b = hue2rgb(q, p, h - 1 / 3);\r\n        }\r\n        return this;\r\n    },\r\n    setStyle: function (style) {\r\n        function handleAlpha(string) {\r\n            if (string === undefined)\r\n                return;\r\n            if (parseFloat(string) < 1) {\r\n                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\r\n            }\r\n        }\r\n        var m;\r\n        if (m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(style)) {\r\n            // rgb / hsl\r\n            var color;\r\n            var name = m[1];\r\n            var components = m[2];\r\n            switch (name) {\r\n                case 'rgb':\r\n                case 'rgba':\r\n                    if (color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\r\n                        // rgb(255,0,0) rgba(255,0,0,0.5)\r\n                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;\r\n                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;\r\n                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;\r\n                        handleAlpha(color[5]);\r\n                        return this;\r\n                    }\r\n                    if (color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\r\n                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;\r\n                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;\r\n                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;\r\n                        handleAlpha(color[5]);\r\n                        return this;\r\n                    }\r\n                    break;\r\n                case 'hsl':\r\n                case 'hsla':\r\n                    if (color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\r\n                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n                        var h = parseFloat(color[1]) / 360;\r\n                        var s = parseInt(color[2], 10) / 100;\r\n                        var l = parseInt(color[3], 10) / 100;\r\n                        handleAlpha(color[5]);\r\n                        return this.setHSL(h, s, l);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        else if (m = /^\\#([A-Fa-f0-9]+)$/.exec(style)) {\r\n            // hex color\r\n            var hex = m[1];\r\n            var size = hex.length;\r\n            if (size === 3) {\r\n                // #ff0\r\n                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\r\n                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\r\n                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\r\n                return this;\r\n            }\r\n            else if (size === 6) {\r\n                // #ff0000\r\n                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\r\n                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\r\n                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\r\n                return this;\r\n            }\r\n        }\r\n        if (style && style.length > 0) {\r\n            // color keywords\r\n            var hex = ColorKeywords[style];\r\n            if (hex !== undefined) {\r\n                // red\r\n                this.setHex(hex);\r\n            }\r\n            else {\r\n                // unknown color\r\n                console.warn('THREE.Color: Unknown color ' + style);\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.r, this.g, this.b);\r\n    },\r\n    copy: function (color) {\r\n        this.r = color.r;\r\n        this.g = color.g;\r\n        this.b = color.b;\r\n        return this;\r\n    },\r\n    copyGammaToLinear: function (color, gammaFactor) {\r\n        if (gammaFactor === undefined)\r\n            gammaFactor = 2.0;\r\n        this.r = Math.pow(color.r, gammaFactor);\r\n        this.g = Math.pow(color.g, gammaFactor);\r\n        this.b = Math.pow(color.b, gammaFactor);\r\n        return this;\r\n    },\r\n    copyLinearToGamma: function (color, gammaFactor) {\r\n        if (gammaFactor === undefined)\r\n            gammaFactor = 2.0;\r\n        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;\r\n        this.r = Math.pow(color.r, safeInverse);\r\n        this.g = Math.pow(color.g, safeInverse);\r\n        this.b = Math.pow(color.b, safeInverse);\r\n        return this;\r\n    },\r\n    convertGammaToLinear: function (gammaFactor) {\r\n        this.copyGammaToLinear(this, gammaFactor);\r\n        return this;\r\n    },\r\n    convertLinearToGamma: function (gammaFactor) {\r\n        this.copyLinearToGamma(this, gammaFactor);\r\n        return this;\r\n    },\r\n    copySRGBToLinear: function (color) {\r\n        this.r = SRGBToLinear(color.r);\r\n        this.g = SRGBToLinear(color.g);\r\n        this.b = SRGBToLinear(color.b);\r\n        return this;\r\n    },\r\n    copyLinearToSRGB: function (color) {\r\n        this.r = LinearToSRGB(color.r);\r\n        this.g = LinearToSRGB(color.g);\r\n        this.b = LinearToSRGB(color.b);\r\n        return this;\r\n    },\r\n    convertSRGBToLinear: function () {\r\n        this.copySRGBToLinear(this);\r\n        return this;\r\n    },\r\n    convertLinearToSRGB: function () {\r\n        this.copyLinearToSRGB(this);\r\n        return this;\r\n    },\r\n    getHex: function () {\r\n        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;\r\n    },\r\n    getHexString: function () {\r\n        return ('000000' + this.getHex().toString(16)).slice(-6);\r\n    },\r\n    getHSL: function (target) {\r\n        // h,s,l ranges are in 0.0 - 1.0\r\n        if (target === undefined) {\r\n            console.warn('THREE.Color: .getHSL() target is now required');\r\n            target = { h: 0, s: 0, l: 0 };\r\n        }\r\n        var r = this.r, g = this.g, b = this.b;\r\n        var max = Math.max(r, g, b);\r\n        var min = Math.min(r, g, b);\r\n        var hue, saturation;\r\n        var lightness = (min + max) / 2.0;\r\n        if (min === max) {\r\n            hue = 0;\r\n            saturation = 0;\r\n        }\r\n        else {\r\n            var delta = max - min;\r\n            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\r\n            switch (max) {\r\n                case r:\r\n                    hue = (g - b) / delta + (g < b ? 6 : 0);\r\n                    break;\r\n                case g:\r\n                    hue = (b - r) / delta + 2;\r\n                    break;\r\n                case b:\r\n                    hue = (r - g) / delta + 4;\r\n                    break;\r\n            }\r\n            hue /= 6;\r\n        }\r\n        target.h = hue;\r\n        target.s = saturation;\r\n        target.l = lightness;\r\n        return target;\r\n    },\r\n    getStyle: function () {\r\n        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';\r\n    },\r\n    offsetHSL: function () {\r\n        var hsl = {};\r\n        return function (h, s, l) {\r\n            this.getHSL(hsl);\r\n            hsl.h += h;\r\n            hsl.s += s;\r\n            hsl.l += l;\r\n            this.setHSL(hsl.h, hsl.s, hsl.l);\r\n            return this;\r\n        };\r\n    }(),\r\n    add: function (color) {\r\n        this.r += color.r;\r\n        this.g += color.g;\r\n        this.b += color.b;\r\n        return this;\r\n    },\r\n    addColors: function (color1, color2) {\r\n        this.r = color1.r + color2.r;\r\n        this.g = color1.g + color2.g;\r\n        this.b = color1.b + color2.b;\r\n        return this;\r\n    },\r\n    addScalar: function (s) {\r\n        this.r += s;\r\n        this.g += s;\r\n        this.b += s;\r\n        return this;\r\n    },\r\n    sub: function (color) {\r\n        this.r = Math.max(0, this.r - color.r);\r\n        this.g = Math.max(0, this.g - color.g);\r\n        this.b = Math.max(0, this.b - color.b);\r\n        return this;\r\n    },\r\n    multiply: function (color) {\r\n        this.r *= color.r;\r\n        this.g *= color.g;\r\n        this.b *= color.b;\r\n        return this;\r\n    },\r\n    multiplyScalar: function (s) {\r\n        this.r *= s;\r\n        this.g *= s;\r\n        this.b *= s;\r\n        return this;\r\n    },\r\n    lerp: function (color, alpha) {\r\n        this.r += (color.r - this.r) * alpha;\r\n        this.g += (color.g - this.g) * alpha;\r\n        this.b += (color.b - this.b) * alpha;\r\n        return this;\r\n    },\r\n    lerpHSL: function () {\r\n        var hslA = { h: 0, s: 0, l: 0 };\r\n        var hslB = { h: 0, s: 0, l: 0 };\r\n        return function lerpHSL(color, alpha) {\r\n            this.getHSL(hslA);\r\n            color.getHSL(hslB);\r\n            var h = _Math.lerp(hslA.h, hslB.h, alpha);\r\n            var s = _Math.lerp(hslA.s, hslB.s, alpha);\r\n            var l = _Math.lerp(hslA.l, hslB.l, alpha);\r\n            this.setHSL(h, s, l);\r\n            return this;\r\n        };\r\n    }(),\r\n    equals: function (c) {\r\n        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);\r\n    },\r\n    fromArray: function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.r = array[offset];\r\n        this.g = array[offset + 1];\r\n        this.b = array[offset + 2];\r\n        return this;\r\n    },\r\n    toArray: function (array, offset) {\r\n        if (array === undefined)\r\n            array = [];\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        array[offset] = this.r;\r\n        array[offset + 1] = this.g;\r\n        array[offset + 2] = this.b;\r\n        return array;\r\n    },\r\n    toJSON: function () {\r\n        return this.getHex();\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Face3(a, b, c, normal, color, materialIndex) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.normal = (normal && normal.isVector3) ? normal : new Vector3();\r\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\r\n    this.color = (color && color.isColor) ? color : new Color();\r\n    this.vertexColors = Array.isArray(color) ? color : [];\r\n    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n}\r\nObject.assign(Face3.prototype, {\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        this.a = source.a;\r\n        this.b = source.b;\r\n        this.c = source.c;\r\n        this.normal.copy(source.normal);\r\n        this.color.copy(source.color);\r\n        this.materialIndex = source.materialIndex;\r\n        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\r\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\r\n        }\r\n        for (var i = 0, il = source.vertexColors.length; i < il; i++) {\r\n            this.vertexColors[i] = source.vertexColors[i].clone();\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nvar materialId = 0;\r\nfunction Material$1() {\r\n    Object.defineProperty(this, 'id', { value: materialId++ });\r\n    this.uuid = _Math.generateUUID();\r\n    this.name = '';\r\n    this.type = 'Material';\r\n    this.fog = true;\r\n    this.lights = true;\r\n    this.blending = NormalBlending;\r\n    this.side = FrontSide;\r\n    this.flatShading = false;\r\n    this.vertexTangents = false;\r\n    this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\r\n    this.opacity = 1;\r\n    this.transparent = false;\r\n    this.blendSrc = SrcAlphaFactor;\r\n    this.blendDst = OneMinusSrcAlphaFactor;\r\n    this.blendEquation = AddEquation;\r\n    this.blendSrcAlpha = null;\r\n    this.blendDstAlpha = null;\r\n    this.blendEquationAlpha = null;\r\n    this.depthFunc = LessEqualDepth;\r\n    this.depthTest = true;\r\n    this.depthWrite = true;\r\n    this.stencilFunc = AlwaysStencilFunc;\r\n    this.stencilRef = 0;\r\n    this.stencilMask = 0xff;\r\n    this.stencilFail = KeepStencilOp;\r\n    this.stencilZFail = KeepStencilOp;\r\n    this.stencilZPass = KeepStencilOp;\r\n    this.stencilWrite = false;\r\n    this.clippingPlanes = null;\r\n    this.clipIntersection = false;\r\n    this.clipShadows = false;\r\n    this.shadowSide = null;\r\n    this.colorWrite = true;\r\n    this.precision = null; // override the renderer's default precision for this material\r\n    this.polygonOffset = false;\r\n    this.polygonOffsetFactor = 0;\r\n    this.polygonOffsetUnits = 0;\r\n    this.dithering = false;\r\n    this.alphaTest = 0;\r\n    this.premultipliedAlpha = false;\r\n    this.visible = true;\r\n    this.userData = {};\r\n    this.needsUpdate = true;\r\n}\r\nMaterial$1.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: Material$1,\r\n    isMaterial: true,\r\n    onBeforeCompile: function () { },\r\n    setValues: function (values) {\r\n        if (values === undefined)\r\n            return;\r\n        for (var key in values) {\r\n            var newValue = values[key];\r\n            if (newValue === undefined) {\r\n                console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\r\n                continue;\r\n            }\r\n            // for backward compatability if shading is set in the constructor\r\n            if (key === 'shading') {\r\n                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\r\n                this.flatShading = (newValue === FlatShading) ? true : false;\r\n                continue;\r\n            }\r\n            var currentValue = this[key];\r\n            if (currentValue === undefined) {\r\n                console.warn(\"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\");\r\n                continue;\r\n            }\r\n            if (currentValue && currentValue.isColor) {\r\n                currentValue.set(newValue);\r\n            }\r\n            else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {\r\n                currentValue.copy(newValue);\r\n            }\r\n            else {\r\n                this[key] = newValue;\r\n            }\r\n        }\r\n    },\r\n    toJSON: function (meta) {\r\n        var isRoot = (meta === undefined || typeof meta === 'string');\r\n        if (isRoot) {\r\n            meta = {\r\n                textures: {},\r\n                images: {}\r\n            };\r\n        }\r\n        var data = {\r\n            metadata: {\r\n                version: 4.5,\r\n                type: 'Material',\r\n                generator: 'Material.toJSON'\r\n            }\r\n        };\r\n        // standard Material serialization\r\n        data.uuid = this.uuid;\r\n        data.type = this.type;\r\n        if (this.name !== '')\r\n            data.name = this.name;\r\n        if (this.color && this.color.isColor)\r\n            data.color = this.color.getHex();\r\n        if (this.roughness !== undefined)\r\n            data.roughness = this.roughness;\r\n        if (this.metalness !== undefined)\r\n            data.metalness = this.metalness;\r\n        if (this.emissive && this.emissive.isColor)\r\n            data.emissive = this.emissive.getHex();\r\n        if (this.emissiveIntensity && this.emissiveIntensity !== 1)\r\n            data.emissiveIntensity = this.emissiveIntensity;\r\n        if (this.specular && this.specular.isColor)\r\n            data.specular = this.specular.getHex();\r\n        if (this.shininess !== undefined)\r\n            data.shininess = this.shininess;\r\n        if (this.clearCoat !== undefined)\r\n            data.clearCoat = this.clearCoat;\r\n        if (this.clearCoatRoughness !== undefined)\r\n            data.clearCoatRoughness = this.clearCoatRoughness;\r\n        if (this.map && this.map.isTexture)\r\n            data.map = this.map.toJSON(meta).uuid;\r\n        if (this.matcap && this.matcap.isTexture)\r\n            data.matcap = this.matcap.toJSON(meta).uuid;\r\n        if (this.alphaMap && this.alphaMap.isTexture)\r\n            data.alphaMap = this.alphaMap.toJSON(meta).uuid;\r\n        if (this.lightMap && this.lightMap.isTexture)\r\n            data.lightMap = this.lightMap.toJSON(meta).uuid;\r\n        if (this.aoMap && this.aoMap.isTexture) {\r\n            data.aoMap = this.aoMap.toJSON(meta).uuid;\r\n            data.aoMapIntensity = this.aoMapIntensity;\r\n        }\r\n        if (this.bumpMap && this.bumpMap.isTexture) {\r\n            data.bumpMap = this.bumpMap.toJSON(meta).uuid;\r\n            data.bumpScale = this.bumpScale;\r\n        }\r\n        if (this.normalMap && this.normalMap.isTexture) {\r\n            data.normalMap = this.normalMap.toJSON(meta).uuid;\r\n            data.normalMapType = this.normalMapType;\r\n            data.normalScale = this.normalScale.toArray();\r\n        }\r\n        if (this.displacementMap && this.displacementMap.isTexture) {\r\n            data.displacementMap = this.displacementMap.toJSON(meta).uuid;\r\n            data.displacementScale = this.displacementScale;\r\n            data.displacementBias = this.displacementBias;\r\n        }\r\n        if (this.roughnessMap && this.roughnessMap.isTexture)\r\n            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\r\n        if (this.metalnessMap && this.metalnessMap.isTexture)\r\n            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\r\n        if (this.emissiveMap && this.emissiveMap.isTexture)\r\n            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\r\n        if (this.specularMap && this.specularMap.isTexture)\r\n            data.specularMap = this.specularMap.toJSON(meta).uuid;\r\n        if (this.envMap && this.envMap.isTexture) {\r\n            data.envMap = this.envMap.toJSON(meta).uuid;\r\n            data.reflectivity = this.reflectivity; // Scale behind envMap\r\n            data.refractionRatio = this.refractionRatio;\r\n            if (this.combine !== undefined)\r\n                data.combine = this.combine;\r\n            if (this.envMapIntensity !== undefined)\r\n                data.envMapIntensity = this.envMapIntensity;\r\n        }\r\n        if (this.gradientMap && this.gradientMap.isTexture) {\r\n            data.gradientMap = this.gradientMap.toJSON(meta).uuid;\r\n        }\r\n        if (this.size !== undefined)\r\n            data.size = this.size;\r\n        if (this.sizeAttenuation !== undefined)\r\n            data.sizeAttenuation = this.sizeAttenuation;\r\n        if (this.blending !== NormalBlending)\r\n            data.blending = this.blending;\r\n        if (this.flatShading === true)\r\n            data.flatShading = this.flatShading;\r\n        if (this.side !== FrontSide)\r\n            data.side = this.side;\r\n        if (this.vertexColors !== NoColors)\r\n            data.vertexColors = this.vertexColors;\r\n        if (this.opacity < 1)\r\n            data.opacity = this.opacity;\r\n        if (this.transparent === true)\r\n            data.transparent = this.transparent;\r\n        data.depthFunc = this.depthFunc;\r\n        data.depthTest = this.depthTest;\r\n        data.depthWrite = this.depthWrite;\r\n        data.stencilWrite = this.stencilWrite;\r\n        data.stencilFunc = this.stencilFunc;\r\n        data.stencilRef = this.stencilRef;\r\n        data.stencilMask = this.stencilMask;\r\n        data.stencilFail = this.stencilFail;\r\n        data.stencilZFail = this.stencilZFail;\r\n        data.stencilZPass = this.stencilZPass;\r\n        // rotation (SpriteMaterial)\r\n        if (this.rotation && this.rotation !== 0)\r\n            data.rotation = this.rotation;\r\n        if (this.polygonOffset === true)\r\n            data.polygonOffset = true;\r\n        if (this.polygonOffsetFactor !== 0)\r\n            data.polygonOffsetFactor = this.polygonOffsetFactor;\r\n        if (this.polygonOffsetUnits !== 0)\r\n            data.polygonOffsetUnits = this.polygonOffsetUnits;\r\n        if (this.linewidth && this.linewidth !== 1)\r\n            data.linewidth = this.linewidth;\r\n        if (this.dashSize !== undefined)\r\n            data.dashSize = this.dashSize;\r\n        if (this.gapSize !== undefined)\r\n            data.gapSize = this.gapSize;\r\n        if (this.scale !== undefined)\r\n            data.scale = this.scale;\r\n        if (this.dithering === true)\r\n            data.dithering = true;\r\n        if (this.alphaTest > 0)\r\n            data.alphaTest = this.alphaTest;\r\n        if (this.premultipliedAlpha === true)\r\n            data.premultipliedAlpha = this.premultipliedAlpha;\r\n        if (this.wireframe === true)\r\n            data.wireframe = this.wireframe;\r\n        if (this.wireframeLinewidth > 1)\r\n            data.wireframeLinewidth = this.wireframeLinewidth;\r\n        if (this.wireframeLinecap !== 'round')\r\n            data.wireframeLinecap = this.wireframeLinecap;\r\n        if (this.wireframeLinejoin !== 'round')\r\n            data.wireframeLinejoin = this.wireframeLinejoin;\r\n        if (this.morphTargets === true)\r\n            data.morphTargets = true;\r\n        if (this.morphNormals === true)\r\n            data.morphNormals = true;\r\n        if (this.skinning === true)\r\n            data.skinning = true;\r\n        if (this.visible === false)\r\n            data.visible = false;\r\n        if (JSON.stringify(this.userData) !== '{}')\r\n            data.userData = this.userData;\r\n        // TODO: Copied from Object3D.toJSON\r\n        function extractFromCache(cache) {\r\n            var values = [];\r\n            for (var key in cache) {\r\n                var data = cache[key];\r\n                delete data.metadata;\r\n                values.push(data);\r\n            }\r\n            return values;\r\n        }\r\n        if (isRoot) {\r\n            var textures = extractFromCache(meta.textures);\r\n            var images = extractFromCache(meta.images);\r\n            if (textures.length > 0)\r\n                data.textures = textures;\r\n            if (images.length > 0)\r\n                data.images = images;\r\n        }\r\n        return data;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        this.name = source.name;\r\n        this.fog = source.fog;\r\n        this.lights = source.lights;\r\n        this.blending = source.blending;\r\n        this.side = source.side;\r\n        this.flatShading = source.flatShading;\r\n        this.vertexColors = source.vertexColors;\r\n        this.opacity = source.opacity;\r\n        this.transparent = source.transparent;\r\n        this.blendSrc = source.blendSrc;\r\n        this.blendDst = source.blendDst;\r\n        this.blendEquation = source.blendEquation;\r\n        this.blendSrcAlpha = source.blendSrcAlpha;\r\n        this.blendDstAlpha = source.blendDstAlpha;\r\n        this.blendEquationAlpha = source.blendEquationAlpha;\r\n        this.depthFunc = source.depthFunc;\r\n        this.depthTest = source.depthTest;\r\n        this.depthWrite = source.depthWrite;\r\n        this.stencilWrite = source.stencilWrite;\r\n        this.stencilFunc = source.stencilFunc;\r\n        this.stencilRef = source.stencilRef;\r\n        this.stencilMask = source.stencilMask;\r\n        this.stencilFail = source.stencilFail;\r\n        this.stencilZFail = source.stencilZFail;\r\n        this.stencilZPass = source.stencilZPass;\r\n        this.colorWrite = source.colorWrite;\r\n        this.precision = source.precision;\r\n        this.polygonOffset = source.polygonOffset;\r\n        this.polygonOffsetFactor = source.polygonOffsetFactor;\r\n        this.polygonOffsetUnits = source.polygonOffsetUnits;\r\n        this.dithering = source.dithering;\r\n        this.alphaTest = source.alphaTest;\r\n        this.premultipliedAlpha = source.premultipliedAlpha;\r\n        this.visible = source.visible;\r\n        this.userData = JSON.parse(JSON.stringify(source.userData));\r\n        this.clipShadows = source.clipShadows;\r\n        this.clipIntersection = source.clipIntersection;\r\n        var srcPlanes = source.clippingPlanes, dstPlanes = null;\r\n        if (srcPlanes !== null) {\r\n            var n = srcPlanes.length;\r\n            dstPlanes = new Array(n);\r\n            for (var i = 0; i !== n; ++i)\r\n                dstPlanes[i] = srcPlanes[i].clone();\r\n        }\r\n        this.clippingPlanes = dstPlanes;\r\n        this.shadowSide = source.shadowSide;\r\n        return this;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>\r\n * }\r\n */\r\nfunction MeshBasicMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshBasicMaterial';\r\n    this.color = new Color(0xffffff); // emissive\r\n    this.map = null;\r\n    this.lightMap = null;\r\n    this.lightMapIntensity = 1.0;\r\n    this.aoMap = null;\r\n    this.aoMapIntensity = 1.0;\r\n    this.specularMap = null;\r\n    this.alphaMap = null;\r\n    this.envMap = null;\r\n    this.combine = MultiplyOperation;\r\n    this.reflectivity = 1;\r\n    this.refractionRatio = 0.98;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.wireframeLinecap = 'round';\r\n    this.wireframeLinejoin = 'round';\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshBasicMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\r\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\r\nMeshBasicMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.map = source.map;\r\n    this.lightMap = source.lightMap;\r\n    this.lightMapIntensity = source.lightMapIntensity;\r\n    this.aoMap = source.aoMap;\r\n    this.aoMapIntensity = source.aoMapIntensity;\r\n    this.specularMap = source.specularMap;\r\n    this.alphaMap = source.alphaMap;\r\n    this.envMap = source.envMap;\r\n    this.combine = source.combine;\r\n    this.reflectivity = source.reflectivity;\r\n    this.refractionRatio = source.refractionRatio;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.wireframeLinecap = source.wireframeLinecap;\r\n    this.wireframeLinejoin = source.wireframeLinejoin;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction BufferAttribute(array, itemSize, normalized) {\r\n    if (Array.isArray(array)) {\r\n        throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\r\n    }\r\n    this.name = '';\r\n    this.array = array;\r\n    this.itemSize = itemSize;\r\n    this.count = array !== undefined ? array.length / itemSize : 0;\r\n    this.normalized = normalized === true;\r\n    this.dynamic = false;\r\n    this.updateRange = { offset: 0, count: -1 };\r\n    this.version = 0;\r\n}\r\nObject.defineProperty(BufferAttribute.prototype, 'needsUpdate', {\r\n    set: function (value) {\r\n        if (value === true)\r\n            this.version++;\r\n    }\r\n});\r\nObject.assign(BufferAttribute.prototype, {\r\n    isBufferAttribute: true,\r\n    onUploadCallback: function () { },\r\n    setArray: function (array) {\r\n        if (Array.isArray(array)) {\r\n            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\r\n        }\r\n        this.count = array !== undefined ? array.length / this.itemSize : 0;\r\n        this.array = array;\r\n        return this;\r\n    },\r\n    setDynamic: function (value) {\r\n        this.dynamic = value;\r\n        return this;\r\n    },\r\n    copy: function (source) {\r\n        this.name = source.name;\r\n        this.array = new source.array.constructor(source.array);\r\n        this.itemSize = source.itemSize;\r\n        this.count = source.count;\r\n        this.normalized = source.normalized;\r\n        this.dynamic = source.dynamic;\r\n        return this;\r\n    },\r\n    copyAt: function (index1, attribute, index2) {\r\n        index1 *= this.itemSize;\r\n        index2 *= attribute.itemSize;\r\n        for (var i = 0, l = this.itemSize; i < l; i++) {\r\n            this.array[index1 + i] = attribute.array[index2 + i];\r\n        }\r\n        return this;\r\n    },\r\n    copyArray: function (array) {\r\n        this.array.set(array);\r\n        return this;\r\n    },\r\n    copyColorsArray: function (colors) {\r\n        var array = this.array, offset = 0;\r\n        for (var i = 0, l = colors.length; i < l; i++) {\r\n            var color = colors[i];\r\n            if (color === undefined) {\r\n                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\r\n                color = new Color();\r\n            }\r\n            array[offset++] = color.r;\r\n            array[offset++] = color.g;\r\n            array[offset++] = color.b;\r\n        }\r\n        return this;\r\n    },\r\n    copyVector2sArray: function (vectors) {\r\n        var array = this.array, offset = 0;\r\n        for (var i = 0, l = vectors.length; i < l; i++) {\r\n            var vector = vectors[i];\r\n            if (vector === undefined) {\r\n                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\r\n                vector = new Vector2();\r\n            }\r\n            array[offset++] = vector.x;\r\n            array[offset++] = vector.y;\r\n        }\r\n        return this;\r\n    },\r\n    copyVector3sArray: function (vectors) {\r\n        var array = this.array, offset = 0;\r\n        for (var i = 0, l = vectors.length; i < l; i++) {\r\n            var vector = vectors[i];\r\n            if (vector === undefined) {\r\n                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\r\n                vector = new Vector3();\r\n            }\r\n            array[offset++] = vector.x;\r\n            array[offset++] = vector.y;\r\n            array[offset++] = vector.z;\r\n        }\r\n        return this;\r\n    },\r\n    copyVector4sArray: function (vectors) {\r\n        var array = this.array, offset = 0;\r\n        for (var i = 0, l = vectors.length; i < l; i++) {\r\n            var vector = vectors[i];\r\n            if (vector === undefined) {\r\n                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\r\n                vector = new Vector4();\r\n            }\r\n            array[offset++] = vector.x;\r\n            array[offset++] = vector.y;\r\n            array[offset++] = vector.z;\r\n            array[offset++] = vector.w;\r\n        }\r\n        return this;\r\n    },\r\n    set: function (value, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.array.set(value, offset);\r\n        return this;\r\n    },\r\n    getX: function (index) {\r\n        return this.array[index * this.itemSize];\r\n    },\r\n    setX: function (index, x) {\r\n        this.array[index * this.itemSize] = x;\r\n        return this;\r\n    },\r\n    getY: function (index) {\r\n        return this.array[index * this.itemSize + 1];\r\n    },\r\n    setY: function (index, y) {\r\n        this.array[index * this.itemSize + 1] = y;\r\n        return this;\r\n    },\r\n    getZ: function (index) {\r\n        return this.array[index * this.itemSize + 2];\r\n    },\r\n    setZ: function (index, z) {\r\n        this.array[index * this.itemSize + 2] = z;\r\n        return this;\r\n    },\r\n    getW: function (index) {\r\n        return this.array[index * this.itemSize + 3];\r\n    },\r\n    setW: function (index, w) {\r\n        this.array[index * this.itemSize + 3] = w;\r\n        return this;\r\n    },\r\n    setXY: function (index, x, y) {\r\n        index *= this.itemSize;\r\n        this.array[index + 0] = x;\r\n        this.array[index + 1] = y;\r\n        return this;\r\n    },\r\n    setXYZ: function (index, x, y, z) {\r\n        index *= this.itemSize;\r\n        this.array[index + 0] = x;\r\n        this.array[index + 1] = y;\r\n        this.array[index + 2] = z;\r\n        return this;\r\n    },\r\n    setXYZW: function (index, x, y, z, w) {\r\n        index *= this.itemSize;\r\n        this.array[index + 0] = x;\r\n        this.array[index + 1] = y;\r\n        this.array[index + 2] = z;\r\n        this.array[index + 3] = w;\r\n        return this;\r\n    },\r\n    onUpload: function (callback) {\r\n        this.onUploadCallback = callback;\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.array, this.itemSize).copy(this);\r\n    },\r\n    toJSON: function () {\r\n        return {\r\n            itemSize: this.itemSize,\r\n            type: this.array.constructor.name,\r\n            array: Array.prototype.slice.call(this.array),\r\n            normalized: this.normalized\r\n        };\r\n    }\r\n});\r\n//\r\nfunction Int8BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);\r\n}\r\nInt8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\r\nfunction Uint8BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);\r\n}\r\nUint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\r\nfunction Uint8ClampedBufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);\r\n}\r\nUint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\r\nfunction Int16BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);\r\n}\r\nInt16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\r\nfunction Uint16BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);\r\n}\r\nUint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\r\nfunction Int32BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);\r\n}\r\nInt32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\r\nfunction Uint32BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);\r\n}\r\nUint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\r\nfunction Float32BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);\r\n}\r\nFloat32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\r\nfunction Float64BufferAttribute(array, itemSize, normalized) {\r\n    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);\r\n}\r\nFloat64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\r\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction DirectGeometry() {\r\n    this.vertices = [];\r\n    this.normals = [];\r\n    this.colors = [];\r\n    this.uvs = [];\r\n    this.uvs2 = [];\r\n    this.groups = [];\r\n    this.morphTargets = {};\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    // this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null;\r\n    // update flags\r\n    this.verticesNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n}\r\nObject.assign(DirectGeometry.prototype, {\r\n    computeGroups: function (geometry) {\r\n        var group;\r\n        var groups = [];\r\n        var materialIndex = undefined;\r\n        var faces = geometry.faces;\r\n        for (var i = 0; i < faces.length; i++) {\r\n            var face = faces[i];\r\n            // materials\r\n            if (face.materialIndex !== materialIndex) {\r\n                materialIndex = face.materialIndex;\r\n                if (group !== undefined) {\r\n                    group.count = (i * 3) - group.start;\r\n                    groups.push(group);\r\n                }\r\n                group = {\r\n                    start: i * 3,\r\n                    materialIndex: materialIndex\r\n                };\r\n            }\r\n        }\r\n        if (group !== undefined) {\r\n            group.count = (i * 3) - group.start;\r\n            groups.push(group);\r\n        }\r\n        this.groups = groups;\r\n    },\r\n    fromGeometry: function (geometry) {\r\n        var faces = geometry.faces;\r\n        var vertices = geometry.vertices;\r\n        var faceVertexUvs = geometry.faceVertexUvs;\r\n        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\r\n        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\r\n        // morphs\r\n        var morphTargets = geometry.morphTargets;\r\n        var morphTargetsLength = morphTargets.length;\r\n        var morphTargetsPosition;\r\n        if (morphTargetsLength > 0) {\r\n            morphTargetsPosition = [];\r\n            for (var i = 0; i < morphTargetsLength; i++) {\r\n                morphTargetsPosition[i] = {\r\n                    name: morphTargets[i].name,\r\n                    data: []\r\n                };\r\n            }\r\n            this.morphTargets.position = morphTargetsPosition;\r\n        }\r\n        var morphNormals = geometry.morphNormals;\r\n        var morphNormalsLength = morphNormals.length;\r\n        var morphTargetsNormal;\r\n        if (morphNormalsLength > 0) {\r\n            morphTargetsNormal = [];\r\n            for (var i = 0; i < morphNormalsLength; i++) {\r\n                morphTargetsNormal[i] = {\r\n                    name: morphNormals[i].name,\r\n                    data: []\r\n                };\r\n            }\r\n            this.morphTargets.normal = morphTargetsNormal;\r\n        }\r\n        // skins\r\n        var skinIndices = geometry.skinIndices;\r\n        var skinWeights = geometry.skinWeights;\r\n        var hasSkinIndices = skinIndices.length === vertices.length;\r\n        var hasSkinWeights = skinWeights.length === vertices.length;\r\n        //\r\n        if (vertices.length > 0 && faces.length === 0) {\r\n            console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\r\n        }\r\n        for (var i = 0; i < faces.length; i++) {\r\n            var face = faces[i];\r\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\r\n            var vertexNormals = face.vertexNormals;\r\n            if (vertexNormals.length === 3) {\r\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\r\n            }\r\n            else {\r\n                var normal = face.normal;\r\n                this.normals.push(normal, normal, normal);\r\n            }\r\n            var vertexColors = face.vertexColors;\r\n            if (vertexColors.length === 3) {\r\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\r\n            }\r\n            else {\r\n                var color = face.color;\r\n                this.colors.push(color, color, color);\r\n            }\r\n            if (hasFaceVertexUv === true) {\r\n                var vertexUvs = faceVertexUvs[0][i];\r\n                if (vertexUvs !== undefined) {\r\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n                }\r\n                else {\r\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\r\n                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());\r\n                }\r\n            }\r\n            if (hasFaceVertexUv2 === true) {\r\n                var vertexUvs = faceVertexUvs[1][i];\r\n                if (vertexUvs !== undefined) {\r\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n                }\r\n                else {\r\n                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\r\n                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\r\n                }\r\n            }\r\n            // morphs\r\n            for (var j = 0; j < morphTargetsLength; j++) {\r\n                var morphTarget = morphTargets[j].vertices;\r\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\r\n            }\r\n            for (var j = 0; j < morphNormalsLength; j++) {\r\n                var morphNormal = morphNormals[j].vertexNormals[i];\r\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\r\n            }\r\n            // skins\r\n            if (hasSkinIndices) {\r\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\r\n            }\r\n            if (hasSkinWeights) {\r\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\r\n            }\r\n        }\r\n        this.computeGroups(geometry);\r\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n        if (geometry.boundingSphere !== null) {\r\n            this.boundingSphere = geometry.boundingSphere.clone();\r\n        }\r\n        if (geometry.boundingBox !== null) {\r\n            this.boundingBox = geometry.boundingBox.clone();\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction arrayMax(array) {\r\n    if (array.length === 0)\r\n        return -Infinity;\r\n    var max = array[0];\r\n    for (var i = 1, l = array.length; i < l; ++i) {\r\n        if (array[i] > max)\r\n            max = array[i];\r\n    }\r\n    return max;\r\n}\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\r\nfunction BufferGeometry() {\r\n    Object.defineProperty(this, 'id', { value: bufferGeometryId += 2 });\r\n    this.uuid = _Math.generateUUID();\r\n    this.name = '';\r\n    this.type = 'BufferGeometry';\r\n    this.index = null;\r\n    this.attributes = {};\r\n    this.morphAttributes = {};\r\n    this.groups = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null;\r\n    this.drawRange = { start: 0, count: Infinity };\r\n    this.userData = {};\r\n}\r\nBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: BufferGeometry,\r\n    isBufferGeometry: true,\r\n    getIndex: function () {\r\n        return this.index;\r\n    },\r\n    setIndex: function (index) {\r\n        if (Array.isArray(index)) {\r\n            this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\r\n        }\r\n        else {\r\n            this.index = index;\r\n        }\r\n    },\r\n    addAttribute: function (name, attribute) {\r\n        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\r\n            console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\r\n            return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\r\n        }\r\n        if (name === 'index') {\r\n            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\r\n            this.setIndex(attribute);\r\n            return this;\r\n        }\r\n        this.attributes[name] = attribute;\r\n        return this;\r\n    },\r\n    getAttribute: function (name) {\r\n        return this.attributes[name];\r\n    },\r\n    removeAttribute: function (name) {\r\n        delete this.attributes[name];\r\n        return this;\r\n    },\r\n    addGroup: function (start, count, materialIndex) {\r\n        this.groups.push({\r\n            start: start,\r\n            count: count,\r\n            materialIndex: materialIndex !== undefined ? materialIndex : 0\r\n        });\r\n    },\r\n    clearGroups: function () {\r\n        this.groups = [];\r\n    },\r\n    setDrawRange: function (start, count) {\r\n        this.drawRange.start = start;\r\n        this.drawRange.count = count;\r\n    },\r\n    applyMatrix: function (matrix) {\r\n        var position = this.attributes.position;\r\n        if (position !== undefined) {\r\n            matrix.applyToBufferAttribute(position);\r\n            position.needsUpdate = true;\r\n        }\r\n        var normal = this.attributes.normal;\r\n        if (normal !== undefined) {\r\n            var normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n            normalMatrix.applyToBufferAttribute(normal);\r\n            normal.needsUpdate = true;\r\n        }\r\n        var tangent = this.attributes.tangent;\r\n        if (tangent !== undefined) {\r\n            var normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n            // Tangent is vec4, but the '.w' component is a sign value (+1/-1).\r\n            normalMatrix.applyToBufferAttribute(tangent);\r\n            tangent.needsUpdate = true;\r\n        }\r\n        if (this.boundingBox !== null) {\r\n            this.computeBoundingBox();\r\n        }\r\n        if (this.boundingSphere !== null) {\r\n            this.computeBoundingSphere();\r\n        }\r\n        return this;\r\n    },\r\n    rotateX: function () {\r\n        // rotate geometry around world x-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateX(angle) {\r\n            m1.makeRotationX(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateY: function () {\r\n        // rotate geometry around world y-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateY(angle) {\r\n            m1.makeRotationY(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateZ: function () {\r\n        // rotate geometry around world z-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateZ(angle) {\r\n            m1.makeRotationZ(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    translate: function () {\r\n        // translate geometry\r\n        var m1 = new Matrix4();\r\n        return function translate(x, y, z) {\r\n            m1.makeTranslation(x, y, z);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    scale: function () {\r\n        // scale geometry\r\n        var m1 = new Matrix4();\r\n        return function scale(x, y, z) {\r\n            m1.makeScale(x, y, z);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    lookAt: function () {\r\n        var obj = new Object3D();\r\n        return function lookAt(vector) {\r\n            obj.lookAt(vector);\r\n            obj.updateMatrix();\r\n            this.applyMatrix(obj.matrix);\r\n        };\r\n    }(),\r\n    center: function () {\r\n        var offset = new Vector3();\r\n        return function center() {\r\n            this.computeBoundingBox();\r\n            this.boundingBox.getCenter(offset).negate();\r\n            this.translate(offset.x, offset.y, offset.z);\r\n            return this;\r\n        };\r\n    }(),\r\n    setFromObject: function (object) {\r\n        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n        var geometry = object.geometry;\r\n        if (object.isPoints || object.isLine) {\r\n            var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\r\n            var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\r\n            this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));\r\n            this.addAttribute('color', colors.copyColorsArray(geometry.colors));\r\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\r\n                var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\r\n                this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\r\n            }\r\n            if (geometry.boundingSphere !== null) {\r\n                this.boundingSphere = geometry.boundingSphere.clone();\r\n            }\r\n            if (geometry.boundingBox !== null) {\r\n                this.boundingBox = geometry.boundingBox.clone();\r\n            }\r\n        }\r\n        else if (object.isMesh) {\r\n            if (geometry && geometry.isGeometry) {\r\n                this.fromGeometry(geometry);\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    setFromPoints: function (points) {\r\n        var position = [];\r\n        for (var i = 0, l = points.length; i < l; i++) {\r\n            var point = points[i];\r\n            position.push(point.x, point.y, point.z || 0);\r\n        }\r\n        this.addAttribute('position', new Float32BufferAttribute(position, 3));\r\n        return this;\r\n    },\r\n    updateFromObject: function (object) {\r\n        var geometry = object.geometry;\r\n        if (object.isMesh) {\r\n            var direct = geometry.__directGeometry;\r\n            if (geometry.elementsNeedUpdate === true) {\r\n                direct = undefined;\r\n                geometry.elementsNeedUpdate = false;\r\n            }\r\n            if (direct === undefined) {\r\n                return this.fromGeometry(geometry);\r\n            }\r\n            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n            geometry.verticesNeedUpdate = false;\r\n            geometry.normalsNeedUpdate = false;\r\n            geometry.colorsNeedUpdate = false;\r\n            geometry.uvsNeedUpdate = false;\r\n            geometry.groupsNeedUpdate = false;\r\n            geometry = direct;\r\n        }\r\n        var attribute;\r\n        if (geometry.verticesNeedUpdate === true) {\r\n            attribute = this.attributes.position;\r\n            if (attribute !== undefined) {\r\n                attribute.copyVector3sArray(geometry.vertices);\r\n                attribute.needsUpdate = true;\r\n            }\r\n            geometry.verticesNeedUpdate = false;\r\n        }\r\n        if (geometry.normalsNeedUpdate === true) {\r\n            attribute = this.attributes.normal;\r\n            if (attribute !== undefined) {\r\n                attribute.copyVector3sArray(geometry.normals);\r\n                attribute.needsUpdate = true;\r\n            }\r\n            geometry.normalsNeedUpdate = false;\r\n        }\r\n        if (geometry.colorsNeedUpdate === true) {\r\n            attribute = this.attributes.color;\r\n            if (attribute !== undefined) {\r\n                attribute.copyColorsArray(geometry.colors);\r\n                attribute.needsUpdate = true;\r\n            }\r\n            geometry.colorsNeedUpdate = false;\r\n        }\r\n        if (geometry.uvsNeedUpdate) {\r\n            attribute = this.attributes.uv;\r\n            if (attribute !== undefined) {\r\n                attribute.copyVector2sArray(geometry.uvs);\r\n                attribute.needsUpdate = true;\r\n            }\r\n            geometry.uvsNeedUpdate = false;\r\n        }\r\n        if (geometry.lineDistancesNeedUpdate) {\r\n            attribute = this.attributes.lineDistance;\r\n            if (attribute !== undefined) {\r\n                attribute.copyArray(geometry.lineDistances);\r\n                attribute.needsUpdate = true;\r\n            }\r\n            geometry.lineDistancesNeedUpdate = false;\r\n        }\r\n        if (geometry.groupsNeedUpdate) {\r\n            geometry.computeGroups(object.geometry);\r\n            this.groups = geometry.groups;\r\n            geometry.groupsNeedUpdate = false;\r\n        }\r\n        return this;\r\n    },\r\n    fromGeometry: function (geometry) {\r\n        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\r\n        return this.fromDirectGeometry(geometry.__directGeometry);\r\n    },\r\n    fromDirectGeometry: function (geometry) {\r\n        var positions = new Float32Array(geometry.vertices.length * 3);\r\n        this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\r\n        if (geometry.normals.length > 0) {\r\n            var normals = new Float32Array(geometry.normals.length * 3);\r\n            this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\r\n        }\r\n        if (geometry.colors.length > 0) {\r\n            var colors = new Float32Array(geometry.colors.length * 3);\r\n            this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\r\n        }\r\n        if (geometry.uvs.length > 0) {\r\n            var uvs = new Float32Array(geometry.uvs.length * 2);\r\n            this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\r\n        }\r\n        if (geometry.uvs2.length > 0) {\r\n            var uvs2 = new Float32Array(geometry.uvs2.length * 2);\r\n            this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\r\n        }\r\n        // groups\r\n        this.groups = geometry.groups;\r\n        // morphs\r\n        for (var name in geometry.morphTargets) {\r\n            var array = [];\r\n            var morphTargets = geometry.morphTargets[name];\r\n            for (var i = 0, l = morphTargets.length; i < l; i++) {\r\n                var morphTarget = morphTargets[i];\r\n                var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\r\n                attribute.name = morphTarget.name;\r\n                array.push(attribute.copyVector3sArray(morphTarget.data));\r\n            }\r\n            this.morphAttributes[name] = array;\r\n        }\r\n        // skinning\r\n        if (geometry.skinIndices.length > 0) {\r\n            var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\r\n            this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\r\n        }\r\n        if (geometry.skinWeights.length > 0) {\r\n            var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\r\n            this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\r\n        }\r\n        //\r\n        if (geometry.boundingSphere !== null) {\r\n            this.boundingSphere = geometry.boundingSphere.clone();\r\n        }\r\n        if (geometry.boundingBox !== null) {\r\n            this.boundingBox = geometry.boundingBox.clone();\r\n        }\r\n        return this;\r\n    },\r\n    computeBoundingBox: function () {\r\n        var box = new Box3();\r\n        return function computeBoundingBox() {\r\n            if (this.boundingBox === null) {\r\n                this.boundingBox = new Box3();\r\n            }\r\n            var position = this.attributes.position;\r\n            var morphAttributesPosition = this.morphAttributes.position;\r\n            if (position !== undefined) {\r\n                this.boundingBox.setFromBufferAttribute(position);\r\n                // process morph attributes if present\r\n                if (morphAttributesPosition) {\r\n                    for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\r\n                        var morphAttribute = morphAttributesPosition[i];\r\n                        box.setFromBufferAttribute(morphAttribute);\r\n                        this.boundingBox.expandByPoint(box.min);\r\n                        this.boundingBox.expandByPoint(box.max);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this.boundingBox.makeEmpty();\r\n            }\r\n            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\r\n                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\r\n            }\r\n        };\r\n    }(),\r\n    computeBoundingSphere: function () {\r\n        var box = new Box3();\r\n        var boxMorphTargets = new Box3();\r\n        var vector = new Vector3();\r\n        return function computeBoundingSphere() {\r\n            if (this.boundingSphere === null) {\r\n                this.boundingSphere = new Sphere();\r\n            }\r\n            var position = this.attributes.position;\r\n            var morphAttributesPosition = this.morphAttributes.position;\r\n            if (position) {\r\n                // first, find the center of the bounding sphere\r\n                var center = this.boundingSphere.center;\r\n                box.setFromBufferAttribute(position);\r\n                // process morph attributes if present\r\n                if (morphAttributesPosition) {\r\n                    for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\r\n                        var morphAttribute = morphAttributesPosition[i];\r\n                        boxMorphTargets.setFromBufferAttribute(morphAttribute);\r\n                        box.expandByPoint(boxMorphTargets.min);\r\n                        box.expandByPoint(boxMorphTargets.max);\r\n                    }\r\n                }\r\n                box.getCenter(center);\r\n                // second, try to find a boundingSphere with a radius smaller than the\r\n                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n                var maxRadiusSq = 0;\r\n                for (var i = 0, il = position.count; i < il; i++) {\r\n                    vector.fromBufferAttribute(position, i);\r\n                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\r\n                }\r\n                // process morph attributes if present\r\n                if (morphAttributesPosition) {\r\n                    for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\r\n                        var morphAttribute = morphAttributesPosition[i];\r\n                        for (var j = 0, jl = morphAttribute.count; j < jl; j++) {\r\n                            vector.fromBufferAttribute(morphAttribute, j);\r\n                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\r\n                        }\r\n                    }\r\n                }\r\n                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n                if (isNaN(this.boundingSphere.radius)) {\r\n                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\r\n                }\r\n            }\r\n        };\r\n    }(),\r\n    computeFaceNormals: function () {\r\n        // backwards compatibility\r\n    },\r\n    computeVertexNormals: function () {\r\n        var index = this.index;\r\n        var attributes = this.attributes;\r\n        if (attributes.position) {\r\n            var positions = attributes.position.array;\r\n            if (attributes.normal === undefined) {\r\n                this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));\r\n            }\r\n            else {\r\n                // reset existing normals to zero\r\n                var array = attributes.normal.array;\r\n                for (var i = 0, il = array.length; i < il; i++) {\r\n                    array[i] = 0;\r\n                }\r\n            }\r\n            var normals = attributes.normal.array;\r\n            var vA, vB, vC;\r\n            var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\r\n            var cb = new Vector3(), ab = new Vector3();\r\n            // indexed elements\r\n            if (index) {\r\n                var indices = index.array;\r\n                for (var i = 0, il = index.count; i < il; i += 3) {\r\n                    vA = indices[i + 0] * 3;\r\n                    vB = indices[i + 1] * 3;\r\n                    vC = indices[i + 2] * 3;\r\n                    pA.fromArray(positions, vA);\r\n                    pB.fromArray(positions, vB);\r\n                    pC.fromArray(positions, vC);\r\n                    cb.subVectors(pC, pB);\r\n                    ab.subVectors(pA, pB);\r\n                    cb.cross(ab);\r\n                    normals[vA] += cb.x;\r\n                    normals[vA + 1] += cb.y;\r\n                    normals[vA + 2] += cb.z;\r\n                    normals[vB] += cb.x;\r\n                    normals[vB + 1] += cb.y;\r\n                    normals[vB + 2] += cb.z;\r\n                    normals[vC] += cb.x;\r\n                    normals[vC + 1] += cb.y;\r\n                    normals[vC + 2] += cb.z;\r\n                }\r\n            }\r\n            else {\r\n                // non-indexed elements (unconnected triangle soup)\r\n                for (var i = 0, il = positions.length; i < il; i += 9) {\r\n                    pA.fromArray(positions, i);\r\n                    pB.fromArray(positions, i + 3);\r\n                    pC.fromArray(positions, i + 6);\r\n                    cb.subVectors(pC, pB);\r\n                    ab.subVectors(pA, pB);\r\n                    cb.cross(ab);\r\n                    normals[i] = cb.x;\r\n                    normals[i + 1] = cb.y;\r\n                    normals[i + 2] = cb.z;\r\n                    normals[i + 3] = cb.x;\r\n                    normals[i + 4] = cb.y;\r\n                    normals[i + 5] = cb.z;\r\n                    normals[i + 6] = cb.x;\r\n                    normals[i + 7] = cb.y;\r\n                    normals[i + 8] = cb.z;\r\n                }\r\n            }\r\n            this.normalizeNormals();\r\n            attributes.normal.needsUpdate = true;\r\n        }\r\n    },\r\n    merge: function (geometry, offset) {\r\n        if (!(geometry && geometry.isBufferGeometry)) {\r\n            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\r\n            return;\r\n        }\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n            console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\r\n                + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\r\n        }\r\n        var attributes = this.attributes;\r\n        for (var key in attributes) {\r\n            if (geometry.attributes[key] === undefined)\r\n                continue;\r\n            var attribute1 = attributes[key];\r\n            var attributeArray1 = attribute1.array;\r\n            var attribute2 = geometry.attributes[key];\r\n            var attributeArray2 = attribute2.array;\r\n            var attributeOffset = attribute2.itemSize * offset;\r\n            var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\r\n            for (var i = 0, j = attributeOffset; i < length; i++, j++) {\r\n                attributeArray1[j] = attributeArray2[i];\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    normalizeNormals: function () {\r\n        var vector = new Vector3();\r\n        return function normalizeNormals() {\r\n            var normals = this.attributes.normal;\r\n            for (var i = 0, il = normals.count; i < il; i++) {\r\n                vector.x = normals.getX(i);\r\n                vector.y = normals.getY(i);\r\n                vector.z = normals.getZ(i);\r\n                vector.normalize();\r\n                normals.setXYZ(i, vector.x, vector.y, vector.z);\r\n            }\r\n        };\r\n    }(),\r\n    toNonIndexed: function () {\r\n        function convertBufferAttribute(attribute, indices) {\r\n            var array = attribute.array;\r\n            var itemSize = attribute.itemSize;\r\n            var array2 = new array.constructor(indices.length * itemSize);\r\n            var index = 0, index2 = 0;\r\n            for (var i = 0, l = indices.length; i < l; i++) {\r\n                index = indices[i] * itemSize;\r\n                for (var j = 0; j < itemSize; j++) {\r\n                    array2[index2++] = array[index++];\r\n                }\r\n            }\r\n            return new BufferAttribute(array2, itemSize);\r\n        }\r\n        //\r\n        if (this.index === null) {\r\n            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\r\n            return this;\r\n        }\r\n        var geometry2 = new BufferGeometry();\r\n        var indices = this.index.array;\r\n        var attributes = this.attributes;\r\n        // attributes\r\n        for (var name in attributes) {\r\n            var attribute = attributes[name];\r\n            var newAttribute = convertBufferAttribute(attribute, indices);\r\n            geometry2.addAttribute(name, newAttribute);\r\n        }\r\n        // morph attributes\r\n        var morphAttributes = this.morphAttributes;\r\n        for (name in morphAttributes) {\r\n            var morphArray = [];\r\n            var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\r\n            for (var i = 0, il = morphAttribute.length; i < il; i++) {\r\n                var attribute = morphAttribute[i];\r\n                var newAttribute = convertBufferAttribute(attribute, indices);\r\n                morphArray.push(newAttribute);\r\n            }\r\n            geometry2.morphAttributes[name] = morphArray;\r\n        }\r\n        // groups\r\n        var groups = this.groups;\r\n        for (var i = 0, l = groups.length; i < l; i++) {\r\n            var group = groups[i];\r\n            geometry2.addGroup(group.start, group.count, group.materialIndex);\r\n        }\r\n        return geometry2;\r\n    },\r\n    toJSON: function () {\r\n        var data = {\r\n            metadata: {\r\n                version: 4.5,\r\n                type: 'BufferGeometry',\r\n                generator: 'BufferGeometry.toJSON'\r\n            }\r\n        };\r\n        // standard BufferGeometry serialization\r\n        data.uuid = this.uuid;\r\n        data.type = this.type;\r\n        if (this.name !== '')\r\n            data.name = this.name;\r\n        if (Object.keys(this.userData).length > 0)\r\n            data.userData = this.userData;\r\n        if (this.parameters !== undefined) {\r\n            var parameters = this.parameters;\r\n            for (var key in parameters) {\r\n                if (parameters[key] !== undefined)\r\n                    data[key] = parameters[key];\r\n            }\r\n            return data;\r\n        }\r\n        data.data = { attributes: {} };\r\n        var index = this.index;\r\n        if (index !== null) {\r\n            data.data.index = {\r\n                type: index.array.constructor.name,\r\n                array: Array.prototype.slice.call(index.array)\r\n            };\r\n        }\r\n        var attributes = this.attributes;\r\n        for (var key in attributes) {\r\n            var attribute = attributes[key];\r\n            var attributeData = attribute.toJSON();\r\n            if (attribute.name !== '')\r\n                attributeData.name = attribute.name;\r\n            data.data.attributes[key] = attributeData;\r\n        }\r\n        var morphAttributes = {};\r\n        var hasMorphAttributes = false;\r\n        for (var key in this.morphAttributes) {\r\n            var attributeArray = this.morphAttributes[key];\r\n            var array = [];\r\n            for (var i = 0, il = attributeArray.length; i < il; i++) {\r\n                var attribute = attributeArray[i];\r\n                var attributeData = attribute.toJSON();\r\n                if (attribute.name !== '')\r\n                    attributeData.name = attribute.name;\r\n                array.push(attributeData);\r\n            }\r\n            if (array.length > 0) {\r\n                morphAttributes[key] = array;\r\n                hasMorphAttributes = true;\r\n            }\r\n        }\r\n        if (hasMorphAttributes)\r\n            data.data.morphAttributes = morphAttributes;\r\n        var groups = this.groups;\r\n        if (groups.length > 0) {\r\n            data.data.groups = JSON.parse(JSON.stringify(groups));\r\n        }\r\n        var boundingSphere = this.boundingSphere;\r\n        if (boundingSphere !== null) {\r\n            data.data.boundingSphere = {\r\n                center: boundingSphere.center.toArray(),\r\n                radius: boundingSphere.radius\r\n            };\r\n        }\r\n        return data;\r\n    },\r\n    clone: function () {\r\n        /*\r\n         // Handle primitives\r\n\r\n         var parameters = this.parameters;\r\n\r\n         if ( parameters !== undefined ) {\r\n\r\n         var values = [];\r\n\r\n         for ( var key in parameters ) {\r\n\r\n         values.push( parameters[ key ] );\r\n\r\n         }\r\n\r\n         var geometry = Object.create( this.constructor.prototype );\r\n         this.constructor.apply( geometry, values );\r\n         return geometry;\r\n\r\n         }\r\n\r\n         return new this.constructor().copy( this );\r\n         */\r\n        return new BufferGeometry().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        var name, i, l;\r\n        // reset\r\n        this.index = null;\r\n        this.attributes = {};\r\n        this.morphAttributes = {};\r\n        this.groups = [];\r\n        this.boundingBox = null;\r\n        this.boundingSphere = null;\r\n        // name\r\n        this.name = source.name;\r\n        // index\r\n        var index = source.index;\r\n        if (index !== null) {\r\n            this.setIndex(index.clone());\r\n        }\r\n        // attributes\r\n        var attributes = source.attributes;\r\n        for (name in attributes) {\r\n            var attribute = attributes[name];\r\n            this.addAttribute(name, attribute.clone());\r\n        }\r\n        // morph attributes\r\n        var morphAttributes = source.morphAttributes;\r\n        for (name in morphAttributes) {\r\n            var array = [];\r\n            var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\r\n            for (i = 0, l = morphAttribute.length; i < l; i++) {\r\n                array.push(morphAttribute[i].clone());\r\n            }\r\n            this.morphAttributes[name] = array;\r\n        }\r\n        // groups\r\n        var groups = source.groups;\r\n        for (i = 0, l = groups.length; i < l; i++) {\r\n            var group = groups[i];\r\n            this.addGroup(group.start, group.count, group.materialIndex);\r\n        }\r\n        // bounding box\r\n        var boundingBox = source.boundingBox;\r\n        if (boundingBox !== null) {\r\n            this.boundingBox = boundingBox.clone();\r\n        }\r\n        // bounding sphere\r\n        var boundingSphere = source.boundingSphere;\r\n        if (boundingSphere !== null) {\r\n            this.boundingSphere = boundingSphere.clone();\r\n        }\r\n        // draw range\r\n        this.drawRange.start = source.drawRange.start;\r\n        this.drawRange.count = source.drawRange.count;\r\n        // user data\r\n        this.userData = source.userData;\r\n        return this;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\nfunction Mesh(geometry, material) {\r\n    Object3D.call(this);\r\n    this.type = 'Mesh';\r\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n    this.material = material !== undefined ? material : new MeshBasicMaterial({ color: Math.random() * 0xffffff });\r\n    this.drawMode = TrianglesDrawMode;\r\n    this.updateMorphTargets();\r\n}\r\nMesh.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Mesh,\r\n    isMesh: true,\r\n    setDrawMode: function (value) {\r\n        this.drawMode = value;\r\n    },\r\n    copy: function (source) {\r\n        Object3D.prototype.copy.call(this, source);\r\n        this.drawMode = source.drawMode;\r\n        if (source.morphTargetInfluences !== undefined) {\r\n            this.morphTargetInfluences = source.morphTargetInfluences.slice();\r\n        }\r\n        if (source.morphTargetDictionary !== undefined) {\r\n            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\r\n        }\r\n        return this;\r\n    },\r\n    updateMorphTargets: function () {\r\n        var geometry = this.geometry;\r\n        var m, ml, name;\r\n        if (geometry.isBufferGeometry) {\r\n            var morphAttributes = geometry.morphAttributes;\r\n            var keys = Object.keys(morphAttributes);\r\n            if (keys.length > 0) {\r\n                var morphAttribute = morphAttributes[keys[0]];\r\n                if (morphAttribute !== undefined) {\r\n                    this.morphTargetInfluences = [];\r\n                    this.morphTargetDictionary = {};\r\n                    for (m = 0, ml = morphAttribute.length; m < ml; m++) {\r\n                        name = morphAttribute[m].name || String(m);\r\n                        this.morphTargetInfluences.push(0);\r\n                        this.morphTargetDictionary[name] = m;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var morphTargets = geometry.morphTargets;\r\n            if (morphTargets !== undefined && morphTargets.length > 0) {\r\n                console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\r\n            }\r\n        }\r\n    },\r\n    raycast: (function () {\r\n        var inverseMatrix = new Matrix4();\r\n        var ray = new Ray();\r\n        var sphere = new Sphere();\r\n        var vA = new Vector3();\r\n        var vB = new Vector3();\r\n        var vC = new Vector3();\r\n        var tempA = new Vector3();\r\n        var tempB = new Vector3();\r\n        var tempC = new Vector3();\r\n        var morphA = new Vector3();\r\n        var morphB = new Vector3();\r\n        var morphC = new Vector3();\r\n        var uvA = new Vector2();\r\n        var uvB = new Vector2();\r\n        var uvC = new Vector2();\r\n        var intersectionPoint = new Vector3();\r\n        var intersectionPointWorld = new Vector3();\r\n        function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\r\n            var intersect;\r\n            if (material.side === BackSide) {\r\n                intersect = ray.intersectTriangle(pC, pB, pA, true, point);\r\n            }\r\n            else {\r\n                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\r\n            }\r\n            if (intersect === null)\r\n                return null;\r\n            intersectionPointWorld.copy(point);\r\n            intersectionPointWorld.applyMatrix4(object.matrixWorld);\r\n            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);\r\n            if (distance < raycaster.near || distance > raycaster.far)\r\n                return null;\r\n            return {\r\n                distance: distance,\r\n                point: intersectionPointWorld.clone(),\r\n                object: object\r\n            };\r\n        }\r\n        function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, uv, uv2, a, b, c) {\r\n            vA.fromBufferAttribute(position, a);\r\n            vB.fromBufferAttribute(position, b);\r\n            vC.fromBufferAttribute(position, c);\r\n            var morphInfluences = object.morphTargetInfluences;\r\n            if (material.morphTargets && morphPosition && morphInfluences) {\r\n                morphA.set(0, 0, 0);\r\n                morphB.set(0, 0, 0);\r\n                morphC.set(0, 0, 0);\r\n                for (var i = 0, il = morphPosition.length; i < il; i++) {\r\n                    var influence = morphInfluences[i];\r\n                    var morphAttribute = morphPosition[i];\r\n                    if (influence === 0)\r\n                        continue;\r\n                    tempA.fromBufferAttribute(morphAttribute, a);\r\n                    tempB.fromBufferAttribute(morphAttribute, b);\r\n                    tempC.fromBufferAttribute(morphAttribute, c);\r\n                    morphA.addScaledVector(tempA.sub(vA), influence);\r\n                    morphB.addScaledVector(tempB.sub(vB), influence);\r\n                    morphC.addScaledVector(tempC.sub(vC), influence);\r\n                }\r\n                vA.add(morphA);\r\n                vB.add(morphB);\r\n                vC.add(morphC);\r\n            }\r\n            var intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);\r\n            if (intersection) {\r\n                if (uv) {\r\n                    uvA.fromBufferAttribute(uv, a);\r\n                    uvB.fromBufferAttribute(uv, b);\r\n                    uvC.fromBufferAttribute(uv, c);\r\n                    intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());\r\n                }\r\n                if (uv2) {\r\n                    uvA.fromBufferAttribute(uv2, a);\r\n                    uvB.fromBufferAttribute(uv2, b);\r\n                    uvC.fromBufferAttribute(uv2, c);\r\n                    intersection.uv2 = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());\r\n                }\r\n                var face = new Face3(a, b, c);\r\n                Triangle.getNormal(vA, vB, vC, face.normal);\r\n                intersection.face = face;\r\n            }\r\n            return intersection;\r\n        }\r\n        return function raycast(raycaster, intersects) {\r\n            var geometry = this.geometry;\r\n            var material = this.material;\r\n            var matrixWorld = this.matrixWorld;\r\n            if (material === undefined)\r\n                return;\r\n            // Checking boundingSphere distance to ray\r\n            if (geometry.boundingSphere === null)\r\n                geometry.computeBoundingSphere();\r\n            sphere.copy(geometry.boundingSphere);\r\n            sphere.applyMatrix4(matrixWorld);\r\n            if (raycaster.ray.intersectsSphere(sphere) === false)\r\n                return;\r\n            //\r\n            inverseMatrix.getInverse(matrixWorld);\r\n            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\r\n            // Check boundingBox before continuing\r\n            if (geometry.boundingBox !== null) {\r\n                if (ray.intersectsBox(geometry.boundingBox) === false)\r\n                    return;\r\n            }\r\n            var intersection;\r\n            if (geometry.isBufferGeometry) {\r\n                var a, b, c;\r\n                var index = geometry.index;\r\n                var position = geometry.attributes.position;\r\n                var morphPosition = geometry.morphAttributes.position;\r\n                var uv = geometry.attributes.uv;\r\n                var uv2 = geometry.attributes.uv2;\r\n                var groups = geometry.groups;\r\n                var drawRange = geometry.drawRange;\r\n                var i, j, il, jl;\r\n                var group, groupMaterial;\r\n                var start, end;\r\n                if (index !== null) {\r\n                    // indexed buffer geometry\r\n                    if (Array.isArray(material)) {\r\n                        for (i = 0, il = groups.length; i < il; i++) {\r\n                            group = groups[i];\r\n                            groupMaterial = material[group.materialIndex];\r\n                            start = Math.max(group.start, drawRange.start);\r\n                            end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));\r\n                            for (j = start, jl = end; j < jl; j += 3) {\r\n                                a = index.getX(j);\r\n                                b = index.getX(j + 1);\r\n                                c = index.getX(j + 2);\r\n                                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, uv2, a, b, c);\r\n                                if (intersection) {\r\n                                    intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\r\n                                    intersection.face.materialIndex = group.materialIndex;\r\n                                    intersects.push(intersection);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        start = Math.max(0, drawRange.start);\r\n                        end = Math.min(index.count, (drawRange.start + drawRange.count));\r\n                        for (i = start, il = end; i < il; i += 3) {\r\n                            a = index.getX(i);\r\n                            b = index.getX(i + 1);\r\n                            c = index.getX(i + 2);\r\n                            intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, uv2, a, b, c);\r\n                            if (intersection) {\r\n                                intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\r\n                                intersects.push(intersection);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if (position !== undefined) {\r\n                    // non-indexed buffer geometry\r\n                    if (Array.isArray(material)) {\r\n                        for (i = 0, il = groups.length; i < il; i++) {\r\n                            group = groups[i];\r\n                            groupMaterial = material[group.materialIndex];\r\n                            start = Math.max(group.start, drawRange.start);\r\n                            end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));\r\n                            for (j = start, jl = end; j < jl; j += 3) {\r\n                                a = j;\r\n                                b = j + 1;\r\n                                c = j + 2;\r\n                                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, uv2, a, b, c);\r\n                                if (intersection) {\r\n                                    intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\r\n                                    intersection.face.materialIndex = group.materialIndex;\r\n                                    intersects.push(intersection);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        start = Math.max(0, drawRange.start);\r\n                        end = Math.min(position.count, (drawRange.start + drawRange.count));\r\n                        for (i = start, il = end; i < il; i += 3) {\r\n                            a = i;\r\n                            b = i + 1;\r\n                            c = i + 2;\r\n                            intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, uv2, a, b, c);\r\n                            if (intersection) {\r\n                                intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\r\n                                intersects.push(intersection);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (geometry.isGeometry) {\r\n                var fvA, fvB, fvC;\r\n                var isMultiMaterial = Array.isArray(material);\r\n                var vertices = geometry.vertices;\r\n                var faces = geometry.faces;\r\n                var uvs;\r\n                var faceVertexUvs = geometry.faceVertexUvs[0];\r\n                if (faceVertexUvs.length > 0)\r\n                    uvs = faceVertexUvs;\r\n                for (var f = 0, fl = faces.length; f < fl; f++) {\r\n                    var face = faces[f];\r\n                    var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;\r\n                    if (faceMaterial === undefined)\r\n                        continue;\r\n                    fvA = vertices[face.a];\r\n                    fvB = vertices[face.b];\r\n                    fvC = vertices[face.c];\r\n                    intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);\r\n                    if (intersection) {\r\n                        if (uvs && uvs[f]) {\r\n                            var uvs_f = uvs[f];\r\n                            uvA.copy(uvs_f[0]);\r\n                            uvB.copy(uvs_f[1]);\r\n                            uvC.copy(uvs_f[2]);\r\n                            intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());\r\n                        }\r\n                        intersection.face = face;\r\n                        intersection.faceIndex = f;\r\n                        intersects.push(intersection);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }()),\r\n    clone: function () {\r\n        return new this.constructor(this.geometry, this.material).copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\nvar geometryId = 0; // Geometry uses even numbers as Id\r\nfunction Geometry() {\r\n    Object.defineProperty(this, 'id', { value: geometryId += 2 });\r\n    this.uuid = _Math.generateUUID();\r\n    this.name = '';\r\n    this.type = 'Geometry';\r\n    this.vertices = [];\r\n    this.colors = [];\r\n    this.faces = [];\r\n    this.faceVertexUvs = [[]];\r\n    this.morphTargets = [];\r\n    this.morphNormals = [];\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null;\r\n    // update flags\r\n    this.elementsNeedUpdate = false;\r\n    this.verticesNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.lineDistancesNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n}\r\nGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: Geometry,\r\n    isGeometry: true,\r\n    applyMatrix: function (matrix) {\r\n        var normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\r\n            var vertex = this.vertices[i];\r\n            vertex.applyMatrix4(matrix);\r\n        }\r\n        for (var i = 0, il = this.faces.length; i < il; i++) {\r\n            var face = this.faces[i];\r\n            face.normal.applyMatrix3(normalMatrix).normalize();\r\n            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\r\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\r\n            }\r\n        }\r\n        if (this.boundingBox !== null) {\r\n            this.computeBoundingBox();\r\n        }\r\n        if (this.boundingSphere !== null) {\r\n            this.computeBoundingSphere();\r\n        }\r\n        this.verticesNeedUpdate = true;\r\n        this.normalsNeedUpdate = true;\r\n        return this;\r\n    },\r\n    rotateX: function () {\r\n        // rotate geometry around world x-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateX(angle) {\r\n            m1.makeRotationX(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateY: function () {\r\n        // rotate geometry around world y-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateY(angle) {\r\n            m1.makeRotationY(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    rotateZ: function () {\r\n        // rotate geometry around world z-axis\r\n        var m1 = new Matrix4();\r\n        return function rotateZ(angle) {\r\n            m1.makeRotationZ(angle);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    translate: function () {\r\n        // translate geometry\r\n        var m1 = new Matrix4();\r\n        return function translate(x, y, z) {\r\n            m1.makeTranslation(x, y, z);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    scale: function () {\r\n        // scale geometry\r\n        var m1 = new Matrix4();\r\n        return function scale(x, y, z) {\r\n            m1.makeScale(x, y, z);\r\n            this.applyMatrix(m1);\r\n            return this;\r\n        };\r\n    }(),\r\n    lookAt: function () {\r\n        var obj = new Object3D();\r\n        return function lookAt(vector) {\r\n            obj.lookAt(vector);\r\n            obj.updateMatrix();\r\n            this.applyMatrix(obj.matrix);\r\n        };\r\n    }(),\r\n    fromBufferGeometry: function (geometry) {\r\n        var scope = this;\r\n        var indices = geometry.index !== null ? geometry.index.array : undefined;\r\n        var attributes = geometry.attributes;\r\n        var positions = attributes.position.array;\r\n        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n        var colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n        if (uvs2 !== undefined)\r\n            this.faceVertexUvs[1] = [];\r\n        for (var i = 0; i < positions.length; i += 3) {\r\n            scope.vertices.push(new Vector3().fromArray(positions, i));\r\n            if (colors !== undefined) {\r\n                scope.colors.push(new Color().fromArray(colors, i));\r\n            }\r\n        }\r\n        function addFace(a, b, c, materialIndex) {\r\n            var vertexColors = (colors === undefined) ? [] : [\r\n                scope.colors[a].clone(),\r\n                scope.colors[b].clone(),\r\n                scope.colors[c].clone()\r\n            ];\r\n            var vertexNormals = (normals === undefined) ? [] : [\r\n                new Vector3().fromArray(normals, a * 3),\r\n                new Vector3().fromArray(normals, b * 3),\r\n                new Vector3().fromArray(normals, c * 3)\r\n            ];\r\n            var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\r\n            scope.faces.push(face);\r\n            if (uvs !== undefined) {\r\n                scope.faceVertexUvs[0].push([\r\n                    new Vector2().fromArray(uvs, a * 2),\r\n                    new Vector2().fromArray(uvs, b * 2),\r\n                    new Vector2().fromArray(uvs, c * 2)\r\n                ]);\r\n            }\r\n            if (uvs2 !== undefined) {\r\n                scope.faceVertexUvs[1].push([\r\n                    new Vector2().fromArray(uvs2, a * 2),\r\n                    new Vector2().fromArray(uvs2, b * 2),\r\n                    new Vector2().fromArray(uvs2, c * 2)\r\n                ]);\r\n            }\r\n        }\r\n        var groups = geometry.groups;\r\n        if (groups.length > 0) {\r\n            for (var i = 0; i < groups.length; i++) {\r\n                var group = groups[i];\r\n                var start = group.start;\r\n                var count = group.count;\r\n                for (var j = start, jl = start + count; j < jl; j += 3) {\r\n                    if (indices !== undefined) {\r\n                        addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);\r\n                    }\r\n                    else {\r\n                        addFace(j, j + 1, j + 2, group.materialIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (indices !== undefined) {\r\n                for (var i = 0; i < indices.length; i += 3) {\r\n                    addFace(indices[i], indices[i + 1], indices[i + 2]);\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i < positions.length / 3; i += 3) {\r\n                    addFace(i, i + 1, i + 2);\r\n                }\r\n            }\r\n        }\r\n        this.computeFaceNormals();\r\n        if (geometry.boundingBox !== null) {\r\n            this.boundingBox = geometry.boundingBox.clone();\r\n        }\r\n        if (geometry.boundingSphere !== null) {\r\n            this.boundingSphere = geometry.boundingSphere.clone();\r\n        }\r\n        return this;\r\n    },\r\n    center: function () {\r\n        var offset = new Vector3();\r\n        return function center() {\r\n            this.computeBoundingBox();\r\n            this.boundingBox.getCenter(offset).negate();\r\n            this.translate(offset.x, offset.y, offset.z);\r\n            return this;\r\n        };\r\n    }(),\r\n    normalize: function () {\r\n        this.computeBoundingSphere();\r\n        var center = this.boundingSphere.center;\r\n        var radius = this.boundingSphere.radius;\r\n        var s = radius === 0 ? 1 : 1.0 / radius;\r\n        var matrix = new Matrix4();\r\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\r\n        this.applyMatrix(matrix);\r\n        return this;\r\n    },\r\n    computeFaceNormals: function () {\r\n        var cb = new Vector3(), ab = new Vector3();\r\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\r\n            var face = this.faces[f];\r\n            var vA = this.vertices[face.a];\r\n            var vB = this.vertices[face.b];\r\n            var vC = this.vertices[face.c];\r\n            cb.subVectors(vC, vB);\r\n            ab.subVectors(vA, vB);\r\n            cb.cross(ab);\r\n            cb.normalize();\r\n            face.normal.copy(cb);\r\n        }\r\n    },\r\n    computeVertexNormals: function (areaWeighted) {\r\n        if (areaWeighted === undefined)\r\n            areaWeighted = true;\r\n        var v, vl, f, fl, face, vertices;\r\n        vertices = new Array(this.vertices.length);\r\n        for (v = 0, vl = this.vertices.length; v < vl; v++) {\r\n            vertices[v] = new Vector3();\r\n        }\r\n        if (areaWeighted) {\r\n            // vertex normals weighted by triangle areas\r\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\r\n            var vA, vB, vC;\r\n            var cb = new Vector3(), ab = new Vector3();\r\n            for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n                face = this.faces[f];\r\n                vA = this.vertices[face.a];\r\n                vB = this.vertices[face.b];\r\n                vC = this.vertices[face.c];\r\n                cb.subVectors(vC, vB);\r\n                ab.subVectors(vA, vB);\r\n                cb.cross(ab);\r\n                vertices[face.a].add(cb);\r\n                vertices[face.b].add(cb);\r\n                vertices[face.c].add(cb);\r\n            }\r\n        }\r\n        else {\r\n            this.computeFaceNormals();\r\n            for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n                face = this.faces[f];\r\n                vertices[face.a].add(face.normal);\r\n                vertices[face.b].add(face.normal);\r\n                vertices[face.c].add(face.normal);\r\n            }\r\n        }\r\n        for (v = 0, vl = this.vertices.length; v < vl; v++) {\r\n            vertices[v].normalize();\r\n        }\r\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n            face = this.faces[f];\r\n            var vertexNormals = face.vertexNormals;\r\n            if (vertexNormals.length === 3) {\r\n                vertexNormals[0].copy(vertices[face.a]);\r\n                vertexNormals[1].copy(vertices[face.b]);\r\n                vertexNormals[2].copy(vertices[face.c]);\r\n            }\r\n            else {\r\n                vertexNormals[0] = vertices[face.a].clone();\r\n                vertexNormals[1] = vertices[face.b].clone();\r\n                vertexNormals[2] = vertices[face.c].clone();\r\n            }\r\n        }\r\n        if (this.faces.length > 0) {\r\n            this.normalsNeedUpdate = true;\r\n        }\r\n    },\r\n    computeFlatVertexNormals: function () {\r\n        var f, fl, face;\r\n        this.computeFaceNormals();\r\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n            face = this.faces[f];\r\n            var vertexNormals = face.vertexNormals;\r\n            if (vertexNormals.length === 3) {\r\n                vertexNormals[0].copy(face.normal);\r\n                vertexNormals[1].copy(face.normal);\r\n                vertexNormals[2].copy(face.normal);\r\n            }\r\n            else {\r\n                vertexNormals[0] = face.normal.clone();\r\n                vertexNormals[1] = face.normal.clone();\r\n                vertexNormals[2] = face.normal.clone();\r\n            }\r\n        }\r\n        if (this.faces.length > 0) {\r\n            this.normalsNeedUpdate = true;\r\n        }\r\n    },\r\n    computeMorphNormals: function () {\r\n        var i, il, f, fl, face;\r\n        // save original normals\r\n        // - create temp variables on first access\r\n        //   otherwise just copy (for faster repeated calls)\r\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n            face = this.faces[f];\r\n            if (!face.__originalFaceNormal) {\r\n                face.__originalFaceNormal = face.normal.clone();\r\n            }\r\n            else {\r\n                face.__originalFaceNormal.copy(face.normal);\r\n            }\r\n            if (!face.__originalVertexNormals)\r\n                face.__originalVertexNormals = [];\r\n            for (i = 0, il = face.vertexNormals.length; i < il; i++) {\r\n                if (!face.__originalVertexNormals[i]) {\r\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\r\n                }\r\n                else {\r\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\r\n                }\r\n            }\r\n        }\r\n        // use temp geometry to compute face and vertex normals for each morph\r\n        var tmpGeo = new Geometry();\r\n        tmpGeo.faces = this.faces;\r\n        for (i = 0, il = this.morphTargets.length; i < il; i++) {\r\n            // create on first access\r\n            if (!this.morphNormals[i]) {\r\n                this.morphNormals[i] = {};\r\n                this.morphNormals[i].faceNormals = [];\r\n                this.morphNormals[i].vertexNormals = [];\r\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\r\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\r\n                var faceNormal, vertexNormals;\r\n                for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n                    faceNormal = new Vector3();\r\n                    vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\r\n                    dstNormalsFace.push(faceNormal);\r\n                    dstNormalsVertex.push(vertexNormals);\r\n                }\r\n            }\r\n            var morphNormals = this.morphNormals[i];\r\n            // set vertices to morph target\r\n            tmpGeo.vertices = this.morphTargets[i].vertices;\r\n            // compute morph normals\r\n            tmpGeo.computeFaceNormals();\r\n            tmpGeo.computeVertexNormals();\r\n            // store morph normals\r\n            var faceNormal, vertexNormals;\r\n            for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n                face = this.faces[f];\r\n                faceNormal = morphNormals.faceNormals[f];\r\n                vertexNormals = morphNormals.vertexNormals[f];\r\n                faceNormal.copy(face.normal);\r\n                vertexNormals.a.copy(face.vertexNormals[0]);\r\n                vertexNormals.b.copy(face.vertexNormals[1]);\r\n                vertexNormals.c.copy(face.vertexNormals[2]);\r\n            }\r\n        }\r\n        // restore original normals\r\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\r\n            face = this.faces[f];\r\n            face.normal = face.__originalFaceNormal;\r\n            face.vertexNormals = face.__originalVertexNormals;\r\n        }\r\n    },\r\n    computeBoundingBox: function () {\r\n        if (this.boundingBox === null) {\r\n            this.boundingBox = new Box3();\r\n        }\r\n        this.boundingBox.setFromPoints(this.vertices);\r\n    },\r\n    computeBoundingSphere: function () {\r\n        if (this.boundingSphere === null) {\r\n            this.boundingSphere = new Sphere();\r\n        }\r\n        this.boundingSphere.setFromPoints(this.vertices);\r\n    },\r\n    merge: function (geometry, matrix, materialIndexOffset) {\r\n        if (!(geometry && geometry.isGeometry)) {\r\n            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\r\n            return;\r\n        }\r\n        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\r\n        if (materialIndexOffset === undefined)\r\n            materialIndexOffset = 0;\r\n        if (matrix !== undefined) {\r\n            normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n        }\r\n        // vertices\r\n        for (var i = 0, il = vertices2.length; i < il; i++) {\r\n            var vertex = vertices2[i];\r\n            var vertexCopy = vertex.clone();\r\n            if (matrix !== undefined)\r\n                vertexCopy.applyMatrix4(matrix);\r\n            vertices1.push(vertexCopy);\r\n        }\r\n        // colors\r\n        for (var i = 0, il = colors2.length; i < il; i++) {\r\n            colors1.push(colors2[i].clone());\r\n        }\r\n        // faces\r\n        for (i = 0, il = faces2.length; i < il; i++) {\r\n            var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\r\n            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\r\n            faceCopy.normal.copy(face.normal);\r\n            if (normalMatrix !== undefined) {\r\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\r\n            }\r\n            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\r\n                normal = faceVertexNormals[j].clone();\r\n                if (normalMatrix !== undefined) {\r\n                    normal.applyMatrix3(normalMatrix).normalize();\r\n                }\r\n                faceCopy.vertexNormals.push(normal);\r\n            }\r\n            faceCopy.color.copy(face.color);\r\n            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\r\n                color = faceVertexColors[j];\r\n                faceCopy.vertexColors.push(color.clone());\r\n            }\r\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n            faces1.push(faceCopy);\r\n        }\r\n        // uvs\r\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\r\n            var faceVertexUvs2 = geometry.faceVertexUvs[i];\r\n            if (this.faceVertexUvs[i] === undefined)\r\n                this.faceVertexUvs[i] = [];\r\n            for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\r\n                var uvs2 = faceVertexUvs2[j], uvsCopy = [];\r\n                for (var k = 0, kl = uvs2.length; k < kl; k++) {\r\n                    uvsCopy.push(uvs2[k].clone());\r\n                }\r\n                this.faceVertexUvs[i].push(uvsCopy);\r\n            }\r\n        }\r\n    },\r\n    mergeMesh: function (mesh) {\r\n        if (!(mesh && mesh.isMesh)) {\r\n            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\r\n            return;\r\n        }\r\n        if (mesh.matrixAutoUpdate)\r\n            mesh.updateMatrix();\r\n        this.merge(mesh.geometry, mesh.matrix);\r\n    },\r\n    /*\r\n     * Checks for duplicate vertices with hashmap.\r\n     * Duplicated vertices are removed\r\n     * and faces' vertices are updated.\r\n     */\r\n    mergeVertices: function () {\r\n        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n        var unique = [], changes = [];\r\n        var v, key;\r\n        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n        var precision = Math.pow(10, precisionPoints);\r\n        var i, il, face;\r\n        var indices, j, jl;\r\n        for (i = 0, il = this.vertices.length; i < il; i++) {\r\n            v = this.vertices[i];\r\n            key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\r\n            if (verticesMap[key] === undefined) {\r\n                verticesMap[key] = i;\r\n                unique.push(this.vertices[i]);\r\n                changes[i] = unique.length - 1;\r\n            }\r\n            else {\r\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n                changes[i] = changes[verticesMap[key]];\r\n            }\r\n        }\r\n        // if faces are completely degenerate after merging vertices, we\r\n        // have to remove them from the geometry.\r\n        var faceIndicesToRemove = [];\r\n        for (i = 0, il = this.faces.length; i < il; i++) {\r\n            face = this.faces[i];\r\n            face.a = changes[face.a];\r\n            face.b = changes[face.b];\r\n            face.c = changes[face.c];\r\n            indices = [face.a, face.b, face.c];\r\n            // if any duplicate vertices are found in a Face3\r\n            // we have to remove the face as nothing can be saved\r\n            for (var n = 0; n < 3; n++) {\r\n                if (indices[n] === indices[(n + 1) % 3]) {\r\n                    faceIndicesToRemove.push(i);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {\r\n            var idx = faceIndicesToRemove[i];\r\n            this.faces.splice(idx, 1);\r\n            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\r\n                this.faceVertexUvs[j].splice(idx, 1);\r\n            }\r\n        }\r\n        // Use unique set of vertices\r\n        var diff = this.vertices.length - unique.length;\r\n        this.vertices = unique;\r\n        return diff;\r\n    },\r\n    setFromPoints: function (points) {\r\n        this.vertices = [];\r\n        for (var i = 0, l = points.length; i < l; i++) {\r\n            var point = points[i];\r\n            this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\r\n        }\r\n        return this;\r\n    },\r\n    sortFacesByMaterialIndex: function () {\r\n        var faces = this.faces;\r\n        var length = faces.length;\r\n        // tag faces\r\n        for (var i = 0; i < length; i++) {\r\n            faces[i]._id = i;\r\n        }\r\n        // sort faces\r\n        function materialIndexSort(a, b) {\r\n            return a.materialIndex - b.materialIndex;\r\n        }\r\n        faces.sort(materialIndexSort);\r\n        // sort uvs\r\n        var uvs1 = this.faceVertexUvs[0];\r\n        var uvs2 = this.faceVertexUvs[1];\r\n        var newUvs1, newUvs2;\r\n        if (uvs1 && uvs1.length === length)\r\n            newUvs1 = [];\r\n        if (uvs2 && uvs2.length === length)\r\n            newUvs2 = [];\r\n        for (var i = 0; i < length; i++) {\r\n            var id = faces[i]._id;\r\n            if (newUvs1)\r\n                newUvs1.push(uvs1[id]);\r\n            if (newUvs2)\r\n                newUvs2.push(uvs2[id]);\r\n        }\r\n        if (newUvs1)\r\n            this.faceVertexUvs[0] = newUvs1;\r\n        if (newUvs2)\r\n            this.faceVertexUvs[1] = newUvs2;\r\n    },\r\n    toJSON: function () {\r\n        var data = {\r\n            metadata: {\r\n                version: 4.5,\r\n                type: 'Geometry',\r\n                generator: 'Geometry.toJSON'\r\n            }\r\n        };\r\n        // standard Geometry serialization\r\n        data.uuid = this.uuid;\r\n        data.type = this.type;\r\n        if (this.name !== '')\r\n            data.name = this.name;\r\n        if (this.parameters !== undefined) {\r\n            var parameters = this.parameters;\r\n            for (var key in parameters) {\r\n                if (parameters[key] !== undefined)\r\n                    data[key] = parameters[key];\r\n            }\r\n            return data;\r\n        }\r\n        var vertices = [];\r\n        for (var i = 0; i < this.vertices.length; i++) {\r\n            var vertex = this.vertices[i];\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n        }\r\n        var faces = [];\r\n        var normals = [];\r\n        var normalsHash = {};\r\n        var colors = [];\r\n        var colorsHash = {};\r\n        var uvs = [];\r\n        var uvsHash = {};\r\n        for (var i = 0; i < this.faces.length; i++) {\r\n            var face = this.faces[i];\r\n            var hasMaterial = true;\r\n            var hasFaceUv = false; // deprecated\r\n            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\r\n            var hasFaceNormal = face.normal.length() > 0;\r\n            var hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n            var hasFaceVertexColor = face.vertexColors.length > 0;\r\n            var faceType = 0;\r\n            faceType = setBit(faceType, 0, 0); // isQuad\r\n            faceType = setBit(faceType, 1, hasMaterial);\r\n            faceType = setBit(faceType, 2, hasFaceUv);\r\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\r\n            faceType = setBit(faceType, 4, hasFaceNormal);\r\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\r\n            faceType = setBit(faceType, 6, hasFaceColor);\r\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\r\n            faces.push(faceType);\r\n            faces.push(face.a, face.b, face.c);\r\n            faces.push(face.materialIndex);\r\n            if (hasFaceVertexUv) {\r\n                var faceVertexUvs = this.faceVertexUvs[0][i];\r\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\r\n            }\r\n            if (hasFaceNormal) {\r\n                faces.push(getNormalIndex(face.normal));\r\n            }\r\n            if (hasFaceVertexNormal) {\r\n                var vertexNormals = face.vertexNormals;\r\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\r\n            }\r\n            if (hasFaceColor) {\r\n                faces.push(getColorIndex(face.color));\r\n            }\r\n            if (hasFaceVertexColor) {\r\n                var vertexColors = face.vertexColors;\r\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\r\n            }\r\n        }\r\n        function setBit(value, position, enabled) {\r\n            return enabled ? value | (1 << position) : value & (~(1 << position));\r\n        }\r\n        function getNormalIndex(normal) {\r\n            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n            if (normalsHash[hash] !== undefined) {\r\n                return normalsHash[hash];\r\n            }\r\n            normalsHash[hash] = normals.length / 3;\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            return normalsHash[hash];\r\n        }\r\n        function getColorIndex(color) {\r\n            var hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n            if (colorsHash[hash] !== undefined) {\r\n                return colorsHash[hash];\r\n            }\r\n            colorsHash[hash] = colors.length;\r\n            colors.push(color.getHex());\r\n            return colorsHash[hash];\r\n        }\r\n        function getUvIndex(uv) {\r\n            var hash = uv.x.toString() + uv.y.toString();\r\n            if (uvsHash[hash] !== undefined) {\r\n                return uvsHash[hash];\r\n            }\r\n            uvsHash[hash] = uvs.length / 2;\r\n            uvs.push(uv.x, uv.y);\r\n            return uvsHash[hash];\r\n        }\r\n        data.data = {};\r\n        data.data.vertices = vertices;\r\n        data.data.normals = normals;\r\n        if (colors.length > 0)\r\n            data.data.colors = colors;\r\n        if (uvs.length > 0)\r\n            data.data.uvs = [uvs]; // temporal backward compatibility\r\n        data.data.faces = faces;\r\n        return data;\r\n    },\r\n    clone: function () {\r\n        /*\r\n         // Handle primitives\r\n\r\n         var parameters = this.parameters;\r\n\r\n         if ( parameters !== undefined ) {\r\n\r\n         var values = [];\r\n\r\n         for ( var key in parameters ) {\r\n\r\n         values.push( parameters[ key ] );\r\n\r\n         }\r\n\r\n         var geometry = Object.create( this.constructor.prototype );\r\n         this.constructor.apply( geometry, values );\r\n         return geometry;\r\n\r\n         }\r\n\r\n         return new this.constructor().copy( this );\r\n         */\r\n        return new Geometry().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        var i, il, j, jl, k, kl;\r\n        // reset\r\n        this.vertices = [];\r\n        this.colors = [];\r\n        this.faces = [];\r\n        this.faceVertexUvs = [[]];\r\n        this.morphTargets = [];\r\n        this.morphNormals = [];\r\n        this.skinWeights = [];\r\n        this.skinIndices = [];\r\n        this.lineDistances = [];\r\n        this.boundingBox = null;\r\n        this.boundingSphere = null;\r\n        // name\r\n        this.name = source.name;\r\n        // vertices\r\n        var vertices = source.vertices;\r\n        for (i = 0, il = vertices.length; i < il; i++) {\r\n            this.vertices.push(vertices[i].clone());\r\n        }\r\n        // colors\r\n        var colors = source.colors;\r\n        for (i = 0, il = colors.length; i < il; i++) {\r\n            this.colors.push(colors[i].clone());\r\n        }\r\n        // faces\r\n        var faces = source.faces;\r\n        for (i = 0, il = faces.length; i < il; i++) {\r\n            this.faces.push(faces[i].clone());\r\n        }\r\n        // face vertex uvs\r\n        for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {\r\n            var faceVertexUvs = source.faceVertexUvs[i];\r\n            if (this.faceVertexUvs[i] === undefined) {\r\n                this.faceVertexUvs[i] = [];\r\n            }\r\n            for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {\r\n                var uvs = faceVertexUvs[j], uvsCopy = [];\r\n                for (k = 0, kl = uvs.length; k < kl; k++) {\r\n                    var uv = uvs[k];\r\n                    uvsCopy.push(uv.clone());\r\n                }\r\n                this.faceVertexUvs[i].push(uvsCopy);\r\n            }\r\n        }\r\n        // morph targets\r\n        var morphTargets = source.morphTargets;\r\n        for (i = 0, il = morphTargets.length; i < il; i++) {\r\n            var morphTarget = {};\r\n            morphTarget.name = morphTargets[i].name;\r\n            // vertices\r\n            if (morphTargets[i].vertices !== undefined) {\r\n                morphTarget.vertices = [];\r\n                for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\r\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\r\n                }\r\n            }\r\n            // normals\r\n            if (morphTargets[i].normals !== undefined) {\r\n                morphTarget.normals = [];\r\n                for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\r\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\r\n                }\r\n            }\r\n            this.morphTargets.push(morphTarget);\r\n        }\r\n        // morph normals\r\n        var morphNormals = source.morphNormals;\r\n        for (i = 0, il = morphNormals.length; i < il; i++) {\r\n            var morphNormal = {};\r\n            // vertex normals\r\n            if (morphNormals[i].vertexNormals !== undefined) {\r\n                morphNormal.vertexNormals = [];\r\n                for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\r\n                    var srcVertexNormal = morphNormals[i].vertexNormals[j];\r\n                    var destVertexNormal = {};\r\n                    destVertexNormal.a = srcVertexNormal.a.clone();\r\n                    destVertexNormal.b = srcVertexNormal.b.clone();\r\n                    destVertexNormal.c = srcVertexNormal.c.clone();\r\n                    morphNormal.vertexNormals.push(destVertexNormal);\r\n                }\r\n            }\r\n            // face normals\r\n            if (morphNormals[i].faceNormals !== undefined) {\r\n                morphNormal.faceNormals = [];\r\n                for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\r\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\r\n                }\r\n            }\r\n            this.morphNormals.push(morphNormal);\r\n        }\r\n        // skin weights\r\n        var skinWeights = source.skinWeights;\r\n        for (i = 0, il = skinWeights.length; i < il; i++) {\r\n            this.skinWeights.push(skinWeights[i].clone());\r\n        }\r\n        // skin indices\r\n        var skinIndices = source.skinIndices;\r\n        for (i = 0, il = skinIndices.length; i < il; i++) {\r\n            this.skinIndices.push(skinIndices[i].clone());\r\n        }\r\n        // line distances\r\n        var lineDistances = source.lineDistances;\r\n        for (i = 0, il = lineDistances.length; i < il; i++) {\r\n            this.lineDistances.push(lineDistances[i]);\r\n        }\r\n        // bounding box\r\n        var boundingBox = source.boundingBox;\r\n        if (boundingBox !== null) {\r\n            this.boundingBox = boundingBox.clone();\r\n        }\r\n        // bounding sphere\r\n        var boundingSphere = source.boundingSphere;\r\n        if (boundingSphere !== null) {\r\n            this.boundingSphere = boundingSphere.clone();\r\n        }\r\n        // update flags\r\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\r\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\r\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\r\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\r\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\r\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\r\n        return this;\r\n    },\r\n    dispose: function () {\r\n        this.dispatchEvent({ type: 'dispose' });\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// BoxGeometry\r\nfunction BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {\r\n    Geometry.call(this);\r\n    this.type = 'BoxGeometry';\r\n    this.parameters = {\r\n        width: width,\r\n        height: height,\r\n        depth: depth,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments,\r\n        depthSegments: depthSegments\r\n    };\r\n    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));\r\n    this.mergeVertices();\r\n}\r\nBoxGeometry.prototype = Object.create(Geometry.prototype);\r\nBoxGeometry.prototype.constructor = BoxGeometry;\r\n// BoxBufferGeometry\r\nfunction BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'BoxBufferGeometry';\r\n    this.parameters = {\r\n        width: width,\r\n        height: height,\r\n        depth: depth,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments,\r\n        depthSegments: depthSegments\r\n    };\r\n    var scope = this;\r\n    width = width || 1;\r\n    height = height || 1;\r\n    depth = depth || 1;\r\n    // segments\r\n    widthSegments = Math.floor(widthSegments) || 1;\r\n    heightSegments = Math.floor(heightSegments) || 1;\r\n    depthSegments = Math.floor(depthSegments) || 1;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var numberOfVertices = 0;\r\n    var groupStart = 0;\r\n    // build each side of the box geometry\r\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\r\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\r\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\r\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\r\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\r\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\r\n        var segmentWidth = width / gridX;\r\n        var segmentHeight = height / gridY;\r\n        var widthHalf = width / 2;\r\n        var heightHalf = height / 2;\r\n        var depthHalf = depth / 2;\r\n        var gridX1 = gridX + 1;\r\n        var gridY1 = gridY + 1;\r\n        var vertexCounter = 0;\r\n        var groupCount = 0;\r\n        var ix, iy;\r\n        var vector = new Vector3();\r\n        // generate vertices, normals and uvs\r\n        for (iy = 0; iy < gridY1; iy++) {\r\n            var y = iy * segmentHeight - heightHalf;\r\n            for (ix = 0; ix < gridX1; ix++) {\r\n                var x = ix * segmentWidth - widthHalf;\r\n                // set values to correct vector component\r\n                vector[u] = x * udir;\r\n                vector[v] = y * vdir;\r\n                vector[w] = depthHalf;\r\n                // now apply vector to vertex buffer\r\n                vertices.push(vector.x, vector.y, vector.z);\r\n                // set values to correct vector component\r\n                vector[u] = 0;\r\n                vector[v] = 0;\r\n                vector[w] = depth > 0 ? 1 : -1;\r\n                // now apply vector to normal buffer\r\n                normals.push(vector.x, vector.y, vector.z);\r\n                // uvs\r\n                uvs.push(ix / gridX);\r\n                uvs.push(1 - (iy / gridY));\r\n                // counters\r\n                vertexCounter += 1;\r\n            }\r\n        }\r\n        // indices\r\n        // 1. you need three indices to draw a single face\r\n        // 2. a single segment consists of two faces\r\n        // 3. so we need to generate six (2*3) indices per segment\r\n        for (iy = 0; iy < gridY; iy++) {\r\n            for (ix = 0; ix < gridX; ix++) {\r\n                var a = numberOfVertices + ix + gridX1 * iy;\r\n                var b = numberOfVertices + ix + gridX1 * (iy + 1);\r\n                var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\r\n                var d = numberOfVertices + (ix + 1) + gridX1 * iy;\r\n                // faces\r\n                indices.push(a, b, d);\r\n                indices.push(b, c, d);\r\n                // increase counter\r\n                groupCount += 6;\r\n            }\r\n        }\r\n        // add a group to the geometry. this will ensure multi material support\r\n        scope.addGroup(groupStart, groupCount, materialIndex);\r\n        // calculate new start value for groups\r\n        groupStart += groupCount;\r\n        // update total number of vertices\r\n        numberOfVertices += vertexCounter;\r\n    }\r\n}\r\nBoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\r\n/**\r\n * Uniform Utilities\r\n */\r\nfunction cloneUniforms(src) {\r\n    var dst = {};\r\n    for (var u in src) {\r\n        dst[u] = {};\r\n        for (var p in src[u]) {\r\n            var property = src[u][p];\r\n            if (property && (property.isColor ||\r\n                property.isMatrix3 || property.isMatrix4 ||\r\n                property.isVector2 || property.isVector3 || property.isVector4 ||\r\n                property.isTexture)) {\r\n                dst[u][p] = property.clone();\r\n            }\r\n            else if (Array.isArray(property)) {\r\n                dst[u][p] = property.slice();\r\n            }\r\n            else {\r\n                dst[u][p] = property;\r\n            }\r\n        }\r\n    }\r\n    return dst;\r\n}\r\nfunction mergeUniforms(uniforms) {\r\n    var merged = {};\r\n    for (var u = 0; u < uniforms.length; u++) {\r\n        var tmp = cloneUniforms(uniforms[u]);\r\n        for (var p in tmp) {\r\n            merged[p] = tmp[p];\r\n        }\r\n    }\r\n    return merged;\r\n}\r\n// Legacy\r\nvar UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\r\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\r\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction ShaderMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'ShaderMaterial';\r\n    this.defines = {};\r\n    this.uniforms = {};\r\n    this.vertexShader = default_vertex;\r\n    this.fragmentShader = default_fragment;\r\n    this.linewidth = 1;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.fog = false; // set to use scene fog\r\n    this.lights = false; // set to use scene lights\r\n    this.clipping = false; // set to use user-defined clipping planes\r\n    this.skinning = false; // set to use skinning attribute streams\r\n    this.morphTargets = false; // set to use morph targets\r\n    this.morphNormals = false; // set to use morph normals\r\n    this.extensions = {\r\n        derivatives: false,\r\n        fragDepth: false,\r\n        drawBuffers: false,\r\n        shaderTextureLOD: false // set to use shader texture LOD\r\n    };\r\n    // When rendered geometry doesn't include these attributes but the material does,\r\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\r\n    this.defaultAttributeValues = {\r\n        'color': [1, 1, 1],\r\n        'uv': [0, 0],\r\n        'uv2': [0, 0]\r\n    };\r\n    this.index0AttributeName = undefined;\r\n    this.uniformsNeedUpdate = false;\r\n    if (parameters !== undefined) {\r\n        if (parameters.attributes !== undefined) {\r\n            console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\r\n        }\r\n        this.setValues(parameters);\r\n    }\r\n}\r\nShaderMaterial.prototype = Object.create(Material$1.prototype);\r\nShaderMaterial.prototype.constructor = ShaderMaterial;\r\nShaderMaterial.prototype.isShaderMaterial = true;\r\nShaderMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.fragmentShader = source.fragmentShader;\r\n    this.vertexShader = source.vertexShader;\r\n    this.uniforms = cloneUniforms(source.uniforms);\r\n    this.defines = Object.assign({}, source.defines);\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.lights = source.lights;\r\n    this.clipping = source.clipping;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    this.extensions = source.extensions;\r\n    return this;\r\n};\r\nShaderMaterial.prototype.toJSON = function (meta) {\r\n    var data = Material$1.prototype.toJSON.call(this, meta);\r\n    data.uniforms = {};\r\n    for (var name in this.uniforms) {\r\n        var uniform = this.uniforms[name];\r\n        var value = uniform.value;\r\n        if (value && value.isTexture) {\r\n            data.uniforms[name] = {\r\n                type: 't',\r\n                value: value.toJSON(meta).uuid\r\n            };\r\n        }\r\n        else if (value && value.isColor) {\r\n            data.uniforms[name] = {\r\n                type: 'c',\r\n                value: value.getHex()\r\n            };\r\n        }\r\n        else if (value && value.isVector2) {\r\n            data.uniforms[name] = {\r\n                type: 'v2',\r\n                value: value.toArray()\r\n            };\r\n        }\r\n        else if (value && value.isVector3) {\r\n            data.uniforms[name] = {\r\n                type: 'v3',\r\n                value: value.toArray()\r\n            };\r\n        }\r\n        else if (value && value.isVector4) {\r\n            data.uniforms[name] = {\r\n                type: 'v4',\r\n                value: value.toArray()\r\n            };\r\n        }\r\n        else if (value && value.isMatrix3) {\r\n            data.uniforms[name] = {\r\n                type: 'm3',\r\n                value: value.toArray()\r\n            };\r\n        }\r\n        else if (value && value.isMatrix4) {\r\n            data.uniforms[name] = {\r\n                type: 'm4',\r\n                value: value.toArray()\r\n            };\r\n        }\r\n        else {\r\n            data.uniforms[name] = {\r\n                value: value\r\n            };\r\n            // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\r\n        }\r\n    }\r\n    if (Object.keys(this.defines).length > 0)\r\n        data.defines = this.defines;\r\n    data.vertexShader = this.vertexShader;\r\n    data.fragmentShader = this.fragmentShader;\r\n    var extensions = {};\r\n    for (var key in this.extensions) {\r\n        if (this.extensions[key] === true)\r\n            extensions[key] = true;\r\n    }\r\n    if (Object.keys(extensions).length > 0)\r\n        data.extensions = extensions;\r\n    return data;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\nfunction Camera() {\r\n    Object3D.call(this);\r\n    this.type = 'Camera';\r\n    this.matrixWorldInverse = new Matrix4();\r\n    this.projectionMatrix = new Matrix4();\r\n    this.projectionMatrixInverse = new Matrix4();\r\n}\r\nCamera.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Camera,\r\n    isCamera: true,\r\n    copy: function (source, recursive) {\r\n        Object3D.prototype.copy.call(this, source, recursive);\r\n        this.matrixWorldInverse.copy(source.matrixWorldInverse);\r\n        this.projectionMatrix.copy(source.projectionMatrix);\r\n        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\r\n        return this;\r\n    },\r\n    getWorldDirection: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Camera: .getWorldDirection() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        this.updateMatrixWorld(true);\r\n        var e = this.matrixWorld.elements;\r\n        return target.set(-e[8], -e[9], -e[10]).normalize();\r\n    },\r\n    updateMatrixWorld: function (force) {\r\n        Object3D.prototype.updateMatrixWorld.call(this, force);\r\n        this.matrixWorldInverse.getInverse(this.matrixWorld);\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author tschw\r\n */\r\nfunction PerspectiveCamera(fov, aspect, near, far) {\r\n    Camera.call(this);\r\n    this.type = 'PerspectiveCamera';\r\n    this.fov = fov !== undefined ? fov : 50;\r\n    this.zoom = 1;\r\n    this.near = near !== undefined ? near : 0.1;\r\n    this.far = far !== undefined ? far : 2000;\r\n    this.focus = 10;\r\n    this.aspect = aspect !== undefined ? aspect : 1;\r\n    this.view = null;\r\n    this.filmGauge = 35; // width of the film (default in millimeters)\r\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\r\n    this.updateProjectionMatrix();\r\n}\r\nPerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {\r\n    constructor: PerspectiveCamera,\r\n    isPerspectiveCamera: true,\r\n    copy: function (source, recursive) {\r\n        Camera.prototype.copy.call(this, source, recursive);\r\n        this.fov = source.fov;\r\n        this.zoom = source.zoom;\r\n        this.near = source.near;\r\n        this.far = source.far;\r\n        this.focus = source.focus;\r\n        this.aspect = source.aspect;\r\n        this.view = source.view === null ? null : Object.assign({}, source.view);\r\n        this.filmGauge = source.filmGauge;\r\n        this.filmOffset = source.filmOffset;\r\n        return this;\r\n    },\r\n    /**\r\n     * Sets the FOV by focal length in respect to the current .filmGauge.\r\n     *\r\n     * The default film gauge is 35, so that the focal length can be specified for\r\n     * a 35mm (full frame) camera.\r\n     *\r\n     * Values for focal length and film gauge must have the same unit.\r\n     */\r\n    setFocalLength: function (focalLength) {\r\n        // see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n        this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);\r\n        this.updateProjectionMatrix();\r\n    },\r\n    /**\r\n     * Calculates the focal length from the current .fov and .filmGauge.\r\n     */\r\n    getFocalLength: function () {\r\n        var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);\r\n        return 0.5 * this.getFilmHeight() / vExtentSlope;\r\n    },\r\n    getEffectiveFOV: function () {\r\n        return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);\r\n    },\r\n    getFilmWidth: function () {\r\n        // film not completely covered in portrait format (aspect < 1)\r\n        return this.filmGauge * Math.min(this.aspect, 1);\r\n    },\r\n    getFilmHeight: function () {\r\n        // film not completely covered in landscape format (aspect > 1)\r\n        return this.filmGauge / Math.max(this.aspect, 1);\r\n    },\r\n    /**\r\n     * Sets an offset in a larger frustum. This is useful for multi-window or\r\n     * multi-monitor/multi-machine setups.\r\n     *\r\n     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n     * the monitors are in grid like this\r\n     *\r\n     *   +---+---+---+\r\n     *   | A | B | C |\r\n     *   +---+---+---+\r\n     *   | D | E | F |\r\n     *   +---+---+---+\r\n     *\r\n     * then for each monitor you would call it like this\r\n     *\r\n     *   var w = 1920;\r\n     *   var h = 1080;\r\n     *   var fullWidth = w * 3;\r\n     *   var fullHeight = h * 2;\r\n     *\r\n     *   --A--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n     *   --B--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n     *   --C--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n     *   --D--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n     *   --E--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n     *   --F--\r\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n     *\r\n     *   Note there is no reason monitors have to be the same size or in a grid.\r\n     */\r\n    setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {\r\n        this.aspect = fullWidth / fullHeight;\r\n        if (this.view === null) {\r\n            this.view = {\r\n                enabled: true,\r\n                fullWidth: 1,\r\n                fullHeight: 1,\r\n                offsetX: 0,\r\n                offsetY: 0,\r\n                width: 1,\r\n                height: 1\r\n            };\r\n        }\r\n        this.view.enabled = true;\r\n        this.view.fullWidth = fullWidth;\r\n        this.view.fullHeight = fullHeight;\r\n        this.view.offsetX = x;\r\n        this.view.offsetY = y;\r\n        this.view.width = width;\r\n        this.view.height = height;\r\n        this.updateProjectionMatrix();\r\n    },\r\n    clearViewOffset: function () {\r\n        if (this.view !== null) {\r\n            this.view.enabled = false;\r\n        }\r\n        this.updateProjectionMatrix();\r\n    },\r\n    updateProjectionMatrix: function () {\r\n        var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;\r\n        if (this.view !== null && this.view.enabled) {\r\n            var fullWidth = view.fullWidth, fullHeight = view.fullHeight;\r\n            left += view.offsetX * width / fullWidth;\r\n            top -= view.offsetY * height / fullHeight;\r\n            width *= view.width / fullWidth;\r\n            height *= view.height / fullHeight;\r\n        }\r\n        var skew = this.filmOffset;\r\n        if (skew !== 0)\r\n            left += near * skew / this.getFilmWidth();\r\n        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\r\n        this.projectionMatrixInverse.getInverse(this.projectionMatrix);\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Object3D.prototype.toJSON.call(this, meta);\r\n        data.object.fov = this.fov;\r\n        data.object.zoom = this.zoom;\r\n        data.object.near = this.near;\r\n        data.object.far = this.far;\r\n        data.object.focus = this.focus;\r\n        data.object.aspect = this.aspect;\r\n        if (this.view !== null)\r\n            data.object.view = Object.assign({}, this.view);\r\n        data.object.filmGauge = this.filmGauge;\r\n        data.object.filmOffset = this.filmOffset;\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nvar fov = 90, aspect = 1;\r\nfunction CubeCamera(near, far, cubeResolution, options) {\r\n    Object3D.call(this);\r\n    this.type = 'CubeCamera';\r\n    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraPX.up.set(0, -1, 0);\r\n    cameraPX.lookAt(new Vector3(1, 0, 0));\r\n    this.add(cameraPX);\r\n    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraNX.up.set(0, -1, 0);\r\n    cameraNX.lookAt(new Vector3(-1, 0, 0));\r\n    this.add(cameraNX);\r\n    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraPY.up.set(0, 0, 1);\r\n    cameraPY.lookAt(new Vector3(0, 1, 0));\r\n    this.add(cameraPY);\r\n    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraNY.up.set(0, 0, -1);\r\n    cameraNY.lookAt(new Vector3(0, -1, 0));\r\n    this.add(cameraNY);\r\n    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraPZ.up.set(0, -1, 0);\r\n    cameraPZ.lookAt(new Vector3(0, 0, 1));\r\n    this.add(cameraPZ);\r\n    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\r\n    cameraNZ.up.set(0, -1, 0);\r\n    cameraNZ.lookAt(new Vector3(0, 0, -1));\r\n    this.add(cameraNZ);\r\n    options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\r\n    this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);\r\n    this.renderTarget.texture.name = \"CubeCamera\";\r\n    this.update = function (renderer, scene) {\r\n        if (this.parent === null)\r\n            this.updateMatrixWorld();\r\n        var currentRenderTarget = renderer.getRenderTarget();\r\n        var renderTarget = this.renderTarget;\r\n        var generateMipmaps = renderTarget.texture.generateMipmaps;\r\n        renderTarget.texture.generateMipmaps = false;\r\n        renderer.setRenderTarget(renderTarget, 0);\r\n        renderer.render(scene, cameraPX);\r\n        renderer.setRenderTarget(renderTarget, 1);\r\n        renderer.render(scene, cameraNX);\r\n        renderer.setRenderTarget(renderTarget, 2);\r\n        renderer.render(scene, cameraPY);\r\n        renderer.setRenderTarget(renderTarget, 3);\r\n        renderer.render(scene, cameraNY);\r\n        renderer.setRenderTarget(renderTarget, 4);\r\n        renderer.render(scene, cameraPZ);\r\n        renderTarget.texture.generateMipmaps = generateMipmaps;\r\n        renderer.setRenderTarget(renderTarget, 5);\r\n        renderer.render(scene, cameraNZ);\r\n        renderer.setRenderTarget(currentRenderTarget);\r\n    };\r\n    this.clear = function (renderer, color, depth, stencil) {\r\n        var currentRenderTarget = renderer.getRenderTarget();\r\n        var renderTarget = this.renderTarget;\r\n        for (var i = 0; i < 6; i++) {\r\n            renderer.setRenderTarget(renderTarget, i);\r\n            renderer.clear(color, depth, stencil);\r\n        }\r\n        renderer.setRenderTarget(currentRenderTarget);\r\n    };\r\n}\r\nCubeCamera.prototype = Object.create(Object3D.prototype);\r\nCubeCamera.prototype.constructor = CubeCamera;\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction WebGLRenderTargetCube(width, height, options) {\r\n    WebGLRenderTarget.call(this, width, height, options);\r\n}\r\nWebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);\r\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\r\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\r\nWebGLRenderTargetCube.prototype.fromEquirectangularTexture = function (renderer, texture) {\r\n    this.texture.type = texture.type;\r\n    this.texture.format = texture.format;\r\n    this.texture.encoding = texture.encoding;\r\n    var scene = new Scene();\r\n    var shader = {\r\n        uniforms: {\r\n            tEquirect: { value: null },\r\n        },\r\n        vertexShader: [\r\n            \"varying vec3 vWorldDirection;\",\r\n            \"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\",\r\n            \"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\",\r\n            \"}\",\r\n            \"void main() {\",\r\n            \"\tvWorldDirection = transformDirection( position, modelMatrix );\",\r\n            \"\t#include <begin_vertex>\",\r\n            \"\t#include <project_vertex>\",\r\n            \"}\"\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            \"uniform sampler2D tEquirect;\",\r\n            \"varying vec3 vWorldDirection;\",\r\n            \"#define RECIPROCAL_PI 0.31830988618\",\r\n            \"#define RECIPROCAL_PI2 0.15915494\",\r\n            \"void main() {\",\r\n            \"\tvec3 direction = normalize( vWorldDirection );\",\r\n            \"\tvec2 sampleUV;\",\r\n            \"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\",\r\n            \"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n            \"\tgl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n            \"}\"\r\n        ].join('\\n'),\r\n    };\r\n    var material = new ShaderMaterial({\r\n        type: 'CubemapFromEquirect',\r\n        uniforms: cloneUniforms(shader.uniforms),\r\n        vertexShader: shader.vertexShader,\r\n        fragmentShader: shader.fragmentShader,\r\n        side: BackSide,\r\n        blending: NoBlending\r\n    });\r\n    material.uniforms.tEquirect.value = texture;\r\n    var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);\r\n    scene.add(mesh);\r\n    var camera = new CubeCamera(1, 10, 1);\r\n    camera.renderTarget = this;\r\n    camera.renderTarget.texture.name = 'CubeCameraTexture';\r\n    camera.update(renderer, scene);\r\n    mesh.geometry.dispose();\r\n    mesh.material.dispose();\r\n    return this;\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\r\n    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\r\n    this.image = { data: data, width: width, height: height };\r\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\r\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\r\n    this.generateMipmaps = false;\r\n    this.flipY = false;\r\n    this.unpackAlignment = 1;\r\n}\r\nDataTexture.prototype = Object.create(Texture.prototype);\r\nDataTexture.prototype.constructor = DataTexture;\r\nDataTexture.prototype.isDataTexture = true;\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\nfunction Plane(normal, constant) {\r\n    // normal is assumed to be normalized\r\n    this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);\r\n    this.constant = (constant !== undefined) ? constant : 0;\r\n}\r\nObject.assign(Plane.prototype, {\r\n    isPlane: true,\r\n    set: function (normal, constant) {\r\n        this.normal.copy(normal);\r\n        this.constant = constant;\r\n        return this;\r\n    },\r\n    setComponents: function (x, y, z, w) {\r\n        this.normal.set(x, y, z);\r\n        this.constant = w;\r\n        return this;\r\n    },\r\n    setFromNormalAndCoplanarPoint: function (normal, point) {\r\n        this.normal.copy(normal);\r\n        this.constant = -point.dot(this.normal);\r\n        return this;\r\n    },\r\n    setFromCoplanarPoints: function () {\r\n        var v1 = new Vector3();\r\n        var v2 = new Vector3();\r\n        return function setFromCoplanarPoints(a, b, c) {\r\n            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();\r\n            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n            this.setFromNormalAndCoplanarPoint(normal, a);\r\n            return this;\r\n        };\r\n    }(),\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (plane) {\r\n        this.normal.copy(plane.normal);\r\n        this.constant = plane.constant;\r\n        return this;\r\n    },\r\n    normalize: function () {\r\n        // Note: will lead to a divide by zero if the plane is invalid.\r\n        var inverseNormalLength = 1.0 / this.normal.length();\r\n        this.normal.multiplyScalar(inverseNormalLength);\r\n        this.constant *= inverseNormalLength;\r\n        return this;\r\n    },\r\n    negate: function () {\r\n        this.constant *= -1;\r\n        this.normal.negate();\r\n        return this;\r\n    },\r\n    distanceToPoint: function (point) {\r\n        return this.normal.dot(point) + this.constant;\r\n    },\r\n    distanceToSphere: function (sphere) {\r\n        return this.distanceToPoint(sphere.center) - sphere.radius;\r\n    },\r\n    projectPoint: function (point, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Plane: .projectPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\r\n    },\r\n    intersectLine: function () {\r\n        var v1 = new Vector3();\r\n        return function intersectLine(line, target) {\r\n            if (target === undefined) {\r\n                console.warn('THREE.Plane: .intersectLine() target is now required');\r\n                target = new Vector3();\r\n            }\r\n            var direction = line.delta(v1);\r\n            var denominator = this.normal.dot(direction);\r\n            if (denominator === 0) {\r\n                // line is coplanar, return origin\r\n                if (this.distanceToPoint(line.start) === 0) {\r\n                    return target.copy(line.start);\r\n                }\r\n                // Unsure if this is the correct method to handle this case.\r\n                return undefined;\r\n            }\r\n            var t = -(line.start.dot(this.normal) + this.constant) / denominator;\r\n            if (t < 0 || t > 1) {\r\n                return undefined;\r\n            }\r\n            return target.copy(direction).multiplyScalar(t).add(line.start);\r\n        };\r\n    }(),\r\n    intersectsLine: function (line) {\r\n        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n        var startSign = this.distanceToPoint(line.start);\r\n        var endSign = this.distanceToPoint(line.end);\r\n        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);\r\n    },\r\n    intersectsBox: function (box) {\r\n        return box.intersectsPlane(this);\r\n    },\r\n    intersectsSphere: function (sphere) {\r\n        return sphere.intersectsPlane(this);\r\n    },\r\n    coplanarPoint: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Plane: .coplanarPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.copy(this.normal).multiplyScalar(-this.constant);\r\n    },\r\n    applyMatrix4: function () {\r\n        var v1 = new Vector3();\r\n        var m1 = new Matrix3();\r\n        return function applyMatrix4(matrix, optionalNormalMatrix) {\r\n            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);\r\n            var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);\r\n            var normal = this.normal.applyMatrix3(normalMatrix).normalize();\r\n            this.constant = -referencePoint.dot(normal);\r\n            return this;\r\n        };\r\n    }(),\r\n    translate: function (offset) {\r\n        this.constant -= offset.dot(this.normal);\r\n        return this;\r\n    },\r\n    equals: function (plane) {\r\n        return plane.normal.equals(this.normal) && (plane.constant === this.constant);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://clara.io\r\n */\r\nfunction Frustum(p0, p1, p2, p3, p4, p5) {\r\n    this.planes = [\r\n        (p0 !== undefined) ? p0 : new Plane(),\r\n        (p1 !== undefined) ? p1 : new Plane(),\r\n        (p2 !== undefined) ? p2 : new Plane(),\r\n        (p3 !== undefined) ? p3 : new Plane(),\r\n        (p4 !== undefined) ? p4 : new Plane(),\r\n        (p5 !== undefined) ? p5 : new Plane()\r\n    ];\r\n}\r\nObject.assign(Frustum.prototype, {\r\n    set: function (p0, p1, p2, p3, p4, p5) {\r\n        var planes = this.planes;\r\n        planes[0].copy(p0);\r\n        planes[1].copy(p1);\r\n        planes[2].copy(p2);\r\n        planes[3].copy(p3);\r\n        planes[4].copy(p4);\r\n        planes[5].copy(p5);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (frustum) {\r\n        var planes = this.planes;\r\n        for (var i = 0; i < 6; i++) {\r\n            planes[i].copy(frustum.planes[i]);\r\n        }\r\n        return this;\r\n    },\r\n    setFromMatrix: function (m) {\r\n        var planes = this.planes;\r\n        var me = m.elements;\r\n        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\r\n        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\r\n        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\r\n        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\r\n        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\r\n        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\r\n        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\r\n        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\r\n        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\r\n        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\r\n        return this;\r\n    },\r\n    intersectsObject: function () {\r\n        var sphere = new Sphere();\r\n        return function intersectsObject(object) {\r\n            var geometry = object.geometry;\r\n            if (geometry.boundingSphere === null)\r\n                geometry.computeBoundingSphere();\r\n            sphere.copy(geometry.boundingSphere)\r\n                .applyMatrix4(object.matrixWorld);\r\n            return this.intersectsSphere(sphere);\r\n        };\r\n    }(),\r\n    intersectsSprite: function () {\r\n        var sphere = new Sphere();\r\n        return function intersectsSprite(sprite) {\r\n            sphere.center.set(0, 0, 0);\r\n            sphere.radius = 0.7071067811865476;\r\n            sphere.applyMatrix4(sprite.matrixWorld);\r\n            return this.intersectsSphere(sphere);\r\n        };\r\n    }(),\r\n    intersectsSphere: function (sphere) {\r\n        var planes = this.planes;\r\n        var center = sphere.center;\r\n        var negRadius = -sphere.radius;\r\n        for (var i = 0; i < 6; i++) {\r\n            var distance = planes[i].distanceToPoint(center);\r\n            if (distance < negRadius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    intersectsBox: function () {\r\n        var p = new Vector3();\r\n        return function intersectsBox(box) {\r\n            var planes = this.planes;\r\n            for (var i = 0; i < 6; i++) {\r\n                var plane = planes[i];\r\n                // corner at max distance\r\n                p.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n                p.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n                p.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n                if (plane.distanceToPoint(p) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n    }(),\r\n    containsPoint: function (point) {\r\n        var planes = this.planes;\r\n        for (var i = 0; i < 6; i++) {\r\n            if (planes[i].distanceToPoint(point) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n});\r\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\r\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\r\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\r\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\r\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\r\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\r\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\r\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\";\r\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\r\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\r\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\r\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\";\r\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\";\r\nvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\nvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\r\nvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\r\nvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\r\nvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\";\r\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\";\r\nvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = normalMatrix * objectTangent;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\r\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\r\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\";\r\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\r\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\r\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\r\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\r\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\r\nvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\r\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\r\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\r\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\";\r\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\r\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\r\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\r\nvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\";\r\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\";\r\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\r\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\";\r\nvar lights_pars_begin = \"uniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\r\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\r\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\r\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\r\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\";\r\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\r\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\";\r\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\";\r\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\";\r\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\r\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\";\r\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\r\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\";\r\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\r\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\r\nvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\";\r\nvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\";\r\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\r\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\r\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\";\r\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\r\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\r\nvar normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\r\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\t\\tnormal = normalize( vTBN * mapN );\\n\\t\\t#else\\n\\t\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t\\t#endif\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\";\r\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\";\r\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\r\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\r\nvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\";\r\nvar dithering_fragment = \"#if defined( DITHERING )\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\r\nvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\r\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\r\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\r\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\r\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\";\r\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\";\r\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\r\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\r\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\r\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\r\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\r\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\r\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\r\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\";\r\nvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\r\nvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\";\r\nvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\r\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\r\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\r\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\r\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\";\r\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\r\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\r\nvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\r\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\r\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\";\r\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\";\r\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\r\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\r\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\r\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\r\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\r\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\r\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\r\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\r\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\r\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\r\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\r\nvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\r\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\r\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\r\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\";\r\nvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\r\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\r\nvar ShaderChunk = {\r\n    alphamap_fragment: alphamap_fragment,\r\n    alphamap_pars_fragment: alphamap_pars_fragment,\r\n    alphatest_fragment: alphatest_fragment,\r\n    aomap_fragment: aomap_fragment,\r\n    aomap_pars_fragment: aomap_pars_fragment,\r\n    begin_vertex: begin_vertex,\r\n    beginnormal_vertex: beginnormal_vertex,\r\n    bsdfs: bsdfs,\r\n    bumpmap_pars_fragment: bumpmap_pars_fragment,\r\n    clipping_planes_fragment: clipping_planes_fragment,\r\n    clipping_planes_pars_fragment: clipping_planes_pars_fragment,\r\n    clipping_planes_pars_vertex: clipping_planes_pars_vertex,\r\n    clipping_planes_vertex: clipping_planes_vertex,\r\n    color_fragment: color_fragment,\r\n    color_pars_fragment: color_pars_fragment,\r\n    color_pars_vertex: color_pars_vertex,\r\n    color_vertex: color_vertex,\r\n    common: common,\r\n    cube_uv_reflection_fragment: cube_uv_reflection_fragment,\r\n    defaultnormal_vertex: defaultnormal_vertex,\r\n    displacementmap_pars_vertex: displacementmap_pars_vertex,\r\n    displacementmap_vertex: displacementmap_vertex,\r\n    emissivemap_fragment: emissivemap_fragment,\r\n    emissivemap_pars_fragment: emissivemap_pars_fragment,\r\n    encodings_fragment: encodings_fragment,\r\n    encodings_pars_fragment: encodings_pars_fragment,\r\n    envmap_fragment: envmap_fragment,\r\n    envmap_pars_fragment: envmap_pars_fragment,\r\n    envmap_pars_vertex: envmap_pars_vertex,\r\n    envmap_physical_pars_fragment: envmap_physical_pars_fragment,\r\n    envmap_vertex: envmap_vertex,\r\n    fog_vertex: fog_vertex,\r\n    fog_pars_vertex: fog_pars_vertex,\r\n    fog_fragment: fog_fragment,\r\n    fog_pars_fragment: fog_pars_fragment,\r\n    gradientmap_pars_fragment: gradientmap_pars_fragment,\r\n    lightmap_fragment: lightmap_fragment,\r\n    lightmap_pars_fragment: lightmap_pars_fragment,\r\n    lights_lambert_vertex: lights_lambert_vertex,\r\n    lights_pars_begin: lights_pars_begin,\r\n    lights_phong_fragment: lights_phong_fragment,\r\n    lights_phong_pars_fragment: lights_phong_pars_fragment,\r\n    lights_physical_fragment: lights_physical_fragment,\r\n    lights_physical_pars_fragment: lights_physical_pars_fragment,\r\n    lights_fragment_begin: lights_fragment_begin,\r\n    lights_fragment_maps: lights_fragment_maps,\r\n    lights_fragment_end: lights_fragment_end,\r\n    logdepthbuf_fragment: logdepthbuf_fragment,\r\n    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\r\n    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\r\n    logdepthbuf_vertex: logdepthbuf_vertex,\r\n    map_fragment: map_fragment,\r\n    map_pars_fragment: map_pars_fragment,\r\n    map_particle_fragment: map_particle_fragment,\r\n    map_particle_pars_fragment: map_particle_pars_fragment,\r\n    metalnessmap_fragment: metalnessmap_fragment,\r\n    metalnessmap_pars_fragment: metalnessmap_pars_fragment,\r\n    morphnormal_vertex: morphnormal_vertex,\r\n    morphtarget_pars_vertex: morphtarget_pars_vertex,\r\n    morphtarget_vertex: morphtarget_vertex,\r\n    normal_fragment_begin: normal_fragment_begin,\r\n    normal_fragment_maps: normal_fragment_maps,\r\n    normalmap_pars_fragment: normalmap_pars_fragment,\r\n    packing: packing,\r\n    premultiplied_alpha_fragment: premultiplied_alpha_fragment,\r\n    project_vertex: project_vertex,\r\n    dithering_fragment: dithering_fragment,\r\n    dithering_pars_fragment: dithering_pars_fragment,\r\n    roughnessmap_fragment: roughnessmap_fragment,\r\n    roughnessmap_pars_fragment: roughnessmap_pars_fragment,\r\n    shadowmap_pars_fragment: shadowmap_pars_fragment,\r\n    shadowmap_pars_vertex: shadowmap_pars_vertex,\r\n    shadowmap_vertex: shadowmap_vertex,\r\n    shadowmask_pars_fragment: shadowmask_pars_fragment,\r\n    skinbase_vertex: skinbase_vertex,\r\n    skinning_pars_vertex: skinning_pars_vertex,\r\n    skinning_vertex: skinning_vertex,\r\n    skinnormal_vertex: skinnormal_vertex,\r\n    specularmap_fragment: specularmap_fragment,\r\n    specularmap_pars_fragment: specularmap_pars_fragment,\r\n    tonemapping_fragment: tonemapping_fragment,\r\n    tonemapping_pars_fragment: tonemapping_pars_fragment,\r\n    uv_pars_fragment: uv_pars_fragment,\r\n    uv_pars_vertex: uv_pars_vertex,\r\n    uv_vertex: uv_vertex,\r\n    uv2_pars_fragment: uv2_pars_fragment,\r\n    uv2_pars_vertex: uv2_pars_vertex,\r\n    uv2_vertex: uv2_vertex,\r\n    worldpos_vertex: worldpos_vertex,\r\n    background_frag: background_frag,\r\n    background_vert: background_vert,\r\n    cube_frag: cube_frag,\r\n    cube_vert: cube_vert,\r\n    depth_frag: depth_frag,\r\n    depth_vert: depth_vert,\r\n    distanceRGBA_frag: distanceRGBA_frag,\r\n    distanceRGBA_vert: distanceRGBA_vert,\r\n    equirect_frag: equirect_frag,\r\n    equirect_vert: equirect_vert,\r\n    linedashed_frag: linedashed_frag,\r\n    linedashed_vert: linedashed_vert,\r\n    meshbasic_frag: meshbasic_frag,\r\n    meshbasic_vert: meshbasic_vert,\r\n    meshlambert_frag: meshlambert_frag,\r\n    meshlambert_vert: meshlambert_vert,\r\n    meshmatcap_frag: meshmatcap_frag,\r\n    meshmatcap_vert: meshmatcap_vert,\r\n    meshphong_frag: meshphong_frag,\r\n    meshphong_vert: meshphong_vert,\r\n    meshphysical_frag: meshphysical_frag,\r\n    meshphysical_vert: meshphysical_vert,\r\n    normal_frag: normal_frag,\r\n    normal_vert: normal_vert,\r\n    points_frag: points_frag,\r\n    points_vert: points_vert,\r\n    shadow_frag: shadow_frag,\r\n    shadow_vert: shadow_vert,\r\n    sprite_frag: sprite_frag,\r\n    sprite_vert: sprite_vert\r\n};\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\nvar UniformsLib = {\r\n    common: {\r\n        diffuse: { value: new Color(0xeeeeee) },\r\n        opacity: { value: 1.0 },\r\n        map: { value: null },\r\n        uvTransform: { value: new Matrix3() },\r\n        alphaMap: { value: null },\r\n    },\r\n    specularmap: {\r\n        specularMap: { value: null },\r\n    },\r\n    envmap: {\r\n        envMap: { value: null },\r\n        flipEnvMap: { value: -1 },\r\n        reflectivity: { value: 1.0 },\r\n        refractionRatio: { value: 0.98 },\r\n        maxMipLevel: { value: 0 }\r\n    },\r\n    aomap: {\r\n        aoMap: { value: null },\r\n        aoMapIntensity: { value: 1 }\r\n    },\r\n    lightmap: {\r\n        lightMap: { value: null },\r\n        lightMapIntensity: { value: 1 }\r\n    },\r\n    emissivemap: {\r\n        emissiveMap: { value: null }\r\n    },\r\n    bumpmap: {\r\n        bumpMap: { value: null },\r\n        bumpScale: { value: 1 }\r\n    },\r\n    normalmap: {\r\n        normalMap: { value: null },\r\n        normalScale: { value: new Vector2(1, 1) }\r\n    },\r\n    displacementmap: {\r\n        displacementMap: { value: null },\r\n        displacementScale: { value: 1 },\r\n        displacementBias: { value: 0 }\r\n    },\r\n    roughnessmap: {\r\n        roughnessMap: { value: null }\r\n    },\r\n    metalnessmap: {\r\n        metalnessMap: { value: null }\r\n    },\r\n    gradientmap: {\r\n        gradientMap: { value: null }\r\n    },\r\n    fog: {\r\n        fogDensity: { value: 0.00025 },\r\n        fogNear: { value: 1 },\r\n        fogFar: { value: 2000 },\r\n        fogColor: { value: new Color(0xffffff) }\r\n    },\r\n    lights: {\r\n        ambientLightColor: { value: [] },\r\n        lightProbe: { value: [] },\r\n        directionalLights: { value: [], properties: {\r\n                direction: {},\r\n                color: {},\r\n                shadow: {},\r\n                shadowBias: {},\r\n                shadowRadius: {},\r\n                shadowMapSize: {}\r\n            } },\r\n        directionalShadowMap: { value: [] },\r\n        directionalShadowMatrix: { value: [] },\r\n        spotLights: { value: [], properties: {\r\n                color: {},\r\n                position: {},\r\n                direction: {},\r\n                distance: {},\r\n                coneCos: {},\r\n                penumbraCos: {},\r\n                decay: {},\r\n                shadow: {},\r\n                shadowBias: {},\r\n                shadowRadius: {},\r\n                shadowMapSize: {}\r\n            } },\r\n        spotShadowMap: { value: [] },\r\n        spotShadowMatrix: { value: [] },\r\n        pointLights: { value: [], properties: {\r\n                color: {},\r\n                position: {},\r\n                decay: {},\r\n                distance: {},\r\n                shadow: {},\r\n                shadowBias: {},\r\n                shadowRadius: {},\r\n                shadowMapSize: {},\r\n                shadowCameraNear: {},\r\n                shadowCameraFar: {}\r\n            } },\r\n        pointShadowMap: { value: [] },\r\n        pointShadowMatrix: { value: [] },\r\n        hemisphereLights: { value: [], properties: {\r\n                direction: {},\r\n                skyColor: {},\r\n                groundColor: {}\r\n            } },\r\n        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\r\n        rectAreaLights: { value: [], properties: {\r\n                color: {},\r\n                position: {},\r\n                width: {},\r\n                height: {}\r\n            } }\r\n    },\r\n    points: {\r\n        diffuse: { value: new Color(0xeeeeee) },\r\n        opacity: { value: 1.0 },\r\n        size: { value: 1.0 },\r\n        scale: { value: 1.0 },\r\n        map: { value: null },\r\n        uvTransform: { value: new Matrix3() }\r\n    },\r\n    sprite: {\r\n        diffuse: { value: new Color(0xeeeeee) },\r\n        opacity: { value: 1.0 },\r\n        center: { value: new Vector2(0.5, 0.5) },\r\n        rotation: { value: 0.0 },\r\n        map: { value: null },\r\n        uvTransform: { value: new Matrix3() }\r\n    }\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\nvar ShaderLib = {\r\n    basic: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.specularmap,\r\n            UniformsLib.envmap,\r\n            UniformsLib.aomap,\r\n            UniformsLib.lightmap,\r\n            UniformsLib.fog\r\n        ]),\r\n        vertexShader: ShaderChunk.meshbasic_vert,\r\n        fragmentShader: ShaderChunk.meshbasic_frag\r\n    },\r\n    lambert: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.specularmap,\r\n            UniformsLib.envmap,\r\n            UniformsLib.aomap,\r\n            UniformsLib.lightmap,\r\n            UniformsLib.emissivemap,\r\n            UniformsLib.fog,\r\n            UniformsLib.lights,\r\n            {\r\n                emissive: { value: new Color(0x000000) }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.meshlambert_vert,\r\n        fragmentShader: ShaderChunk.meshlambert_frag\r\n    },\r\n    phong: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.specularmap,\r\n            UniformsLib.envmap,\r\n            UniformsLib.aomap,\r\n            UniformsLib.lightmap,\r\n            UniformsLib.emissivemap,\r\n            UniformsLib.bumpmap,\r\n            UniformsLib.normalmap,\r\n            UniformsLib.displacementmap,\r\n            UniformsLib.gradientmap,\r\n            UniformsLib.fog,\r\n            UniformsLib.lights,\r\n            {\r\n                emissive: { value: new Color(0x000000) },\r\n                specular: { value: new Color(0x111111) },\r\n                shininess: { value: 30 }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.meshphong_vert,\r\n        fragmentShader: ShaderChunk.meshphong_frag\r\n    },\r\n    standard: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.envmap,\r\n            UniformsLib.aomap,\r\n            UniformsLib.lightmap,\r\n            UniformsLib.emissivemap,\r\n            UniformsLib.bumpmap,\r\n            UniformsLib.normalmap,\r\n            UniformsLib.displacementmap,\r\n            UniformsLib.roughnessmap,\r\n            UniformsLib.metalnessmap,\r\n            UniformsLib.fog,\r\n            UniformsLib.lights,\r\n            {\r\n                emissive: { value: new Color(0x000000) },\r\n                roughness: { value: 0.5 },\r\n                metalness: { value: 0.5 },\r\n                envMapIntensity: { value: 1 } // temporary\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.meshphysical_vert,\r\n        fragmentShader: ShaderChunk.meshphysical_frag\r\n    },\r\n    matcap: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.bumpmap,\r\n            UniformsLib.normalmap,\r\n            UniformsLib.displacementmap,\r\n            UniformsLib.fog,\r\n            {\r\n                matcap: { value: null }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.meshmatcap_vert,\r\n        fragmentShader: ShaderChunk.meshmatcap_frag\r\n    },\r\n    points: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.points,\r\n            UniformsLib.fog\r\n        ]),\r\n        vertexShader: ShaderChunk.points_vert,\r\n        fragmentShader: ShaderChunk.points_frag\r\n    },\r\n    dashed: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.fog,\r\n            {\r\n                scale: { value: 1 },\r\n                dashSize: { value: 1 },\r\n                totalSize: { value: 2 }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.linedashed_vert,\r\n        fragmentShader: ShaderChunk.linedashed_frag\r\n    },\r\n    depth: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.displacementmap\r\n        ]),\r\n        vertexShader: ShaderChunk.depth_vert,\r\n        fragmentShader: ShaderChunk.depth_frag\r\n    },\r\n    normal: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.bumpmap,\r\n            UniformsLib.normalmap,\r\n            UniformsLib.displacementmap,\r\n            {\r\n                opacity: { value: 1.0 }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.normal_vert,\r\n        fragmentShader: ShaderChunk.normal_frag\r\n    },\r\n    sprite: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.sprite,\r\n            UniformsLib.fog\r\n        ]),\r\n        vertexShader: ShaderChunk.sprite_vert,\r\n        fragmentShader: ShaderChunk.sprite_frag\r\n    },\r\n    background: {\r\n        uniforms: {\r\n            uvTransform: { value: new Matrix3() },\r\n            t2D: { value: null },\r\n        },\r\n        vertexShader: ShaderChunk.background_vert,\r\n        fragmentShader: ShaderChunk.background_frag\r\n    },\r\n    /* -------------------------------------------------------------------------\r\n    //\tCube map shader\r\n     ------------------------------------------------------------------------- */\r\n    cube: {\r\n        uniforms: {\r\n            tCube: { value: null },\r\n            tFlip: { value: -1 },\r\n            opacity: { value: 1.0 }\r\n        },\r\n        vertexShader: ShaderChunk.cube_vert,\r\n        fragmentShader: ShaderChunk.cube_frag\r\n    },\r\n    equirect: {\r\n        uniforms: {\r\n            tEquirect: { value: null },\r\n        },\r\n        vertexShader: ShaderChunk.equirect_vert,\r\n        fragmentShader: ShaderChunk.equirect_frag\r\n    },\r\n    distanceRGBA: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.common,\r\n            UniformsLib.displacementmap,\r\n            {\r\n                referencePosition: { value: new Vector3() },\r\n                nearDistance: { value: 1 },\r\n                farDistance: { value: 1000 }\r\n            }\r\n        ]),\r\n        vertexShader: ShaderChunk.distanceRGBA_vert,\r\n        fragmentShader: ShaderChunk.distanceRGBA_frag\r\n    },\r\n    shadow: {\r\n        uniforms: mergeUniforms([\r\n            UniformsLib.lights,\r\n            UniformsLib.fog,\r\n            {\r\n                color: { value: new Color(0x00000) },\r\n                opacity: { value: 1.0 }\r\n            },\r\n        ]),\r\n        vertexShader: ShaderChunk.shadow_vert,\r\n        fragmentShader: ShaderChunk.shadow_frag\r\n    }\r\n};\r\nShaderLib.physical = {\r\n    uniforms: mergeUniforms([\r\n        ShaderLib.standard.uniforms,\r\n        {\r\n            clearCoat: { value: 0 },\r\n            clearCoatRoughness: { value: 0 }\r\n        }\r\n    ]),\r\n    vertexShader: ShaderChunk.meshphysical_vert,\r\n    fragmentShader: ShaderChunk.meshphysical_frag\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLAnimation() {\r\n    var context = null;\r\n    var isAnimating = false;\r\n    var animationLoop = null;\r\n    function onAnimationFrame(time, frame) {\r\n        if (isAnimating === false)\r\n            return;\r\n        animationLoop(time, frame);\r\n        context.requestAnimationFrame(onAnimationFrame);\r\n    }\r\n    return {\r\n        start: function () {\r\n            if (isAnimating === true)\r\n                return;\r\n            if (animationLoop === null)\r\n                return;\r\n            context.requestAnimationFrame(onAnimationFrame);\r\n            isAnimating = true;\r\n        },\r\n        stop: function () {\r\n            isAnimating = false;\r\n        },\r\n        setAnimationLoop: function (callback) {\r\n            animationLoop = callback;\r\n        },\r\n        setContext: function (value) {\r\n            context = value;\r\n        }\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLAttributes(gl) {\r\n    var buffers = new WeakMap();\r\n    function createBuffer(attribute, bufferType) {\r\n        var array = attribute.array;\r\n        var usage = attribute.dynamic ? 35048 : 35044;\r\n        var buffer = gl.createBuffer();\r\n        gl.bindBuffer(bufferType, buffer);\r\n        gl.bufferData(bufferType, array, usage);\r\n        attribute.onUploadCallback();\r\n        var type = 5126;\r\n        if (array instanceof Float32Array) {\r\n            type = 5126;\r\n        }\r\n        else if (array instanceof Float64Array) {\r\n            console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');\r\n        }\r\n        else if (array instanceof Uint16Array) {\r\n            type = 5123;\r\n        }\r\n        else if (array instanceof Int16Array) {\r\n            type = 5122;\r\n        }\r\n        else if (array instanceof Uint32Array) {\r\n            type = 5125;\r\n        }\r\n        else if (array instanceof Int32Array) {\r\n            type = 5124;\r\n        }\r\n        else if (array instanceof Int8Array) {\r\n            type = 5120;\r\n        }\r\n        else if (array instanceof Uint8Array) {\r\n            type = 5121;\r\n        }\r\n        return {\r\n            buffer: buffer,\r\n            type: type,\r\n            bytesPerElement: array.BYTES_PER_ELEMENT,\r\n            version: attribute.version\r\n        };\r\n    }\r\n    function updateBuffer(buffer, attribute, bufferType) {\r\n        var array = attribute.array;\r\n        var updateRange = attribute.updateRange;\r\n        gl.bindBuffer(bufferType, buffer);\r\n        if (attribute.dynamic === false) {\r\n            gl.bufferData(bufferType, array, 35044);\r\n        }\r\n        else if (updateRange.count === -1) {\r\n            // Not using update ranges\r\n            gl.bufferSubData(bufferType, 0, array);\r\n        }\r\n        else if (updateRange.count === 0) {\r\n            console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');\r\n        }\r\n        else {\r\n            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\r\n            updateRange.count = -1; // reset range\r\n        }\r\n    }\r\n    //\r\n    function get(attribute) {\r\n        if (attribute.isInterleavedBufferAttribute)\r\n            attribute = attribute.data;\r\n        return buffers.get(attribute);\r\n    }\r\n    function remove(attribute) {\r\n        if (attribute.isInterleavedBufferAttribute)\r\n            attribute = attribute.data;\r\n        var data = buffers.get(attribute);\r\n        if (data) {\r\n            gl.deleteBuffer(data.buffer);\r\n            buffers.delete(attribute);\r\n        }\r\n    }\r\n    function update(attribute, bufferType) {\r\n        if (attribute.isInterleavedBufferAttribute)\r\n            attribute = attribute.data;\r\n        var data = buffers.get(attribute);\r\n        if (data === undefined) {\r\n            buffers.set(attribute, createBuffer(attribute, bufferType));\r\n        }\r\n        else if (data.version < attribute.version) {\r\n            updateBuffer(data.buffer, attribute, bufferType);\r\n            data.version = attribute.version;\r\n        }\r\n    }\r\n    return {\r\n        get: get,\r\n        remove: remove,\r\n        update: update\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// PlaneGeometry\r\nfunction PlaneGeometry(width, height, widthSegments, heightSegments) {\r\n    Geometry.call(this);\r\n    this.type = 'PlaneGeometry';\r\n    this.parameters = {\r\n        width: width,\r\n        height: height,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments\r\n    };\r\n    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));\r\n    this.mergeVertices();\r\n}\r\nPlaneGeometry.prototype = Object.create(Geometry.prototype);\r\nPlaneGeometry.prototype.constructor = PlaneGeometry;\r\n// PlaneBufferGeometry\r\nfunction PlaneBufferGeometry(width, height, widthSegments, heightSegments) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'PlaneBufferGeometry';\r\n    this.parameters = {\r\n        width: width,\r\n        height: height,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments\r\n    };\r\n    width = width || 1;\r\n    height = height || 1;\r\n    var width_half = width / 2;\r\n    var height_half = height / 2;\r\n    var gridX = Math.floor(widthSegments) || 1;\r\n    var gridY = Math.floor(heightSegments) || 1;\r\n    var gridX1 = gridX + 1;\r\n    var gridY1 = gridY + 1;\r\n    var segment_width = width / gridX;\r\n    var segment_height = height / gridY;\r\n    var ix, iy;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // generate vertices, normals and uvs\r\n    for (iy = 0; iy < gridY1; iy++) {\r\n        var y = iy * segment_height - height_half;\r\n        for (ix = 0; ix < gridX1; ix++) {\r\n            var x = ix * segment_width - width_half;\r\n            vertices.push(x, -y, 0);\r\n            normals.push(0, 0, 1);\r\n            uvs.push(ix / gridX);\r\n            uvs.push(1 - (iy / gridY));\r\n        }\r\n    }\r\n    // indices\r\n    for (iy = 0; iy < gridY; iy++) {\r\n        for (ix = 0; ix < gridX; ix++) {\r\n            var a = ix + gridX1 * iy;\r\n            var b = ix + gridX1 * (iy + 1);\r\n            var c = (ix + 1) + gridX1 * (iy + 1);\r\n            var d = (ix + 1) + gridX1 * iy;\r\n            // faces\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nPlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLBackground(renderer, state, objects, premultipliedAlpha) {\r\n    var clearColor = new Color(0x000000);\r\n    var clearAlpha = 0;\r\n    var planeMesh;\r\n    var boxMesh;\r\n    // Store the current background texture and its `version`\r\n    // so we can recompile the material accordingly.\r\n    var currentBackground = null;\r\n    var currentBackgroundVersion = 0;\r\n    function render(renderList, scene, camera, forceClear) {\r\n        var background = scene.background;\r\n        // Ignore background in AR\r\n        // TODO: Reconsider this.\r\n        var vr = renderer.vr;\r\n        var session = vr.getSession && vr.getSession();\r\n        if (session && session.environmentBlendMode === 'additive') {\r\n            background = null;\r\n        }\r\n        if (background === null) {\r\n            setClear(clearColor, clearAlpha);\r\n            currentBackground = null;\r\n            currentBackgroundVersion = 0;\r\n        }\r\n        else if (background && background.isColor) {\r\n            setClear(background, 1);\r\n            forceClear = true;\r\n            currentBackground = null;\r\n            currentBackgroundVersion = 0;\r\n        }\r\n        if (renderer.autoClear || forceClear) {\r\n            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\r\n        }\r\n        if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {\r\n            if (boxMesh === undefined) {\r\n                boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({\r\n                    type: 'BackgroundCubeMaterial',\r\n                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),\r\n                    vertexShader: ShaderLib.cube.vertexShader,\r\n                    fragmentShader: ShaderLib.cube.fragmentShader,\r\n                    side: BackSide,\r\n                    depthTest: false,\r\n                    depthWrite: false,\r\n                    fog: false\r\n                }));\r\n                boxMesh.geometry.removeAttribute('normal');\r\n                boxMesh.geometry.removeAttribute('uv');\r\n                boxMesh.onBeforeRender = function (renderer, scene, camera) {\r\n                    this.matrixWorld.copyPosition(camera.matrixWorld);\r\n                };\r\n                // enable code injection for non-built-in material\r\n                Object.defineProperty(boxMesh.material, 'map', {\r\n                    get: function () {\r\n                        return this.uniforms.tCube.value;\r\n                    }\r\n                });\r\n                objects.update(boxMesh);\r\n            }\r\n            var texture = background.isWebGLRenderTargetCube ? background.texture : background;\r\n            boxMesh.material.uniforms.tCube.value = texture;\r\n            boxMesh.material.uniforms.tFlip.value = (background.isWebGLRenderTargetCube) ? 1 : -1;\r\n            if (currentBackground !== background ||\r\n                currentBackgroundVersion !== texture.version) {\r\n                boxMesh.material.needsUpdate = true;\r\n                currentBackground = background;\r\n                currentBackgroundVersion = texture.version;\r\n            }\r\n            // push to the pre-sorted opaque render list\r\n            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\r\n        }\r\n        else if (background && background.isTexture) {\r\n            if (planeMesh === undefined) {\r\n                planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({\r\n                    type: 'BackgroundMaterial',\r\n                    uniforms: cloneUniforms(ShaderLib.background.uniforms),\r\n                    vertexShader: ShaderLib.background.vertexShader,\r\n                    fragmentShader: ShaderLib.background.fragmentShader,\r\n                    side: FrontSide,\r\n                    depthTest: false,\r\n                    depthWrite: false,\r\n                    fog: false\r\n                }));\r\n                planeMesh.geometry.removeAttribute('normal');\r\n                // enable code injection for non-built-in material\r\n                Object.defineProperty(planeMesh.material, 'map', {\r\n                    get: function () {\r\n                        return this.uniforms.t2D.value;\r\n                    }\r\n                });\r\n                objects.update(planeMesh);\r\n            }\r\n            planeMesh.material.uniforms.t2D.value = background;\r\n            if (background.matrixAutoUpdate === true) {\r\n                background.updateMatrix();\r\n            }\r\n            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\r\n            if (currentBackground !== background ||\r\n                currentBackgroundVersion !== background.version) {\r\n                planeMesh.material.needsUpdate = true;\r\n                currentBackground = background;\r\n                currentBackgroundVersion = background.version;\r\n            }\r\n            // push to the pre-sorted opaque render list\r\n            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\r\n        }\r\n    }\r\n    function setClear(color, alpha) {\r\n        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\r\n    }\r\n    return {\r\n        getClearColor: function () {\r\n            return clearColor;\r\n        },\r\n        setClearColor: function (color, alpha) {\r\n            clearColor.set(color);\r\n            clearAlpha = alpha !== undefined ? alpha : 1;\r\n            setClear(clearColor, clearAlpha);\r\n        },\r\n        getClearAlpha: function () {\r\n            return clearAlpha;\r\n        },\r\n        setClearAlpha: function (alpha) {\r\n            clearAlpha = alpha;\r\n            setClear(clearColor, clearAlpha);\r\n        },\r\n        render: render\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\r\n    var mode;\r\n    function setMode(value) {\r\n        mode = value;\r\n    }\r\n    function render(start, count) {\r\n        gl.drawArrays(mode, start, count);\r\n        info.update(count, mode);\r\n    }\r\n    function renderInstances(geometry, start, count) {\r\n        var extension;\r\n        if (capabilities.isWebGL2) {\r\n            extension = gl;\r\n        }\r\n        else {\r\n            extension = extensions.get('ANGLE_instanced_arrays');\r\n            if (extension === null) {\r\n                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\r\n                return;\r\n            }\r\n        }\r\n        extension[capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](mode, start, count, geometry.maxInstancedCount);\r\n        info.update(count, mode, geometry.maxInstancedCount);\r\n    }\r\n    //\r\n    this.setMode = setMode;\r\n    this.render = render;\r\n    this.renderInstances = renderInstances;\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLCapabilities(gl, extensions, parameters) {\r\n    var maxAnisotropy;\r\n    function getMaxAnisotropy() {\r\n        if (maxAnisotropy !== undefined)\r\n            return maxAnisotropy;\r\n        var extension = extensions.get('EXT_texture_filter_anisotropic');\r\n        if (extension !== null) {\r\n            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\r\n        }\r\n        else {\r\n            maxAnisotropy = 0;\r\n        }\r\n        return maxAnisotropy;\r\n    }\r\n    function getMaxPrecision(precision) {\r\n        if (precision === 'highp') {\r\n            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&\r\n                gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {\r\n                return 'highp';\r\n            }\r\n            precision = 'mediump';\r\n        }\r\n        if (precision === 'mediump') {\r\n            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&\r\n                gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {\r\n                return 'mediump';\r\n            }\r\n        }\r\n        return 'lowp';\r\n    }\r\n    var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\r\n    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';\r\n    var maxPrecision = getMaxPrecision(precision);\r\n    if (maxPrecision !== precision) {\r\n        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');\r\n        precision = maxPrecision;\r\n    }\r\n    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\r\n    var maxTextures = gl.getParameter(34930);\r\n    var maxVertexTextures = gl.getParameter(35660);\r\n    var maxTextureSize = gl.getParameter(3379);\r\n    var maxCubemapSize = gl.getParameter(34076);\r\n    var maxAttributes = gl.getParameter(34921);\r\n    var maxVertexUniforms = gl.getParameter(36347);\r\n    var maxVaryings = gl.getParameter(36348);\r\n    var maxFragmentUniforms = gl.getParameter(36349);\r\n    var vertexTextures = maxVertexTextures > 0;\r\n    var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');\r\n    var floatVertexTextures = vertexTextures && floatFragmentTextures;\r\n    var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;\r\n    return {\r\n        isWebGL2: isWebGL2,\r\n        getMaxAnisotropy: getMaxAnisotropy,\r\n        getMaxPrecision: getMaxPrecision,\r\n        precision: precision,\r\n        logarithmicDepthBuffer: logarithmicDepthBuffer,\r\n        maxTextures: maxTextures,\r\n        maxVertexTextures: maxVertexTextures,\r\n        maxTextureSize: maxTextureSize,\r\n        maxCubemapSize: maxCubemapSize,\r\n        maxAttributes: maxAttributes,\r\n        maxVertexUniforms: maxVertexUniforms,\r\n        maxVaryings: maxVaryings,\r\n        maxFragmentUniforms: maxFragmentUniforms,\r\n        vertexTextures: vertexTextures,\r\n        floatFragmentTextures: floatFragmentTextures,\r\n        floatVertexTextures: floatVertexTextures,\r\n        maxSamples: maxSamples\r\n    };\r\n}\r\n/**\r\n * @author tschw\r\n */\r\nfunction WebGLClipping() {\r\n    var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };\r\n    this.uniform = uniform;\r\n    this.numPlanes = 0;\r\n    this.numIntersection = 0;\r\n    this.init = function (planes, enableLocalClipping, camera) {\r\n        var enabled = planes.length !== 0 ||\r\n            enableLocalClipping ||\r\n            // enable state of previous frame - the clipping code has to\r\n            // run another frame in order to reset the state:\r\n            numGlobalPlanes !== 0 ||\r\n            localClippingEnabled;\r\n        localClippingEnabled = enableLocalClipping;\r\n        globalState = projectPlanes(planes, camera, 0);\r\n        numGlobalPlanes = planes.length;\r\n        return enabled;\r\n    };\r\n    this.beginShadows = function () {\r\n        renderingShadows = true;\r\n        projectPlanes(null);\r\n    };\r\n    this.endShadows = function () {\r\n        renderingShadows = false;\r\n        resetGlobalState();\r\n    };\r\n    this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {\r\n        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\r\n            // there's no local clipping\r\n            if (renderingShadows) {\r\n                // there's no global clipping\r\n                projectPlanes(null);\r\n            }\r\n            else {\r\n                resetGlobalState();\r\n            }\r\n        }\r\n        else {\r\n            var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;\r\n            uniform.value = dstArray; // ensure unique state\r\n            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);\r\n            for (var i = 0; i !== lGlobal; ++i) {\r\n                dstArray[i] = globalState[i];\r\n            }\r\n            cache.clippingState = dstArray;\r\n            this.numIntersection = clipIntersection ? this.numPlanes : 0;\r\n            this.numPlanes += nGlobal;\r\n        }\r\n    };\r\n    function resetGlobalState() {\r\n        if (uniform.value !== globalState) {\r\n            uniform.value = globalState;\r\n            uniform.needsUpdate = numGlobalPlanes > 0;\r\n        }\r\n        scope.numPlanes = numGlobalPlanes;\r\n        scope.numIntersection = 0;\r\n    }\r\n    function projectPlanes(planes, camera, dstOffset, skipTransform) {\r\n        var nPlanes = planes !== null ? planes.length : 0, dstArray = null;\r\n        if (nPlanes !== 0) {\r\n            dstArray = uniform.value;\r\n            if (skipTransform !== true || dstArray === null) {\r\n                var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;\r\n                viewNormalMatrix.getNormalMatrix(viewMatrix);\r\n                if (dstArray === null || dstArray.length < flatSize) {\r\n                    dstArray = new Float32Array(flatSize);\r\n                }\r\n                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\r\n                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\r\n                    plane.normal.toArray(dstArray, i4);\r\n                    dstArray[i4 + 3] = plane.constant;\r\n                }\r\n            }\r\n            uniform.value = dstArray;\r\n            uniform.needsUpdate = true;\r\n        }\r\n        scope.numPlanes = nPlanes;\r\n        return dstArray;\r\n    }\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLExtensions(gl) {\r\n    var extensions = {};\r\n    return {\r\n        get: function (name) {\r\n            if (extensions[name] !== undefined) {\r\n                return extensions[name];\r\n            }\r\n            var extension;\r\n            switch (name) {\r\n                case 'WEBGL_depth_texture':\r\n                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\r\n                    break;\r\n                case 'EXT_texture_filter_anisotropic':\r\n                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\r\n                    break;\r\n                case 'WEBGL_compressed_texture_s3tc':\r\n                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\r\n                    break;\r\n                case 'WEBGL_compressed_texture_pvrtc':\r\n                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\r\n                    break;\r\n                default:\r\n                    extension = gl.getExtension(name);\r\n            }\r\n            if (extension === null) {\r\n                console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\r\n            }\r\n            extensions[name] = extension;\r\n            return extension;\r\n        }\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLGeometries(gl, attributes, info) {\r\n    var geometries = {};\r\n    var wireframeAttributes = {};\r\n    function onGeometryDispose(event) {\r\n        var geometry = event.target;\r\n        var buffergeometry = geometries[geometry.id];\r\n        if (buffergeometry.index !== null) {\r\n            attributes.remove(buffergeometry.index);\r\n        }\r\n        for (var name in buffergeometry.attributes) {\r\n            attributes.remove(buffergeometry.attributes[name]);\r\n        }\r\n        geometry.removeEventListener('dispose', onGeometryDispose);\r\n        delete geometries[geometry.id];\r\n        var attribute = wireframeAttributes[buffergeometry.id];\r\n        if (attribute) {\r\n            attributes.remove(attribute);\r\n            delete wireframeAttributes[buffergeometry.id];\r\n        }\r\n        //\r\n        info.memory.geometries--;\r\n    }\r\n    function get(object, geometry) {\r\n        var buffergeometry = geometries[geometry.id];\r\n        if (buffergeometry)\r\n            return buffergeometry;\r\n        geometry.addEventListener('dispose', onGeometryDispose);\r\n        if (geometry.isBufferGeometry) {\r\n            buffergeometry = geometry;\r\n        }\r\n        else if (geometry.isGeometry) {\r\n            if (geometry._bufferGeometry === undefined) {\r\n                geometry._bufferGeometry = new BufferGeometry().setFromObject(object);\r\n            }\r\n            buffergeometry = geometry._bufferGeometry;\r\n        }\r\n        geometries[geometry.id] = buffergeometry;\r\n        info.memory.geometries++;\r\n        return buffergeometry;\r\n    }\r\n    function update(geometry) {\r\n        var index = geometry.index;\r\n        var geometryAttributes = geometry.attributes;\r\n        if (index !== null) {\r\n            attributes.update(index, 34963);\r\n        }\r\n        for (var name in geometryAttributes) {\r\n            attributes.update(geometryAttributes[name], 34962);\r\n        }\r\n        // morph targets\r\n        var morphAttributes = geometry.morphAttributes;\r\n        for (var name in morphAttributes) {\r\n            var array = morphAttributes[name];\r\n            for (var i = 0, l = array.length; i < l; i++) {\r\n                attributes.update(array[i], 34962);\r\n            }\r\n        }\r\n    }\r\n    function updateWireframeAttribute(geometry) {\r\n        var indices = [];\r\n        var geometryIndex = geometry.index;\r\n        var geometryPosition = geometry.attributes.position;\r\n        var version = 0;\r\n        if (geometryIndex !== null) {\r\n            var array = geometryIndex.array;\r\n            version = geometryIndex.version;\r\n            for (var i = 0, l = array.length; i < l; i += 3) {\r\n                var a = array[i + 0];\r\n                var b = array[i + 1];\r\n                var c = array[i + 2];\r\n                indices.push(a, b, b, c, c, a);\r\n            }\r\n        }\r\n        else {\r\n            var array = geometryPosition.array;\r\n            version = geometryPosition.version;\r\n            for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {\r\n                var a = i + 0;\r\n                var b = i + 1;\r\n                var c = i + 2;\r\n                indices.push(a, b, b, c, c, a);\r\n            }\r\n        }\r\n        var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\r\n        attribute.version = version;\r\n        attributes.update(attribute, 34963);\r\n        //\r\n        var previousAttribute = wireframeAttributes[geometry.id];\r\n        if (previousAttribute)\r\n            attributes.remove(previousAttribute);\r\n        //\r\n        wireframeAttributes[geometry.id] = attribute;\r\n    }\r\n    function getWireframeAttribute(geometry) {\r\n        var currentAttribute = wireframeAttributes[geometry.id];\r\n        if (currentAttribute) {\r\n            var geometryIndex = geometry.index;\r\n            if (geometryIndex !== null) {\r\n                // if the attribute is obsolete, create a new one\r\n                if (currentAttribute.version < geometryIndex.version) {\r\n                    updateWireframeAttribute(geometry);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            updateWireframeAttribute(geometry);\r\n        }\r\n        return wireframeAttributes[geometry.id];\r\n    }\r\n    return {\r\n        get: get,\r\n        update: update,\r\n        getWireframeAttribute: getWireframeAttribute\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\r\n    var mode;\r\n    function setMode(value) {\r\n        mode = value;\r\n    }\r\n    var type, bytesPerElement;\r\n    function setIndex(value) {\r\n        type = value.type;\r\n        bytesPerElement = value.bytesPerElement;\r\n    }\r\n    function render(start, count) {\r\n        gl.drawElements(mode, count, type, start * bytesPerElement);\r\n        info.update(count, mode);\r\n    }\r\n    function renderInstances(geometry, start, count) {\r\n        var extension;\r\n        if (capabilities.isWebGL2) {\r\n            extension = gl;\r\n        }\r\n        else {\r\n            var extension = extensions.get('ANGLE_instanced_arrays');\r\n            if (extension === null) {\r\n                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\r\n                return;\r\n            }\r\n        }\r\n        extension[capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);\r\n        info.update(count, mode, geometry.maxInstancedCount);\r\n    }\r\n    //\r\n    this.setMode = setMode;\r\n    this.setIndex = setIndex;\r\n    this.render = render;\r\n    this.renderInstances = renderInstances;\r\n}\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction WebGLInfo(gl) {\r\n    var memory = {\r\n        geometries: 0,\r\n        textures: 0\r\n    };\r\n    var render = {\r\n        frame: 0,\r\n        calls: 0,\r\n        triangles: 0,\r\n        points: 0,\r\n        lines: 0\r\n    };\r\n    function update(count, mode, instanceCount) {\r\n        instanceCount = instanceCount || 1;\r\n        render.calls++;\r\n        switch (mode) {\r\n            case 4:\r\n                render.triangles += instanceCount * (count / 3);\r\n                break;\r\n            case 5:\r\n            case 6:\r\n                render.triangles += instanceCount * (count - 2);\r\n                break;\r\n            case 1:\r\n                render.lines += instanceCount * (count / 2);\r\n                break;\r\n            case 3:\r\n                render.lines += instanceCount * (count - 1);\r\n                break;\r\n            case 2:\r\n                render.lines += instanceCount * count;\r\n                break;\r\n            case 0:\r\n                render.points += instanceCount * count;\r\n                break;\r\n            default:\r\n                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);\r\n                break;\r\n        }\r\n    }\r\n    function reset() {\r\n        render.frame++;\r\n        render.calls = 0;\r\n        render.triangles = 0;\r\n        render.points = 0;\r\n        render.lines = 0;\r\n    }\r\n    return {\r\n        memory: memory,\r\n        render: render,\r\n        programs: null,\r\n        autoReset: true,\r\n        reset: reset,\r\n        update: update\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction absNumericalSort(a, b) {\r\n    return Math.abs(b[1]) - Math.abs(a[1]);\r\n}\r\nfunction WebGLMorphtargets(gl) {\r\n    var influencesList = {};\r\n    var morphInfluences = new Float32Array(8);\r\n    function update(object, geometry, material, program) {\r\n        var objectInfluences = object.morphTargetInfluences;\r\n        var length = objectInfluences.length;\r\n        var influences = influencesList[geometry.id];\r\n        if (influences === undefined) {\r\n            // initialise list\r\n            influences = [];\r\n            for (var i = 0; i < length; i++) {\r\n                influences[i] = [i, 0];\r\n            }\r\n            influencesList[geometry.id] = influences;\r\n        }\r\n        var morphTargets = material.morphTargets && geometry.morphAttributes.position;\r\n        var morphNormals = material.morphNormals && geometry.morphAttributes.normal;\r\n        // Remove current morphAttributes\r\n        for (var i = 0; i < length; i++) {\r\n            var influence = influences[i];\r\n            if (influence[1] !== 0) {\r\n                if (morphTargets)\r\n                    geometry.removeAttribute('morphTarget' + i);\r\n                if (morphNormals)\r\n                    geometry.removeAttribute('morphNormal' + i);\r\n            }\r\n        }\r\n        // Collect influences\r\n        for (var i = 0; i < length; i++) {\r\n            var influence = influences[i];\r\n            influence[0] = i;\r\n            influence[1] = objectInfluences[i];\r\n        }\r\n        influences.sort(absNumericalSort);\r\n        // Add morphAttributes\r\n        for (var i = 0; i < 8; i++) {\r\n            var influence = influences[i];\r\n            if (influence) {\r\n                var index = influence[0];\r\n                var value = influence[1];\r\n                if (value) {\r\n                    if (morphTargets)\r\n                        geometry.addAttribute('morphTarget' + i, morphTargets[index]);\r\n                    if (morphNormals)\r\n                        geometry.addAttribute('morphNormal' + i, morphNormals[index]);\r\n                    morphInfluences[i] = value;\r\n                    continue;\r\n                }\r\n            }\r\n            morphInfluences[i] = 0;\r\n        }\r\n        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\r\n    }\r\n    return {\r\n        update: update\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLObjects(geometries, info) {\r\n    var updateList = {};\r\n    function update(object) {\r\n        var frame = info.render.frame;\r\n        var geometry = object.geometry;\r\n        var buffergeometry = geometries.get(object, geometry);\r\n        // Update once per frame\r\n        if (updateList[buffergeometry.id] !== frame) {\r\n            if (geometry.isGeometry) {\r\n                buffergeometry.updateFromObject(object);\r\n            }\r\n            geometries.update(buffergeometry);\r\n            updateList[buffergeometry.id] = frame;\r\n        }\r\n        return buffergeometry;\r\n    }\r\n    function dispose() {\r\n        updateList = {};\r\n    }\r\n    return {\r\n        update: update,\r\n        dispose: dispose\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\r\n    images = images !== undefined ? images : [];\r\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\r\n    format = format !== undefined ? format : RGBFormat;\r\n    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\r\n    this.flipY = false;\r\n}\r\nCubeTexture.prototype = Object.create(Texture.prototype);\r\nCubeTexture.prototype.constructor = CubeTexture;\r\nCubeTexture.prototype.isCubeTexture = true;\r\nObject.defineProperty(CubeTexture.prototype, 'images', {\r\n    get: function () {\r\n        return this.image;\r\n    },\r\n    set: function (value) {\r\n        this.image = value;\r\n    }\r\n});\r\n/**\r\n * @author Takahiro https://github.com/takahirox\r\n */\r\nfunction DataTexture2DArray(data, width, height, depth) {\r\n    Texture.call(this, null);\r\n    this.image = { data: data, width: width, height: height, depth: depth };\r\n    this.magFilter = NearestFilter;\r\n    this.minFilter = NearestFilter;\r\n    this.wrapR = ClampToEdgeWrapping;\r\n    this.generateMipmaps = false;\r\n    this.flipY = false;\r\n}\r\nDataTexture2DArray.prototype = Object.create(Texture.prototype);\r\nDataTexture2DArray.prototype.constructor = DataTexture2DArray;\r\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\r\n/**\r\n * @author Artur Trzesiok\r\n */\r\nfunction DataTexture3D(data, width, height, depth) {\r\n    // We're going to add .setXXX() methods for setting properties later.\r\n    // Users can still set in DataTexture3D directly.\r\n    //\r\n    //\tvar texture = new THREE.DataTexture3D( data, width, height, depth );\r\n    // \ttexture.anisotropy = 16;\r\n    //\r\n    // See #14839\r\n    Texture.call(this, null);\r\n    this.image = { data: data, width: width, height: height, depth: depth };\r\n    this.magFilter = NearestFilter;\r\n    this.minFilter = NearestFilter;\r\n    this.wrapR = ClampToEdgeWrapping;\r\n    this.generateMipmaps = false;\r\n    this.flipY = false;\r\n}\r\nDataTexture3D.prototype = Object.create(Texture.prototype);\r\nDataTexture3D.prototype.constructor = DataTexture3D;\r\nDataTexture3D.prototype.isDataTexture3D = true;\r\n/**\r\n * @author tschw\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Uniforms of a program.\r\n * Those form a tree structure with a special top-level container for the root,\r\n * which you get by calling 'new WebGLUniforms( gl, program )'.\r\n *\r\n *\r\n * Properties of inner nodes including the top-level container:\r\n *\r\n * .seq - array of nested uniforms\r\n * .map - nested uniforms by name\r\n *\r\n *\r\n * Methods of all nodes except the top-level container:\r\n *\r\n * .setValue( gl, value, [textures] )\r\n *\r\n * \t\tuploads a uniform value(s)\r\n *  \tthe 'textures' parameter is needed for sampler uniforms\r\n *\r\n *\r\n * Static methods of the top-level container (textures factorizations):\r\n *\r\n * .upload( gl, seq, values, textures )\r\n *\r\n * \t\tsets uniforms in 'seq' to 'values[id].value'\r\n *\r\n * .seqWithValue( seq, values ) : filteredSeq\r\n *\r\n * \t\tfilters 'seq' entries with corresponding entry in values\r\n *\r\n *\r\n * Methods of the top-level container (textures factorizations):\r\n *\r\n * .setValue( gl, name, value, textures )\r\n *\r\n * \t\tsets uniform with  name 'name' to 'value'\r\n *\r\n * .setOptional( gl, obj, prop )\r\n *\r\n * \t\tlike .set for an optional property of the object\r\n *\r\n */\r\nvar emptyTexture = new Texture();\r\nvar emptyTexture2dArray = new DataTexture2DArray();\r\nvar emptyTexture3d = new DataTexture3D();\r\nvar emptyCubeTexture = new CubeTexture();\r\n// --- Utilities ---\r\n// Array Caches (provide typed arrays for temporary by size)\r\nvar arrayCacheF32 = [];\r\nvar arrayCacheI32 = [];\r\n// Float32Array caches used for uploading Matrix uniforms\r\nvar mat4array = new Float32Array(16);\r\nvar mat3array = new Float32Array(9);\r\nvar mat2array = new Float32Array(4);\r\n// Flattening for arrays of vectors and matrices\r\nfunction flatten(array, nBlocks, blockSize) {\r\n    var firstElem = array[0];\r\n    if (firstElem <= 0 || firstElem > 0)\r\n        return array;\r\n    // unoptimized: ! isNaN( firstElem )\r\n    // see http://jacksondunstan.com/articles/983\r\n    var n = nBlocks * blockSize, r = arrayCacheF32[n];\r\n    if (r === undefined) {\r\n        r = new Float32Array(n);\r\n        arrayCacheF32[n] = r;\r\n    }\r\n    if (nBlocks !== 0) {\r\n        firstElem.toArray(r, 0);\r\n        for (var i = 1, offset = 0; i !== nBlocks; ++i) {\r\n            offset += blockSize;\r\n            array[i].toArray(r, offset);\r\n        }\r\n    }\r\n    return r;\r\n}\r\nfunction arraysEqual(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    for (var i = 0, l = a.length; i < l; i++) {\r\n        if (a[i] !== b[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction copyArray(a, b) {\r\n    for (var i = 0, l = b.length; i < l; i++) {\r\n        a[i] = b[i];\r\n    }\r\n}\r\n// Texture unit allocation\r\nfunction allocTexUnits(textures, n) {\r\n    var r = arrayCacheI32[n];\r\n    if (r === undefined) {\r\n        r = new Int32Array(n);\r\n        arrayCacheI32[n] = r;\r\n    }\r\n    for (var i = 0; i !== n; ++i)\r\n        r[i] = textures.allocateTextureUnit();\r\n    return r;\r\n}\r\n// --- Setters ---\r\n// Note: Defining these methods externally, because they come in a bunch\r\n// and this way their names minify.\r\n// Single scalar\r\nfunction setValueV1f(gl, v) {\r\n    var cache = this.cache;\r\n    if (cache[0] === v)\r\n        return;\r\n    gl.uniform1f(this.addr, v);\r\n    cache[0] = v;\r\n}\r\n// Single float vector (from flat array or THREE.VectorN)\r\nfunction setValueV2f(gl, v) {\r\n    var cache = this.cache;\r\n    if (v.x !== undefined) {\r\n        if (cache[0] !== v.x || cache[1] !== v.y) {\r\n            gl.uniform2f(this.addr, v.x, v.y);\r\n            cache[0] = v.x;\r\n            cache[1] = v.y;\r\n        }\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniform2fv(this.addr, v);\r\n        copyArray(cache, v);\r\n    }\r\n}\r\nfunction setValueV3f(gl, v) {\r\n    var cache = this.cache;\r\n    if (v.x !== undefined) {\r\n        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\r\n            gl.uniform3f(this.addr, v.x, v.y, v.z);\r\n            cache[0] = v.x;\r\n            cache[1] = v.y;\r\n            cache[2] = v.z;\r\n        }\r\n    }\r\n    else if (v.r !== undefined) {\r\n        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\r\n            gl.uniform3f(this.addr, v.r, v.g, v.b);\r\n            cache[0] = v.r;\r\n            cache[1] = v.g;\r\n            cache[2] = v.b;\r\n        }\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniform3fv(this.addr, v);\r\n        copyArray(cache, v);\r\n    }\r\n}\r\nfunction setValueV4f(gl, v) {\r\n    var cache = this.cache;\r\n    if (v.x !== undefined) {\r\n        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\r\n            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\r\n            cache[0] = v.x;\r\n            cache[1] = v.y;\r\n            cache[2] = v.z;\r\n            cache[3] = v.w;\r\n        }\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniform4fv(this.addr, v);\r\n        copyArray(cache, v);\r\n    }\r\n}\r\n// Single matrix (from flat array or MatrixN)\r\nfunction setValueM2(gl, v) {\r\n    var cache = this.cache;\r\n    var elements = v.elements;\r\n    if (elements === undefined) {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniformMatrix2fv(this.addr, false, v);\r\n        copyArray(cache, v);\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, elements))\r\n            return;\r\n        mat2array.set(elements);\r\n        gl.uniformMatrix2fv(this.addr, false, mat2array);\r\n        copyArray(cache, elements);\r\n    }\r\n}\r\nfunction setValueM3(gl, v) {\r\n    var cache = this.cache;\r\n    var elements = v.elements;\r\n    if (elements === undefined) {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniformMatrix3fv(this.addr, false, v);\r\n        copyArray(cache, v);\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, elements))\r\n            return;\r\n        mat3array.set(elements);\r\n        gl.uniformMatrix3fv(this.addr, false, mat3array);\r\n        copyArray(cache, elements);\r\n    }\r\n}\r\nfunction setValueM4(gl, v) {\r\n    var cache = this.cache;\r\n    var elements = v.elements;\r\n    if (elements === undefined) {\r\n        if (arraysEqual(cache, v))\r\n            return;\r\n        gl.uniformMatrix4fv(this.addr, false, v);\r\n        copyArray(cache, v);\r\n    }\r\n    else {\r\n        if (arraysEqual(cache, elements))\r\n            return;\r\n        mat4array.set(elements);\r\n        gl.uniformMatrix4fv(this.addr, false, mat4array);\r\n        copyArray(cache, elements);\r\n    }\r\n}\r\n// Single texture (2D / Cube)\r\nfunction setValueT1(gl, v, textures) {\r\n    var cache = this.cache;\r\n    var unit = textures.allocateTextureUnit();\r\n    if (cache[0] !== unit) {\r\n        gl.uniform1i(this.addr, unit);\r\n        cache[0] = unit;\r\n    }\r\n    textures.safeSetTexture2D(v || emptyTexture, unit);\r\n}\r\nfunction setValueT2DArray1(gl, v, textures) {\r\n    var cache = this.cache;\r\n    var unit = textures.allocateTextureUnit();\r\n    if (cache[0] !== unit) {\r\n        gl.uniform1i(this.addr, unit);\r\n        cache[0] = unit;\r\n    }\r\n    textures.setTexture2DArray(v || emptyTexture2dArray, unit);\r\n}\r\nfunction setValueT3D1(gl, v, textures) {\r\n    var cache = this.cache;\r\n    var unit = textures.allocateTextureUnit();\r\n    if (cache[0] !== unit) {\r\n        gl.uniform1i(this.addr, unit);\r\n        cache[0] = unit;\r\n    }\r\n    textures.setTexture3D(v || emptyTexture3d, unit);\r\n}\r\nfunction setValueT6(gl, v, textures) {\r\n    var cache = this.cache;\r\n    var unit = textures.allocateTextureUnit();\r\n    if (cache[0] !== unit) {\r\n        gl.uniform1i(this.addr, unit);\r\n        cache[0] = unit;\r\n    }\r\n    textures.safeSetTextureCube(v || emptyCubeTexture, unit);\r\n}\r\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\nfunction setValueV1i(gl, v) {\r\n    var cache = this.cache;\r\n    if (cache[0] === v)\r\n        return;\r\n    gl.uniform1i(this.addr, v);\r\n    cache[0] = v;\r\n}\r\nfunction setValueV2i(gl, v) {\r\n    var cache = this.cache;\r\n    if (arraysEqual(cache, v))\r\n        return;\r\n    gl.uniform2iv(this.addr, v);\r\n    copyArray(cache, v);\r\n}\r\nfunction setValueV3i(gl, v) {\r\n    var cache = this.cache;\r\n    if (arraysEqual(cache, v))\r\n        return;\r\n    gl.uniform3iv(this.addr, v);\r\n    copyArray(cache, v);\r\n}\r\nfunction setValueV4i(gl, v) {\r\n    var cache = this.cache;\r\n    if (arraysEqual(cache, v))\r\n        return;\r\n    gl.uniform4iv(this.addr, v);\r\n    copyArray(cache, v);\r\n}\r\n// Helper to pick the right setter for the singular case\r\nfunction getSingularSetter(type) {\r\n    switch (type) {\r\n        case 0x1406: return setValueV1f; // FLOAT\r\n        case 0x8b50: return setValueV2f; // _VEC2\r\n        case 0x8b51: return setValueV3f; // _VEC3\r\n        case 0x8b52: return setValueV4f; // _VEC4\r\n        case 0x8b5a: return setValueM2; // _MAT2\r\n        case 0x8b5b: return setValueM3; // _MAT3\r\n        case 0x8b5c: return setValueM4; // _MAT4\r\n        case 0x8b5e:\r\n        case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\r\n        case 0x8b5f: return setValueT3D1; // SAMPLER_3D\r\n        case 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n        case 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY\r\n        case 0x1404:\r\n        case 0x8b56: return setValueV1i; // INT, BOOL\r\n        case 0x8b53:\r\n        case 0x8b57: return setValueV2i; // _VEC2\r\n        case 0x8b54:\r\n        case 0x8b58: return setValueV3i; // _VEC3\r\n        case 0x8b55:\r\n        case 0x8b59: return setValueV4i; // _VEC4\r\n    }\r\n}\r\n// Array of scalars\r\nfunction setValueV1fArray(gl, v) {\r\n    gl.uniform1fv(this.addr, v);\r\n}\r\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\nfunction setValueV1iArray(gl, v) {\r\n    gl.uniform1iv(this.addr, v);\r\n}\r\nfunction setValueV2iArray(gl, v) {\r\n    gl.uniform2iv(this.addr, v);\r\n}\r\nfunction setValueV3iArray(gl, v) {\r\n    gl.uniform3iv(this.addr, v);\r\n}\r\nfunction setValueV4iArray(gl, v) {\r\n    gl.uniform4iv(this.addr, v);\r\n}\r\n// Array of vectors (flat or from THREE classes)\r\nfunction setValueV2fArray(gl, v) {\r\n    var data = flatten(v, this.size, 2);\r\n    gl.uniform2fv(this.addr, data);\r\n}\r\nfunction setValueV3fArray(gl, v) {\r\n    var data = flatten(v, this.size, 3);\r\n    gl.uniform3fv(this.addr, data);\r\n}\r\nfunction setValueV4fArray(gl, v) {\r\n    var data = flatten(v, this.size, 4);\r\n    gl.uniform4fv(this.addr, data);\r\n}\r\n// Array of matrices (flat or from THREE clases)\r\nfunction setValueM2Array(gl, v) {\r\n    var data = flatten(v, this.size, 4);\r\n    gl.uniformMatrix2fv(this.addr, false, data);\r\n}\r\nfunction setValueM3Array(gl, v) {\r\n    var data = flatten(v, this.size, 9);\r\n    gl.uniformMatrix3fv(this.addr, false, data);\r\n}\r\nfunction setValueM4Array(gl, v) {\r\n    var data = flatten(v, this.size, 16);\r\n    gl.uniformMatrix4fv(this.addr, false, data);\r\n}\r\n// Array of textures (2D / Cube)\r\nfunction setValueT1Array(gl, v, textures) {\r\n    var n = v.length;\r\n    var units = allocTexUnits(textures, n);\r\n    gl.uniform1iv(this.addr, units);\r\n    for (var i = 0; i !== n; ++i) {\r\n        textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\r\n    }\r\n}\r\nfunction setValueT6Array(gl, v, textures) {\r\n    var n = v.length;\r\n    var units = allocTexUnits(textures, n);\r\n    gl.uniform1iv(this.addr, units);\r\n    for (var i = 0; i !== n; ++i) {\r\n        textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\r\n    }\r\n}\r\n// Helper to pick the right setter for a pure (bottom-level) array\r\nfunction getPureArraySetter(type) {\r\n    switch (type) {\r\n        case 0x1406: return setValueV1fArray; // FLOAT\r\n        case 0x8b50: return setValueV2fArray; // _VEC2\r\n        case 0x8b51: return setValueV3fArray; // _VEC3\r\n        case 0x8b52: return setValueV4fArray; // _VEC4\r\n        case 0x8b5a: return setValueM2Array; // _MAT2\r\n        case 0x8b5b: return setValueM3Array; // _MAT3\r\n        case 0x8b5c: return setValueM4Array; // _MAT4\r\n        case 0x8b5e: return setValueT1Array; // SAMPLER_2D\r\n        case 0x8b60: return setValueT6Array; // SAMPLER_CUBE\r\n        case 0x1404:\r\n        case 0x8b56: return setValueV1iArray; // INT, BOOL\r\n        case 0x8b53:\r\n        case 0x8b57: return setValueV2iArray; // _VEC2\r\n        case 0x8b54:\r\n        case 0x8b58: return setValueV3iArray; // _VEC3\r\n        case 0x8b55:\r\n        case 0x8b59: return setValueV4iArray; // _VEC4\r\n    }\r\n}\r\n// --- Uniform Classes ---\r\nfunction SingleUniform(id, activeInfo, addr) {\r\n    this.id = id;\r\n    this.addr = addr;\r\n    this.cache = [];\r\n    this.setValue = getSingularSetter(activeInfo.type);\r\n    // this.path = activeInfo.name; // DEBUG\r\n}\r\nfunction PureArrayUniform(id, activeInfo, addr) {\r\n    this.id = id;\r\n    this.addr = addr;\r\n    this.cache = [];\r\n    this.size = activeInfo.size;\r\n    this.setValue = getPureArraySetter(activeInfo.type);\r\n    // this.path = activeInfo.name; // DEBUG\r\n}\r\nPureArrayUniform.prototype.updateCache = function (data) {\r\n    var cache = this.cache;\r\n    if (data instanceof Float32Array && cache.length !== data.length) {\r\n        this.cache = new Float32Array(data.length);\r\n    }\r\n    copyArray(cache, data);\r\n};\r\nfunction StructuredUniform(id) {\r\n    this.id = id;\r\n    this.seq = [];\r\n    this.map = {};\r\n}\r\nStructuredUniform.prototype.setValue = function (gl, value, textures) {\r\n    var seq = this.seq;\r\n    for (var i = 0, n = seq.length; i !== n; ++i) {\r\n        var u = seq[i];\r\n        u.setValue(gl, value[u.id], textures);\r\n    }\r\n};\r\n// --- Top-level ---\r\n// Parser - builds up the property tree from the path strings\r\nvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\r\n// extracts\r\n// \t- the identifier (member name or array index)\r\n//  - followed by an optional right bracket (found when array index)\r\n//  - followed by an optional left bracket or dot (type of subscript)\r\n//\r\n// Note: These portions can be read in a non-overlapping fashion and\r\n// allow straightforward parsing of the hierarchy that WebGL encodes\r\n// in the uniform names.\r\nfunction addUniform(container, uniformObject) {\r\n    container.seq.push(uniformObject);\r\n    container.map[uniformObject.id] = uniformObject;\r\n}\r\nfunction parseUniform(activeInfo, addr, container) {\r\n    var path = activeInfo.name, pathLength = path.length;\r\n    // reset RegExp object, because of the early exit of a previous run\r\n    RePathPart.lastIndex = 0;\r\n    while (true) {\r\n        var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === ']', subscript = match[3];\r\n        if (idIsIndex)\r\n            id = id | 0; // convert to integer\r\n        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {\r\n            // bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n            addUniform(container, subscript === undefined ?\r\n                new SingleUniform(id, activeInfo, addr) :\r\n                new PureArrayUniform(id, activeInfo, addr));\r\n            break;\r\n        }\r\n        else {\r\n            // step into inner node / create it in case it doesn't exist\r\n            var map = container.map, next = map[id];\r\n            if (next === undefined) {\r\n                next = new StructuredUniform(id);\r\n                addUniform(container, next);\r\n            }\r\n            container = next;\r\n        }\r\n    }\r\n}\r\n// Root Container\r\nfunction WebGLUniforms(gl, program) {\r\n    this.seq = [];\r\n    this.map = {};\r\n    var n = gl.getProgramParameter(program, 35718);\r\n    for (var i = 0; i < n; ++i) {\r\n        var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);\r\n        parseUniform(info, addr, this);\r\n    }\r\n}\r\nWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\r\n    var u = this.map[name];\r\n    if (u !== undefined)\r\n        u.setValue(gl, value, textures);\r\n};\r\nWebGLUniforms.prototype.setOptional = function (gl, object, name) {\r\n    var v = object[name];\r\n    if (v !== undefined)\r\n        this.setValue(gl, name, v);\r\n};\r\n// Static interface\r\nWebGLUniforms.upload = function (gl, seq, values, textures) {\r\n    for (var i = 0, n = seq.length; i !== n; ++i) {\r\n        var u = seq[i], v = values[u.id];\r\n        if (v.needsUpdate !== false) {\r\n            // note: always updating when .needsUpdate is undefined\r\n            u.setValue(gl, v.value, textures);\r\n        }\r\n    }\r\n};\r\nWebGLUniforms.seqWithValue = function (seq, values) {\r\n    var r = [];\r\n    for (var i = 0, n = seq.length; i !== n; ++i) {\r\n        var u = seq[i];\r\n        if (u.id in values)\r\n            r.push(u);\r\n    }\r\n    return r;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLShader(gl, type, string) {\r\n    var shader = gl.createShader(type);\r\n    gl.shaderSource(shader, string);\r\n    gl.compileShader(shader);\r\n    return shader;\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar programIdCount = 0;\r\nfunction addLineNumbers(string) {\r\n    var lines = string.split('\\n');\r\n    for (var i = 0; i < lines.length; i++) {\r\n        lines[i] = (i + 1) + ': ' + lines[i];\r\n    }\r\n    return lines.join('\\n');\r\n}\r\nfunction getEncodingComponents(encoding) {\r\n    switch (encoding) {\r\n        case LinearEncoding:\r\n            return ['Linear', '( value )'];\r\n        case sRGBEncoding:\r\n            return ['sRGB', '( value )'];\r\n        case RGBEEncoding:\r\n            return ['RGBE', '( value )'];\r\n        case RGBM7Encoding:\r\n            return ['RGBM', '( value, 7.0 )'];\r\n        case RGBM16Encoding:\r\n            return ['RGBM', '( value, 16.0 )'];\r\n        case RGBDEncoding:\r\n            return ['RGBD', '( value, 256.0 )'];\r\n        case GammaEncoding:\r\n            return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\r\n        default:\r\n            throw new Error('unsupported encoding: ' + encoding);\r\n    }\r\n}\r\nfunction getShaderErrors(gl, shader, type) {\r\n    var status = gl.getShaderParameter(shader, 35713);\r\n    var log = gl.getShaderInfoLog(shader).trim();\r\n    if (status && log === '')\r\n        return '';\r\n    // --enable-privileged-webgl-extension\r\n    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n    var source = gl.getShaderSource(shader);\r\n    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers(source);\r\n}\r\nfunction getTexelDecodingFunction(functionName, encoding) {\r\n    var components = getEncodingComponents(encoding);\r\n    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\r\n}\r\nfunction getTexelEncodingFunction(functionName, encoding) {\r\n    var components = getEncodingComponents(encoding);\r\n    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';\r\n}\r\nfunction getToneMappingFunction(functionName, toneMapping) {\r\n    var toneMappingName;\r\n    switch (toneMapping) {\r\n        case LinearToneMapping:\r\n            toneMappingName = 'Linear';\r\n            break;\r\n        case ReinhardToneMapping:\r\n            toneMappingName = 'Reinhard';\r\n            break;\r\n        case Uncharted2ToneMapping:\r\n            toneMappingName = 'Uncharted2';\r\n            break;\r\n        case CineonToneMapping:\r\n            toneMappingName = 'OptimizedCineon';\r\n            break;\r\n        case ACESFilmicToneMapping:\r\n            toneMappingName = 'ACESFilmic';\r\n            break;\r\n        default:\r\n            throw new Error('unsupported toneMapping: ' + toneMapping);\r\n    }\r\n    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\r\n}\r\nfunction generateExtensions(extensions, parameters, rendererExtensions) {\r\n    extensions = extensions || {};\r\n    var chunks = [\r\n        (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || (parameters.normalMap && !parameters.objectSpaceNormalMap) || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n        (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',\r\n        (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',\r\n        (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''\r\n    ];\r\n    return chunks.filter(filterEmptyLine).join('\\n');\r\n}\r\nfunction generateDefines(defines) {\r\n    var chunks = [];\r\n    for (var name in defines) {\r\n        var value = defines[name];\r\n        if (value === false)\r\n            continue;\r\n        chunks.push('#define ' + name + ' ' + value);\r\n    }\r\n    return chunks.join('\\n');\r\n}\r\nfunction fetchAttributeLocations(gl, program) {\r\n    var attributes = {};\r\n    var n = gl.getProgramParameter(program, 35721);\r\n    for (var i = 0; i < n; i++) {\r\n        var info = gl.getActiveAttrib(program, i);\r\n        var name = info.name;\r\n        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\r\n        attributes[name] = gl.getAttribLocation(program, name);\r\n    }\r\n    return attributes;\r\n}\r\nfunction filterEmptyLine(string) {\r\n    return string !== '';\r\n}\r\nfunction replaceLightNums(string, parameters) {\r\n    return string\r\n        .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)\r\n        .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)\r\n        .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)\r\n        .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)\r\n        .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);\r\n}\r\nfunction replaceClippingPlaneNums(string, parameters) {\r\n    return string\r\n        .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)\r\n        .replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));\r\n}\r\nfunction parseIncludes(string) {\r\n    var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\r\n    function replace(match, include) {\r\n        var replace = ShaderChunk[include];\r\n        if (replace === undefined) {\r\n            throw new Error('Can not resolve #include <' + include + '>');\r\n        }\r\n        return parseIncludes(replace);\r\n    }\r\n    return string.replace(pattern, replace);\r\n}\r\nfunction unrollLoops(string) {\r\n    var pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n    function replace(match, start, end, snippet) {\r\n        var unroll = '';\r\n        for (var i = parseInt(start); i < parseInt(end); i++) {\r\n            unroll += snippet.replace(/\\[ i \\]/g, '[ ' + i + ' ]');\r\n        }\r\n        return unroll;\r\n    }\r\n    return string.replace(pattern, replace);\r\n}\r\nfunction WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {\r\n    var gl = renderer.getContext();\r\n    var defines = material.defines;\r\n    var vertexShader = shader.vertexShader;\r\n    var fragmentShader = shader.fragmentShader;\r\n    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n    if (parameters.shadowMapType === PCFShadowMap) {\r\n        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n    }\r\n    else if (parameters.shadowMapType === PCFSoftShadowMap) {\r\n        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n    }\r\n    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n    if (parameters.envMap) {\r\n        switch (material.envMap.mapping) {\r\n            case CubeReflectionMapping:\r\n            case CubeRefractionMapping:\r\n                envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n                break;\r\n            case CubeUVReflectionMapping:\r\n            case CubeUVRefractionMapping:\r\n                envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n                break;\r\n            case EquirectangularReflectionMapping:\r\n            case EquirectangularRefractionMapping:\r\n                envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n                break;\r\n            case SphericalReflectionMapping:\r\n                envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n                break;\r\n        }\r\n        switch (material.envMap.mapping) {\r\n            case CubeRefractionMapping:\r\n            case EquirectangularRefractionMapping:\r\n                envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n                break;\r\n        }\r\n        switch (material.combine) {\r\n            case MultiplyOperation:\r\n                envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n                break;\r\n            case MixOperation:\r\n                envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n                break;\r\n            case AddOperation:\r\n                envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n                break;\r\n        }\r\n    }\r\n    var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;\r\n    // console.log( 'building new program ' );\r\n    //\r\n    var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);\r\n    var customDefines = generateDefines(defines);\r\n    //\r\n    var program = gl.createProgram();\r\n    var prefixVertex, prefixFragment;\r\n    if (material.isRawShaderMaterial) {\r\n        prefixVertex = [\r\n            customDefines\r\n        ].filter(filterEmptyLine).join('\\n');\r\n        if (prefixVertex.length > 0) {\r\n            prefixVertex += '\\n';\r\n        }\r\n        prefixFragment = [\r\n            customExtensions,\r\n            customDefines\r\n        ].filter(filterEmptyLine).join('\\n');\r\n        if (prefixFragment.length > 0) {\r\n            prefixFragment += '\\n';\r\n        }\r\n    }\r\n    else {\r\n        prefixVertex = [\r\n            'precision ' + parameters.precision + ' float;',\r\n            'precision ' + parameters.precision + ' int;',\r\n            '#define SHADER_NAME ' + shader.name,\r\n            customDefines,\r\n            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n            '#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n            '#define MAX_BONES ' + parameters.maxBones,\r\n            (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',\r\n            (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',\r\n            parameters.map ? '#define USE_MAP' : '',\r\n            parameters.envMap ? '#define USE_ENVMAP' : '',\r\n            parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n            parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n            parameters.aoMap ? '#define USE_AOMAP' : '',\r\n            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n            parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n            parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n            (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',\r\n            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n            parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n            parameters.vertexTangents ? '#define USE_TANGENT' : '',\r\n            parameters.vertexColors ? '#define USE_COLOR' : '',\r\n            parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n            parameters.skinning ? '#define USE_SKINNING' : '',\r\n            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n            parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n            parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n            'uniform mat4 modelMatrix;',\r\n            'uniform mat4 modelViewMatrix;',\r\n            'uniform mat4 projectionMatrix;',\r\n            'uniform mat4 viewMatrix;',\r\n            'uniform mat3 normalMatrix;',\r\n            'uniform vec3 cameraPosition;',\r\n            'attribute vec3 position;',\r\n            'attribute vec3 normal;',\r\n            'attribute vec2 uv;',\r\n            '#ifdef USE_TANGENT',\r\n            '\tattribute vec4 tangent;',\r\n            '#endif',\r\n            '#ifdef USE_COLOR',\r\n            '\tattribute vec3 color;',\r\n            '#endif',\r\n            '#ifdef USE_MORPHTARGETS',\r\n            '\tattribute vec3 morphTarget0;',\r\n            '\tattribute vec3 morphTarget1;',\r\n            '\tattribute vec3 morphTarget2;',\r\n            '\tattribute vec3 morphTarget3;',\r\n            '\t#ifdef USE_MORPHNORMALS',\r\n            '\t\tattribute vec3 morphNormal0;',\r\n            '\t\tattribute vec3 morphNormal1;',\r\n            '\t\tattribute vec3 morphNormal2;',\r\n            '\t\tattribute vec3 morphNormal3;',\r\n            '\t#else',\r\n            '\t\tattribute vec3 morphTarget4;',\r\n            '\t\tattribute vec3 morphTarget5;',\r\n            '\t\tattribute vec3 morphTarget6;',\r\n            '\t\tattribute vec3 morphTarget7;',\r\n            '\t#endif',\r\n            '#endif',\r\n            '#ifdef USE_SKINNING',\r\n            '\tattribute vec4 skinIndex;',\r\n            '\tattribute vec4 skinWeight;',\r\n            '#endif',\r\n            '\\n'\r\n        ].filter(filterEmptyLine).join('\\n');\r\n        prefixFragment = [\r\n            customExtensions,\r\n            'precision ' + parameters.precision + ' float;',\r\n            'precision ' + parameters.precision + ' int;',\r\n            '#define SHADER_NAME ' + shader.name,\r\n            customDefines,\r\n            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',\r\n            '#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n            (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',\r\n            (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',\r\n            parameters.map ? '#define USE_MAP' : '',\r\n            parameters.matcap ? '#define USE_MATCAP' : '',\r\n            parameters.envMap ? '#define USE_ENVMAP' : '',\r\n            parameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n            parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n            parameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n            parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n            parameters.aoMap ? '#define USE_AOMAP' : '',\r\n            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n            parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n            parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n            (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',\r\n            parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n            parameters.vertexTangents ? '#define USE_TANGENT' : '',\r\n            parameters.vertexColors ? '#define USE_COLOR' : '',\r\n            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\r\n            parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n            parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\r\n            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\r\n            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n            parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n            parameters.envMap && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '',\r\n            'uniform mat4 viewMatrix;',\r\n            'uniform vec3 cameraPosition;',\r\n            (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',\r\n            (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '',\r\n            (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',\r\n            parameters.dithering ? '#define DITHERING' : '',\r\n            (parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ?\r\n                ShaderChunk['encodings_pars_fragment'] : '',\r\n            parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',\r\n            parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',\r\n            parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',\r\n            parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',\r\n            parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',\r\n            parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\r\n            '\\n'\r\n        ].filter(filterEmptyLine).join('\\n');\r\n    }\r\n    vertexShader = parseIncludes(vertexShader);\r\n    vertexShader = replaceLightNums(vertexShader, parameters);\r\n    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\r\n    fragmentShader = parseIncludes(fragmentShader);\r\n    fragmentShader = replaceLightNums(fragmentShader, parameters);\r\n    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\r\n    vertexShader = unrollLoops(vertexShader);\r\n    fragmentShader = unrollLoops(fragmentShader);\r\n    if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {\r\n        var isGLSL3ShaderMaterial = false;\r\n        var versionRegex = /^\\s*#version\\s+300\\s+es\\s*\\n/;\r\n        if (material.isShaderMaterial &&\r\n            vertexShader.match(versionRegex) !== null &&\r\n            fragmentShader.match(versionRegex) !== null) {\r\n            isGLSL3ShaderMaterial = true;\r\n            vertexShader = vertexShader.replace(versionRegex, '');\r\n            fragmentShader = fragmentShader.replace(versionRegex, '');\r\n        }\r\n        // GLSL 3.0 conversion\r\n        prefixVertex = [\r\n            '#version 300 es\\n',\r\n            '#define attribute in',\r\n            '#define varying out',\r\n            '#define texture2D texture'\r\n        ].join('\\n') + '\\n' + prefixVertex;\r\n        prefixFragment = [\r\n            '#version 300 es\\n',\r\n            '#define varying in',\r\n            isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',\r\n            isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',\r\n            '#define gl_FragDepthEXT gl_FragDepth',\r\n            '#define texture2D texture',\r\n            '#define textureCube texture',\r\n            '#define texture2DProj textureProj',\r\n            '#define texture2DLodEXT textureLod',\r\n            '#define texture2DProjLodEXT textureProjLod',\r\n            '#define textureCubeLodEXT textureLod',\r\n            '#define texture2DGradEXT textureGrad',\r\n            '#define texture2DProjGradEXT textureProjGrad',\r\n            '#define textureCubeGradEXT textureGrad'\r\n        ].join('\\n') + '\\n' + prefixFragment;\r\n    }\r\n    var vertexGlsl = prefixVertex + vertexShader;\r\n    var fragmentGlsl = prefixFragment + fragmentShader;\r\n    // console.log( '*VERTEX*', vertexGlsl );\r\n    // console.log( '*FRAGMENT*', fragmentGlsl );\r\n    var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);\r\n    var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);\r\n    gl.attachShader(program, glVertexShader);\r\n    gl.attachShader(program, glFragmentShader);\r\n    // Force a particular attribute to index 0.\r\n    if (material.index0AttributeName !== undefined) {\r\n        gl.bindAttribLocation(program, 0, material.index0AttributeName);\r\n    }\r\n    else if (parameters.morphTargets === true) {\r\n        // programs with morphTargets displace position out of attribute 0\r\n        gl.bindAttribLocation(program, 0, 'position');\r\n    }\r\n    gl.linkProgram(program);\r\n    // check for link errors\r\n    if (renderer.debug.checkShaderErrors) {\r\n        var programLog = gl.getProgramInfoLog(program).trim();\r\n        var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\r\n        var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\r\n        var runnable = true;\r\n        var haveDiagnostics = true;\r\n        if (gl.getProgramParameter(program, 35714) === false) {\r\n            runnable = false;\r\n            var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\r\n            var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\r\n            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);\r\n        }\r\n        else if (programLog !== '') {\r\n            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\r\n        }\r\n        else if (vertexLog === '' || fragmentLog === '') {\r\n            haveDiagnostics = false;\r\n        }\r\n        if (haveDiagnostics) {\r\n            this.diagnostics = {\r\n                runnable: runnable,\r\n                material: material,\r\n                programLog: programLog,\r\n                vertexShader: {\r\n                    log: vertexLog,\r\n                    prefix: prefixVertex\r\n                },\r\n                fragmentShader: {\r\n                    log: fragmentLog,\r\n                    prefix: prefixFragment\r\n                }\r\n            };\r\n        }\r\n    }\r\n    // clean up\r\n    gl.deleteShader(glVertexShader);\r\n    gl.deleteShader(glFragmentShader);\r\n    // set up caching for uniform locations\r\n    var cachedUniforms;\r\n    this.getUniforms = function () {\r\n        if (cachedUniforms === undefined) {\r\n            cachedUniforms = new WebGLUniforms(gl, program);\r\n        }\r\n        return cachedUniforms;\r\n    };\r\n    // set up caching for attribute locations\r\n    var cachedAttributes;\r\n    this.getAttributes = function () {\r\n        if (cachedAttributes === undefined) {\r\n            cachedAttributes = fetchAttributeLocations(gl, program);\r\n        }\r\n        return cachedAttributes;\r\n    };\r\n    // free resource\r\n    this.destroy = function () {\r\n        gl.deleteProgram(program);\r\n        this.program = undefined;\r\n    };\r\n    //\r\n    this.name = shader.name;\r\n    this.id = programIdCount++;\r\n    this.code = code;\r\n    this.usedTimes = 1;\r\n    this.program = program;\r\n    this.vertexShader = glVertexShader;\r\n    this.fragmentShader = glFragmentShader;\r\n    return this;\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLPrograms(renderer, extensions, capabilities) {\r\n    var programs = [];\r\n    var shaderIDs = {\r\n        MeshDepthMaterial: 'depth',\r\n        MeshDistanceMaterial: 'distanceRGBA',\r\n        MeshNormalMaterial: 'normal',\r\n        MeshBasicMaterial: 'basic',\r\n        MeshLambertMaterial: 'lambert',\r\n        MeshPhongMaterial: 'phong',\r\n        MeshToonMaterial: 'phong',\r\n        MeshStandardMaterial: 'physical',\r\n        MeshPhysicalMaterial: 'physical',\r\n        MeshMatcapMaterial: 'matcap',\r\n        LineBasicMaterial: 'basic',\r\n        LineDashedMaterial: 'dashed',\r\n        PointsMaterial: 'points',\r\n        ShadowMaterial: 'shadow',\r\n        SpriteMaterial: 'sprite'\r\n    };\r\n    var parameterNames = [\r\n        \"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"matcap\", \"matcapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n        \"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"objectSpaceNormalMap\", \"displacementMap\", \"specularMap\",\r\n        \"roughnessMap\", \"metalnessMap\", \"gradientMap\",\r\n        \"alphaMap\", \"combine\", \"vertexColors\", \"vertexTangents\", \"fog\", \"useFog\", \"fogExp\",\r\n        \"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n        \"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n        \"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n        \"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\r\n        \"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n        \"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\r\n    ];\r\n    function allocateBones(object) {\r\n        var skeleton = object.skeleton;\r\n        var bones = skeleton.bones;\r\n        if (capabilities.floatVertexTextures) {\r\n            return 1024;\r\n        }\r\n        else {\r\n            // default for when object is not specified\r\n            // ( for example when prebuilding shader to be used with multiple objects )\r\n            //\r\n            //  - leave some extra space for other uniforms\r\n            //  - limit here is ANGLE's 254 max uniform vectors\r\n            //    (up to 54 should be safe)\r\n            var nVertexUniforms = capabilities.maxVertexUniforms;\r\n            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\r\n            var maxBones = Math.min(nVertexMatrices, bones.length);\r\n            if (maxBones < bones.length) {\r\n                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\r\n                return 0;\r\n            }\r\n            return maxBones;\r\n        }\r\n    }\r\n    function getTextureEncodingFromMap(map, gammaOverrideLinear) {\r\n        var encoding;\r\n        if (!map) {\r\n            encoding = LinearEncoding;\r\n        }\r\n        else if (map.isTexture) {\r\n            encoding = map.encoding;\r\n        }\r\n        else if (map.isWebGLRenderTarget) {\r\n            console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\r\n            encoding = map.texture.encoding;\r\n        }\r\n        // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n        if (encoding === LinearEncoding && gammaOverrideLinear) {\r\n            encoding = GammaEncoding;\r\n        }\r\n        return encoding;\r\n    }\r\n    this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {\r\n        var shaderID = shaderIDs[material.type];\r\n        // heuristics to create shader parameters according to lights in the scene\r\n        // (not to blow over maxLights budget)\r\n        var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;\r\n        var precision = capabilities.precision;\r\n        if (material.precision !== null) {\r\n            precision = capabilities.getMaxPrecision(material.precision);\r\n            if (precision !== material.precision) {\r\n                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\r\n            }\r\n        }\r\n        var currentRenderTarget = renderer.getRenderTarget();\r\n        var parameters = {\r\n            shaderID: shaderID,\r\n            precision: precision,\r\n            supportsVertexTextures: capabilities.vertexTextures,\r\n            outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),\r\n            map: !!material.map,\r\n            mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),\r\n            matcap: !!material.matcap,\r\n            matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),\r\n            envMap: !!material.envMap,\r\n            envMapMode: material.envMap && material.envMap.mapping,\r\n            envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),\r\n            envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === CubeUVReflectionMapping) || (material.envMap.mapping === CubeUVRefractionMapping)),\r\n            lightMap: !!material.lightMap,\r\n            aoMap: !!material.aoMap,\r\n            emissiveMap: !!material.emissiveMap,\r\n            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),\r\n            bumpMap: !!material.bumpMap,\r\n            normalMap: !!material.normalMap,\r\n            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\r\n            displacementMap: !!material.displacementMap,\r\n            roughnessMap: !!material.roughnessMap,\r\n            metalnessMap: !!material.metalnessMap,\r\n            specularMap: !!material.specularMap,\r\n            alphaMap: !!material.alphaMap,\r\n            gradientMap: !!material.gradientMap,\r\n            combine: material.combine,\r\n            vertexTangents: (material.normalMap && material.vertexTangents),\r\n            vertexColors: material.vertexColors,\r\n            fog: !!fog,\r\n            useFog: material.fog,\r\n            fogExp: (fog && fog.isFogExp2),\r\n            flatShading: material.flatShading,\r\n            sizeAttenuation: material.sizeAttenuation,\r\n            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n            skinning: material.skinning && maxBones > 0,\r\n            maxBones: maxBones,\r\n            useVertexTexture: capabilities.floatVertexTextures,\r\n            morphTargets: material.morphTargets,\r\n            morphNormals: material.morphNormals,\r\n            maxMorphTargets: renderer.maxMorphTargets,\r\n            maxMorphNormals: renderer.maxMorphNormals,\r\n            numDirLights: lights.directional.length,\r\n            numPointLights: lights.point.length,\r\n            numSpotLights: lights.spot.length,\r\n            numRectAreaLights: lights.rectArea.length,\r\n            numHemiLights: lights.hemi.length,\r\n            numClippingPlanes: nClipPlanes,\r\n            numClipIntersection: nClipIntersection,\r\n            dithering: material.dithering,\r\n            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\r\n            shadowMapType: renderer.shadowMap.type,\r\n            toneMapping: renderer.toneMapping,\r\n            physicallyCorrectLights: renderer.physicallyCorrectLights,\r\n            premultipliedAlpha: material.premultipliedAlpha,\r\n            alphaTest: material.alphaTest,\r\n            doubleSided: material.side === DoubleSide,\r\n            flipSided: material.side === BackSide,\r\n            depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false\r\n        };\r\n        return parameters;\r\n    };\r\n    this.getProgramCode = function (material, parameters) {\r\n        var array = [];\r\n        if (parameters.shaderID) {\r\n            array.push(parameters.shaderID);\r\n        }\r\n        else {\r\n            array.push(material.fragmentShader);\r\n            array.push(material.vertexShader);\r\n        }\r\n        if (material.defines !== undefined) {\r\n            for (var name in material.defines) {\r\n                array.push(name);\r\n                array.push(material.defines[name]);\r\n            }\r\n        }\r\n        for (var i = 0; i < parameterNames.length; i++) {\r\n            array.push(parameters[parameterNames[i]]);\r\n        }\r\n        array.push(material.onBeforeCompile.toString());\r\n        array.push(renderer.gammaOutput);\r\n        array.push(renderer.gammaFactor);\r\n        return array.join();\r\n    };\r\n    this.acquireProgram = function (material, shader, parameters, code) {\r\n        var program;\r\n        // Check if code has been already compiled\r\n        for (var p = 0, pl = programs.length; p < pl; p++) {\r\n            var programInfo = programs[p];\r\n            if (programInfo.code === code) {\r\n                program = programInfo;\r\n                ++program.usedTimes;\r\n                break;\r\n            }\r\n        }\r\n        if (program === undefined) {\r\n            program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);\r\n            programs.push(program);\r\n        }\r\n        return program;\r\n    };\r\n    this.releaseProgram = function (program) {\r\n        if (--program.usedTimes === 0) {\r\n            // Remove from unordered set\r\n            var i = programs.indexOf(program);\r\n            programs[i] = programs[programs.length - 1];\r\n            programs.pop();\r\n            // Free WebGL resources\r\n            program.destroy();\r\n        }\r\n    };\r\n    // Exposed for resource monitoring & error feedback via renderer.info:\r\n    this.programs = programs;\r\n}\r\n/**\r\n * @author fordacious / fordacious.github.io\r\n */\r\nfunction WebGLProperties() {\r\n    var properties = new WeakMap();\r\n    function get(object) {\r\n        var map = properties.get(object);\r\n        if (map === undefined) {\r\n            map = {};\r\n            properties.set(object, map);\r\n        }\r\n        return map;\r\n    }\r\n    function remove(object) {\r\n        properties.delete(object);\r\n    }\r\n    function update(object, key, value) {\r\n        properties.get(object)[key] = value;\r\n    }\r\n    function dispose() {\r\n        properties = new WeakMap();\r\n    }\r\n    return {\r\n        get: get,\r\n        remove: remove,\r\n        update: update,\r\n        dispose: dispose\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction painterSortStable(a, b) {\r\n    if (a.groupOrder !== b.groupOrder) {\r\n        return a.groupOrder - b.groupOrder;\r\n    }\r\n    else if (a.renderOrder !== b.renderOrder) {\r\n        return a.renderOrder - b.renderOrder;\r\n    }\r\n    else if (a.program !== b.program) {\r\n        return a.program.id - b.program.id;\r\n    }\r\n    else if (a.material.id !== b.material.id) {\r\n        return a.material.id - b.material.id;\r\n    }\r\n    else if (a.z !== b.z) {\r\n        return a.z - b.z;\r\n    }\r\n    else {\r\n        return a.id - b.id;\r\n    }\r\n}\r\nfunction reversePainterSortStable(a, b) {\r\n    if (a.groupOrder !== b.groupOrder) {\r\n        return a.groupOrder - b.groupOrder;\r\n    }\r\n    else if (a.renderOrder !== b.renderOrder) {\r\n        return a.renderOrder - b.renderOrder;\r\n    }\r\n    else if (a.z !== b.z) {\r\n        return b.z - a.z;\r\n    }\r\n    else {\r\n        return a.id - b.id;\r\n    }\r\n}\r\nfunction WebGLRenderList() {\r\n    var renderItems = [];\r\n    var renderItemsIndex = 0;\r\n    var opaque = [];\r\n    var transparent = [];\r\n    var defaultProgram = { id: -1 };\r\n    function init() {\r\n        renderItemsIndex = 0;\r\n        opaque.length = 0;\r\n        transparent.length = 0;\r\n    }\r\n    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\r\n        var renderItem = renderItems[renderItemsIndex];\r\n        if (renderItem === undefined) {\r\n            renderItem = {\r\n                id: object.id,\r\n                object: object,\r\n                geometry: geometry,\r\n                material: material,\r\n                program: material.program || defaultProgram,\r\n                groupOrder: groupOrder,\r\n                renderOrder: object.renderOrder,\r\n                z: z,\r\n                group: group\r\n            };\r\n            renderItems[renderItemsIndex] = renderItem;\r\n        }\r\n        else {\r\n            renderItem.id = object.id;\r\n            renderItem.object = object;\r\n            renderItem.geometry = geometry;\r\n            renderItem.material = material;\r\n            renderItem.program = material.program || defaultProgram;\r\n            renderItem.groupOrder = groupOrder;\r\n            renderItem.renderOrder = object.renderOrder;\r\n            renderItem.z = z;\r\n            renderItem.group = group;\r\n        }\r\n        renderItemsIndex++;\r\n        return renderItem;\r\n    }\r\n    function push(object, geometry, material, groupOrder, z, group) {\r\n        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\r\n        (material.transparent === true ? transparent : opaque).push(renderItem);\r\n    }\r\n    function unshift(object, geometry, material, groupOrder, z, group) {\r\n        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\r\n        (material.transparent === true ? transparent : opaque).unshift(renderItem);\r\n    }\r\n    function sort() {\r\n        if (opaque.length > 1)\r\n            opaque.sort(painterSortStable);\r\n        if (transparent.length > 1)\r\n            transparent.sort(reversePainterSortStable);\r\n    }\r\n    return {\r\n        opaque: opaque,\r\n        transparent: transparent,\r\n        init: init,\r\n        push: push,\r\n        unshift: unshift,\r\n        sort: sort\r\n    };\r\n}\r\nfunction WebGLRenderLists() {\r\n    var lists = {};\r\n    function onSceneDispose(event) {\r\n        var scene = event.target;\r\n        scene.removeEventListener('dispose', onSceneDispose);\r\n        delete lists[scene.id];\r\n    }\r\n    function get(scene, camera) {\r\n        var cameras = lists[scene.id];\r\n        var list;\r\n        if (cameras === undefined) {\r\n            list = new WebGLRenderList();\r\n            lists[scene.id] = {};\r\n            lists[scene.id][camera.id] = list;\r\n            scene.addEventListener('dispose', onSceneDispose);\r\n        }\r\n        else {\r\n            list = cameras[camera.id];\r\n            if (list === undefined) {\r\n                list = new WebGLRenderList();\r\n                cameras[camera.id] = list;\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n    function dispose() {\r\n        lists = {};\r\n    }\r\n    return {\r\n        get: get,\r\n        dispose: dispose\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction UniformsCache() {\r\n    var lights = {};\r\n    return {\r\n        get: function (light) {\r\n            if (lights[light.id] !== undefined) {\r\n                return lights[light.id];\r\n            }\r\n            var uniforms;\r\n            switch (light.type) {\r\n                case 'DirectionalLight':\r\n                    uniforms = {\r\n                        direction: new Vector3(),\r\n                        color: new Color(),\r\n                        shadow: false,\r\n                        shadowBias: 0,\r\n                        shadowRadius: 1,\r\n                        shadowMapSize: new Vector2()\r\n                    };\r\n                    break;\r\n                case 'SpotLight':\r\n                    uniforms = {\r\n                        position: new Vector3(),\r\n                        direction: new Vector3(),\r\n                        color: new Color(),\r\n                        distance: 0,\r\n                        coneCos: 0,\r\n                        penumbraCos: 0,\r\n                        decay: 0,\r\n                        shadow: false,\r\n                        shadowBias: 0,\r\n                        shadowRadius: 1,\r\n                        shadowMapSize: new Vector2()\r\n                    };\r\n                    break;\r\n                case 'PointLight':\r\n                    uniforms = {\r\n                        position: new Vector3(),\r\n                        color: new Color(),\r\n                        distance: 0,\r\n                        decay: 0,\r\n                        shadow: false,\r\n                        shadowBias: 0,\r\n                        shadowRadius: 1,\r\n                        shadowMapSize: new Vector2(),\r\n                        shadowCameraNear: 1,\r\n                        shadowCameraFar: 1000\r\n                    };\r\n                    break;\r\n                case 'HemisphereLight':\r\n                    uniforms = {\r\n                        direction: new Vector3(),\r\n                        skyColor: new Color(),\r\n                        groundColor: new Color()\r\n                    };\r\n                    break;\r\n                case 'RectAreaLight':\r\n                    uniforms = {\r\n                        color: new Color(),\r\n                        position: new Vector3(),\r\n                        halfWidth: new Vector3(),\r\n                        halfHeight: new Vector3()\r\n                        // TODO (abelnation): set RectAreaLight shadow uniforms\r\n                    };\r\n                    break;\r\n            }\r\n            lights[light.id] = uniforms;\r\n            return uniforms;\r\n        }\r\n    };\r\n}\r\nvar nextVersion = 0;\r\nfunction WebGLLights() {\r\n    var cache = new UniformsCache();\r\n    var state = {\r\n        version: 0,\r\n        hash: {\r\n            directionalLength: -1,\r\n            pointLength: -1,\r\n            spotLength: -1,\r\n            rectAreaLength: -1,\r\n            hemiLength: -1,\r\n            shadowsLength: -1,\r\n        },\r\n        ambient: [0, 0, 0],\r\n        probe: [],\r\n        directional: [],\r\n        directionalShadowMap: [],\r\n        directionalShadowMatrix: [],\r\n        spot: [],\r\n        spotShadowMap: [],\r\n        spotShadowMatrix: [],\r\n        rectArea: [],\r\n        point: [],\r\n        pointShadowMap: [],\r\n        pointShadowMatrix: [],\r\n        hemi: []\r\n    };\r\n    for (var i = 0; i < 9; i++)\r\n        state.probe.push(new Vector3());\r\n    var vector3 = new Vector3();\r\n    var matrix4 = new Matrix4();\r\n    var matrix42 = new Matrix4();\r\n    function setup(lights, shadows, camera) {\r\n        var r = 0, g = 0, b = 0;\r\n        for (var i = 0; i < 9; i++)\r\n            state.probe[i].set(0, 0, 0);\r\n        var directionalLength = 0;\r\n        var pointLength = 0;\r\n        var spotLength = 0;\r\n        var rectAreaLength = 0;\r\n        var hemiLength = 0;\r\n        var viewMatrix = camera.matrixWorldInverse;\r\n        for (var i = 0, l = lights.length; i < l; i++) {\r\n            var light = lights[i];\r\n            var color = light.color;\r\n            var intensity = light.intensity;\r\n            var distance = light.distance;\r\n            var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;\r\n            if (light.isAmbientLight) {\r\n                r += color.r * intensity;\r\n                g += color.g * intensity;\r\n                b += color.b * intensity;\r\n            }\r\n            else if (light.isLightProbe) {\r\n                for (var j = 0; j < 9; j++) {\r\n                    state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\r\n                }\r\n            }\r\n            else if (light.isDirectionalLight) {\r\n                var uniforms = cache.get(light);\r\n                uniforms.color.copy(light.color).multiplyScalar(light.intensity);\r\n                uniforms.direction.setFromMatrixPosition(light.matrixWorld);\r\n                vector3.setFromMatrixPosition(light.target.matrixWorld);\r\n                uniforms.direction.sub(vector3);\r\n                uniforms.direction.transformDirection(viewMatrix);\r\n                uniforms.shadow = light.castShadow;\r\n                if (light.castShadow) {\r\n                    var shadow = light.shadow;\r\n                    uniforms.shadowBias = shadow.bias;\r\n                    uniforms.shadowRadius = shadow.radius;\r\n                    uniforms.shadowMapSize = shadow.mapSize;\r\n                }\r\n                state.directionalShadowMap[directionalLength] = shadowMap;\r\n                state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\r\n                state.directional[directionalLength] = uniforms;\r\n                directionalLength++;\r\n            }\r\n            else if (light.isSpotLight) {\r\n                var uniforms = cache.get(light);\r\n                uniforms.position.setFromMatrixPosition(light.matrixWorld);\r\n                uniforms.position.applyMatrix4(viewMatrix);\r\n                uniforms.color.copy(color).multiplyScalar(intensity);\r\n                uniforms.distance = distance;\r\n                uniforms.direction.setFromMatrixPosition(light.matrixWorld);\r\n                vector3.setFromMatrixPosition(light.target.matrixWorld);\r\n                uniforms.direction.sub(vector3);\r\n                uniforms.direction.transformDirection(viewMatrix);\r\n                uniforms.coneCos = Math.cos(light.angle);\r\n                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\r\n                uniforms.decay = light.decay;\r\n                uniforms.shadow = light.castShadow;\r\n                if (light.castShadow) {\r\n                    var shadow = light.shadow;\r\n                    uniforms.shadowBias = shadow.bias;\r\n                    uniforms.shadowRadius = shadow.radius;\r\n                    uniforms.shadowMapSize = shadow.mapSize;\r\n                }\r\n                state.spotShadowMap[spotLength] = shadowMap;\r\n                state.spotShadowMatrix[spotLength] = light.shadow.matrix;\r\n                state.spot[spotLength] = uniforms;\r\n                spotLength++;\r\n            }\r\n            else if (light.isRectAreaLight) {\r\n                var uniforms = cache.get(light);\r\n                // (a) intensity is the total visible light emitted\r\n                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\r\n                // (b) intensity is the brightness of the light\r\n                uniforms.color.copy(color).multiplyScalar(intensity);\r\n                uniforms.position.setFromMatrixPosition(light.matrixWorld);\r\n                uniforms.position.applyMatrix4(viewMatrix);\r\n                // extract local rotation of light to derive width/height half vectors\r\n                matrix42.identity();\r\n                matrix4.copy(light.matrixWorld);\r\n                matrix4.premultiply(viewMatrix);\r\n                matrix42.extractRotation(matrix4);\r\n                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\r\n                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\r\n                uniforms.halfWidth.applyMatrix4(matrix42);\r\n                uniforms.halfHeight.applyMatrix4(matrix42);\r\n                // TODO (abelnation): RectAreaLight distance?\r\n                // uniforms.distance = distance;\r\n                state.rectArea[rectAreaLength] = uniforms;\r\n                rectAreaLength++;\r\n            }\r\n            else if (light.isPointLight) {\r\n                var uniforms = cache.get(light);\r\n                uniforms.position.setFromMatrixPosition(light.matrixWorld);\r\n                uniforms.position.applyMatrix4(viewMatrix);\r\n                uniforms.color.copy(light.color).multiplyScalar(light.intensity);\r\n                uniforms.distance = light.distance;\r\n                uniforms.decay = light.decay;\r\n                uniforms.shadow = light.castShadow;\r\n                if (light.castShadow) {\r\n                    var shadow = light.shadow;\r\n                    uniforms.shadowBias = shadow.bias;\r\n                    uniforms.shadowRadius = shadow.radius;\r\n                    uniforms.shadowMapSize = shadow.mapSize;\r\n                    uniforms.shadowCameraNear = shadow.camera.near;\r\n                    uniforms.shadowCameraFar = shadow.camera.far;\r\n                }\r\n                state.pointShadowMap[pointLength] = shadowMap;\r\n                state.pointShadowMatrix[pointLength] = light.shadow.matrix;\r\n                state.point[pointLength] = uniforms;\r\n                pointLength++;\r\n            }\r\n            else if (light.isHemisphereLight) {\r\n                var uniforms = cache.get(light);\r\n                uniforms.direction.setFromMatrixPosition(light.matrixWorld);\r\n                uniforms.direction.transformDirection(viewMatrix);\r\n                uniforms.direction.normalize();\r\n                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);\r\n                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\r\n                state.hemi[hemiLength] = uniforms;\r\n                hemiLength++;\r\n            }\r\n        }\r\n        state.ambient[0] = r;\r\n        state.ambient[1] = g;\r\n        state.ambient[2] = b;\r\n        var hash = state.hash;\r\n        if (hash.directionalLength !== directionalLength ||\r\n            hash.pointLength !== pointLength ||\r\n            hash.spotLength !== spotLength ||\r\n            hash.rectAreaLength !== rectAreaLength ||\r\n            hash.hemiLength !== hemiLength ||\r\n            hash.shadowsLength !== shadows.length) {\r\n            state.directional.length = directionalLength;\r\n            state.spot.length = spotLength;\r\n            state.rectArea.length = rectAreaLength;\r\n            state.point.length = pointLength;\r\n            state.hemi.length = hemiLength;\r\n            hash.directionalLength = directionalLength;\r\n            hash.pointLength = pointLength;\r\n            hash.spotLength = spotLength;\r\n            hash.rectAreaLength = rectAreaLength;\r\n            hash.hemiLength = hemiLength;\r\n            hash.shadowsLength = shadows.length;\r\n            state.version = nextVersion++;\r\n        }\r\n    }\r\n    return {\r\n        setup: setup,\r\n        state: state\r\n    };\r\n}\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction WebGLRenderState() {\r\n    var lights = new WebGLLights();\r\n    var lightsArray = [];\r\n    var shadowsArray = [];\r\n    function init() {\r\n        lightsArray.length = 0;\r\n        shadowsArray.length = 0;\r\n    }\r\n    function pushLight(light) {\r\n        lightsArray.push(light);\r\n    }\r\n    function pushShadow(shadowLight) {\r\n        shadowsArray.push(shadowLight);\r\n    }\r\n    function setupLights(camera) {\r\n        lights.setup(lightsArray, shadowsArray, camera);\r\n    }\r\n    var state = {\r\n        lightsArray: lightsArray,\r\n        shadowsArray: shadowsArray,\r\n        lights: lights\r\n    };\r\n    return {\r\n        init: init,\r\n        state: state,\r\n        setupLights: setupLights,\r\n        pushLight: pushLight,\r\n        pushShadow: pushShadow\r\n    };\r\n}\r\nfunction WebGLRenderStates() {\r\n    var renderStates = {};\r\n    function onSceneDispose(event) {\r\n        var scene = event.target;\r\n        scene.removeEventListener('dispose', onSceneDispose);\r\n        delete renderStates[scene.id];\r\n    }\r\n    function get(scene, camera) {\r\n        var renderState;\r\n        if (renderStates[scene.id] === undefined) {\r\n            renderState = new WebGLRenderState();\r\n            renderStates[scene.id] = {};\r\n            renderStates[scene.id][camera.id] = renderState;\r\n            scene.addEventListener('dispose', onSceneDispose);\r\n        }\r\n        else {\r\n            if (renderStates[scene.id][camera.id] === undefined) {\r\n                renderState = new WebGLRenderState();\r\n                renderStates[scene.id][camera.id] = renderState;\r\n            }\r\n            else {\r\n                renderState = renderStates[scene.id][camera.id];\r\n            }\r\n        }\r\n        return renderState;\r\n    }\r\n    function dispose() {\r\n        renderStates = {};\r\n    }\r\n    return {\r\n        get: get,\r\n        dispose: dispose\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / https://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\nfunction MeshDepthMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshDepthMaterial';\r\n    this.depthPacking = BasicDepthPacking;\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.map = null;\r\n    this.alphaMap = null;\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.fog = false;\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshDepthMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\r\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\r\nMeshDepthMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.depthPacking = source.depthPacking;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.map = source.map;\r\n    this.alphaMap = source.alphaMap;\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    return this;\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *\r\n *  referencePosition: <float>,\r\n *  nearDistance: <float>,\r\n *  farDistance: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>\r\n *\r\n * }\r\n */\r\nfunction MeshDistanceMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshDistanceMaterial';\r\n    this.referencePosition = new Vector3();\r\n    this.nearDistance = 1;\r\n    this.farDistance = 1000;\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.map = null;\r\n    this.alphaMap = null;\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.fog = false;\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshDistanceMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\r\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\r\nMeshDistanceMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.referencePosition.copy(source.referencePosition);\r\n    this.nearDistance = source.nearDistance;\r\n    this.farDistance = source.farDistance;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.map = source.map;\r\n    this.alphaMap = source.alphaMap;\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    return this;\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLShadowMap(_renderer, _objects, maxTextureSize) {\r\n    var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};\r\n    var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\r\n    var cubeDirections = [\r\n        new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),\r\n        new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)\r\n    ];\r\n    var cubeUps = [\r\n        new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),\r\n        new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)\r\n    ];\r\n    var cube2DViewPorts = [\r\n        new Vector4(), new Vector4(), new Vector4(),\r\n        new Vector4(), new Vector4(), new Vector4()\r\n    ];\r\n    // init\r\n    for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {\r\n        var useMorphing = (i & _MorphingFlag) !== 0;\r\n        var useSkinning = (i & _SkinningFlag) !== 0;\r\n        var depthMaterial = new MeshDepthMaterial({\r\n            depthPacking: RGBADepthPacking,\r\n            morphTargets: useMorphing,\r\n            skinning: useSkinning\r\n        });\r\n        _depthMaterials[i] = depthMaterial;\r\n        //\r\n        var distanceMaterial = new MeshDistanceMaterial({\r\n            morphTargets: useMorphing,\r\n            skinning: useSkinning\r\n        });\r\n        _distanceMaterials[i] = distanceMaterial;\r\n    }\r\n    //\r\n    var scope = this;\r\n    this.enabled = false;\r\n    this.autoUpdate = true;\r\n    this.needsUpdate = false;\r\n    this.type = PCFShadowMap;\r\n    this.render = function (lights, scene, camera) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        if (scope.autoUpdate === false && scope.needsUpdate === false)\r\n            return;\r\n        if (lights.length === 0)\r\n            return;\r\n        var currentRenderTarget = _renderer.getRenderTarget();\r\n        var activeCubeFace = _renderer.getActiveCubeFace();\r\n        var activeMipmapLevel = _renderer.getActiveMipmapLevel();\r\n        var _state = _renderer.state;\r\n        // Set GL state for depth map.\r\n        _state.setBlending(NoBlending);\r\n        _state.buffers.color.setClear(1, 1, 1, 1);\r\n        _state.buffers.depth.setTest(true);\r\n        _state.setScissorTest(false);\r\n        // render depth map\r\n        var faceCount;\r\n        for (var i = 0, il = lights.length; i < il; i++) {\r\n            var light = lights[i];\r\n            var shadow = light.shadow;\r\n            var isPointLight = light && light.isPointLight;\r\n            if (shadow === undefined) {\r\n                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\r\n                continue;\r\n            }\r\n            var shadowCamera = shadow.camera;\r\n            _shadowMapSize.copy(shadow.mapSize);\r\n            _shadowMapSize.min(_maxShadowMapSize);\r\n            if (isPointLight) {\r\n                var vpWidth = _shadowMapSize.x;\r\n                var vpHeight = _shadowMapSize.y;\r\n                // These viewports map a cube-map onto a 2D texture with the\r\n                // following orientation:\r\n                //\r\n                //  xzXZ\r\n                //   y Y\r\n                //\r\n                // X - Positive x direction\r\n                // x - Negative x direction\r\n                // Y - Positive y direction\r\n                // y - Negative y direction\r\n                // Z - Positive z direction\r\n                // z - Negative z direction\r\n                // positive X\r\n                cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);\r\n                // negative X\r\n                cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);\r\n                // positive Z\r\n                cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);\r\n                // negative Z\r\n                cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);\r\n                // positive Y\r\n                cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);\r\n                // negative Y\r\n                cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);\r\n                _shadowMapSize.x *= 4.0;\r\n                _shadowMapSize.y *= 2.0;\r\n            }\r\n            if (shadow.map === null) {\r\n                var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\r\n                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\r\n                shadow.map.texture.name = light.name + \".shadowMap\";\r\n                shadowCamera.updateProjectionMatrix();\r\n            }\r\n            if (shadow.isSpotLightShadow) {\r\n                shadow.update(light);\r\n            }\r\n            var shadowMap = shadow.map;\r\n            var shadowMatrix = shadow.matrix;\r\n            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\r\n            shadowCamera.position.copy(_lightPositionWorld);\r\n            if (isPointLight) {\r\n                faceCount = 6;\r\n                // for point lights we set the shadow matrix to be a translation-only matrix\r\n                // equal to inverse of the light's position\r\n                shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\r\n            }\r\n            else {\r\n                faceCount = 1;\r\n                _lookTarget.setFromMatrixPosition(light.target.matrixWorld);\r\n                shadowCamera.lookAt(_lookTarget);\r\n                shadowCamera.updateMatrixWorld();\r\n                // compute shadow matrix\r\n                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n                shadowMatrix.multiply(shadowCamera.projectionMatrix);\r\n                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\r\n            }\r\n            _renderer.setRenderTarget(shadowMap);\r\n            _renderer.clear();\r\n            // render shadow map for each cube face (if omni-directional) or\r\n            // run a single pass if not\r\n            for (var face = 0; face < faceCount; face++) {\r\n                if (isPointLight) {\r\n                    _lookTarget.copy(shadowCamera.position);\r\n                    _lookTarget.add(cubeDirections[face]);\r\n                    shadowCamera.up.copy(cubeUps[face]);\r\n                    shadowCamera.lookAt(_lookTarget);\r\n                    shadowCamera.updateMatrixWorld();\r\n                    var vpDimensions = cube2DViewPorts[face];\r\n                    _state.viewport(vpDimensions);\r\n                }\r\n                // update camera matrices and frustum\r\n                _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\r\n                _frustum.setFromMatrix(_projScreenMatrix);\r\n                // set object matrices & frustum culling\r\n                renderObject(scene, camera, shadowCamera, isPointLight);\r\n            }\r\n        }\r\n        scope.needsUpdate = false;\r\n        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\r\n    };\r\n    function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {\r\n        var geometry = object.geometry;\r\n        var result = null;\r\n        var materialVariants = _depthMaterials;\r\n        var customMaterial = object.customDepthMaterial;\r\n        if (isPointLight) {\r\n            materialVariants = _distanceMaterials;\r\n            customMaterial = object.customDistanceMaterial;\r\n        }\r\n        if (!customMaterial) {\r\n            var useMorphing = false;\r\n            if (material.morphTargets) {\r\n                if (geometry && geometry.isBufferGeometry) {\r\n                    useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\r\n                }\r\n                else if (geometry && geometry.isGeometry) {\r\n                    useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\r\n                }\r\n            }\r\n            if (object.isSkinnedMesh && material.skinning === false) {\r\n                console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);\r\n            }\r\n            var useSkinning = object.isSkinnedMesh && material.skinning;\r\n            var variantIndex = 0;\r\n            if (useMorphing)\r\n                variantIndex |= _MorphingFlag;\r\n            if (useSkinning)\r\n                variantIndex |= _SkinningFlag;\r\n            result = materialVariants[variantIndex];\r\n        }\r\n        else {\r\n            result = customMaterial;\r\n        }\r\n        if (_renderer.localClippingEnabled &&\r\n            material.clipShadows === true &&\r\n            material.clippingPlanes.length !== 0) {\r\n            // in this case we need a unique material instance reflecting the\r\n            // appropriate state\r\n            var keyA = result.uuid, keyB = material.uuid;\r\n            var materialsForVariant = _materialCache[keyA];\r\n            if (materialsForVariant === undefined) {\r\n                materialsForVariant = {};\r\n                _materialCache[keyA] = materialsForVariant;\r\n            }\r\n            var cachedMaterial = materialsForVariant[keyB];\r\n            if (cachedMaterial === undefined) {\r\n                cachedMaterial = result.clone();\r\n                materialsForVariant[keyB] = cachedMaterial;\r\n            }\r\n            result = cachedMaterial;\r\n        }\r\n        result.visible = material.visible;\r\n        result.wireframe = material.wireframe;\r\n        result.side = (material.shadowSide != null) ? material.shadowSide : shadowSide[material.side];\r\n        result.clipShadows = material.clipShadows;\r\n        result.clippingPlanes = material.clippingPlanes;\r\n        result.clipIntersection = material.clipIntersection;\r\n        result.wireframeLinewidth = material.wireframeLinewidth;\r\n        result.linewidth = material.linewidth;\r\n        if (isPointLight && result.isMeshDistanceMaterial) {\r\n            result.referencePosition.copy(lightPositionWorld);\r\n            result.nearDistance = shadowCameraNear;\r\n            result.farDistance = shadowCameraFar;\r\n        }\r\n        return result;\r\n    }\r\n    function renderObject(object, camera, shadowCamera, isPointLight) {\r\n        if (object.visible === false)\r\n            return;\r\n        var visible = object.layers.test(camera.layers);\r\n        if (visible && (object.isMesh || object.isLine || object.isPoints)) {\r\n            if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {\r\n                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\r\n                var geometry = _objects.update(object);\r\n                var material = object.material;\r\n                if (Array.isArray(material)) {\r\n                    var groups = geometry.groups;\r\n                    for (var k = 0, kl = groups.length; k < kl; k++) {\r\n                        var group = groups[k];\r\n                        var groupMaterial = material[group.materialIndex];\r\n                        if (groupMaterial && groupMaterial.visible) {\r\n                            var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);\r\n                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\r\n                        }\r\n                    }\r\n                }\r\n                else if (material.visible) {\r\n                    var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);\r\n                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\r\n                }\r\n            }\r\n        }\r\n        var children = object.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            renderObject(children[i], camera, shadowCamera, isPointLight);\r\n        }\r\n    }\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLState(gl, extensions, utils, capabilities) {\r\n    function ColorBuffer() {\r\n        var locked = false;\r\n        var color = new Vector4();\r\n        var currentColorMask = null;\r\n        var currentColorClear = new Vector4(0, 0, 0, 0);\r\n        return {\r\n            setMask: function (colorMask) {\r\n                if (currentColorMask !== colorMask && !locked) {\r\n                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);\r\n                    currentColorMask = colorMask;\r\n                }\r\n            },\r\n            setLocked: function (lock) {\r\n                locked = lock;\r\n            },\r\n            setClear: function (r, g, b, a, premultipliedAlpha) {\r\n                if (premultipliedAlpha === true) {\r\n                    r *= a;\r\n                    g *= a;\r\n                    b *= a;\r\n                }\r\n                color.set(r, g, b, a);\r\n                if (currentColorClear.equals(color) === false) {\r\n                    gl.clearColor(r, g, b, a);\r\n                    currentColorClear.copy(color);\r\n                }\r\n            },\r\n            reset: function () {\r\n                locked = false;\r\n                currentColorMask = null;\r\n                currentColorClear.set(-1, 0, 0, 0); // set to invalid state\r\n            }\r\n        };\r\n    }\r\n    function DepthBuffer() {\r\n        var locked = false;\r\n        var currentDepthMask = null;\r\n        var currentDepthFunc = null;\r\n        var currentDepthClear = null;\r\n        return {\r\n            setTest: function (depthTest) {\r\n                if (depthTest) {\r\n                    enable(2929);\r\n                }\r\n                else {\r\n                    disable(2929);\r\n                }\r\n            },\r\n            setMask: function (depthMask) {\r\n                if (currentDepthMask !== depthMask && !locked) {\r\n                    gl.depthMask(depthMask);\r\n                    currentDepthMask = depthMask;\r\n                }\r\n            },\r\n            setFunc: function (depthFunc) {\r\n                if (currentDepthFunc !== depthFunc) {\r\n                    if (depthFunc) {\r\n                        switch (depthFunc) {\r\n                            case NeverDepth:\r\n                                gl.depthFunc(512);\r\n                                break;\r\n                            case AlwaysDepth:\r\n                                gl.depthFunc(519);\r\n                                break;\r\n                            case LessDepth:\r\n                                gl.depthFunc(513);\r\n                                break;\r\n                            case LessEqualDepth:\r\n                                gl.depthFunc(515);\r\n                                break;\r\n                            case EqualDepth:\r\n                                gl.depthFunc(514);\r\n                                break;\r\n                            case GreaterEqualDepth:\r\n                                gl.depthFunc(518);\r\n                                break;\r\n                            case GreaterDepth:\r\n                                gl.depthFunc(516);\r\n                                break;\r\n                            case NotEqualDepth:\r\n                                gl.depthFunc(517);\r\n                                break;\r\n                            default:\r\n                                gl.depthFunc(515);\r\n                        }\r\n                    }\r\n                    else {\r\n                        gl.depthFunc(515);\r\n                    }\r\n                    currentDepthFunc = depthFunc;\r\n                }\r\n            },\r\n            setLocked: function (lock) {\r\n                locked = lock;\r\n            },\r\n            setClear: function (depth) {\r\n                if (currentDepthClear !== depth) {\r\n                    gl.clearDepth(depth);\r\n                    currentDepthClear = depth;\r\n                }\r\n            },\r\n            reset: function () {\r\n                locked = false;\r\n                currentDepthMask = null;\r\n                currentDepthFunc = null;\r\n                currentDepthClear = null;\r\n            }\r\n        };\r\n    }\r\n    function StencilBuffer() {\r\n        var locked = false;\r\n        var currentStencilMask = null;\r\n        var currentStencilFunc = null;\r\n        var currentStencilRef = null;\r\n        var currentStencilFuncMask = null;\r\n        var currentStencilFail = null;\r\n        var currentStencilZFail = null;\r\n        var currentStencilZPass = null;\r\n        var currentStencilClear = null;\r\n        return {\r\n            setTest: function (stencilTest) {\r\n                if (stencilTest) {\r\n                    enable(2960);\r\n                }\r\n                else {\r\n                    disable(2960);\r\n                }\r\n            },\r\n            setMask: function (stencilMask) {\r\n                if (currentStencilMask !== stencilMask && !locked) {\r\n                    gl.stencilMask(stencilMask);\r\n                    currentStencilMask = stencilMask;\r\n                }\r\n            },\r\n            setFunc: function (stencilFunc, stencilRef, stencilMask) {\r\n                if (currentStencilFunc !== stencilFunc ||\r\n                    currentStencilRef !== stencilRef ||\r\n                    currentStencilFuncMask !== stencilMask) {\r\n                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\r\n                    currentStencilFunc = stencilFunc;\r\n                    currentStencilRef = stencilRef;\r\n                    currentStencilFuncMask = stencilMask;\r\n                }\r\n            },\r\n            setOp: function (stencilFail, stencilZFail, stencilZPass) {\r\n                if (currentStencilFail !== stencilFail ||\r\n                    currentStencilZFail !== stencilZFail ||\r\n                    currentStencilZPass !== stencilZPass) {\r\n                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\r\n                    currentStencilFail = stencilFail;\r\n                    currentStencilZFail = stencilZFail;\r\n                    currentStencilZPass = stencilZPass;\r\n                }\r\n            },\r\n            setLocked: function (lock) {\r\n                locked = lock;\r\n            },\r\n            setClear: function (stencil) {\r\n                if (currentStencilClear !== stencil) {\r\n                    gl.clearStencil(stencil);\r\n                    currentStencilClear = stencil;\r\n                }\r\n            },\r\n            reset: function () {\r\n                locked = false;\r\n                currentStencilMask = null;\r\n                currentStencilFunc = null;\r\n                currentStencilRef = null;\r\n                currentStencilFuncMask = null;\r\n                currentStencilFail = null;\r\n                currentStencilZFail = null;\r\n                currentStencilZPass = null;\r\n                currentStencilClear = null;\r\n            }\r\n        };\r\n    }\r\n    //\r\n    var colorBuffer = new ColorBuffer();\r\n    var depthBuffer = new DepthBuffer();\r\n    var stencilBuffer = new StencilBuffer();\r\n    var maxVertexAttributes = gl.getParameter(34921);\r\n    var newAttributes = new Uint8Array(maxVertexAttributes);\r\n    var enabledAttributes = new Uint8Array(maxVertexAttributes);\r\n    var attributeDivisors = new Uint8Array(maxVertexAttributes);\r\n    var enabledCapabilities = {};\r\n    var compressedTextureFormats = null;\r\n    var currentProgram = null;\r\n    var currentBlendingEnabled = null;\r\n    var currentBlending = null;\r\n    var currentBlendEquation = null;\r\n    var currentBlendSrc = null;\r\n    var currentBlendDst = null;\r\n    var currentBlendEquationAlpha = null;\r\n    var currentBlendSrcAlpha = null;\r\n    var currentBlendDstAlpha = null;\r\n    var currentPremultipledAlpha = false;\r\n    var currentFlipSided = null;\r\n    var currentCullFace = null;\r\n    var currentLineWidth = null;\r\n    var currentPolygonOffsetFactor = null;\r\n    var currentPolygonOffsetUnits = null;\r\n    var maxTextures = gl.getParameter(35661);\r\n    var lineWidthAvailable = false;\r\n    var version = 0;\r\n    var glVersion = gl.getParameter(7938);\r\n    if (glVersion.indexOf('WebGL') !== -1) {\r\n        version = parseFloat(/^WebGL\\ ([0-9])/.exec(glVersion)[1]);\r\n        lineWidthAvailable = (version >= 1.0);\r\n    }\r\n    else if (glVersion.indexOf('OpenGL ES') !== -1) {\r\n        version = parseFloat(/^OpenGL\\ ES\\ ([0-9])/.exec(glVersion)[1]);\r\n        lineWidthAvailable = (version >= 2.0);\r\n    }\r\n    var currentTextureSlot = null;\r\n    var currentBoundTextures = {};\r\n    var currentScissor = new Vector4();\r\n    var currentViewport = new Vector4();\r\n    function createTexture(type, target, count) {\r\n        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\r\n        var texture = gl.createTexture();\r\n        gl.bindTexture(type, texture);\r\n        gl.texParameteri(type, 10241, 9728);\r\n        gl.texParameteri(type, 10240, 9728);\r\n        for (var i = 0; i < count; i++) {\r\n            gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);\r\n        }\r\n        return texture;\r\n    }\r\n    var emptyTextures = {};\r\n    emptyTextures[3553] = createTexture(3553, 3553, 1);\r\n    emptyTextures[34067] = createTexture(34067, 34069, 6);\r\n    // init\r\n    colorBuffer.setClear(0, 0, 0, 1);\r\n    depthBuffer.setClear(1);\r\n    stencilBuffer.setClear(0);\r\n    enable(2929);\r\n    depthBuffer.setFunc(LessEqualDepth);\r\n    setFlipSided(false);\r\n    setCullFace(CullFaceBack);\r\n    enable(2884);\r\n    setBlending(NoBlending);\r\n    //\r\n    function initAttributes() {\r\n        for (var i = 0, l = newAttributes.length; i < l; i++) {\r\n            newAttributes[i] = 0;\r\n        }\r\n    }\r\n    function enableAttribute(attribute) {\r\n        enableAttributeAndDivisor(attribute, 0);\r\n    }\r\n    function enableAttributeAndDivisor(attribute, meshPerAttribute) {\r\n        newAttributes[attribute] = 1;\r\n        if (enabledAttributes[attribute] === 0) {\r\n            gl.enableVertexAttribArray(attribute);\r\n            enabledAttributes[attribute] = 1;\r\n        }\r\n        if (attributeDivisors[attribute] !== meshPerAttribute) {\r\n            var extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\r\n            extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\r\n            attributeDivisors[attribute] = meshPerAttribute;\r\n        }\r\n    }\r\n    function disableUnusedAttributes() {\r\n        for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {\r\n            if (enabledAttributes[i] !== newAttributes[i]) {\r\n                gl.disableVertexAttribArray(i);\r\n                enabledAttributes[i] = 0;\r\n            }\r\n        }\r\n    }\r\n    function enable(id) {\r\n        if (enabledCapabilities[id] !== true) {\r\n            gl.enable(id);\r\n            enabledCapabilities[id] = true;\r\n        }\r\n    }\r\n    function disable(id) {\r\n        if (enabledCapabilities[id] !== false) {\r\n            gl.disable(id);\r\n            enabledCapabilities[id] = false;\r\n        }\r\n    }\r\n    function getCompressedTextureFormats() {\r\n        if (compressedTextureFormats === null) {\r\n            compressedTextureFormats = [];\r\n            if (extensions.get('WEBGL_compressed_texture_pvrtc') ||\r\n                extensions.get('WEBGL_compressed_texture_s3tc') ||\r\n                extensions.get('WEBGL_compressed_texture_etc1') ||\r\n                extensions.get('WEBGL_compressed_texture_astc')) {\r\n                var formats = gl.getParameter(34467);\r\n                for (var i = 0; i < formats.length; i++) {\r\n                    compressedTextureFormats.push(formats[i]);\r\n                }\r\n            }\r\n        }\r\n        return compressedTextureFormats;\r\n    }\r\n    function useProgram(program) {\r\n        if (currentProgram !== program) {\r\n            gl.useProgram(program);\r\n            currentProgram = program;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\r\n        if (blending === NoBlending) {\r\n            if (currentBlendingEnabled) {\r\n                disable(3042);\r\n                currentBlendingEnabled = false;\r\n            }\r\n            return;\r\n        }\r\n        if (!currentBlendingEnabled) {\r\n            enable(3042);\r\n            currentBlendingEnabled = true;\r\n        }\r\n        if (blending !== CustomBlending) {\r\n            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\r\n                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\r\n                    gl.blendEquation(32774);\r\n                    currentBlendEquation = AddEquation;\r\n                    currentBlendEquationAlpha = AddEquation;\r\n                }\r\n                if (premultipliedAlpha) {\r\n                    switch (blending) {\r\n                        case NormalBlending:\r\n                            gl.blendFuncSeparate(1, 771, 1, 771);\r\n                            break;\r\n                        case AdditiveBlending:\r\n                            gl.blendFunc(1, 1);\r\n                            break;\r\n                        case SubtractiveBlending:\r\n                            gl.blendFuncSeparate(0, 0, 769, 771);\r\n                            break;\r\n                        case MultiplyBlending:\r\n                            gl.blendFuncSeparate(0, 768, 0, 770);\r\n                            break;\r\n                        default:\r\n                            console.error('THREE.WebGLState: Invalid blending: ', blending);\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    switch (blending) {\r\n                        case NormalBlending:\r\n                            gl.blendFuncSeparate(770, 771, 1, 771);\r\n                            break;\r\n                        case AdditiveBlending:\r\n                            gl.blendFunc(770, 1);\r\n                            break;\r\n                        case SubtractiveBlending:\r\n                            gl.blendFunc(0, 769);\r\n                            break;\r\n                        case MultiplyBlending:\r\n                            gl.blendFunc(0, 768);\r\n                            break;\r\n                        default:\r\n                            console.error('THREE.WebGLState: Invalid blending: ', blending);\r\n                            break;\r\n                    }\r\n                }\r\n                currentBlendSrc = null;\r\n                currentBlendDst = null;\r\n                currentBlendSrcAlpha = null;\r\n                currentBlendDstAlpha = null;\r\n                currentBlending = blending;\r\n                currentPremultipledAlpha = premultipliedAlpha;\r\n            }\r\n            return;\r\n        }\r\n        // custom blending\r\n        blendEquationAlpha = blendEquationAlpha || blendEquation;\r\n        blendSrcAlpha = blendSrcAlpha || blendSrc;\r\n        blendDstAlpha = blendDstAlpha || blendDst;\r\n        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\r\n            gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));\r\n            currentBlendEquation = blendEquation;\r\n            currentBlendEquationAlpha = blendEquationAlpha;\r\n        }\r\n        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\r\n            gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));\r\n            currentBlendSrc = blendSrc;\r\n            currentBlendDst = blendDst;\r\n            currentBlendSrcAlpha = blendSrcAlpha;\r\n            currentBlendDstAlpha = blendDstAlpha;\r\n        }\r\n        currentBlending = blending;\r\n        currentPremultipledAlpha = null;\r\n    }\r\n    function setMaterial(material, frontFaceCW) {\r\n        material.side === DoubleSide\r\n            ? disable(2884)\r\n            : enable(2884);\r\n        var flipSided = (material.side === BackSide);\r\n        if (frontFaceCW)\r\n            flipSided = !flipSided;\r\n        setFlipSided(flipSided);\r\n        (material.blending === NormalBlending && material.transparent === false)\r\n            ? setBlending(NoBlending)\r\n            : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\r\n        depthBuffer.setFunc(material.depthFunc);\r\n        depthBuffer.setTest(material.depthTest);\r\n        depthBuffer.setMask(material.depthWrite);\r\n        colorBuffer.setMask(material.colorWrite);\r\n        var stencilWrite = material.stencilWrite;\r\n        stencilBuffer.setTest(stencilWrite);\r\n        if (stencilWrite) {\r\n            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilMask);\r\n            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\r\n        }\r\n        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\r\n    }\r\n    //\r\n    function setFlipSided(flipSided) {\r\n        if (currentFlipSided !== flipSided) {\r\n            if (flipSided) {\r\n                gl.frontFace(2304);\r\n            }\r\n            else {\r\n                gl.frontFace(2305);\r\n            }\r\n            currentFlipSided = flipSided;\r\n        }\r\n    }\r\n    function setCullFace(cullFace) {\r\n        if (cullFace !== CullFaceNone) {\r\n            enable(2884);\r\n            if (cullFace !== currentCullFace) {\r\n                if (cullFace === CullFaceBack) {\r\n                    gl.cullFace(1029);\r\n                }\r\n                else if (cullFace === CullFaceFront) {\r\n                    gl.cullFace(1028);\r\n                }\r\n                else {\r\n                    gl.cullFace(1032);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            disable(2884);\r\n        }\r\n        currentCullFace = cullFace;\r\n    }\r\n    function setLineWidth(width) {\r\n        if (width !== currentLineWidth) {\r\n            if (lineWidthAvailable)\r\n                gl.lineWidth(width);\r\n            currentLineWidth = width;\r\n        }\r\n    }\r\n    function setPolygonOffset(polygonOffset, factor, units) {\r\n        if (polygonOffset) {\r\n            enable(32823);\r\n            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\r\n                gl.polygonOffset(factor, units);\r\n                currentPolygonOffsetFactor = factor;\r\n                currentPolygonOffsetUnits = units;\r\n            }\r\n        }\r\n        else {\r\n            disable(32823);\r\n        }\r\n    }\r\n    function setScissorTest(scissorTest) {\r\n        if (scissorTest) {\r\n            enable(3089);\r\n        }\r\n        else {\r\n            disable(3089);\r\n        }\r\n    }\r\n    // texture\r\n    function activeTexture(webglSlot) {\r\n        if (webglSlot === undefined)\r\n            webglSlot = 33984 + maxTextures - 1;\r\n        if (currentTextureSlot !== webglSlot) {\r\n            gl.activeTexture(webglSlot);\r\n            currentTextureSlot = webglSlot;\r\n        }\r\n    }\r\n    function bindTexture(webglType, webglTexture) {\r\n        if (currentTextureSlot === null) {\r\n            activeTexture();\r\n        }\r\n        var boundTexture = currentBoundTextures[currentTextureSlot];\r\n        if (boundTexture === undefined) {\r\n            boundTexture = { type: undefined, texture: undefined };\r\n            currentBoundTextures[currentTextureSlot] = boundTexture;\r\n        }\r\n        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\r\n            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\r\n            boundTexture.type = webglType;\r\n            boundTexture.texture = webglTexture;\r\n        }\r\n    }\r\n    function compressedTexImage2D() {\r\n        try {\r\n            gl.compressedTexImage2D.apply(gl, arguments);\r\n        }\r\n        catch (error) {\r\n            console.error('THREE.WebGLState:', error);\r\n        }\r\n    }\r\n    function texImage2D() {\r\n        try {\r\n            gl.texImage2D.apply(gl, arguments);\r\n        }\r\n        catch (error) {\r\n            console.error('THREE.WebGLState:', error);\r\n        }\r\n    }\r\n    function texImage3D() {\r\n        try {\r\n            gl.texImage3D.apply(gl, arguments);\r\n        }\r\n        catch (error) {\r\n            console.error('THREE.WebGLState:', error);\r\n        }\r\n    }\r\n    //\r\n    function scissor(scissor) {\r\n        if (currentScissor.equals(scissor) === false) {\r\n            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\r\n            currentScissor.copy(scissor);\r\n        }\r\n    }\r\n    function viewport(viewport) {\r\n        if (currentViewport.equals(viewport) === false) {\r\n            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\r\n            currentViewport.copy(viewport);\r\n        }\r\n    }\r\n    //\r\n    function reset() {\r\n        for (var i = 0; i < enabledAttributes.length; i++) {\r\n            if (enabledAttributes[i] === 1) {\r\n                gl.disableVertexAttribArray(i);\r\n                enabledAttributes[i] = 0;\r\n            }\r\n        }\r\n        enabledCapabilities = {};\r\n        compressedTextureFormats = null;\r\n        currentTextureSlot = null;\r\n        currentBoundTextures = {};\r\n        currentProgram = null;\r\n        currentBlending = null;\r\n        currentFlipSided = null;\r\n        currentCullFace = null;\r\n        colorBuffer.reset();\r\n        depthBuffer.reset();\r\n        stencilBuffer.reset();\r\n    }\r\n    return {\r\n        buffers: {\r\n            color: colorBuffer,\r\n            depth: depthBuffer,\r\n            stencil: stencilBuffer\r\n        },\r\n        initAttributes: initAttributes,\r\n        enableAttribute: enableAttribute,\r\n        enableAttributeAndDivisor: enableAttributeAndDivisor,\r\n        disableUnusedAttributes: disableUnusedAttributes,\r\n        enable: enable,\r\n        disable: disable,\r\n        getCompressedTextureFormats: getCompressedTextureFormats,\r\n        useProgram: useProgram,\r\n        setBlending: setBlending,\r\n        setMaterial: setMaterial,\r\n        setFlipSided: setFlipSided,\r\n        setCullFace: setCullFace,\r\n        setLineWidth: setLineWidth,\r\n        setPolygonOffset: setPolygonOffset,\r\n        setScissorTest: setScissorTest,\r\n        activeTexture: activeTexture,\r\n        bindTexture: bindTexture,\r\n        compressedTexImage2D: compressedTexImage2D,\r\n        texImage2D: texImage2D,\r\n        texImage3D: texImage3D,\r\n        scissor: scissor,\r\n        viewport: viewport,\r\n        reset: reset\r\n    };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\r\n    var _videoTextures = {};\r\n    var _canvas;\r\n    //\r\n    var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\r\n    function createCanvas(width, height) {\r\n        // Use OffscreenCanvas when available. Specially needed in web workers\r\n        return useOffscreenCanvas ?\r\n            new OffscreenCanvas(width, height) :\r\n            document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\r\n    }\r\n    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\r\n        var scale = 1;\r\n        // handle case if texture exceeds max size\r\n        if (image.width > maxSize || image.height > maxSize) {\r\n            scale = maxSize / Math.max(image.width, image.height);\r\n        }\r\n        // only perform resize if necessary\r\n        if (scale < 1 || needsPowerOfTwo === true) {\r\n            // only perform resize for certain image types\r\n            if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||\r\n                (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||\r\n                (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {\r\n                var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;\r\n                var width = floor(scale * image.width);\r\n                var height = floor(scale * image.height);\r\n                if (_canvas === undefined)\r\n                    _canvas = createCanvas(width, height);\r\n                // cube textures can't reuse the same canvas\r\n                var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                var context = canvas.getContext('2d');\r\n                context.drawImage(image, 0, 0, width, height);\r\n                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\r\n                return canvas;\r\n            }\r\n            else {\r\n                if ('data' in image) {\r\n                    console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\r\n                }\r\n                return image;\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    function isPowerOfTwo(image) {\r\n        return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);\r\n    }\r\n    function textureNeedsPowerOfTwo(texture) {\r\n        if (capabilities.isWebGL2)\r\n            return false;\r\n        return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||\r\n            (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);\r\n    }\r\n    function textureNeedsGenerateMipmaps(texture, supportsMips) {\r\n        return texture.generateMipmaps && supportsMips &&\r\n            texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\r\n    }\r\n    function generateMipmap(target, texture, width, height) {\r\n        _gl.generateMipmap(target);\r\n        var textureProperties = properties.get(texture);\r\n        // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11\r\n        textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;\r\n    }\r\n    function getInternalFormat(glFormat, glType) {\r\n        if (!capabilities.isWebGL2)\r\n            return glFormat;\r\n        var internalFormat = glFormat;\r\n        if (glFormat === 6403) {\r\n            if (glType === 5126)\r\n                internalFormat = 33326;\r\n            if (glType === 5131)\r\n                internalFormat = 33325;\r\n            if (glType === 5121)\r\n                internalFormat = 33321;\r\n        }\r\n        if (glFormat === 6407) {\r\n            if (glType === 5126)\r\n                internalFormat = 34837;\r\n            if (glType === 5131)\r\n                internalFormat = 34843;\r\n            if (glType === 5121)\r\n                internalFormat = 32849;\r\n        }\r\n        if (glFormat === 6408) {\r\n            if (glType === 5126)\r\n                internalFormat = 34836;\r\n            if (glType === 5131)\r\n                internalFormat = 34842;\r\n            if (glType === 5121)\r\n                internalFormat = 32856;\r\n        }\r\n        if (internalFormat === 33325 || internalFormat === 33326 ||\r\n            internalFormat === 34842 || internalFormat === 34836) {\r\n            extensions.get('EXT_color_buffer_float');\r\n        }\r\n        else if (internalFormat === 34843 || internalFormat === 34837) {\r\n            console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');\r\n        }\r\n        return internalFormat;\r\n    }\r\n    // Fallback filters for non-power-of-2 textures\r\n    function filterFallback(f) {\r\n        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\r\n            return 9728;\r\n        }\r\n        return 9729;\r\n    }\r\n    //\r\n    function onTextureDispose(event) {\r\n        var texture = event.target;\r\n        texture.removeEventListener('dispose', onTextureDispose);\r\n        deallocateTexture(texture);\r\n        if (texture.isVideoTexture) {\r\n            delete _videoTextures[texture.id];\r\n        }\r\n        info.memory.textures--;\r\n    }\r\n    function onRenderTargetDispose(event) {\r\n        var renderTarget = event.target;\r\n        renderTarget.removeEventListener('dispose', onRenderTargetDispose);\r\n        deallocateRenderTarget(renderTarget);\r\n        info.memory.textures--;\r\n    }\r\n    //\r\n    function deallocateTexture(texture) {\r\n        var textureProperties = properties.get(texture);\r\n        if (textureProperties.__webglInit === undefined)\r\n            return;\r\n        _gl.deleteTexture(textureProperties.__webglTexture);\r\n        properties.remove(texture);\r\n    }\r\n    function deallocateRenderTarget(renderTarget) {\r\n        var renderTargetProperties = properties.get(renderTarget);\r\n        var textureProperties = properties.get(renderTarget.texture);\r\n        if (!renderTarget)\r\n            return;\r\n        if (textureProperties.__webglTexture !== undefined) {\r\n            _gl.deleteTexture(textureProperties.__webglTexture);\r\n        }\r\n        if (renderTarget.depthTexture) {\r\n            renderTarget.depthTexture.dispose();\r\n        }\r\n        if (renderTarget.isWebGLRenderTargetCube) {\r\n            for (var i = 0; i < 6; i++) {\r\n                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\r\n                if (renderTargetProperties.__webglDepthbuffer)\r\n                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\r\n            }\r\n        }\r\n        else {\r\n            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\r\n            if (renderTargetProperties.__webglDepthbuffer)\r\n                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\r\n        }\r\n        properties.remove(renderTarget.texture);\r\n        properties.remove(renderTarget);\r\n    }\r\n    //\r\n    var textureUnits = 0;\r\n    function resetTextureUnits() {\r\n        textureUnits = 0;\r\n    }\r\n    function allocateTextureUnit() {\r\n        var textureUnit = textureUnits;\r\n        if (textureUnit >= capabilities.maxTextures) {\r\n            console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);\r\n        }\r\n        textureUnits += 1;\r\n        return textureUnit;\r\n    }\r\n    //\r\n    function setTexture2D(texture, slot) {\r\n        var textureProperties = properties.get(texture);\r\n        if (texture.isVideoTexture)\r\n            updateVideoTexture(texture);\r\n        if (texture.version > 0 && textureProperties.__version !== texture.version) {\r\n            var image = texture.image;\r\n            if (image === undefined) {\r\n                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\r\n            }\r\n            else if (image.complete === false) {\r\n                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\r\n            }\r\n            else {\r\n                uploadTexture(textureProperties, texture, slot);\r\n                return;\r\n            }\r\n        }\r\n        state.activeTexture(33984 + slot);\r\n        state.bindTexture(3553, textureProperties.__webglTexture);\r\n    }\r\n    function setTexture2DArray(texture, slot) {\r\n        var textureProperties = properties.get(texture);\r\n        if (texture.version > 0 && textureProperties.__version !== texture.version) {\r\n            uploadTexture(textureProperties, texture, slot);\r\n            return;\r\n        }\r\n        state.activeTexture(33984 + slot);\r\n        state.bindTexture(35866, textureProperties.__webglTexture);\r\n    }\r\n    function setTexture3D(texture, slot) {\r\n        var textureProperties = properties.get(texture);\r\n        if (texture.version > 0 && textureProperties.__version !== texture.version) {\r\n            uploadTexture(textureProperties, texture, slot);\r\n            return;\r\n        }\r\n        state.activeTexture(33984 + slot);\r\n        state.bindTexture(32879, textureProperties.__webglTexture);\r\n    }\r\n    function setTextureCube(texture, slot) {\r\n        var textureProperties = properties.get(texture);\r\n        if (texture.image.length === 6) {\r\n            if (texture.version > 0 && textureProperties.__version !== texture.version) {\r\n                initTexture(textureProperties, texture);\r\n                state.activeTexture(33984 + slot);\r\n                state.bindTexture(34067, textureProperties.__webglTexture);\r\n                _gl.pixelStorei(37440, texture.flipY);\r\n                var isCompressed = (texture && texture.isCompressedTexture);\r\n                var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);\r\n                var cubeImage = [];\r\n                for (var i = 0; i < 6; i++) {\r\n                    if (!isCompressed && !isDataTexture) {\r\n                        cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);\r\n                    }\r\n                    else {\r\n                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\r\n                    }\r\n                }\r\n                var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);\r\n                setTextureParameters(34067, texture, supportsMips);\r\n                for (var i = 0; i < 6; i++) {\r\n                    if (!isCompressed) {\r\n                        if (isDataTexture) {\r\n                            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\r\n                        }\r\n                        else {\r\n                            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var mipmap, mipmaps = cubeImage[i].mipmaps;\r\n                        for (var j = 0, jl = mipmaps.length; j < jl; j++) {\r\n                            mipmap = mipmaps[j];\r\n                            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\r\n                                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {\r\n                                    state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\r\n                                }\r\n                                else {\r\n                                    console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\r\n                                }\r\n                            }\r\n                            else {\r\n                                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!isCompressed) {\r\n                    textureProperties.__maxMipLevel = 0;\r\n                }\r\n                else {\r\n                    textureProperties.__maxMipLevel = mipmaps.length - 1;\r\n                }\r\n                if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\r\n                    // We assume images for cube map have the same size.\r\n                    generateMipmap(34067, texture, image.width, image.height);\r\n                }\r\n                textureProperties.__version = texture.version;\r\n                if (texture.onUpdate)\r\n                    texture.onUpdate(texture);\r\n            }\r\n            else {\r\n                state.activeTexture(33984 + slot);\r\n                state.bindTexture(34067, textureProperties.__webglTexture);\r\n            }\r\n        }\r\n    }\r\n    function setTextureCubeDynamic(texture, slot) {\r\n        state.activeTexture(33984 + slot);\r\n        state.bindTexture(34067, properties.get(texture).__webglTexture);\r\n    }\r\n    function setTextureParameters(textureType, texture, supportsMips) {\r\n        var extension;\r\n        if (supportsMips) {\r\n            _gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));\r\n            _gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));\r\n            if (textureType === 32879 || textureType === 35866) {\r\n                _gl.texParameteri(textureType, 32882, utils.convert(texture.wrapR));\r\n            }\r\n            _gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));\r\n            _gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));\r\n        }\r\n        else {\r\n            _gl.texParameteri(textureType, 10242, 33071);\r\n            _gl.texParameteri(textureType, 10243, 33071);\r\n            if (textureType === 32879 || textureType === 35866) {\r\n                _gl.texParameteri(textureType, 32882, 33071);\r\n            }\r\n            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\r\n                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\r\n            }\r\n            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));\r\n            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));\r\n            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\r\n                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\r\n            }\r\n        }\r\n        extension = extensions.get('EXT_texture_filter_anisotropic');\r\n        if (extension) {\r\n            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null)\r\n                return;\r\n            if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null)\r\n                return;\r\n            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\r\n                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\r\n                properties.get(texture).__currentAnisotropy = texture.anisotropy;\r\n            }\r\n        }\r\n    }\r\n    function initTexture(textureProperties, texture) {\r\n        if (textureProperties.__webglInit === undefined) {\r\n            textureProperties.__webglInit = true;\r\n            texture.addEventListener('dispose', onTextureDispose);\r\n            textureProperties.__webglTexture = _gl.createTexture();\r\n            info.memory.textures++;\r\n        }\r\n    }\r\n    function uploadTexture(textureProperties, texture, slot) {\r\n        var textureType = 3553;\r\n        if (texture.isDataTexture2DArray)\r\n            textureType = 35866;\r\n        if (texture.isDataTexture3D)\r\n            textureType = 32879;\r\n        initTexture(textureProperties, texture);\r\n        state.activeTexture(33984 + slot);\r\n        state.bindTexture(textureType, textureProperties.__webglTexture);\r\n        _gl.pixelStorei(37440, texture.flipY);\r\n        _gl.pixelStorei(37441, texture.premultiplyAlpha);\r\n        _gl.pixelStorei(3317, texture.unpackAlignment);\r\n        var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;\r\n        var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);\r\n        var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);\r\n        setTextureParameters(textureType, texture, supportsMips);\r\n        var mipmap, mipmaps = texture.mipmaps;\r\n        if (texture.isDepthTexture) {\r\n            // populate depth texture with dummy data\r\n            glInternalFormat = 6402;\r\n            if (texture.type === FloatType) {\r\n                if (!capabilities.isWebGL2)\r\n                    throw new Error('Float Depth Texture only supported in WebGL2.0');\r\n                glInternalFormat = 36012;\r\n            }\r\n            else if (capabilities.isWebGL2) {\r\n                // WebGL 2.0 requires signed internalformat for glTexImage2D\r\n                glInternalFormat = 33189;\r\n            }\r\n            if (texture.format === DepthFormat && glInternalFormat === 6402) {\r\n                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\r\n                // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\r\n                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\r\n                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\r\n                    texture.type = UnsignedShortType;\r\n                    glType = utils.convert(texture.type);\r\n                }\r\n            }\r\n            // Depth stencil textures need the DEPTH_STENCIL internal format\r\n            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n            if (texture.format === DepthStencilFormat) {\r\n                glInternalFormat = 34041;\r\n                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\r\n                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\r\n                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n                if (texture.type !== UnsignedInt248Type) {\r\n                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\r\n                    texture.type = UnsignedInt248Type;\r\n                    glType = utils.convert(texture.type);\r\n                }\r\n            }\r\n            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\r\n        }\r\n        else if (texture.isDataTexture) {\r\n            // use manually created mipmaps if available\r\n            // if there are no manual mipmaps\r\n            // set 0 level mipmap and then use GL to generate other mipmap levels\r\n            if (mipmaps.length > 0 && supportsMips) {\r\n                for (var i = 0, il = mipmaps.length; i < il; i++) {\r\n                    mipmap = mipmaps[i];\r\n                    state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\r\n                }\r\n                texture.generateMipmaps = false;\r\n                textureProperties.__maxMipLevel = mipmaps.length - 1;\r\n            }\r\n            else {\r\n                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\r\n                textureProperties.__maxMipLevel = 0;\r\n            }\r\n        }\r\n        else if (texture.isCompressedTexture) {\r\n            for (var i = 0, il = mipmaps.length; i < il; i++) {\r\n                mipmap = mipmaps[i];\r\n                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\r\n                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {\r\n                        state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\r\n                    }\r\n                    else {\r\n                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\r\n                    }\r\n                }\r\n                else {\r\n                    state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\r\n                }\r\n            }\r\n            textureProperties.__maxMipLevel = mipmaps.length - 1;\r\n        }\r\n        else if (texture.isDataTexture2DArray) {\r\n            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\r\n            textureProperties.__maxMipLevel = 0;\r\n        }\r\n        else if (texture.isDataTexture3D) {\r\n            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\r\n            textureProperties.__maxMipLevel = 0;\r\n        }\r\n        else {\r\n            // regular Texture (image, video, canvas)\r\n            // use manually created mipmaps if available\r\n            // if there are no manual mipmaps\r\n            // set 0 level mipmap and then use GL to generate other mipmap levels\r\n            if (mipmaps.length > 0 && supportsMips) {\r\n                for (var i = 0, il = mipmaps.length; i < il; i++) {\r\n                    mipmap = mipmaps[i];\r\n                    state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);\r\n                }\r\n                texture.generateMipmaps = false;\r\n                textureProperties.__maxMipLevel = mipmaps.length - 1;\r\n            }\r\n            else {\r\n                state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);\r\n                textureProperties.__maxMipLevel = 0;\r\n            }\r\n        }\r\n        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\r\n            generateMipmap(3553, texture, image.width, image.height);\r\n        }\r\n        textureProperties.__version = texture.version;\r\n        if (texture.onUpdate)\r\n            texture.onUpdate(texture);\r\n    }\r\n    // Render targets\r\n    // Setup storage for target texture and bind it to correct framebuffer\r\n    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {\r\n        var glFormat = utils.convert(renderTarget.texture.format);\r\n        var glType = utils.convert(renderTarget.texture.type);\r\n        var glInternalFormat = getInternalFormat(glFormat, glType);\r\n        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\r\n        _gl.bindFramebuffer(36160, framebuffer);\r\n        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);\r\n        _gl.bindFramebuffer(36160, null);\r\n    }\r\n    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\r\n        _gl.bindRenderbuffer(36161, renderbuffer);\r\n        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\r\n            if (isMultisample) {\r\n                var samples = getRenderTargetSamples(renderTarget);\r\n                _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);\r\n            }\r\n            else {\r\n                _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);\r\n            }\r\n            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);\r\n        }\r\n        else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\r\n            if (isMultisample) {\r\n                var samples = getRenderTargetSamples(renderTarget);\r\n                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);\r\n            }\r\n            else {\r\n                _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);\r\n            }\r\n            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);\r\n        }\r\n        else {\r\n            var glFormat = utils.convert(renderTarget.texture.format);\r\n            var glType = utils.convert(renderTarget.texture.type);\r\n            var glInternalFormat = getInternalFormat(glFormat, glType);\r\n            if (isMultisample) {\r\n                var samples = getRenderTargetSamples(renderTarget);\r\n                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\r\n            }\r\n            else {\r\n                _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\r\n            }\r\n        }\r\n        _gl.bindRenderbuffer(36161, null);\r\n    }\r\n    // Setup resources for a Depth Texture for a FBO (needs an extension)\r\n    function setupDepthTexture(framebuffer, renderTarget) {\r\n        var isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);\r\n        if (isCube)\r\n            throw new Error('Depth Texture with cube render targets is not supported');\r\n        _gl.bindFramebuffer(36160, framebuffer);\r\n        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\r\n            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\r\n        }\r\n        // upload an empty depth texture with framebuffer size\r\n        if (!properties.get(renderTarget.depthTexture).__webglTexture ||\r\n            renderTarget.depthTexture.image.width !== renderTarget.width ||\r\n            renderTarget.depthTexture.image.height !== renderTarget.height) {\r\n            renderTarget.depthTexture.image.width = renderTarget.width;\r\n            renderTarget.depthTexture.image.height = renderTarget.height;\r\n            renderTarget.depthTexture.needsUpdate = true;\r\n        }\r\n        setTexture2D(renderTarget.depthTexture, 0);\r\n        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\r\n        if (renderTarget.depthTexture.format === DepthFormat) {\r\n            _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);\r\n        }\r\n        else if (renderTarget.depthTexture.format === DepthStencilFormat) {\r\n            _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);\r\n        }\r\n        else {\r\n            throw new Error('Unknown depthTexture format');\r\n        }\r\n    }\r\n    // Setup GL resources for a non-texture depth buffer\r\n    function setupDepthRenderbuffer(renderTarget) {\r\n        var renderTargetProperties = properties.get(renderTarget);\r\n        var isCube = (renderTarget.isWebGLRenderTargetCube === true);\r\n        if (renderTarget.depthTexture) {\r\n            if (isCube)\r\n                throw new Error('target.depthTexture not supported in Cube render targets');\r\n            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\r\n        }\r\n        else {\r\n            if (isCube) {\r\n                renderTargetProperties.__webglDepthbuffer = [];\r\n                for (var i = 0; i < 6; i++) {\r\n                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);\r\n                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\r\n                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);\r\n                }\r\n            }\r\n            else {\r\n                _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\r\n                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);\r\n            }\r\n        }\r\n        _gl.bindFramebuffer(36160, null);\r\n    }\r\n    // Set up GL resources for the render target\r\n    function setupRenderTarget(renderTarget) {\r\n        var renderTargetProperties = properties.get(renderTarget);\r\n        var textureProperties = properties.get(renderTarget.texture);\r\n        renderTarget.addEventListener('dispose', onRenderTargetDispose);\r\n        textureProperties.__webglTexture = _gl.createTexture();\r\n        info.memory.textures++;\r\n        var isCube = (renderTarget.isWebGLRenderTargetCube === true);\r\n        var isMultisample = (renderTarget.isWebGLMultisampleRenderTarget === true);\r\n        var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;\r\n        // Setup framebuffer\r\n        if (isCube) {\r\n            renderTargetProperties.__webglFramebuffer = [];\r\n            for (var i = 0; i < 6; i++) {\r\n                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\r\n            }\r\n        }\r\n        else {\r\n            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n            if (isMultisample) {\r\n                if (capabilities.isWebGL2) {\r\n                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\r\n                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\r\n                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);\r\n                    var glFormat = utils.convert(renderTarget.texture.format);\r\n                    var glType = utils.convert(renderTarget.texture.type);\r\n                    var glInternalFormat = getInternalFormat(glFormat, glType);\r\n                    var samples = getRenderTargetSamples(renderTarget);\r\n                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\r\n                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\r\n                    _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);\r\n                    _gl.bindRenderbuffer(36161, null);\r\n                    if (renderTarget.depthBuffer) {\r\n                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\r\n                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\r\n                    }\r\n                    _gl.bindFramebuffer(36160, null);\r\n                }\r\n                else {\r\n                    console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\r\n                }\r\n            }\r\n        }\r\n        // Setup color buffer\r\n        if (isCube) {\r\n            state.bindTexture(34067, textureProperties.__webglTexture);\r\n            setTextureParameters(34067, renderTarget.texture, supportsMips);\r\n            for (var i = 0; i < 6; i++) {\r\n                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);\r\n            }\r\n            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {\r\n                generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);\r\n            }\r\n            state.bindTexture(34067, null);\r\n        }\r\n        else {\r\n            state.bindTexture(3553, textureProperties.__webglTexture);\r\n            setTextureParameters(3553, renderTarget.texture, supportsMips);\r\n            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);\r\n            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {\r\n                generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);\r\n            }\r\n            state.bindTexture(3553, null);\r\n        }\r\n        // Setup depth and stencil buffers\r\n        if (renderTarget.depthBuffer) {\r\n            setupDepthRenderbuffer(renderTarget);\r\n        }\r\n    }\r\n    function updateRenderTargetMipmap(renderTarget) {\r\n        var texture = renderTarget.texture;\r\n        var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;\r\n        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\r\n            var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;\r\n            var webglTexture = properties.get(texture).__webglTexture;\r\n            state.bindTexture(target, webglTexture);\r\n            generateMipmap(target, texture, renderTarget.width, renderTarget.height);\r\n            state.bindTexture(target, null);\r\n        }\r\n    }\r\n    function updateMultisampleRenderTarget(renderTarget) {\r\n        if (renderTarget.isWebGLMultisampleRenderTarget) {\r\n            if (capabilities.isWebGL2) {\r\n                var renderTargetProperties = properties.get(renderTarget);\r\n                _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);\r\n                _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);\r\n                var width = renderTarget.width;\r\n                var height = renderTarget.height;\r\n                var mask = 16384;\r\n                if (renderTarget.depthBuffer)\r\n                    mask |= 256;\r\n                if (renderTarget.stencilBuffer)\r\n                    mask |= 1024;\r\n                _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);\r\n            }\r\n            else {\r\n                console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\r\n            }\r\n        }\r\n    }\r\n    function getRenderTargetSamples(renderTarget) {\r\n        return (capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget) ?\r\n            Math.min(capabilities.maxSamples, renderTarget.samples) : 0;\r\n    }\r\n    function updateVideoTexture(texture) {\r\n        var id = texture.id;\r\n        var frame = info.render.frame;\r\n        // Check the last frame we updated the VideoTexture\r\n        if (_videoTextures[id] !== frame) {\r\n            _videoTextures[id] = frame;\r\n            texture.update();\r\n        }\r\n    }\r\n    // backwards compatibility\r\n    var warnedTexture2D = false;\r\n    var warnedTextureCube = false;\r\n    function safeSetTexture2D(texture, slot) {\r\n        if (texture && texture.isWebGLRenderTarget) {\r\n            if (warnedTexture2D === false) {\r\n                console.warn(\"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\");\r\n                warnedTexture2D = true;\r\n            }\r\n            texture = texture.texture;\r\n        }\r\n        setTexture2D(texture, slot);\r\n    }\r\n    function safeSetTextureCube(texture, slot) {\r\n        if (texture && texture.isWebGLRenderTargetCube) {\r\n            if (warnedTextureCube === false) {\r\n                console.warn(\"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\");\r\n                warnedTextureCube = true;\r\n            }\r\n            texture = texture.texture;\r\n        }\r\n        // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\r\n        // TODO: unify these code paths\r\n        if ((texture && texture.isCubeTexture) ||\r\n            (Array.isArray(texture.image) && texture.image.length === 6)) {\r\n            // CompressedTexture can have Array in image :/\r\n            // this function alone should take care of cube textures\r\n            setTextureCube(texture, slot);\r\n        }\r\n        else {\r\n            // assumed: texture property of THREE.WebGLRenderTargetCube\r\n            setTextureCubeDynamic(texture, slot);\r\n        }\r\n    }\r\n    //\r\n    this.allocateTextureUnit = allocateTextureUnit;\r\n    this.resetTextureUnits = resetTextureUnits;\r\n    this.setTexture2D = setTexture2D;\r\n    this.setTexture2DArray = setTexture2DArray;\r\n    this.setTexture3D = setTexture3D;\r\n    this.setTextureCube = setTextureCube;\r\n    this.setTextureCubeDynamic = setTextureCubeDynamic;\r\n    this.setupRenderTarget = setupRenderTarget;\r\n    this.updateRenderTargetMipmap = updateRenderTargetMipmap;\r\n    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\r\n    this.safeSetTexture2D = safeSetTexture2D;\r\n    this.safeSetTextureCube = safeSetTextureCube;\r\n}\r\n/**\r\n * @author thespite / http://www.twitter.com/thespite\r\n */\r\nfunction WebGLUtils(gl, extensions, capabilities) {\r\n    function convert(p) {\r\n        var extension;\r\n        if (p === RepeatWrapping)\r\n            return 10497;\r\n        if (p === ClampToEdgeWrapping)\r\n            return 33071;\r\n        if (p === MirroredRepeatWrapping)\r\n            return 33648;\r\n        if (p === NearestFilter)\r\n            return 9728;\r\n        if (p === NearestMipmapNearestFilter)\r\n            return 9984;\r\n        if (p === NearestMipmapLinearFilter)\r\n            return 9986;\r\n        if (p === LinearFilter)\r\n            return 9729;\r\n        if (p === LinearMipmapNearestFilter)\r\n            return 9985;\r\n        if (p === LinearMipmapLinearFilter)\r\n            return 9987;\r\n        if (p === UnsignedByteType)\r\n            return 5121;\r\n        if (p === UnsignedShort4444Type)\r\n            return 32819;\r\n        if (p === UnsignedShort5551Type)\r\n            return 32820;\r\n        if (p === UnsignedShort565Type)\r\n            return 33635;\r\n        if (p === ByteType)\r\n            return 5120;\r\n        if (p === ShortType)\r\n            return 5122;\r\n        if (p === UnsignedShortType)\r\n            return 5123;\r\n        if (p === IntType)\r\n            return 5124;\r\n        if (p === UnsignedIntType)\r\n            return 5125;\r\n        if (p === FloatType)\r\n            return 5126;\r\n        if (p === HalfFloatType) {\r\n            if (capabilities.isWebGL2)\r\n                return 5131;\r\n            extension = extensions.get('OES_texture_half_float');\r\n            if (extension !== null)\r\n                return extension.HALF_FLOAT_OES;\r\n        }\r\n        if (p === AlphaFormat)\r\n            return 6406;\r\n        if (p === RGBFormat)\r\n            return 6407;\r\n        if (p === RGBAFormat)\r\n            return 6408;\r\n        if (p === LuminanceFormat)\r\n            return 6409;\r\n        if (p === LuminanceAlphaFormat)\r\n            return 6410;\r\n        if (p === DepthFormat)\r\n            return 6402;\r\n        if (p === DepthStencilFormat)\r\n            return 34041;\r\n        if (p === RedFormat)\r\n            return 6403;\r\n        if (p === AddEquation)\r\n            return 32774;\r\n        if (p === SubtractEquation)\r\n            return 32778;\r\n        if (p === ReverseSubtractEquation)\r\n            return 32779;\r\n        if (p === ZeroFactor)\r\n            return 0;\r\n        if (p === OneFactor)\r\n            return 1;\r\n        if (p === SrcColorFactor)\r\n            return 768;\r\n        if (p === OneMinusSrcColorFactor)\r\n            return 769;\r\n        if (p === SrcAlphaFactor)\r\n            return 770;\r\n        if (p === OneMinusSrcAlphaFactor)\r\n            return 771;\r\n        if (p === DstAlphaFactor)\r\n            return 772;\r\n        if (p === OneMinusDstAlphaFactor)\r\n            return 773;\r\n        if (p === DstColorFactor)\r\n            return 774;\r\n        if (p === OneMinusDstColorFactor)\r\n            return 775;\r\n        if (p === SrcAlphaSaturateFactor)\r\n            return 776;\r\n        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\r\n            p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\r\n            extension = extensions.get('WEBGL_compressed_texture_s3tc');\r\n            if (extension !== null) {\r\n                if (p === RGB_S3TC_DXT1_Format)\r\n                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n                if (p === RGBA_S3TC_DXT1_Format)\r\n                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n                if (p === RGBA_S3TC_DXT3_Format)\r\n                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n                if (p === RGBA_S3TC_DXT5_Format)\r\n                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n            }\r\n        }\r\n        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\r\n            p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\r\n            extension = extensions.get('WEBGL_compressed_texture_pvrtc');\r\n            if (extension !== null) {\r\n                if (p === RGB_PVRTC_4BPPV1_Format)\r\n                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n                if (p === RGB_PVRTC_2BPPV1_Format)\r\n                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n                if (p === RGBA_PVRTC_4BPPV1_Format)\r\n                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n                if (p === RGBA_PVRTC_2BPPV1_Format)\r\n                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n            }\r\n        }\r\n        if (p === RGB_ETC1_Format) {\r\n            extension = extensions.get('WEBGL_compressed_texture_etc1');\r\n            if (extension !== null)\r\n                return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n        }\r\n        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\r\n            p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\r\n            p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\r\n            p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\r\n            p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\r\n            extension = extensions.get('WEBGL_compressed_texture_astc');\r\n            if (extension !== null) {\r\n                return p;\r\n            }\r\n        }\r\n        if (p === MinEquation || p === MaxEquation) {\r\n            if (capabilities.isWebGL2) {\r\n                if (p === MinEquation)\r\n                    return 32775;\r\n                if (p === MaxEquation)\r\n                    return 32776;\r\n            }\r\n            extension = extensions.get('EXT_blend_minmax');\r\n            if (extension !== null) {\r\n                if (p === MinEquation)\r\n                    return extension.MIN_EXT;\r\n                if (p === MaxEquation)\r\n                    return extension.MAX_EXT;\r\n            }\r\n        }\r\n        if (p === UnsignedInt248Type) {\r\n            if (capabilities.isWebGL2)\r\n                return 34042;\r\n            extension = extensions.get('WEBGL_depth_texture');\r\n            if (extension !== null)\r\n                return extension.UNSIGNED_INT_24_8_WEBGL;\r\n        }\r\n        return 0;\r\n    }\r\n    return { convert: convert };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Group() {\r\n    Object3D.call(this);\r\n    this.type = 'Group';\r\n}\r\nGroup.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Group,\r\n    isGroup: true\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction ArrayCamera(array) {\r\n    PerspectiveCamera.call(this);\r\n    this.cameras = array || [];\r\n}\r\nArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {\r\n    constructor: ArrayCamera,\r\n    isArrayCamera: true\r\n});\r\n/**\r\n * @author jsantell / https://www.jsantell.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar cameraLPos = new Vector3();\r\nvar cameraRPos = new Vector3();\r\n/**\r\n * Assumes 2 cameras that are parallel and share an X-axis, and that\r\n * the cameras' projection and world matrices have already been set.\r\n * And that near and far planes are identical for both cameras.\r\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\r\n */\r\nfunction setProjectionFromUnion(camera, cameraL, cameraR) {\r\n    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\r\n    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\r\n    var ipd = cameraLPos.distanceTo(cameraRPos);\r\n    var projL = cameraL.projectionMatrix.elements;\r\n    var projR = cameraR.projectionMatrix.elements;\r\n    // VR systems will have identical far and near planes, and\r\n    // most likely identical top and bottom frustum extents.\r\n    // Use the left camera for these values.\r\n    var near = projL[14] / (projL[10] - 1);\r\n    var far = projL[14] / (projL[10] + 1);\r\n    var topFov = (projL[9] + 1) / projL[5];\r\n    var bottomFov = (projL[9] - 1) / projL[5];\r\n    var leftFov = (projL[8] - 1) / projL[0];\r\n    var rightFov = (projR[8] + 1) / projR[0];\r\n    var left = near * leftFov;\r\n    var right = near * rightFov;\r\n    // Calculate the new camera's position offset from the\r\n    // left camera. xOffset should be roughly half `ipd`.\r\n    var zOffset = ipd / (-leftFov + rightFov);\r\n    var xOffset = zOffset * -leftFov;\r\n    // TODO: Better way to apply this offset?\r\n    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\r\n    camera.translateX(xOffset);\r\n    camera.translateZ(zOffset);\r\n    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\r\n    camera.matrixWorldInverse.getInverse(camera.matrixWorld);\r\n    // Find the union of the frustum values of the cameras and scale\r\n    // the values so that the near plane's position does not change in world space,\r\n    // although must now be relative to the new union camera.\r\n    var near2 = near + zOffset;\r\n    var far2 = far + zOffset;\r\n    var left2 = left - xOffset;\r\n    var right2 = right + (ipd - xOffset);\r\n    var top2 = topFov * far / far2 * near2;\r\n    var bottom2 = bottomFov * far / far2 * near2;\r\n    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebVRManager(renderer) {\r\n    var renderWidth, renderHeight;\r\n    var scope = this;\r\n    var device = null;\r\n    var frameData = null;\r\n    var poseTarget = null;\r\n    var controllers = [];\r\n    var standingMatrix = new Matrix4();\r\n    var standingMatrixInverse = new Matrix4();\r\n    var framebufferScaleFactor = 1.0;\r\n    var referenceSpaceType = 'local-floor';\r\n    if (typeof window !== 'undefined' && 'VRFrameData' in window) {\r\n        frameData = new window.VRFrameData();\r\n        window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);\r\n    }\r\n    var matrixWorldInverse = new Matrix4();\r\n    var tempQuaternion = new Quaternion();\r\n    var tempPosition = new Vector3();\r\n    var cameraL = new PerspectiveCamera();\r\n    cameraL.viewport = new Vector4();\r\n    cameraL.layers.enable(1);\r\n    var cameraR = new PerspectiveCamera();\r\n    cameraR.viewport = new Vector4();\r\n    cameraR.layers.enable(2);\r\n    var cameraVR = new ArrayCamera([cameraL, cameraR]);\r\n    cameraVR.layers.enable(1);\r\n    cameraVR.layers.enable(2);\r\n    //\r\n    function isPresenting() {\r\n        return device !== null && device.isPresenting === true;\r\n    }\r\n    var currentSize = new Vector2(), currentPixelRatio;\r\n    function onVRDisplayPresentChange() {\r\n        if (isPresenting()) {\r\n            var eyeParameters = device.getEyeParameters('left');\r\n            renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;\r\n            renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;\r\n            currentPixelRatio = renderer.getPixelRatio();\r\n            renderer.getSize(currentSize);\r\n            renderer.setDrawingBufferSize(renderWidth, renderHeight, 1);\r\n            cameraL.viewport.set(0, 0, renderWidth / 2, renderHeight);\r\n            cameraR.viewport.set(renderWidth / 2, 0, renderWidth / 2, renderHeight);\r\n            animation.start();\r\n            scope.dispatchEvent({ type: 'sessionstart' });\r\n        }\r\n        else {\r\n            if (scope.enabled) {\r\n                renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);\r\n            }\r\n            animation.stop();\r\n            scope.dispatchEvent({ type: 'sessionend' });\r\n        }\r\n    }\r\n    //\r\n    var triggers = [];\r\n    function findGamepad(id) {\r\n        var gamepads = navigator.getGamepads && navigator.getGamepads();\r\n        for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {\r\n            var gamepad = gamepads[i];\r\n            if (gamepad && (gamepad.id === 'Daydream Controller' ||\r\n                gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||\r\n                gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch') ||\r\n                gamepad.id.startsWith('HTC Vive Focus') ||\r\n                gamepad.id.startsWith('Spatial Controller'))) {\r\n                if (j === id)\r\n                    return gamepad;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    function updateControllers() {\r\n        for (var i = 0; i < controllers.length; i++) {\r\n            var controller = controllers[i];\r\n            var gamepad = findGamepad(i);\r\n            if (gamepad !== undefined && gamepad.pose !== undefined) {\r\n                if (gamepad.pose === null)\r\n                    return;\r\n                // Pose\r\n                var pose = gamepad.pose;\r\n                if (pose.hasPosition === false)\r\n                    controller.position.set(0.2, -0.6, -0.05);\r\n                if (pose.position !== null)\r\n                    controller.position.fromArray(pose.position);\r\n                if (pose.orientation !== null)\r\n                    controller.quaternion.fromArray(pose.orientation);\r\n                controller.matrix.compose(controller.position, controller.quaternion, controller.scale);\r\n                controller.matrix.premultiply(standingMatrix);\r\n                controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);\r\n                controller.matrixWorldNeedsUpdate = true;\r\n                controller.visible = true;\r\n                // Trigger\r\n                var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;\r\n                if (triggers[i] === undefined)\r\n                    triggers[i] = false;\r\n                if (triggers[i] !== gamepad.buttons[buttonId].pressed) {\r\n                    triggers[i] = gamepad.buttons[buttonId].pressed;\r\n                    if (triggers[i] === true) {\r\n                        controller.dispatchEvent({ type: 'selectstart' });\r\n                    }\r\n                    else {\r\n                        controller.dispatchEvent({ type: 'selectend' });\r\n                        controller.dispatchEvent({ type: 'select' });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                controller.visible = false;\r\n            }\r\n        }\r\n    }\r\n    function updateViewportFromBounds(viewport, bounds) {\r\n        if (bounds !== null && bounds.length === 4) {\r\n            viewport.set(bounds[0] * renderWidth, bounds[1] * renderHeight, bounds[2] * renderWidth, bounds[3] * renderHeight);\r\n        }\r\n    }\r\n    //\r\n    this.enabled = false;\r\n    this.getController = function (id) {\r\n        var controller = controllers[id];\r\n        if (controller === undefined) {\r\n            controller = new Group();\r\n            controller.matrixAutoUpdate = false;\r\n            controller.visible = false;\r\n            controllers[id] = controller;\r\n        }\r\n        return controller;\r\n    };\r\n    this.getDevice = function () {\r\n        return device;\r\n    };\r\n    this.setDevice = function (value) {\r\n        if (value !== undefined)\r\n            device = value;\r\n        animation.setContext(value);\r\n    };\r\n    this.setFramebufferScaleFactor = function (value) {\r\n        framebufferScaleFactor = value;\r\n    };\r\n    this.setReferenceSpaceType = function (value) {\r\n        referenceSpaceType = value;\r\n    };\r\n    this.setPoseTarget = function (object) {\r\n        if (object !== undefined)\r\n            poseTarget = object;\r\n    };\r\n    this.getCamera = function (camera) {\r\n        var userHeight = referenceSpaceType === 'local-floor' ? 1.6 : 0;\r\n        if (isPresenting() === false) {\r\n            camera.position.set(0, userHeight, 0);\r\n            camera.rotation.set(0, 0, 0);\r\n            return camera;\r\n        }\r\n        device.depthNear = camera.near;\r\n        device.depthFar = camera.far;\r\n        device.getFrameData(frameData);\r\n        //\r\n        if (referenceSpaceType === 'local-floor') {\r\n            var stageParameters = device.stageParameters;\r\n            if (stageParameters) {\r\n                standingMatrix.fromArray(stageParameters.sittingToStandingTransform);\r\n            }\r\n            else {\r\n                standingMatrix.makeTranslation(0, userHeight, 0);\r\n            }\r\n        }\r\n        var pose = frameData.pose;\r\n        var poseObject = poseTarget !== null ? poseTarget : camera;\r\n        // We want to manipulate poseObject by its position and quaternion components since users may rely on them.\r\n        poseObject.matrix.copy(standingMatrix);\r\n        poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);\r\n        if (pose.orientation !== null) {\r\n            tempQuaternion.fromArray(pose.orientation);\r\n            poseObject.quaternion.multiply(tempQuaternion);\r\n        }\r\n        if (pose.position !== null) {\r\n            tempQuaternion.setFromRotationMatrix(standingMatrix);\r\n            tempPosition.fromArray(pose.position);\r\n            tempPosition.applyQuaternion(tempQuaternion);\r\n            poseObject.position.add(tempPosition);\r\n        }\r\n        poseObject.updateMatrixWorld();\r\n        //\r\n        cameraL.near = camera.near;\r\n        cameraR.near = camera.near;\r\n        cameraL.far = camera.far;\r\n        cameraR.far = camera.far;\r\n        cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);\r\n        cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);\r\n        // TODO (mrdoob) Double check this code\r\n        standingMatrixInverse.getInverse(standingMatrix);\r\n        if (referenceSpaceType === 'local-floor') {\r\n            cameraL.matrixWorldInverse.multiply(standingMatrixInverse);\r\n            cameraR.matrixWorldInverse.multiply(standingMatrixInverse);\r\n        }\r\n        var parent = poseObject.parent;\r\n        if (parent !== null) {\r\n            matrixWorldInverse.getInverse(parent.matrixWorld);\r\n            cameraL.matrixWorldInverse.multiply(matrixWorldInverse);\r\n            cameraR.matrixWorldInverse.multiply(matrixWorldInverse);\r\n        }\r\n        // envMap and Mirror needs camera.matrixWorld\r\n        cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);\r\n        cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);\r\n        cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);\r\n        cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);\r\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\r\n        //\r\n        var layers = device.getLayers();\r\n        if (layers.length) {\r\n            var layer = layers[0];\r\n            updateViewportFromBounds(cameraL.viewport, layer.leftBounds);\r\n            updateViewportFromBounds(cameraR.viewport, layer.rightBounds);\r\n        }\r\n        updateControllers();\r\n        return cameraVR;\r\n    };\r\n    this.getStandingMatrix = function () {\r\n        return standingMatrix;\r\n    };\r\n    this.isPresenting = isPresenting;\r\n    // Animation Loop\r\n    var animation = new WebGLAnimation();\r\n    this.setAnimationLoop = function (callback) {\r\n        animation.setAnimationLoop(callback);\r\n        if (isPresenting())\r\n            animation.start();\r\n    };\r\n    this.submitFrame = function () {\r\n        if (isPresenting())\r\n            device.submitFrame();\r\n    };\r\n    this.dispose = function () {\r\n        if (typeof window !== 'undefined') {\r\n            window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);\r\n        }\r\n    };\r\n    // DEPRECATED\r\n    this.setFrameOfReferenceType = function () {\r\n        console.warn('THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.');\r\n    };\r\n}\r\nObject.assign(WebVRManager.prototype, EventDispatcher.prototype);\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction WebXRManager(renderer, gl) {\r\n    var scope = this;\r\n    var session = null;\r\n    var referenceSpace = null;\r\n    var referenceSpaceType = 'local-floor';\r\n    var pose = null;\r\n    var controllers = [];\r\n    var inputSources = [];\r\n    function isPresenting() {\r\n        return session !== null && referenceSpace !== null;\r\n    }\r\n    //\r\n    var cameraL = new PerspectiveCamera();\r\n    cameraL.layers.enable(1);\r\n    cameraL.viewport = new Vector4();\r\n    var cameraR = new PerspectiveCamera();\r\n    cameraR.layers.enable(2);\r\n    cameraR.viewport = new Vector4();\r\n    var cameraVR = new ArrayCamera([cameraL, cameraR]);\r\n    cameraVR.layers.enable(1);\r\n    cameraVR.layers.enable(2);\r\n    //\r\n    this.enabled = false;\r\n    this.getController = function (id) {\r\n        var controller = controllers[id];\r\n        if (controller === undefined) {\r\n            controller = new Group();\r\n            controller.matrixAutoUpdate = false;\r\n            controller.visible = false;\r\n            controllers[id] = controller;\r\n        }\r\n        return controller;\r\n    };\r\n    //\r\n    function onSessionEvent(event) {\r\n        for (var i = 0; i < controllers.length; i++) {\r\n            if (inputSources[i] === event.inputSource) {\r\n                controllers[i].dispatchEvent({ type: event.type });\r\n            }\r\n        }\r\n    }\r\n    function onSessionEnd() {\r\n        renderer.setFramebuffer(null);\r\n        renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830\r\n        animation.stop();\r\n        scope.dispatchEvent({ type: 'sessionend' });\r\n    }\r\n    function onRequestReferenceSpace(value) {\r\n        referenceSpace = value;\r\n        animation.setContext(session);\r\n        animation.start();\r\n        scope.dispatchEvent({ type: 'sessionstart' });\r\n    }\r\n    this.setFramebufferScaleFactor = function (value) {\r\n    };\r\n    this.setReferenceSpaceType = function (value) {\r\n        referenceSpaceType = value;\r\n    };\r\n    this.getSession = function () {\r\n        return session;\r\n    };\r\n    this.setSession = function (value) {\r\n        session = value;\r\n        if (session !== null) {\r\n            session.addEventListener('select', onSessionEvent);\r\n            session.addEventListener('selectstart', onSessionEvent);\r\n            session.addEventListener('selectend', onSessionEvent);\r\n            session.addEventListener('end', onSessionEnd);\r\n            session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });\r\n            session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);\r\n            //\r\n            inputSources = session.inputSources;\r\n            session.addEventListener('inputsourceschange', function () {\r\n                inputSources = session.inputSources;\r\n                console.log(inputSources);\r\n                for (var i = 0; i < controllers.length; i++) {\r\n                    var controller = controllers[i];\r\n                    controller.userData.inputSource = inputSources[i];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    function updateCamera(camera, parent) {\r\n        if (parent === null) {\r\n            camera.matrixWorld.copy(camera.matrix);\r\n        }\r\n        else {\r\n            camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\r\n        }\r\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\r\n    }\r\n    this.getCamera = function (camera) {\r\n        if (isPresenting()) {\r\n            var parent = camera.parent;\r\n            var cameras = cameraVR.cameras;\r\n            updateCamera(cameraVR, parent);\r\n            for (var i = 0; i < cameras.length; i++) {\r\n                updateCamera(cameras[i], parent);\r\n            }\r\n            // update camera and its children\r\n            camera.matrixWorld.copy(cameraVR.matrixWorld);\r\n            var children = camera.children;\r\n            for (var i = 0, l = children.length; i < l; i++) {\r\n                children[i].updateMatrixWorld(true);\r\n            }\r\n            setProjectionFromUnion(cameraVR, cameraL, cameraR);\r\n            return cameraVR;\r\n        }\r\n        return camera;\r\n    };\r\n    this.isPresenting = isPresenting;\r\n    // Animation Loop\r\n    var onAnimationFrameCallback = null;\r\n    function onAnimationFrame(time, frame) {\r\n        pose = frame.getViewerPose(referenceSpace);\r\n        if (pose !== null) {\r\n            var views = pose.views;\r\n            var baseLayer = session.renderState.baseLayer;\r\n            renderer.setFramebuffer(baseLayer.framebuffer);\r\n            for (var i = 0; i < views.length; i++) {\r\n                var view = views[i];\r\n                var viewport = baseLayer.getViewport(view);\r\n                var viewMatrix = view.transform.inverse.matrix;\r\n                var camera = cameraVR.cameras[i];\r\n                camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);\r\n                camera.projectionMatrix.fromArray(view.projectionMatrix);\r\n                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\r\n                if (i === 0) {\r\n                    cameraVR.matrix.copy(camera.matrix);\r\n                }\r\n            }\r\n        }\r\n        //\r\n        for (var i = 0; i < controllers.length; i++) {\r\n            var controller = controllers[i];\r\n            var inputSource = inputSources[i];\r\n            if (inputSource) {\r\n                var inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\r\n                if (inputPose !== null) {\r\n                    controller.matrix.fromArray(inputPose.transform.matrix);\r\n                    controller.matrix.decompose(controller.position, controller.rotation, controller.scale);\r\n                    controller.visible = true;\r\n                    continue;\r\n                }\r\n            }\r\n            controller.visible = false;\r\n        }\r\n        if (onAnimationFrameCallback)\r\n            onAnimationFrameCallback(time);\r\n    }\r\n    var animation = new WebGLAnimation();\r\n    animation.setAnimationLoop(onAnimationFrame);\r\n    this.setAnimationLoop = function (callback) {\r\n        onAnimationFrameCallback = callback;\r\n    };\r\n    this.dispose = function () { };\r\n    // DEPRECATED\r\n    this.getStandingMatrix = function () {\r\n        console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');\r\n        return new Matrix4();\r\n    };\r\n    this.getDevice = function () {\r\n        console.warn('THREE.WebXRManager: getDevice() has been deprecated.');\r\n    };\r\n    this.setDevice = function () {\r\n        console.warn('THREE.WebXRManager: setDevice() has been deprecated.');\r\n    };\r\n    this.setFrameOfReferenceType = function () {\r\n        console.warn('THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.');\r\n    };\r\n    this.submitFrame = function () { };\r\n}\r\nObject.assign(WebXRManager.prototype, EventDispatcher.prototype);\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n * @author tschw\r\n */\r\nfunction WebGLRenderer(parameters) {\r\n    console.log('THREE.WebGLRenderer', REVISION);\r\n    parameters = parameters || {};\r\n    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\r\n    var currentRenderList = null;\r\n    var currentRenderState = null;\r\n    // public properties\r\n    this.domElement = _canvas;\r\n    // Debug configuration container\r\n    this.debug = {\r\n        /**\r\n         * Enables error checking and reporting when shader programs are being compiled\r\n         * @type {boolean}\r\n         */\r\n        checkShaderErrors: true\r\n    };\r\n    // clearing\r\n    this.autoClear = true;\r\n    this.autoClearColor = true;\r\n    this.autoClearDepth = true;\r\n    this.autoClearStencil = true;\r\n    // scene graph\r\n    this.sortObjects = true;\r\n    // user-defined clipping\r\n    this.clippingPlanes = [];\r\n    this.localClippingEnabled = false;\r\n    // physically based shading\r\n    this.gammaFactor = 2.0; // for backwards compatibility\r\n    this.gammaInput = false;\r\n    this.gammaOutput = false;\r\n    // physical lights\r\n    this.physicallyCorrectLights = false;\r\n    // tone mapping\r\n    this.toneMapping = LinearToneMapping;\r\n    this.toneMappingExposure = 1.0;\r\n    this.toneMappingWhitePoint = 1.0;\r\n    // morphs\r\n    this.maxMorphTargets = 8;\r\n    this.maxMorphNormals = 4;\r\n    // internal properties\r\n    var _this = this, _isContextLost = false, \r\n    // internal state cache\r\n    _framebuffer = null, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, \r\n    // geometry and program caching\r\n    _currentGeometryProgram = {\r\n        geometry: null,\r\n        program: null,\r\n        wireframe: false\r\n    }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, \r\n    //\r\n    _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, \r\n    // frustum\r\n    _frustum = new Frustum(), \r\n    // clipping\r\n    _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, \r\n    // camera matrices cache\r\n    _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();\r\n    function getTargetPixelRatio() {\r\n        return _currentRenderTarget === null ? _pixelRatio : 1;\r\n    }\r\n    // initialize\r\n    var _gl;\r\n    try {\r\n        var contextAttributes = {\r\n            alpha: _alpha,\r\n            depth: _depth,\r\n            stencil: _stencil,\r\n            antialias: _antialias,\r\n            premultipliedAlpha: _premultipliedAlpha,\r\n            preserveDrawingBuffer: _preserveDrawingBuffer,\r\n            powerPreference: _powerPreference,\r\n            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,\r\n            xrCompatible: true\r\n        };\r\n        // event listeners must be registered before WebGL context is created, see #12753\r\n        _canvas.addEventListener('webglcontextlost', onContextLost, false);\r\n        _canvas.addEventListener('webglcontextrestored', onContextRestore, false);\r\n        _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);\r\n        if (_gl === null) {\r\n            if (_canvas.getContext('webgl') !== null) {\r\n                throw new Error('Error creating WebGL context with your selected attributes.');\r\n            }\r\n            else {\r\n                throw new Error('Error creating WebGL context.');\r\n            }\r\n        }\r\n        // Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n        if (_gl.getShaderPrecisionFormat === undefined) {\r\n            _gl.getShaderPrecisionFormat = function () {\r\n                return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n            };\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.error('THREE.WebGLRenderer: ' + error.message);\r\n        throw error;\r\n    }\r\n    var extensions, capabilities, state, info;\r\n    var properties, textures, attributes, geometries, objects;\r\n    var programCache, renderLists, renderStates;\r\n    var background, morphtargets, bufferRenderer, indexedBufferRenderer;\r\n    var utils;\r\n    function initGLContext() {\r\n        extensions = new WebGLExtensions(_gl);\r\n        capabilities = new WebGLCapabilities(_gl, extensions, parameters);\r\n        if (!capabilities.isWebGL2) {\r\n            extensions.get('WEBGL_depth_texture');\r\n            extensions.get('OES_texture_float');\r\n            extensions.get('OES_texture_half_float');\r\n            extensions.get('OES_texture_half_float_linear');\r\n            extensions.get('OES_standard_derivatives');\r\n            extensions.get('OES_element_index_uint');\r\n            extensions.get('ANGLE_instanced_arrays');\r\n        }\r\n        extensions.get('OES_texture_float_linear');\r\n        utils = new WebGLUtils(_gl, extensions, capabilities);\r\n        state = new WebGLState(_gl, extensions, utils, capabilities);\r\n        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\r\n        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\r\n        info = new WebGLInfo(_gl);\r\n        properties = new WebGLProperties();\r\n        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\r\n        attributes = new WebGLAttributes(_gl);\r\n        geometries = new WebGLGeometries(_gl, attributes, info);\r\n        objects = new WebGLObjects(geometries, info);\r\n        morphtargets = new WebGLMorphtargets(_gl);\r\n        programCache = new WebGLPrograms(_this, extensions, capabilities);\r\n        renderLists = new WebGLRenderLists();\r\n        renderStates = new WebGLRenderStates();\r\n        background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);\r\n        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\r\n        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\r\n        info.programs = programCache.programs;\r\n        _this.capabilities = capabilities;\r\n        _this.extensions = extensions;\r\n        _this.properties = properties;\r\n        _this.renderLists = renderLists;\r\n        _this.state = state;\r\n        _this.info = info;\r\n    }\r\n    initGLContext();\r\n    // vr\r\n    var vr = (typeof navigator !== 'undefined' && 'xr' in navigator && 'supportsSession' in navigator.xr) ? new WebXRManager(_this, _gl) : new WebVRManager(_this);\r\n    this.vr = vr;\r\n    // shadow map\r\n    var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);\r\n    this.shadowMap = shadowMap;\r\n    // API\r\n    this.getContext = function () {\r\n        return _gl;\r\n    };\r\n    this.getContextAttributes = function () {\r\n        return _gl.getContextAttributes();\r\n    };\r\n    this.forceContextLoss = function () {\r\n        var extension = extensions.get('WEBGL_lose_context');\r\n        if (extension)\r\n            extension.loseContext();\r\n    };\r\n    this.forceContextRestore = function () {\r\n        var extension = extensions.get('WEBGL_lose_context');\r\n        if (extension)\r\n            extension.restoreContext();\r\n    };\r\n    this.getPixelRatio = function () {\r\n        return _pixelRatio;\r\n    };\r\n    this.setPixelRatio = function (value) {\r\n        if (value === undefined)\r\n            return;\r\n        _pixelRatio = value;\r\n        this.setSize(_width, _height, false);\r\n    };\r\n    this.getSize = function (target) {\r\n        if (target === undefined) {\r\n            console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');\r\n            target = new Vector2();\r\n        }\r\n        return target.set(_width, _height);\r\n    };\r\n    this.setSize = function (width, height, updateStyle) {\r\n        if (vr.isPresenting()) {\r\n            console.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\r\n            return;\r\n        }\r\n        _width = width;\r\n        _height = height;\r\n        _canvas.width = Math.floor(width * _pixelRatio);\r\n        _canvas.height = Math.floor(height * _pixelRatio);\r\n        if (updateStyle !== false) {\r\n            _canvas.style.width = width + 'px';\r\n            _canvas.style.height = height + 'px';\r\n        }\r\n        this.setViewport(0, 0, width, height);\r\n    };\r\n    this.getDrawingBufferSize = function (target) {\r\n        if (target === undefined) {\r\n            console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');\r\n            target = new Vector2();\r\n        }\r\n        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\r\n    };\r\n    this.setDrawingBufferSize = function (width, height, pixelRatio) {\r\n        _width = width;\r\n        _height = height;\r\n        _pixelRatio = pixelRatio;\r\n        _canvas.width = Math.floor(width * pixelRatio);\r\n        _canvas.height = Math.floor(height * pixelRatio);\r\n        this.setViewport(0, 0, width, height);\r\n    };\r\n    this.getCurrentViewport = function (target) {\r\n        if (target === undefined) {\r\n            console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');\r\n            target = new Vector4();\r\n        }\r\n        return target.copy(_currentViewport);\r\n    };\r\n    this.getViewport = function (target) {\r\n        return target.copy(_viewport);\r\n    };\r\n    this.setViewport = function (x, y, width, height) {\r\n        if (x.isVector4) {\r\n            _viewport.set(x.x, x.y, x.z, x.w);\r\n        }\r\n        else {\r\n            _viewport.set(x, y, width, height);\r\n        }\r\n        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\r\n    };\r\n    this.getScissor = function (target) {\r\n        return target.copy(_scissor);\r\n    };\r\n    this.setScissor = function (x, y, width, height) {\r\n        if (x.isVector4) {\r\n            _scissor.set(x.x, x.y, x.z, x.w);\r\n        }\r\n        else {\r\n            _scissor.set(x, y, width, height);\r\n        }\r\n        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\r\n    };\r\n    this.getScissorTest = function () {\r\n        return _scissorTest;\r\n    };\r\n    this.setScissorTest = function (boolean) {\r\n        state.setScissorTest(_scissorTest = boolean);\r\n    };\r\n    // Clearing\r\n    this.getClearColor = function () {\r\n        return background.getClearColor();\r\n    };\r\n    this.setClearColor = function () {\r\n        background.setClearColor.apply(background, arguments);\r\n    };\r\n    this.getClearAlpha = function () {\r\n        return background.getClearAlpha();\r\n    };\r\n    this.setClearAlpha = function () {\r\n        background.setClearAlpha.apply(background, arguments);\r\n    };\r\n    this.clear = function (color, depth, stencil) {\r\n        var bits = 0;\r\n        if (color === undefined || color)\r\n            bits |= 16384;\r\n        if (depth === undefined || depth)\r\n            bits |= 256;\r\n        if (stencil === undefined || stencil)\r\n            bits |= 1024;\r\n        _gl.clear(bits);\r\n    };\r\n    this.clearColor = function () {\r\n        this.clear(true, false, false);\r\n    };\r\n    this.clearDepth = function () {\r\n        this.clear(false, true, false);\r\n    };\r\n    this.clearStencil = function () {\r\n        this.clear(false, false, true);\r\n    };\r\n    //\r\n    this.dispose = function () {\r\n        _canvas.removeEventListener('webglcontextlost', onContextLost, false);\r\n        _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\r\n        renderLists.dispose();\r\n        renderStates.dispose();\r\n        properties.dispose();\r\n        objects.dispose();\r\n        vr.dispose();\r\n        animation.stop();\r\n    };\r\n    // Events\r\n    function onContextLost(event) {\r\n        event.preventDefault();\r\n        console.log('THREE.WebGLRenderer: Context Lost.');\r\n        _isContextLost = true;\r\n    }\r\n    function onContextRestore( /* event */) {\r\n        console.log('THREE.WebGLRenderer: Context Restored.');\r\n        _isContextLost = false;\r\n        initGLContext();\r\n    }\r\n    function onMaterialDispose(event) {\r\n        var material = event.target;\r\n        material.removeEventListener('dispose', onMaterialDispose);\r\n        deallocateMaterial(material);\r\n    }\r\n    // Buffer deallocation\r\n    function deallocateMaterial(material) {\r\n        releaseMaterialProgramReference(material);\r\n        properties.remove(material);\r\n    }\r\n    function releaseMaterialProgramReference(material) {\r\n        var programInfo = properties.get(material).program;\r\n        material.program = undefined;\r\n        if (programInfo !== undefined) {\r\n            programCache.releaseProgram(programInfo);\r\n        }\r\n    }\r\n    // Buffer rendering\r\n    function renderObjectImmediate(object, program) {\r\n        object.render(function (object) {\r\n            _this.renderBufferImmediate(object, program);\r\n        });\r\n    }\r\n    this.renderBufferImmediate = function (object, program) {\r\n        state.initAttributes();\r\n        var buffers = properties.get(object);\r\n        if (object.hasPositions && !buffers.position)\r\n            buffers.position = _gl.createBuffer();\r\n        if (object.hasNormals && !buffers.normal)\r\n            buffers.normal = _gl.createBuffer();\r\n        if (object.hasUvs && !buffers.uv)\r\n            buffers.uv = _gl.createBuffer();\r\n        if (object.hasColors && !buffers.color)\r\n            buffers.color = _gl.createBuffer();\r\n        var programAttributes = program.getAttributes();\r\n        if (object.hasPositions) {\r\n            _gl.bindBuffer(34962, buffers.position);\r\n            _gl.bufferData(34962, object.positionArray, 35048);\r\n            state.enableAttribute(programAttributes.position);\r\n            _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);\r\n        }\r\n        if (object.hasNormals) {\r\n            _gl.bindBuffer(34962, buffers.normal);\r\n            _gl.bufferData(34962, object.normalArray, 35048);\r\n            state.enableAttribute(programAttributes.normal);\r\n            _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);\r\n        }\r\n        if (object.hasUvs) {\r\n            _gl.bindBuffer(34962, buffers.uv);\r\n            _gl.bufferData(34962, object.uvArray, 35048);\r\n            state.enableAttribute(programAttributes.uv);\r\n            _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);\r\n        }\r\n        if (object.hasColors) {\r\n            _gl.bindBuffer(34962, buffers.color);\r\n            _gl.bufferData(34962, object.colorArray, 35048);\r\n            state.enableAttribute(programAttributes.color);\r\n            _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);\r\n        }\r\n        state.disableUnusedAttributes();\r\n        _gl.drawArrays(4, 0, object.count);\r\n        object.count = 0;\r\n    };\r\n    this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {\r\n        var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);\r\n        state.setMaterial(material, frontFaceCW);\r\n        var program = setProgram(camera, fog, material, object);\r\n        var updateBuffers = false;\r\n        if (_currentGeometryProgram.geometry !== geometry.id ||\r\n            _currentGeometryProgram.program !== program.id ||\r\n            _currentGeometryProgram.wireframe !== (material.wireframe === true)) {\r\n            _currentGeometryProgram.geometry = geometry.id;\r\n            _currentGeometryProgram.program = program.id;\r\n            _currentGeometryProgram.wireframe = material.wireframe === true;\r\n            updateBuffers = true;\r\n        }\r\n        if (object.morphTargetInfluences) {\r\n            morphtargets.update(object, geometry, material, program);\r\n            updateBuffers = true;\r\n        }\r\n        //\r\n        var index = geometry.index;\r\n        var position = geometry.attributes.position;\r\n        var rangeFactor = 1;\r\n        if (material.wireframe === true) {\r\n            index = geometries.getWireframeAttribute(geometry);\r\n            rangeFactor = 2;\r\n        }\r\n        var attribute;\r\n        var renderer = bufferRenderer;\r\n        if (index !== null) {\r\n            attribute = attributes.get(index);\r\n            renderer = indexedBufferRenderer;\r\n            renderer.setIndex(attribute);\r\n        }\r\n        if (updateBuffers) {\r\n            setupVertexAttributes(material, program, geometry);\r\n            if (index !== null) {\r\n                _gl.bindBuffer(34963, attribute.buffer);\r\n            }\r\n        }\r\n        //\r\n        var dataCount = Infinity;\r\n        if (index !== null) {\r\n            dataCount = index.count;\r\n        }\r\n        else if (position !== undefined) {\r\n            dataCount = position.count;\r\n        }\r\n        var rangeStart = geometry.drawRange.start * rangeFactor;\r\n        var rangeCount = geometry.drawRange.count * rangeFactor;\r\n        var groupStart = group !== null ? group.start * rangeFactor : 0;\r\n        var groupCount = group !== null ? group.count * rangeFactor : Infinity;\r\n        var drawStart = Math.max(rangeStart, groupStart);\r\n        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\r\n        var drawCount = Math.max(0, drawEnd - drawStart + 1);\r\n        if (drawCount === 0)\r\n            return;\r\n        //\r\n        if (object.isMesh) {\r\n            if (material.wireframe === true) {\r\n                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\r\n                renderer.setMode(1);\r\n            }\r\n            else {\r\n                switch (object.drawMode) {\r\n                    case TrianglesDrawMode:\r\n                        renderer.setMode(4);\r\n                        break;\r\n                    case TriangleStripDrawMode:\r\n                        renderer.setMode(5);\r\n                        break;\r\n                    case TriangleFanDrawMode:\r\n                        renderer.setMode(6);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        else if (object.isLine) {\r\n            var lineWidth = material.linewidth;\r\n            if (lineWidth === undefined)\r\n                lineWidth = 1; // Not using Line*Material\r\n            state.setLineWidth(lineWidth * getTargetPixelRatio());\r\n            if (object.isLineSegments) {\r\n                renderer.setMode(1);\r\n            }\r\n            else if (object.isLineLoop) {\r\n                renderer.setMode(2);\r\n            }\r\n            else {\r\n                renderer.setMode(3);\r\n            }\r\n        }\r\n        else if (object.isPoints) {\r\n            renderer.setMode(0);\r\n        }\r\n        else if (object.isSprite) {\r\n            renderer.setMode(4);\r\n        }\r\n        if (geometry && geometry.isInstancedBufferGeometry) {\r\n            if (geometry.maxInstancedCount > 0) {\r\n                renderer.renderInstances(geometry, drawStart, drawCount);\r\n            }\r\n        }\r\n        else {\r\n            renderer.render(drawStart, drawCount);\r\n        }\r\n    };\r\n    function setupVertexAttributes(material, program, geometry) {\r\n        if (geometry && geometry.isInstancedBufferGeometry && !capabilities.isWebGL2) {\r\n            if (extensions.get('ANGLE_instanced_arrays') === null) {\r\n                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\r\n                return;\r\n            }\r\n        }\r\n        state.initAttributes();\r\n        var geometryAttributes = geometry.attributes;\r\n        var programAttributes = program.getAttributes();\r\n        var materialDefaultAttributeValues = material.defaultAttributeValues;\r\n        for (var name in programAttributes) {\r\n            var programAttribute = programAttributes[name];\r\n            if (programAttribute >= 0) {\r\n                var geometryAttribute = geometryAttributes[name];\r\n                if (geometryAttribute !== undefined) {\r\n                    var normalized = geometryAttribute.normalized;\r\n                    var size = geometryAttribute.itemSize;\r\n                    var attribute = attributes.get(geometryAttribute);\r\n                    // TODO Attribute may not be available on context restore\r\n                    if (attribute === undefined)\r\n                        continue;\r\n                    var buffer = attribute.buffer;\r\n                    var type = attribute.type;\r\n                    var bytesPerElement = attribute.bytesPerElement;\r\n                    if (geometryAttribute.isInterleavedBufferAttribute) {\r\n                        var data = geometryAttribute.data;\r\n                        var stride = data.stride;\r\n                        var offset = geometryAttribute.offset;\r\n                        if (data && data.isInstancedInterleavedBuffer) {\r\n                            state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\r\n                            if (geometry.maxInstancedCount === undefined) {\r\n                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n                            }\r\n                        }\r\n                        else {\r\n                            state.enableAttribute(programAttribute);\r\n                        }\r\n                        _gl.bindBuffer(34962, buffer);\r\n                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\r\n                    }\r\n                    else {\r\n                        if (geometryAttribute.isInstancedBufferAttribute) {\r\n                            state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\r\n                            if (geometry.maxInstancedCount === undefined) {\r\n                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n                            }\r\n                        }\r\n                        else {\r\n                            state.enableAttribute(programAttribute);\r\n                        }\r\n                        _gl.bindBuffer(34962, buffer);\r\n                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\r\n                    }\r\n                }\r\n                else if (materialDefaultAttributeValues !== undefined) {\r\n                    var value = materialDefaultAttributeValues[name];\r\n                    if (value !== undefined) {\r\n                        switch (value.length) {\r\n                            case 2:\r\n                                _gl.vertexAttrib2fv(programAttribute, value);\r\n                                break;\r\n                            case 3:\r\n                                _gl.vertexAttrib3fv(programAttribute, value);\r\n                                break;\r\n                            case 4:\r\n                                _gl.vertexAttrib4fv(programAttribute, value);\r\n                                break;\r\n                            default:\r\n                                _gl.vertexAttrib1fv(programAttribute, value);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        state.disableUnusedAttributes();\r\n    }\r\n    // Compile\r\n    this.compile = function (scene, camera) {\r\n        currentRenderState = renderStates.get(scene, camera);\r\n        currentRenderState.init();\r\n        scene.traverse(function (object) {\r\n            if (object.isLight) {\r\n                currentRenderState.pushLight(object);\r\n                if (object.castShadow) {\r\n                    currentRenderState.pushShadow(object);\r\n                }\r\n            }\r\n        });\r\n        currentRenderState.setupLights(camera);\r\n        scene.traverse(function (object) {\r\n            if (object.material) {\r\n                if (Array.isArray(object.material)) {\r\n                    for (var i = 0; i < object.material.length; i++) {\r\n                        initMaterial(object.material[i], scene.fog, object);\r\n                    }\r\n                }\r\n                else {\r\n                    initMaterial(object.material, scene.fog, object);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    // Animation Loop\r\n    var onAnimationFrameCallback = null;\r\n    function onAnimationFrame(time) {\r\n        if (vr.isPresenting())\r\n            return;\r\n        if (onAnimationFrameCallback)\r\n            onAnimationFrameCallback(time);\r\n    }\r\n    var animation = new WebGLAnimation();\r\n    animation.setAnimationLoop(onAnimationFrame);\r\n    if (typeof window !== 'undefined')\r\n        animation.setContext(window);\r\n    this.setAnimationLoop = function (callback) {\r\n        onAnimationFrameCallback = callback;\r\n        vr.setAnimationLoop(callback);\r\n        animation.start();\r\n    };\r\n    // Rendering\r\n    this.render = function (scene, camera) {\r\n        var renderTarget, forceClear;\r\n        if (arguments[2] !== undefined) {\r\n            console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\r\n            renderTarget = arguments[2];\r\n        }\r\n        if (arguments[3] !== undefined) {\r\n            console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');\r\n            forceClear = arguments[3];\r\n        }\r\n        if (!(camera && camera.isCamera)) {\r\n            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\r\n            return;\r\n        }\r\n        if (_isContextLost)\r\n            return;\r\n        // reset caching for this frame\r\n        _currentGeometryProgram.geometry = null;\r\n        _currentGeometryProgram.program = null;\r\n        _currentGeometryProgram.wireframe = false;\r\n        _currentMaterialId = -1;\r\n        _currentCamera = null;\r\n        // update scene graph\r\n        if (scene.autoUpdate === true)\r\n            scene.updateMatrixWorld();\r\n        // update camera matrices and frustum\r\n        if (camera.parent === null)\r\n            camera.updateMatrixWorld();\r\n        if (vr.enabled) {\r\n            camera = vr.getCamera(camera);\r\n        }\r\n        //\r\n        currentRenderState = renderStates.get(scene, camera);\r\n        currentRenderState.init();\r\n        scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);\r\n        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\r\n        _frustum.setFromMatrix(_projScreenMatrix);\r\n        _localClippingEnabled = this.localClippingEnabled;\r\n        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\r\n        currentRenderList = renderLists.get(scene, camera);\r\n        currentRenderList.init();\r\n        projectObject(scene, camera, 0, _this.sortObjects);\r\n        if (_this.sortObjects === true) {\r\n            currentRenderList.sort();\r\n        }\r\n        //\r\n        if (_clippingEnabled)\r\n            _clipping.beginShadows();\r\n        var shadowsArray = currentRenderState.state.shadowsArray;\r\n        shadowMap.render(shadowsArray, scene, camera);\r\n        currentRenderState.setupLights(camera);\r\n        if (_clippingEnabled)\r\n            _clipping.endShadows();\r\n        //\r\n        if (this.info.autoReset)\r\n            this.info.reset();\r\n        if (renderTarget !== undefined) {\r\n            this.setRenderTarget(renderTarget);\r\n        }\r\n        //\r\n        background.render(currentRenderList, scene, camera, forceClear);\r\n        // render scene\r\n        var opaqueObjects = currentRenderList.opaque;\r\n        var transparentObjects = currentRenderList.transparent;\r\n        if (scene.overrideMaterial) {\r\n            var overrideMaterial = scene.overrideMaterial;\r\n            if (opaqueObjects.length)\r\n                renderObjects(opaqueObjects, scene, camera, overrideMaterial);\r\n            if (transparentObjects.length)\r\n                renderObjects(transparentObjects, scene, camera, overrideMaterial);\r\n        }\r\n        else {\r\n            // opaque pass (front-to-back order)\r\n            if (opaqueObjects.length)\r\n                renderObjects(opaqueObjects, scene, camera);\r\n            // transparent pass (back-to-front order)\r\n            if (transparentObjects.length)\r\n                renderObjects(transparentObjects, scene, camera);\r\n        }\r\n        //\r\n        scene.onAfterRender(_this, scene, camera);\r\n        //\r\n        if (_currentRenderTarget !== null) {\r\n            // Generate mipmap if we're using any kind of mipmap filtering\r\n            textures.updateRenderTargetMipmap(_currentRenderTarget);\r\n            // resolve multisample renderbuffers to a single-sample texture if necessary\r\n            textures.updateMultisampleRenderTarget(_currentRenderTarget);\r\n        }\r\n        // Ensure depth buffer writing is enabled so it can be cleared on next render\r\n        state.buffers.depth.setTest(true);\r\n        state.buffers.depth.setMask(true);\r\n        state.buffers.color.setMask(true);\r\n        state.setPolygonOffset(false);\r\n        if (vr.enabled) {\r\n            vr.submitFrame();\r\n        }\r\n        // _gl.finish();\r\n        currentRenderList = null;\r\n        currentRenderState = null;\r\n    };\r\n    function projectObject(object, camera, groupOrder, sortObjects) {\r\n        if (object.visible === false)\r\n            return;\r\n        var visible = object.layers.test(camera.layers);\r\n        if (visible) {\r\n            if (object.isGroup) {\r\n                groupOrder = object.renderOrder;\r\n            }\r\n            else if (object.isLOD) {\r\n                if (object.autoUpdate === true)\r\n                    object.update(camera);\r\n            }\r\n            else if (object.isLight) {\r\n                currentRenderState.pushLight(object);\r\n                if (object.castShadow) {\r\n                    currentRenderState.pushShadow(object);\r\n                }\r\n            }\r\n            else if (object.isSprite) {\r\n                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\r\n                    if (sortObjects) {\r\n                        _vector3.setFromMatrixPosition(object.matrixWorld)\r\n                            .applyMatrix4(_projScreenMatrix);\r\n                    }\r\n                    var geometry = objects.update(object);\r\n                    var material = object.material;\r\n                    if (material.visible) {\r\n                        currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\r\n                    }\r\n                }\r\n            }\r\n            else if (object.isImmediateRenderObject) {\r\n                if (sortObjects) {\r\n                    _vector3.setFromMatrixPosition(object.matrixWorld)\r\n                        .applyMatrix4(_projScreenMatrix);\r\n                }\r\n                currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\r\n            }\r\n            else if (object.isMesh || object.isLine || object.isPoints) {\r\n                if (object.isSkinnedMesh) {\r\n                    object.skeleton.update();\r\n                }\r\n                if (!object.frustumCulled || _frustum.intersectsObject(object)) {\r\n                    if (sortObjects) {\r\n                        _vector3.setFromMatrixPosition(object.matrixWorld)\r\n                            .applyMatrix4(_projScreenMatrix);\r\n                    }\r\n                    var geometry = objects.update(object);\r\n                    var material = object.material;\r\n                    if (Array.isArray(material)) {\r\n                        var groups = geometry.groups;\r\n                        for (var i = 0, l = groups.length; i < l; i++) {\r\n                            var group = groups[i];\r\n                            var groupMaterial = material[group.materialIndex];\r\n                            if (groupMaterial && groupMaterial.visible) {\r\n                                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (material.visible) {\r\n                        currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var children = object.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            projectObject(children[i], camera, groupOrder, sortObjects);\r\n        }\r\n    }\r\n    function renderObjects(renderList, scene, camera, overrideMaterial) {\r\n        for (var i = 0, l = renderList.length; i < l; i++) {\r\n            var renderItem = renderList[i];\r\n            var object = renderItem.object;\r\n            var geometry = renderItem.geometry;\r\n            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n            var group = renderItem.group;\r\n            if (camera.isArrayCamera) {\r\n                _currentArrayCamera = camera;\r\n                var cameras = camera.cameras;\r\n                for (var j = 0, jl = cameras.length; j < jl; j++) {\r\n                    var camera2 = cameras[j];\r\n                    if (object.layers.test(camera2.layers)) {\r\n                        state.viewport(_currentViewport.copy(camera2.viewport));\r\n                        currentRenderState.setupLights(camera2);\r\n                        renderObject(object, scene, camera2, geometry, material, group);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                _currentArrayCamera = null;\r\n                renderObject(object, scene, camera, geometry, material, group);\r\n            }\r\n        }\r\n    }\r\n    function renderObject(object, scene, camera, geometry, material, group) {\r\n        object.onBeforeRender(_this, scene, camera, geometry, material, group);\r\n        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);\r\n        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\r\n        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\r\n        if (object.isImmediateRenderObject) {\r\n            state.setMaterial(material);\r\n            var program = setProgram(camera, scene.fog, material, object);\r\n            _currentGeometryProgram.geometry = null;\r\n            _currentGeometryProgram.program = null;\r\n            _currentGeometryProgram.wireframe = false;\r\n            renderObjectImmediate(object, program);\r\n        }\r\n        else {\r\n            _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);\r\n        }\r\n        object.onAfterRender(_this, scene, camera, geometry, material, group);\r\n        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);\r\n    }\r\n    function initMaterial(material, fog, object) {\r\n        var materialProperties = properties.get(material);\r\n        var lights = currentRenderState.state.lights;\r\n        var shadowsArray = currentRenderState.state.shadowsArray;\r\n        var lightsStateVersion = lights.state.version;\r\n        var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);\r\n        var code = programCache.getProgramCode(material, parameters);\r\n        var program = materialProperties.program;\r\n        var programChange = true;\r\n        if (program === undefined) {\r\n            // new material\r\n            material.addEventListener('dispose', onMaterialDispose);\r\n        }\r\n        else if (program.code !== code) {\r\n            // changed glsl or parameters\r\n            releaseMaterialProgramReference(material);\r\n        }\r\n        else if (materialProperties.lightsStateVersion !== lightsStateVersion) {\r\n            materialProperties.lightsStateVersion = lightsStateVersion;\r\n            programChange = false;\r\n        }\r\n        else if (parameters.shaderID !== undefined) {\r\n            // same glsl and uniform list\r\n            return;\r\n        }\r\n        else {\r\n            // only rebuild uniform list\r\n            programChange = false;\r\n        }\r\n        if (programChange) {\r\n            if (parameters.shaderID) {\r\n                var shader = ShaderLib[parameters.shaderID];\r\n                materialProperties.shader = {\r\n                    name: material.type,\r\n                    uniforms: cloneUniforms(shader.uniforms),\r\n                    vertexShader: shader.vertexShader,\r\n                    fragmentShader: shader.fragmentShader\r\n                };\r\n            }\r\n            else {\r\n                materialProperties.shader = {\r\n                    name: material.type,\r\n                    uniforms: material.uniforms,\r\n                    vertexShader: material.vertexShader,\r\n                    fragmentShader: material.fragmentShader\r\n                };\r\n            }\r\n            material.onBeforeCompile(materialProperties.shader, _this);\r\n            // Computing code again as onBeforeCompile may have changed the shaders\r\n            code = programCache.getProgramCode(material, parameters);\r\n            program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);\r\n            materialProperties.program = program;\r\n            material.program = program;\r\n        }\r\n        var programAttributes = program.getAttributes();\r\n        if (material.morphTargets) {\r\n            material.numSupportedMorphTargets = 0;\r\n            for (var i = 0; i < _this.maxMorphTargets; i++) {\r\n                if (programAttributes['morphTarget' + i] >= 0) {\r\n                    material.numSupportedMorphTargets++;\r\n                }\r\n            }\r\n        }\r\n        if (material.morphNormals) {\r\n            material.numSupportedMorphNormals = 0;\r\n            for (var i = 0; i < _this.maxMorphNormals; i++) {\r\n                if (programAttributes['morphNormal' + i] >= 0) {\r\n                    material.numSupportedMorphNormals++;\r\n                }\r\n            }\r\n        }\r\n        var uniforms = materialProperties.shader.uniforms;\r\n        if (!material.isShaderMaterial &&\r\n            !material.isRawShaderMaterial ||\r\n            material.clipping === true) {\r\n            materialProperties.numClippingPlanes = _clipping.numPlanes;\r\n            materialProperties.numIntersection = _clipping.numIntersection;\r\n            uniforms.clippingPlanes = _clipping.uniform;\r\n        }\r\n        materialProperties.fog = fog;\r\n        // store the light setup it was created for\r\n        materialProperties.lightsStateVersion = lightsStateVersion;\r\n        if (material.lights) {\r\n            // wire up the material to this renderer's lighting state\r\n            uniforms.ambientLightColor.value = lights.state.ambient;\r\n            uniforms.lightProbe.value = lights.state.probe;\r\n            uniforms.directionalLights.value = lights.state.directional;\r\n            uniforms.spotLights.value = lights.state.spot;\r\n            uniforms.rectAreaLights.value = lights.state.rectArea;\r\n            uniforms.pointLights.value = lights.state.point;\r\n            uniforms.hemisphereLights.value = lights.state.hemi;\r\n            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\r\n            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\r\n            uniforms.spotShadowMap.value = lights.state.spotShadowMap;\r\n            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\r\n            uniforms.pointShadowMap.value = lights.state.pointShadowMap;\r\n            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\r\n            // TODO (abelnation): add area lights shadow info to uniforms\r\n        }\r\n        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\r\n        materialProperties.uniformsList = uniformsList;\r\n    }\r\n    function setProgram(camera, fog, material, object) {\r\n        textures.resetTextureUnits();\r\n        var materialProperties = properties.get(material);\r\n        var lights = currentRenderState.state.lights;\r\n        if (_clippingEnabled) {\r\n            if (_localClippingEnabled || camera !== _currentCamera) {\r\n                var useCache = camera === _currentCamera &&\r\n                    material.id === _currentMaterialId;\r\n                // we might want to call this function with some ClippingGroup\r\n                // object instead of the material, once it becomes feasible\r\n                // (#8465, #8379)\r\n                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);\r\n            }\r\n        }\r\n        if (material.needsUpdate === false) {\r\n            if (materialProperties.program === undefined) {\r\n                material.needsUpdate = true;\r\n            }\r\n            else if (material.fog && materialProperties.fog !== fog) {\r\n                material.needsUpdate = true;\r\n            }\r\n            else if (material.lights && materialProperties.lightsStateVersion !== lights.state.version) {\r\n                material.needsUpdate = true;\r\n            }\r\n            else if (materialProperties.numClippingPlanes !== undefined &&\r\n                (materialProperties.numClippingPlanes !== _clipping.numPlanes ||\r\n                    materialProperties.numIntersection !== _clipping.numIntersection)) {\r\n                material.needsUpdate = true;\r\n            }\r\n        }\r\n        if (material.needsUpdate) {\r\n            initMaterial(material, fog, object);\r\n            material.needsUpdate = false;\r\n        }\r\n        var refreshProgram = false;\r\n        var refreshMaterial = false;\r\n        var refreshLights = false;\r\n        var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;\r\n        if (state.useProgram(program.program)) {\r\n            refreshProgram = true;\r\n            refreshMaterial = true;\r\n            refreshLights = true;\r\n        }\r\n        if (material.id !== _currentMaterialId) {\r\n            _currentMaterialId = material.id;\r\n            refreshMaterial = true;\r\n        }\r\n        if (refreshProgram || _currentCamera !== camera) {\r\n            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\r\n            if (capabilities.logarithmicDepthBuffer) {\r\n                p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\r\n            }\r\n            if (_currentCamera !== camera) {\r\n                _currentCamera = camera;\r\n                // lighting uniforms depend on the camera so enforce an update\r\n                // now, in case this material supports lights - or later, when\r\n                // the next material that does gets activated:\r\n                refreshMaterial = true; // set to true on material change\r\n                refreshLights = true; // remains set until update done\r\n            }\r\n            // load material specific uniforms\r\n            // (shader material also gets them for the sake of genericity)\r\n            if (material.isShaderMaterial ||\r\n                material.isMeshPhongMaterial ||\r\n                material.isMeshStandardMaterial ||\r\n                material.envMap) {\r\n                var uCamPos = p_uniforms.map.cameraPosition;\r\n                if (uCamPos !== undefined) {\r\n                    uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\r\n                }\r\n            }\r\n            if (material.isMeshPhongMaterial ||\r\n                material.isMeshLambertMaterial ||\r\n                material.isMeshBasicMaterial ||\r\n                material.isMeshStandardMaterial ||\r\n                material.isShaderMaterial ||\r\n                material.skinning) {\r\n                p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\r\n            }\r\n        }\r\n        // skinning uniforms must be set even if material didn't change\r\n        // auto-setting of texture unit for bone texture must go before other textures\r\n        // not sure why, but otherwise weird things happen\r\n        if (material.skinning) {\r\n            p_uniforms.setOptional(_gl, object, 'bindMatrix');\r\n            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\r\n            var skeleton = object.skeleton;\r\n            if (skeleton) {\r\n                var bones = skeleton.bones;\r\n                if (capabilities.floatVertexTextures) {\r\n                    if (skeleton.boneTexture === undefined) {\r\n                        // layout (1 matrix = 4 pixels)\r\n                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n                        var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix\r\n                        size = _Math.ceilPowerOfTwo(size);\r\n                        size = Math.max(size, 4);\r\n                        var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\r\n                        boneMatrices.set(skeleton.boneMatrices); // copy current values\r\n                        var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\r\n                        boneTexture.needsUpdate = true;\r\n                        skeleton.boneMatrices = boneMatrices;\r\n                        skeleton.boneTexture = boneTexture;\r\n                        skeleton.boneTextureSize = size;\r\n                    }\r\n                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\r\n                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\r\n                }\r\n                else {\r\n                    p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\r\n                }\r\n            }\r\n        }\r\n        if (refreshMaterial) {\r\n            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\r\n            p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);\r\n            if (material.lights) {\r\n                // the current material requires lighting info\r\n                // note: all lighting uniforms are always set correctly\r\n                // they simply reference the renderer's state for their\r\n                // values\r\n                //\r\n                // use the current material's .needsUpdate flags to set\r\n                // the GL state when required\r\n                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\r\n            }\r\n            // refresh uniforms common to several materials\r\n            if (fog && material.fog) {\r\n                refreshUniformsFog(m_uniforms, fog);\r\n            }\r\n            if (material.isMeshBasicMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n            }\r\n            else if (material.isMeshLambertMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                refreshUniformsLambert(m_uniforms, material);\r\n            }\r\n            else if (material.isMeshPhongMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                if (material.isMeshToonMaterial) {\r\n                    refreshUniformsToon(m_uniforms, material);\r\n                }\r\n                else {\r\n                    refreshUniformsPhong(m_uniforms, material);\r\n                }\r\n            }\r\n            else if (material.isMeshStandardMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                if (material.isMeshPhysicalMaterial) {\r\n                    refreshUniformsPhysical(m_uniforms, material);\r\n                }\r\n                else {\r\n                    refreshUniformsStandard(m_uniforms, material);\r\n                }\r\n            }\r\n            else if (material.isMeshMatcapMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                refreshUniformsMatcap(m_uniforms, material);\r\n            }\r\n            else if (material.isMeshDepthMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                refreshUniformsDepth(m_uniforms, material);\r\n            }\r\n            else if (material.isMeshDistanceMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                refreshUniformsDistance(m_uniforms, material);\r\n            }\r\n            else if (material.isMeshNormalMaterial) {\r\n                refreshUniformsCommon(m_uniforms, material);\r\n                refreshUniformsNormal(m_uniforms, material);\r\n            }\r\n            else if (material.isLineBasicMaterial) {\r\n                refreshUniformsLine(m_uniforms, material);\r\n                if (material.isLineDashedMaterial) {\r\n                    refreshUniformsDash(m_uniforms, material);\r\n                }\r\n            }\r\n            else if (material.isPointsMaterial) {\r\n                refreshUniformsPoints(m_uniforms, material);\r\n            }\r\n            else if (material.isSpriteMaterial) {\r\n                refreshUniformsSprites(m_uniforms, material);\r\n            }\r\n            else if (material.isShadowMaterial) {\r\n                m_uniforms.color.value.copy(material.color);\r\n                m_uniforms.opacity.value = material.opacity;\r\n            }\r\n            // RectAreaLight Texture\r\n            // TODO (mrdoob): Find a nicer implementation\r\n            if (m_uniforms.ltc_1 !== undefined)\r\n                m_uniforms.ltc_1.value = UniformsLib.LTC_1;\r\n            if (m_uniforms.ltc_2 !== undefined)\r\n                m_uniforms.ltc_2.value = UniformsLib.LTC_2;\r\n            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\r\n        }\r\n        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\r\n            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\r\n            material.uniformsNeedUpdate = false;\r\n        }\r\n        if (material.isSpriteMaterial) {\r\n            p_uniforms.setValue(_gl, 'center', object.center);\r\n        }\r\n        // common matrices\r\n        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\r\n        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\r\n        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\r\n        return program;\r\n    }\r\n    // Uniforms (refresh uniforms objects)\r\n    function refreshUniformsCommon(uniforms, material) {\r\n        uniforms.opacity.value = material.opacity;\r\n        if (material.color) {\r\n            uniforms.diffuse.value.copy(material.color);\r\n        }\r\n        if (material.emissive) {\r\n            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\r\n        }\r\n        if (material.map) {\r\n            uniforms.map.value = material.map;\r\n        }\r\n        if (material.alphaMap) {\r\n            uniforms.alphaMap.value = material.alphaMap;\r\n        }\r\n        if (material.specularMap) {\r\n            uniforms.specularMap.value = material.specularMap;\r\n        }\r\n        if (material.envMap) {\r\n            uniforms.envMap.value = material.envMap;\r\n            // don't flip CubeTexture envMaps, flip everything else:\r\n            //  WebGLRenderTargetCube will be flipped for backwards compatibility\r\n            //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\r\n            // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\r\n            uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\r\n            uniforms.reflectivity.value = material.reflectivity;\r\n            uniforms.refractionRatio.value = material.refractionRatio;\r\n            uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;\r\n        }\r\n        if (material.lightMap) {\r\n            uniforms.lightMap.value = material.lightMap;\r\n            uniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n        }\r\n        if (material.aoMap) {\r\n            uniforms.aoMap.value = material.aoMap;\r\n            uniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n        }\r\n        // uv repeat and offset setting priorities\r\n        // 1. color map\r\n        // 2. specular map\r\n        // 3. normal map\r\n        // 4. bump map\r\n        // 5. alpha map\r\n        // 6. emissive map\r\n        var uvScaleMap;\r\n        if (material.map) {\r\n            uvScaleMap = material.map;\r\n        }\r\n        else if (material.specularMap) {\r\n            uvScaleMap = material.specularMap;\r\n        }\r\n        else if (material.displacementMap) {\r\n            uvScaleMap = material.displacementMap;\r\n        }\r\n        else if (material.normalMap) {\r\n            uvScaleMap = material.normalMap;\r\n        }\r\n        else if (material.bumpMap) {\r\n            uvScaleMap = material.bumpMap;\r\n        }\r\n        else if (material.roughnessMap) {\r\n            uvScaleMap = material.roughnessMap;\r\n        }\r\n        else if (material.metalnessMap) {\r\n            uvScaleMap = material.metalnessMap;\r\n        }\r\n        else if (material.alphaMap) {\r\n            uvScaleMap = material.alphaMap;\r\n        }\r\n        else if (material.emissiveMap) {\r\n            uvScaleMap = material.emissiveMap;\r\n        }\r\n        if (uvScaleMap !== undefined) {\r\n            // backwards compatibility\r\n            if (uvScaleMap.isWebGLRenderTarget) {\r\n                uvScaleMap = uvScaleMap.texture;\r\n            }\r\n            if (uvScaleMap.matrixAutoUpdate === true) {\r\n                uvScaleMap.updateMatrix();\r\n            }\r\n            uniforms.uvTransform.value.copy(uvScaleMap.matrix);\r\n        }\r\n    }\r\n    function refreshUniformsLine(uniforms, material) {\r\n        uniforms.diffuse.value.copy(material.color);\r\n        uniforms.opacity.value = material.opacity;\r\n    }\r\n    function refreshUniformsDash(uniforms, material) {\r\n        uniforms.dashSize.value = material.dashSize;\r\n        uniforms.totalSize.value = material.dashSize + material.gapSize;\r\n        uniforms.scale.value = material.scale;\r\n    }\r\n    function refreshUniformsPoints(uniforms, material) {\r\n        uniforms.diffuse.value.copy(material.color);\r\n        uniforms.opacity.value = material.opacity;\r\n        uniforms.size.value = material.size * _pixelRatio;\r\n        uniforms.scale.value = _height * 0.5;\r\n        uniforms.map.value = material.map;\r\n        if (material.map !== null) {\r\n            if (material.map.matrixAutoUpdate === true) {\r\n                material.map.updateMatrix();\r\n            }\r\n            uniforms.uvTransform.value.copy(material.map.matrix);\r\n        }\r\n    }\r\n    function refreshUniformsSprites(uniforms, material) {\r\n        uniforms.diffuse.value.copy(material.color);\r\n        uniforms.opacity.value = material.opacity;\r\n        uniforms.rotation.value = material.rotation;\r\n        uniforms.map.value = material.map;\r\n        if (material.map !== null) {\r\n            if (material.map.matrixAutoUpdate === true) {\r\n                material.map.updateMatrix();\r\n            }\r\n            uniforms.uvTransform.value.copy(material.map.matrix);\r\n        }\r\n    }\r\n    function refreshUniformsFog(uniforms, fog) {\r\n        uniforms.fogColor.value.copy(fog.color);\r\n        if (fog.isFog) {\r\n            uniforms.fogNear.value = fog.near;\r\n            uniforms.fogFar.value = fog.far;\r\n        }\r\n        else if (fog.isFogExp2) {\r\n            uniforms.fogDensity.value = fog.density;\r\n        }\r\n    }\r\n    function refreshUniformsLambert(uniforms, material) {\r\n        if (material.emissiveMap) {\r\n            uniforms.emissiveMap.value = material.emissiveMap;\r\n        }\r\n    }\r\n    function refreshUniformsPhong(uniforms, material) {\r\n        uniforms.specular.value.copy(material.specular);\r\n        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\r\n        if (material.emissiveMap) {\r\n            uniforms.emissiveMap.value = material.emissiveMap;\r\n        }\r\n        if (material.bumpMap) {\r\n            uniforms.bumpMap.value = material.bumpMap;\r\n            uniforms.bumpScale.value = material.bumpScale;\r\n            if (material.side === BackSide)\r\n                uniforms.bumpScale.value *= -1;\r\n        }\r\n        if (material.normalMap) {\r\n            uniforms.normalMap.value = material.normalMap;\r\n            uniforms.normalScale.value.copy(material.normalScale);\r\n            if (material.side === BackSide)\r\n                uniforms.normalScale.value.negate();\r\n        }\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n    }\r\n    function refreshUniformsToon(uniforms, material) {\r\n        refreshUniformsPhong(uniforms, material);\r\n        if (material.gradientMap) {\r\n            uniforms.gradientMap.value = material.gradientMap;\r\n        }\r\n    }\r\n    function refreshUniformsStandard(uniforms, material) {\r\n        uniforms.roughness.value = material.roughness;\r\n        uniforms.metalness.value = material.metalness;\r\n        if (material.roughnessMap) {\r\n            uniforms.roughnessMap.value = material.roughnessMap;\r\n        }\r\n        if (material.metalnessMap) {\r\n            uniforms.metalnessMap.value = material.metalnessMap;\r\n        }\r\n        if (material.emissiveMap) {\r\n            uniforms.emissiveMap.value = material.emissiveMap;\r\n        }\r\n        if (material.bumpMap) {\r\n            uniforms.bumpMap.value = material.bumpMap;\r\n            uniforms.bumpScale.value = material.bumpScale;\r\n            if (material.side === BackSide)\r\n                uniforms.bumpScale.value *= -1;\r\n        }\r\n        if (material.normalMap) {\r\n            uniforms.normalMap.value = material.normalMap;\r\n            uniforms.normalScale.value.copy(material.normalScale);\r\n            if (material.side === BackSide)\r\n                uniforms.normalScale.value.negate();\r\n        }\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n        if (material.envMap) {\r\n            //uniforms.envMap.value = material.envMap; // part of uniforms common\r\n            uniforms.envMapIntensity.value = material.envMapIntensity;\r\n        }\r\n    }\r\n    function refreshUniformsPhysical(uniforms, material) {\r\n        refreshUniformsStandard(uniforms, material);\r\n        uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\r\n        uniforms.clearCoat.value = material.clearCoat;\r\n        uniforms.clearCoatRoughness.value = material.clearCoatRoughness;\r\n    }\r\n    function refreshUniformsMatcap(uniforms, material) {\r\n        if (material.matcap) {\r\n            uniforms.matcap.value = material.matcap;\r\n        }\r\n        if (material.bumpMap) {\r\n            uniforms.bumpMap.value = material.bumpMap;\r\n            uniforms.bumpScale.value = material.bumpScale;\r\n            if (material.side === BackSide)\r\n                uniforms.bumpScale.value *= -1;\r\n        }\r\n        if (material.normalMap) {\r\n            uniforms.normalMap.value = material.normalMap;\r\n            uniforms.normalScale.value.copy(material.normalScale);\r\n            if (material.side === BackSide)\r\n                uniforms.normalScale.value.negate();\r\n        }\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n    }\r\n    function refreshUniformsDepth(uniforms, material) {\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n    }\r\n    function refreshUniformsDistance(uniforms, material) {\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n        uniforms.referencePosition.value.copy(material.referencePosition);\r\n        uniforms.nearDistance.value = material.nearDistance;\r\n        uniforms.farDistance.value = material.farDistance;\r\n    }\r\n    function refreshUniformsNormal(uniforms, material) {\r\n        if (material.bumpMap) {\r\n            uniforms.bumpMap.value = material.bumpMap;\r\n            uniforms.bumpScale.value = material.bumpScale;\r\n            if (material.side === BackSide)\r\n                uniforms.bumpScale.value *= -1;\r\n        }\r\n        if (material.normalMap) {\r\n            uniforms.normalMap.value = material.normalMap;\r\n            uniforms.normalScale.value.copy(material.normalScale);\r\n            if (material.side === BackSide)\r\n                uniforms.normalScale.value.negate();\r\n        }\r\n        if (material.displacementMap) {\r\n            uniforms.displacementMap.value = material.displacementMap;\r\n            uniforms.displacementScale.value = material.displacementScale;\r\n            uniforms.displacementBias.value = material.displacementBias;\r\n        }\r\n    }\r\n    // If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n    function markUniformsLightsNeedsUpdate(uniforms, value) {\r\n        uniforms.ambientLightColor.needsUpdate = value;\r\n        uniforms.lightProbe.needsUpdate = value;\r\n        uniforms.directionalLights.needsUpdate = value;\r\n        uniforms.pointLights.needsUpdate = value;\r\n        uniforms.spotLights.needsUpdate = value;\r\n        uniforms.rectAreaLights.needsUpdate = value;\r\n        uniforms.hemisphereLights.needsUpdate = value;\r\n    }\r\n    //\r\n    this.setFramebuffer = function (value) {\r\n        if (_framebuffer !== value)\r\n            _gl.bindFramebuffer(36160, value);\r\n        _framebuffer = value;\r\n    };\r\n    this.getActiveCubeFace = function () {\r\n        return _currentActiveCubeFace;\r\n    };\r\n    this.getActiveMipmapLevel = function () {\r\n        return _currentActiveMipmapLevel;\r\n    };\r\n    this.getRenderTarget = function () {\r\n        return _currentRenderTarget;\r\n    };\r\n    this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {\r\n        _currentRenderTarget = renderTarget;\r\n        _currentActiveCubeFace = activeCubeFace;\r\n        _currentActiveMipmapLevel = activeMipmapLevel;\r\n        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\r\n            textures.setupRenderTarget(renderTarget);\r\n        }\r\n        var framebuffer = _framebuffer;\r\n        var isCube = false;\r\n        if (renderTarget) {\r\n            var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\r\n            if (renderTarget.isWebGLRenderTargetCube) {\r\n                framebuffer = __webglFramebuffer[activeCubeFace || 0];\r\n                isCube = true;\r\n            }\r\n            else if (renderTarget.isWebGLMultisampleRenderTarget) {\r\n                framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\r\n            }\r\n            else {\r\n                framebuffer = __webglFramebuffer;\r\n            }\r\n            _currentViewport.copy(renderTarget.viewport);\r\n            _currentScissor.copy(renderTarget.scissor);\r\n            _currentScissorTest = renderTarget.scissorTest;\r\n        }\r\n        else {\r\n            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\r\n            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\r\n            _currentScissorTest = _scissorTest;\r\n        }\r\n        if (_currentFramebuffer !== framebuffer) {\r\n            _gl.bindFramebuffer(36160, framebuffer);\r\n            _currentFramebuffer = framebuffer;\r\n        }\r\n        state.viewport(_currentViewport);\r\n        state.scissor(_currentScissor);\r\n        state.setScissorTest(_currentScissorTest);\r\n        if (isCube) {\r\n            var textureProperties = properties.get(renderTarget.texture);\r\n            _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);\r\n        }\r\n    };\r\n    this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\r\n        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\r\n            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\r\n            return;\r\n        }\r\n        var framebuffer = properties.get(renderTarget).__webglFramebuffer;\r\n        if (renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== undefined) {\r\n            framebuffer = framebuffer[activeCubeFaceIndex];\r\n        }\r\n        if (framebuffer) {\r\n            var restore = false;\r\n            if (framebuffer !== _currentFramebuffer) {\r\n                _gl.bindFramebuffer(36160, framebuffer);\r\n                restore = true;\r\n            }\r\n            try {\r\n                var texture = renderTarget.texture;\r\n                var textureFormat = texture.format;\r\n                var textureType = texture.type;\r\n                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {\r\n                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\r\n                    return;\r\n                }\r\n                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)\r\n                    !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\r\n                    !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {\r\n                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\r\n                    return;\r\n                }\r\n                if (_gl.checkFramebufferStatus(36160) === 36053) {\r\n                    // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {\r\n                        _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\r\n                    }\r\n                }\r\n                else {\r\n                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\r\n                }\r\n            }\r\n            finally {\r\n                if (restore) {\r\n                    _gl.bindFramebuffer(36160, _currentFramebuffer);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    this.copyFramebufferToTexture = function (position, texture, level) {\r\n        var width = texture.image.width;\r\n        var height = texture.image.height;\r\n        var glFormat = utils.convert(texture.format);\r\n        textures.setTexture2D(texture, 0);\r\n        _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);\r\n    };\r\n    this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {\r\n        var width = srcTexture.image.width;\r\n        var height = srcTexture.image.height;\r\n        var glFormat = utils.convert(dstTexture.format);\r\n        var glType = utils.convert(dstTexture.type);\r\n        textures.setTexture2D(dstTexture, 0);\r\n        if (srcTexture.isDataTexture) {\r\n            _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\r\n        }\r\n        else {\r\n            _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);\r\n        }\r\n    };\r\n    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\r\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this })); // eslint-disable-line no-undef\r\n    }\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction FogExp2(color, density) {\r\n    this.name = '';\r\n    this.color = new Color(color);\r\n    this.density = (density !== undefined) ? density : 0.00025;\r\n}\r\nObject.assign(FogExp2.prototype, {\r\n    isFogExp2: true,\r\n    clone: function () {\r\n        return new FogExp2(this.color, this.density);\r\n    },\r\n    toJSON: function ( /* meta */) {\r\n        return {\r\n            type: 'FogExp2',\r\n            color: this.color.getHex(),\r\n            density: this.density\r\n        };\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Fog(color, near, far) {\r\n    this.name = '';\r\n    this.color = new Color(color);\r\n    this.near = (near !== undefined) ? near : 1;\r\n    this.far = (far !== undefined) ? far : 1000;\r\n}\r\nObject.assign(Fog.prototype, {\r\n    isFog: true,\r\n    clone: function () {\r\n        return new Fog(this.color, this.near, this.far);\r\n    },\r\n    toJSON: function ( /* meta */) {\r\n        return {\r\n            type: 'Fog',\r\n            color: this.color.getHex(),\r\n            near: this.near,\r\n            far: this.far\r\n        };\r\n    }\r\n});\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\nfunction InterleavedBuffer(array, stride) {\r\n    this.array = array;\r\n    this.stride = stride;\r\n    this.count = array !== undefined ? array.length / stride : 0;\r\n    this.dynamic = false;\r\n    this.updateRange = { offset: 0, count: -1 };\r\n    this.version = 0;\r\n}\r\nObject.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {\r\n    set: function (value) {\r\n        if (value === true)\r\n            this.version++;\r\n    }\r\n});\r\nObject.assign(InterleavedBuffer.prototype, {\r\n    isInterleavedBuffer: true,\r\n    onUploadCallback: function () { },\r\n    setArray: function (array) {\r\n        if (Array.isArray(array)) {\r\n            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\r\n        }\r\n        this.count = array !== undefined ? array.length / this.stride : 0;\r\n        this.array = array;\r\n        return this;\r\n    },\r\n    setDynamic: function (value) {\r\n        this.dynamic = value;\r\n        return this;\r\n    },\r\n    copy: function (source) {\r\n        this.array = new source.array.constructor(source.array);\r\n        this.count = source.count;\r\n        this.stride = source.stride;\r\n        this.dynamic = source.dynamic;\r\n        return this;\r\n    },\r\n    copyAt: function (index1, attribute, index2) {\r\n        index1 *= this.stride;\r\n        index2 *= attribute.stride;\r\n        for (var i = 0, l = this.stride; i < l; i++) {\r\n            this.array[index1 + i] = attribute.array[index2 + i];\r\n        }\r\n        return this;\r\n    },\r\n    set: function (value, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.array.set(value, offset);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    onUpload: function (callback) {\r\n        this.onUploadCallback = callback;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\nfunction InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {\r\n    this.data = interleavedBuffer;\r\n    this.itemSize = itemSize;\r\n    this.offset = offset;\r\n    this.normalized = normalized === true;\r\n}\r\nObject.defineProperties(InterleavedBufferAttribute.prototype, {\r\n    count: {\r\n        get: function () {\r\n            return this.data.count;\r\n        }\r\n    },\r\n    array: {\r\n        get: function () {\r\n            return this.data.array;\r\n        }\r\n    }\r\n});\r\nObject.assign(InterleavedBufferAttribute.prototype, {\r\n    isInterleavedBufferAttribute: true,\r\n    setX: function (index, x) {\r\n        this.data.array[index * this.data.stride + this.offset] = x;\r\n        return this;\r\n    },\r\n    setY: function (index, y) {\r\n        this.data.array[index * this.data.stride + this.offset + 1] = y;\r\n        return this;\r\n    },\r\n    setZ: function (index, z) {\r\n        this.data.array[index * this.data.stride + this.offset + 2] = z;\r\n        return this;\r\n    },\r\n    setW: function (index, w) {\r\n        this.data.array[index * this.data.stride + this.offset + 3] = w;\r\n        return this;\r\n    },\r\n    getX: function (index) {\r\n        return this.data.array[index * this.data.stride + this.offset];\r\n    },\r\n    getY: function (index) {\r\n        return this.data.array[index * this.data.stride + this.offset + 1];\r\n    },\r\n    getZ: function (index) {\r\n        return this.data.array[index * this.data.stride + this.offset + 2];\r\n    },\r\n    getW: function (index) {\r\n        return this.data.array[index * this.data.stride + this.offset + 3];\r\n    },\r\n    setXY: function (index, x, y) {\r\n        index = index * this.data.stride + this.offset;\r\n        this.data.array[index + 0] = x;\r\n        this.data.array[index + 1] = y;\r\n        return this;\r\n    },\r\n    setXYZ: function (index, x, y, z) {\r\n        index = index * this.data.stride + this.offset;\r\n        this.data.array[index + 0] = x;\r\n        this.data.array[index + 1] = y;\r\n        this.data.array[index + 2] = z;\r\n        return this;\r\n    },\r\n    setXYZW: function (index, x, y, z, w) {\r\n        index = index * this.data.stride + this.offset;\r\n        this.data.array[index + 0] = x;\r\n        this.data.array[index + 1] = y;\r\n        this.data.array[index + 2] = z;\r\n        this.data.array[index + 3] = w;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *  rotation: <float>,\r\n *  sizeAttenuation: <bool>\r\n * }\r\n */\r\nfunction SpriteMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'SpriteMaterial';\r\n    this.color = new Color(0xffffff);\r\n    this.map = null;\r\n    this.rotation = 0;\r\n    this.sizeAttenuation = true;\r\n    this.lights = false;\r\n    this.transparent = true;\r\n    this.setValues(parameters);\r\n}\r\nSpriteMaterial.prototype = Object.create(Material$1.prototype);\r\nSpriteMaterial.prototype.constructor = SpriteMaterial;\r\nSpriteMaterial.prototype.isSpriteMaterial = true;\r\nSpriteMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.map = source.map;\r\n    this.rotation = source.rotation;\r\n    this.sizeAttenuation = source.sizeAttenuation;\r\n    return this;\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nvar geometry;\r\nfunction Sprite(material) {\r\n    Object3D.call(this);\r\n    this.type = 'Sprite';\r\n    if (geometry === undefined) {\r\n        geometry = new BufferGeometry();\r\n        var float32Array = new Float32Array([\r\n            -0.5, -0.5, 0, 0, 0,\r\n            0.5, -0.5, 0, 1, 0,\r\n            0.5, 0.5, 0, 1, 1,\r\n            -0.5, 0.5, 0, 0, 1\r\n        ]);\r\n        var interleavedBuffer = new InterleavedBuffer(float32Array, 5);\r\n        geometry.setIndex([0, 1, 2, 0, 2, 3]);\r\n        geometry.addAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\r\n        geometry.addAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\r\n    }\r\n    this.geometry = geometry;\r\n    this.material = (material !== undefined) ? material : new SpriteMaterial();\r\n    this.center = new Vector2(0.5, 0.5);\r\n}\r\nSprite.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Sprite,\r\n    isSprite: true,\r\n    raycast: (function () {\r\n        var intersectPoint = new Vector3();\r\n        var worldScale = new Vector3();\r\n        var mvPosition = new Vector3();\r\n        var alignedPosition = new Vector2();\r\n        var rotatedPosition = new Vector2();\r\n        var viewWorldMatrix = new Matrix4();\r\n        var vA = new Vector3();\r\n        var vB = new Vector3();\r\n        var vC = new Vector3();\r\n        var uvA = new Vector2();\r\n        var uvB = new Vector2();\r\n        var uvC = new Vector2();\r\n        function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\r\n            // compute position in camera space\r\n            alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);\r\n            // to check if rotation is not zero\r\n            if (sin !== undefined) {\r\n                rotatedPosition.x = (cos * alignedPosition.x) - (sin * alignedPosition.y);\r\n                rotatedPosition.y = (sin * alignedPosition.x) + (cos * alignedPosition.y);\r\n            }\r\n            else {\r\n                rotatedPosition.copy(alignedPosition);\r\n            }\r\n            vertexPosition.copy(mvPosition);\r\n            vertexPosition.x += rotatedPosition.x;\r\n            vertexPosition.y += rotatedPosition.y;\r\n            // transform to world space\r\n            vertexPosition.applyMatrix4(viewWorldMatrix);\r\n        }\r\n        return function raycast(raycaster, intersects) {\r\n            worldScale.setFromMatrixScale(this.matrixWorld);\r\n            viewWorldMatrix.copy(raycaster._camera.matrixWorld);\r\n            this.modelViewMatrix.multiplyMatrices(raycaster._camera.matrixWorldInverse, this.matrixWorld);\r\n            mvPosition.setFromMatrixPosition(this.modelViewMatrix);\r\n            if (raycaster._camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\r\n                worldScale.multiplyScalar(-mvPosition.z);\r\n            }\r\n            var rotation = this.material.rotation;\r\n            var sin, cos;\r\n            if (rotation !== 0) {\r\n                cos = Math.cos(rotation);\r\n                sin = Math.sin(rotation);\r\n            }\r\n            var center = this.center;\r\n            transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);\r\n            transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);\r\n            transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);\r\n            uvA.set(0, 0);\r\n            uvB.set(1, 0);\r\n            uvC.set(1, 1);\r\n            // check first triangle\r\n            var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);\r\n            if (intersect === null) {\r\n                // check second triangle\r\n                transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);\r\n                uvB.set(0, 1);\r\n                intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);\r\n                if (intersect === null) {\r\n                    return;\r\n                }\r\n            }\r\n            var distance = raycaster.ray.origin.distanceTo(intersectPoint);\r\n            if (distance < raycaster.near || distance > raycaster.far)\r\n                return;\r\n            intersects.push({\r\n                distance: distance,\r\n                point: intersectPoint.clone(),\r\n                uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),\r\n                face: null,\r\n                object: this\r\n            });\r\n        };\r\n    }()),\r\n    clone: function () {\r\n        return new this.constructor(this.material).copy(this);\r\n    },\r\n    copy: function (source) {\r\n        Object3D.prototype.copy.call(this, source);\r\n        if (source.center !== undefined)\r\n            this.center.copy(source.center);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction LOD() {\r\n    Object3D.call(this);\r\n    this.type = 'LOD';\r\n    Object.defineProperties(this, {\r\n        levels: {\r\n            enumerable: true,\r\n            value: []\r\n        }\r\n    });\r\n    this.autoUpdate = true;\r\n}\r\nLOD.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: LOD,\r\n    isLOD: true,\r\n    copy: function (source) {\r\n        Object3D.prototype.copy.call(this, source, false);\r\n        var levels = source.levels;\r\n        for (var i = 0, l = levels.length; i < l; i++) {\r\n            var level = levels[i];\r\n            this.addLevel(level.object.clone(), level.distance);\r\n        }\r\n        return this;\r\n    },\r\n    addLevel: function (object, distance) {\r\n        if (distance === undefined)\r\n            distance = 0;\r\n        distance = Math.abs(distance);\r\n        var levels = this.levels;\r\n        for (var l = 0; l < levels.length; l++) {\r\n            if (distance < levels[l].distance) {\r\n                break;\r\n            }\r\n        }\r\n        levels.splice(l, 0, { distance: distance, object: object });\r\n        this.add(object);\r\n        return this;\r\n    },\r\n    getObjectForDistance: function (distance) {\r\n        var levels = this.levels;\r\n        for (var i = 1, l = levels.length; i < l; i++) {\r\n            if (distance < levels[i].distance) {\r\n                break;\r\n            }\r\n        }\r\n        return levels[i - 1].object;\r\n    },\r\n    raycast: (function () {\r\n        var matrixPosition = new Vector3();\r\n        return function raycast(raycaster, intersects) {\r\n            matrixPosition.setFromMatrixPosition(this.matrixWorld);\r\n            var distance = raycaster.ray.origin.distanceTo(matrixPosition);\r\n            this.getObjectForDistance(distance).raycast(raycaster, intersects);\r\n        };\r\n    }()),\r\n    update: function () {\r\n        var v1 = new Vector3();\r\n        var v2 = new Vector3();\r\n        return function update(camera) {\r\n            var levels = this.levels;\r\n            if (levels.length > 1) {\r\n                v1.setFromMatrixPosition(camera.matrixWorld);\r\n                v2.setFromMatrixPosition(this.matrixWorld);\r\n                var distance = v1.distanceTo(v2);\r\n                levels[0].object.visible = true;\r\n                for (var i = 1, l = levels.length; i < l; i++) {\r\n                    if (distance >= levels[i].distance) {\r\n                        levels[i - 1].object.visible = false;\r\n                        levels[i].object.visible = true;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                for (; i < l; i++) {\r\n                    levels[i].object.visible = false;\r\n                }\r\n            }\r\n        };\r\n    }(),\r\n    toJSON: function (meta) {\r\n        var data = Object3D.prototype.toJSON.call(this, meta);\r\n        data.object.levels = [];\r\n        var levels = this.levels;\r\n        for (var i = 0, l = levels.length; i < l; i++) {\r\n            var level = levels[i];\r\n            data.object.levels.push({\r\n                object: level.object.uuid,\r\n                distance: level.distance\r\n            });\r\n        }\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\nfunction SkinnedMesh(geometry, material) {\r\n    if (geometry && geometry.isGeometry) {\r\n        console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\r\n    }\r\n    Mesh.call(this, geometry, material);\r\n    this.type = 'SkinnedMesh';\r\n    this.bindMode = 'attached';\r\n    this.bindMatrix = new Matrix4();\r\n    this.bindMatrixInverse = new Matrix4();\r\n}\r\nSkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\r\n    constructor: SkinnedMesh,\r\n    isSkinnedMesh: true,\r\n    bind: function (skeleton, bindMatrix) {\r\n        this.skeleton = skeleton;\r\n        if (bindMatrix === undefined) {\r\n            this.updateMatrixWorld(true);\r\n            this.skeleton.calculateInverses();\r\n            bindMatrix = this.matrixWorld;\r\n        }\r\n        this.bindMatrix.copy(bindMatrix);\r\n        this.bindMatrixInverse.getInverse(bindMatrix);\r\n    },\r\n    pose: function () {\r\n        this.skeleton.pose();\r\n    },\r\n    normalizeSkinWeights: function () {\r\n        var vector = new Vector4();\r\n        var skinWeight = this.geometry.attributes.skinWeight;\r\n        for (var i = 0, l = skinWeight.count; i < l; i++) {\r\n            vector.x = skinWeight.getX(i);\r\n            vector.y = skinWeight.getY(i);\r\n            vector.z = skinWeight.getZ(i);\r\n            vector.w = skinWeight.getW(i);\r\n            var scale = 1.0 / vector.manhattanLength();\r\n            if (scale !== Infinity) {\r\n                vector.multiplyScalar(scale);\r\n            }\r\n            else {\r\n                vector.set(1, 0, 0, 0); // do something reasonable\r\n            }\r\n            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\r\n        }\r\n    },\r\n    updateMatrixWorld: function (force) {\r\n        Mesh.prototype.updateMatrixWorld.call(this, force);\r\n        if (this.bindMode === 'attached') {\r\n            this.bindMatrixInverse.getInverse(this.matrixWorld);\r\n        }\r\n        else if (this.bindMode === 'detached') {\r\n            this.bindMatrixInverse.getInverse(this.bindMatrix);\r\n        }\r\n        else {\r\n            console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\r\n        }\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.geometry, this.material).copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\nfunction Skeleton(bones, boneInverses) {\r\n    // copy the bone array\r\n    bones = bones || [];\r\n    this.bones = bones.slice(0);\r\n    this.boneMatrices = new Float32Array(this.bones.length * 16);\r\n    // use the supplied bone inverses or calculate the inverses\r\n    if (boneInverses === undefined) {\r\n        this.calculateInverses();\r\n    }\r\n    else {\r\n        if (this.bones.length === boneInverses.length) {\r\n            this.boneInverses = boneInverses.slice(0);\r\n        }\r\n        else {\r\n            console.warn('THREE.Skeleton boneInverses is the wrong length.');\r\n            this.boneInverses = [];\r\n            for (var i = 0, il = this.bones.length; i < il; i++) {\r\n                this.boneInverses.push(new Matrix4());\r\n            }\r\n        }\r\n    }\r\n}\r\nObject.assign(Skeleton.prototype, {\r\n    calculateInverses: function () {\r\n        this.boneInverses = [];\r\n        for (var i = 0, il = this.bones.length; i < il; i++) {\r\n            var inverse = new Matrix4();\r\n            if (this.bones[i]) {\r\n                inverse.getInverse(this.bones[i].matrixWorld);\r\n            }\r\n            this.boneInverses.push(inverse);\r\n        }\r\n    },\r\n    pose: function () {\r\n        var bone, i, il;\r\n        // recover the bind-time world matrices\r\n        for (i = 0, il = this.bones.length; i < il; i++) {\r\n            bone = this.bones[i];\r\n            if (bone) {\r\n                bone.matrixWorld.getInverse(this.boneInverses[i]);\r\n            }\r\n        }\r\n        // compute the local matrices, positions, rotations and scales\r\n        for (i = 0, il = this.bones.length; i < il; i++) {\r\n            bone = this.bones[i];\r\n            if (bone) {\r\n                if (bone.parent && bone.parent.isBone) {\r\n                    bone.matrix.getInverse(bone.parent.matrixWorld);\r\n                    bone.matrix.multiply(bone.matrixWorld);\r\n                }\r\n                else {\r\n                    bone.matrix.copy(bone.matrixWorld);\r\n                }\r\n                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n            }\r\n        }\r\n    },\r\n    update: (function () {\r\n        var offsetMatrix = new Matrix4();\r\n        var identityMatrix = new Matrix4();\r\n        return function update() {\r\n            var bones = this.bones;\r\n            var boneInverses = this.boneInverses;\r\n            var boneMatrices = this.boneMatrices;\r\n            var boneTexture = this.boneTexture;\r\n            // flatten bone matrices to array\r\n            for (var i = 0, il = bones.length; i < il; i++) {\r\n                // compute the offset between the current and the original transform\r\n                var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;\r\n                offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\r\n                offsetMatrix.toArray(boneMatrices, i * 16);\r\n            }\r\n            if (boneTexture !== undefined) {\r\n                boneTexture.needsUpdate = true;\r\n            }\r\n        };\r\n    })(),\r\n    clone: function () {\r\n        return new Skeleton(this.bones, this.boneInverses);\r\n    },\r\n    getBoneByName: function (name) {\r\n        for (var i = 0, il = this.bones.length; i < il; i++) {\r\n            var bone = this.bones[i];\r\n            if (bone.name === name) {\r\n                return bone;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n});\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\nfunction Bone() {\r\n    Object3D.call(this);\r\n    this.type = 'Bone';\r\n}\r\nBone.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Bone,\r\n    isBone: true\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\"\r\n * }\r\n */\r\nfunction LineBasicMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'LineBasicMaterial';\r\n    this.color = new Color(0xffffff);\r\n    this.linewidth = 1;\r\n    this.linecap = 'round';\r\n    this.linejoin = 'round';\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nLineBasicMaterial.prototype = Object.create(Material$1.prototype);\r\nLineBasicMaterial.prototype.constructor = LineBasicMaterial;\r\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\r\nLineBasicMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.linewidth = source.linewidth;\r\n    this.linecap = source.linecap;\r\n    this.linejoin = source.linejoin;\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Line(geometry, material, mode) {\r\n    if (mode === 1) {\r\n        console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');\r\n    }\r\n    Object3D.call(this);\r\n    this.type = 'Line';\r\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n    this.material = material !== undefined ? material : new LineBasicMaterial({ color: Math.random() * 0xffffff });\r\n}\r\nLine.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Line,\r\n    isLine: true,\r\n    computeLineDistances: (function () {\r\n        var start = new Vector3();\r\n        var end = new Vector3();\r\n        return function computeLineDistances() {\r\n            var geometry = this.geometry;\r\n            if (geometry.isBufferGeometry) {\r\n                // we assume non-indexed geometry\r\n                if (geometry.index === null) {\r\n                    var positionAttribute = geometry.attributes.position;\r\n                    var lineDistances = [0];\r\n                    for (var i = 1, l = positionAttribute.count; i < l; i++) {\r\n                        start.fromBufferAttribute(positionAttribute, i - 1);\r\n                        end.fromBufferAttribute(positionAttribute, i);\r\n                        lineDistances[i] = lineDistances[i - 1];\r\n                        lineDistances[i] += start.distanceTo(end);\r\n                    }\r\n                    geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\r\n                }\r\n                else {\r\n                    console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\r\n                }\r\n            }\r\n            else if (geometry.isGeometry) {\r\n                var vertices = geometry.vertices;\r\n                var lineDistances = geometry.lineDistances;\r\n                lineDistances[0] = 0;\r\n                for (var i = 1, l = vertices.length; i < l; i++) {\r\n                    lineDistances[i] = lineDistances[i - 1];\r\n                    lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n    }()),\r\n    raycast: (function () {\r\n        var inverseMatrix = new Matrix4();\r\n        var ray = new Ray();\r\n        var sphere = new Sphere();\r\n        return function raycast(raycaster, intersects) {\r\n            var precision = raycaster.linePrecision;\r\n            var geometry = this.geometry;\r\n            var matrixWorld = this.matrixWorld;\r\n            // Checking boundingSphere distance to ray\r\n            if (geometry.boundingSphere === null)\r\n                geometry.computeBoundingSphere();\r\n            sphere.copy(geometry.boundingSphere);\r\n            sphere.applyMatrix4(matrixWorld);\r\n            sphere.radius += precision;\r\n            if (raycaster.ray.intersectsSphere(sphere) === false)\r\n                return;\r\n            //\r\n            inverseMatrix.getInverse(matrixWorld);\r\n            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\r\n            var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);\r\n            var localPrecisionSq = localPrecision * localPrecision;\r\n            var vStart = new Vector3();\r\n            var vEnd = new Vector3();\r\n            var interSegment = new Vector3();\r\n            var interRay = new Vector3();\r\n            var step = (this && this.isLineSegments) ? 2 : 1;\r\n            if (geometry.isBufferGeometry) {\r\n                var index = geometry.index;\r\n                var attributes = geometry.attributes;\r\n                var positions = attributes.position.array;\r\n                if (index !== null) {\r\n                    var indices = index.array;\r\n                    for (var i = 0, l = indices.length - 1; i < l; i += step) {\r\n                        var a = indices[i];\r\n                        var b = indices[i + 1];\r\n                        vStart.fromArray(positions, a * 3);\r\n                        vEnd.fromArray(positions, b * 3);\r\n                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\r\n                        if (distSq > localPrecisionSq)\r\n                            continue;\r\n                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\r\n                        var distance = raycaster.ray.origin.distanceTo(interRay);\r\n                        if (distance < raycaster.near || distance > raycaster.far)\r\n                            continue;\r\n                        intersects.push({\r\n                            distance: distance,\r\n                            // What do we want? intersection point on the ray or on the segment??\r\n                            // point: raycaster.ray.at( distance ),\r\n                            point: interSegment.clone().applyMatrix4(this.matrixWorld),\r\n                            index: i,\r\n                            face: null,\r\n                            faceIndex: null,\r\n                            object: this\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {\r\n                        vStart.fromArray(positions, 3 * i);\r\n                        vEnd.fromArray(positions, 3 * i + 3);\r\n                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\r\n                        if (distSq > localPrecisionSq)\r\n                            continue;\r\n                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\r\n                        var distance = raycaster.ray.origin.distanceTo(interRay);\r\n                        if (distance < raycaster.near || distance > raycaster.far)\r\n                            continue;\r\n                        intersects.push({\r\n                            distance: distance,\r\n                            // What do we want? intersection point on the ray or on the segment??\r\n                            // point: raycaster.ray.at( distance ),\r\n                            point: interSegment.clone().applyMatrix4(this.matrixWorld),\r\n                            index: i,\r\n                            face: null,\r\n                            faceIndex: null,\r\n                            object: this\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else if (geometry.isGeometry) {\r\n                var vertices = geometry.vertices;\r\n                var nbVertices = vertices.length;\r\n                for (var i = 0; i < nbVertices - 1; i += step) {\r\n                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);\r\n                    if (distSq > localPrecisionSq)\r\n                        continue;\r\n                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\r\n                    var distance = raycaster.ray.origin.distanceTo(interRay);\r\n                    if (distance < raycaster.near || distance > raycaster.far)\r\n                        continue;\r\n                    intersects.push({\r\n                        distance: distance,\r\n                        // What do we want? intersection point on the ray or on the segment??\r\n                        // point: raycaster.ray.at( distance ),\r\n                        point: interSegment.clone().applyMatrix4(this.matrixWorld),\r\n                        index: i,\r\n                        face: null,\r\n                        faceIndex: null,\r\n                        object: this\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }()),\r\n    clone: function () {\r\n        return new this.constructor(this.geometry, this.material).copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction LineSegments(geometry, material) {\r\n    Line.call(this, geometry, material);\r\n    this.type = 'LineSegments';\r\n}\r\nLineSegments.prototype = Object.assign(Object.create(Line.prototype), {\r\n    constructor: LineSegments,\r\n    isLineSegments: true,\r\n    computeLineDistances: (function () {\r\n        var start = new Vector3();\r\n        var end = new Vector3();\r\n        return function computeLineDistances() {\r\n            var geometry = this.geometry;\r\n            if (geometry.isBufferGeometry) {\r\n                // we assume non-indexed geometry\r\n                if (geometry.index === null) {\r\n                    var positionAttribute = geometry.attributes.position;\r\n                    var lineDistances = [];\r\n                    for (var i = 0, l = positionAttribute.count; i < l; i += 2) {\r\n                        start.fromBufferAttribute(positionAttribute, i);\r\n                        end.fromBufferAttribute(positionAttribute, i + 1);\r\n                        lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];\r\n                        lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);\r\n                    }\r\n                    geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\r\n                }\r\n                else {\r\n                    console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\r\n                }\r\n            }\r\n            else if (geometry.isGeometry) {\r\n                var vertices = geometry.vertices;\r\n                var lineDistances = geometry.lineDistances;\r\n                for (var i = 0, l = vertices.length; i < l; i += 2) {\r\n                    start.copy(vertices[i]);\r\n                    end.copy(vertices[i + 1]);\r\n                    lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];\r\n                    lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n    }())\r\n});\r\n/**\r\n * @author mgreter / http://github.com/mgreter\r\n */\r\nfunction LineLoop(geometry, material) {\r\n    Line.call(this, geometry, material);\r\n    this.type = 'LineLoop';\r\n}\r\nLineLoop.prototype = Object.assign(Object.create(Line.prototype), {\r\n    constructor: LineLoop,\r\n    isLineLoop: true,\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>\r\n *\r\n *  morphTargets: <bool>\r\n * }\r\n */\r\nfunction PointsMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'PointsMaterial';\r\n    this.color = new Color(0xffffff);\r\n    this.map = null;\r\n    this.size = 1;\r\n    this.sizeAttenuation = true;\r\n    this.morphTargets = false;\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nPointsMaterial.prototype = Object.create(Material$1.prototype);\r\nPointsMaterial.prototype.constructor = PointsMaterial;\r\nPointsMaterial.prototype.isPointsMaterial = true;\r\nPointsMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.map = source.map;\r\n    this.size = source.size;\r\n    this.sizeAttenuation = source.sizeAttenuation;\r\n    this.morphTargets = source.morphTargets;\r\n    return this;\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Points(geometry, material) {\r\n    Object3D.call(this);\r\n    this.type = 'Points';\r\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n    this.material = material !== undefined ? material : new PointsMaterial({ color: Math.random() * 0xffffff });\r\n    this.updateMorphTargets();\r\n}\r\nPoints.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Points,\r\n    isPoints: true,\r\n    raycast: (function () {\r\n        var inverseMatrix = new Matrix4();\r\n        var ray = new Ray();\r\n        var sphere = new Sphere();\r\n        return function raycast(raycaster, intersects) {\r\n            var object = this;\r\n            var geometry = this.geometry;\r\n            var matrixWorld = this.matrixWorld;\r\n            var threshold = raycaster.params.Points.threshold;\r\n            // Checking boundingSphere distance to ray\r\n            if (geometry.boundingSphere === null)\r\n                geometry.computeBoundingSphere();\r\n            sphere.copy(geometry.boundingSphere);\r\n            sphere.applyMatrix4(matrixWorld);\r\n            sphere.radius += threshold;\r\n            if (raycaster.ray.intersectsSphere(sphere) === false)\r\n                return;\r\n            //\r\n            inverseMatrix.getInverse(matrixWorld);\r\n            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\r\n            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\r\n            var localThresholdSq = localThreshold * localThreshold;\r\n            var position = new Vector3();\r\n            var intersectPoint = new Vector3();\r\n            function testPoint(point, index) {\r\n                var rayPointDistanceSq = ray.distanceSqToPoint(point);\r\n                if (rayPointDistanceSq < localThresholdSq) {\r\n                    ray.closestPointToPoint(point, intersectPoint);\r\n                    intersectPoint.applyMatrix4(matrixWorld);\r\n                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);\r\n                    if (distance < raycaster.near || distance > raycaster.far)\r\n                        return;\r\n                    intersects.push({\r\n                        distance: distance,\r\n                        distanceToRay: Math.sqrt(rayPointDistanceSq),\r\n                        point: intersectPoint.clone(),\r\n                        index: index,\r\n                        face: null,\r\n                        object: object\r\n                    });\r\n                }\r\n            }\r\n            if (geometry.isBufferGeometry) {\r\n                var index = geometry.index;\r\n                var attributes = geometry.attributes;\r\n                var positions = attributes.position.array;\r\n                if (index !== null) {\r\n                    var indices = index.array;\r\n                    for (var i = 0, il = indices.length; i < il; i++) {\r\n                        var a = indices[i];\r\n                        position.fromArray(positions, a * 3);\r\n                        testPoint(position, a);\r\n                    }\r\n                }\r\n                else {\r\n                    for (var i = 0, l = positions.length / 3; i < l; i++) {\r\n                        position.fromArray(positions, i * 3);\r\n                        testPoint(position, i);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var vertices = geometry.vertices;\r\n                for (var i = 0, l = vertices.length; i < l; i++) {\r\n                    testPoint(vertices[i], i);\r\n                }\r\n            }\r\n        };\r\n    }()),\r\n    updateMorphTargets: function () {\r\n        var geometry = this.geometry;\r\n        var m, ml, name;\r\n        if (geometry.isBufferGeometry) {\r\n            var morphAttributes = geometry.morphAttributes;\r\n            var keys = Object.keys(morphAttributes);\r\n            if (keys.length > 0) {\r\n                var morphAttribute = morphAttributes[keys[0]];\r\n                if (morphAttribute !== undefined) {\r\n                    this.morphTargetInfluences = [];\r\n                    this.morphTargetDictionary = {};\r\n                    for (m = 0, ml = morphAttribute.length; m < ml; m++) {\r\n                        name = morphAttribute[m].name || String(m);\r\n                        this.morphTargetInfluences.push(0);\r\n                        this.morphTargetDictionary[name] = m;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var morphTargets = geometry.morphTargets;\r\n            if (morphTargets !== undefined && morphTargets.length > 0) {\r\n                console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\r\n            }\r\n        }\r\n    },\r\n    clone: function () {\r\n        return new this.constructor(this.geometry, this.material).copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\r\n    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\r\n    this.format = format !== undefined ? format : RGBFormat;\r\n    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\r\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\r\n    this.generateMipmaps = false;\r\n}\r\nVideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {\r\n    constructor: VideoTexture,\r\n    isVideoTexture: true,\r\n    update: function () {\r\n        var video = this.image;\r\n        if (video.readyState >= video.HAVE_CURRENT_DATA) {\r\n            this.needsUpdate = true;\r\n        }\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\r\n    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\r\n    this.image = { width: width, height: height };\r\n    this.mipmaps = mipmaps;\r\n    // no flipping for cube textures\r\n    // (also flipping doesn't work for compressed textures )\r\n    this.flipY = false;\r\n    // can't generate mipmaps for compressed textures\r\n    // mips must be embedded in DDS files\r\n    this.generateMipmaps = false;\r\n}\r\nCompressedTexture.prototype = Object.create(Texture.prototype);\r\nCompressedTexture.prototype.constructor = CompressedTexture;\r\nCompressedTexture.prototype.isCompressedTexture = true;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\r\n    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\r\n    this.needsUpdate = true;\r\n}\r\nCanvasTexture.prototype = Object.create(Texture.prototype);\r\nCanvasTexture.prototype.constructor = CanvasTexture;\r\nCanvasTexture.prototype.isCanvasTexture = true;\r\n/**\r\n * @author Matt DesLauriers / @mattdesl\r\n * @author atix / arthursilber.de\r\n */\r\nfunction DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\r\n    format = format !== undefined ? format : DepthFormat;\r\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\r\n        throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\r\n    }\r\n    if (type === undefined && format === DepthFormat)\r\n        type = UnsignedShortType;\r\n    if (type === undefined && format === DepthStencilFormat)\r\n        type = UnsignedInt248Type;\r\n    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\r\n    this.image = { width: width, height: height };\r\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\r\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\r\n    this.flipY = false;\r\n    this.generateMipmaps = false;\r\n}\r\nDepthTexture.prototype = Object.create(Texture.prototype);\r\nDepthTexture.prototype.constructor = DepthTexture;\r\nDepthTexture.prototype.isDepthTexture = true;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction WireframeGeometry(geometry) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'WireframeGeometry';\r\n    // buffer\r\n    var vertices = [];\r\n    // helper variables\r\n    var i, j, l, o, ol;\r\n    var edge = [0, 0], edges = {}, e, edge1, edge2;\r\n    var key, keys = ['a', 'b', 'c'];\r\n    var vertex;\r\n    // different logic for Geometry and BufferGeometry\r\n    if (geometry && geometry.isGeometry) {\r\n        // create a data structure that contains all edges without duplicates\r\n        var faces = geometry.faces;\r\n        for (i = 0, l = faces.length; i < l; i++) {\r\n            var face = faces[i];\r\n            for (j = 0; j < 3; j++) {\r\n                edge1 = face[keys[j]];\r\n                edge2 = face[keys[(j + 1) % 3]];\r\n                edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\r\n                edge[1] = Math.max(edge1, edge2);\r\n                key = edge[0] + ',' + edge[1];\r\n                if (edges[key] === undefined) {\r\n                    edges[key] = { index1: edge[0], index2: edge[1] };\r\n                }\r\n            }\r\n        }\r\n        // generate vertices\r\n        for (key in edges) {\r\n            e = edges[key];\r\n            vertex = geometry.vertices[e.index1];\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            vertex = geometry.vertices[e.index2];\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n        }\r\n    }\r\n    else if (geometry && geometry.isBufferGeometry) {\r\n        var position, indices, groups;\r\n        var group, start, count;\r\n        var index1, index2;\r\n        vertex = new Vector3();\r\n        if (geometry.index !== null) {\r\n            // indexed BufferGeometry\r\n            position = geometry.attributes.position;\r\n            indices = geometry.index;\r\n            groups = geometry.groups;\r\n            if (groups.length === 0) {\r\n                groups = [{ start: 0, count: indices.count, materialIndex: 0 }];\r\n            }\r\n            // create a data structure that contains all eges without duplicates\r\n            for (o = 0, ol = groups.length; o < ol; ++o) {\r\n                group = groups[o];\r\n                start = group.start;\r\n                count = group.count;\r\n                for (i = start, l = (start + count); i < l; i += 3) {\r\n                    for (j = 0; j < 3; j++) {\r\n                        edge1 = indices.getX(i + j);\r\n                        edge2 = indices.getX(i + (j + 1) % 3);\r\n                        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\r\n                        edge[1] = Math.max(edge1, edge2);\r\n                        key = edge[0] + ',' + edge[1];\r\n                        if (edges[key] === undefined) {\r\n                            edges[key] = { index1: edge[0], index2: edge[1] };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // generate vertices\r\n            for (key in edges) {\r\n                e = edges[key];\r\n                vertex.fromBufferAttribute(position, e.index1);\r\n                vertices.push(vertex.x, vertex.y, vertex.z);\r\n                vertex.fromBufferAttribute(position, e.index2);\r\n                vertices.push(vertex.x, vertex.y, vertex.z);\r\n            }\r\n        }\r\n        else {\r\n            // non-indexed BufferGeometry\r\n            position = geometry.attributes.position;\r\n            for (i = 0, l = (position.count / 3); i < l; i++) {\r\n                for (j = 0; j < 3; j++) {\r\n                    // three edges per triangle, an edge is represented as (index1, index2)\r\n                    // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\r\n                    index1 = 3 * i + j;\r\n                    vertex.fromBufferAttribute(position, index1);\r\n                    vertices.push(vertex.x, vertex.y, vertex.z);\r\n                    index2 = 3 * i + ((j + 1) % 3);\r\n                    vertex.fromBufferAttribute(position, index2);\r\n                    vertices.push(vertex.x, vertex.y, vertex.z);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // build geometry\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n}\r\nWireframeGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nWireframeGeometry.prototype.constructor = WireframeGeometry;\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n */\r\n// ParametricGeometry\r\nfunction ParametricGeometry(func, slices, stacks) {\r\n    Geometry.call(this);\r\n    this.type = 'ParametricGeometry';\r\n    this.parameters = {\r\n        func: func,\r\n        slices: slices,\r\n        stacks: stacks\r\n    };\r\n    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));\r\n    this.mergeVertices();\r\n}\r\nParametricGeometry.prototype = Object.create(Geometry.prototype);\r\nParametricGeometry.prototype.constructor = ParametricGeometry;\r\n// ParametricBufferGeometry\r\nfunction ParametricBufferGeometry(func, slices, stacks) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'ParametricBufferGeometry';\r\n    this.parameters = {\r\n        func: func,\r\n        slices: slices,\r\n        stacks: stacks\r\n    };\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var EPS = 0.00001;\r\n    var normal = new Vector3();\r\n    var p0 = new Vector3(), p1 = new Vector3();\r\n    var pu = new Vector3(), pv = new Vector3();\r\n    var i, j;\r\n    if (func.length < 3) {\r\n        console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\r\n    }\r\n    // generate vertices, normals and uvs\r\n    var sliceCount = slices + 1;\r\n    for (i = 0; i <= stacks; i++) {\r\n        var v = i / stacks;\r\n        for (j = 0; j <= slices; j++) {\r\n            var u = j / slices;\r\n            // vertex\r\n            func(u, v, p0);\r\n            vertices.push(p0.x, p0.y, p0.z);\r\n            // normal\r\n            // approximate tangent vectors via finite differences\r\n            if (u - EPS >= 0) {\r\n                func(u - EPS, v, p1);\r\n                pu.subVectors(p0, p1);\r\n            }\r\n            else {\r\n                func(u + EPS, v, p1);\r\n                pu.subVectors(p1, p0);\r\n            }\r\n            if (v - EPS >= 0) {\r\n                func(u, v - EPS, p1);\r\n                pv.subVectors(p0, p1);\r\n            }\r\n            else {\r\n                func(u, v + EPS, p1);\r\n                pv.subVectors(p1, p0);\r\n            }\r\n            // cross product of tangent vectors returns surface normal\r\n            normal.crossVectors(pu, pv).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, v);\r\n        }\r\n    }\r\n    // generate indices\r\n    for (i = 0; i < stacks; i++) {\r\n        for (j = 0; j < slices; j++) {\r\n            var a = i * sliceCount + j;\r\n            var b = i * sliceCount + j + 1;\r\n            var c = (i + 1) * sliceCount + j + 1;\r\n            var d = (i + 1) * sliceCount + j;\r\n            // faces one and two\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// PolyhedronGeometry\r\nfunction PolyhedronGeometry(vertices, indices, radius, detail) {\r\n    Geometry.call(this);\r\n    this.type = 'PolyhedronGeometry';\r\n    this.parameters = {\r\n        vertices: vertices,\r\n        indices: indices,\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));\r\n    this.mergeVertices();\r\n}\r\nPolyhedronGeometry.prototype = Object.create(Geometry.prototype);\r\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\r\n// PolyhedronBufferGeometry\r\nfunction PolyhedronBufferGeometry(vertices, indices, radius, detail) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'PolyhedronBufferGeometry';\r\n    this.parameters = {\r\n        vertices: vertices,\r\n        indices: indices,\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    radius = radius || 1;\r\n    detail = detail || 0;\r\n    // default buffer data\r\n    var vertexBuffer = [];\r\n    var uvBuffer = [];\r\n    // the subdivision creates the vertex buffer data\r\n    subdivide(detail);\r\n    // all vertices should lie on a conceptual sphere with a given radius\r\n    applyRadius(radius);\r\n    // finally, create the uv data\r\n    generateUVs();\r\n    // build non-indexed geometry\r\n    this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\r\n    if (detail === 0) {\r\n        this.computeVertexNormals(); // flat normals\r\n    }\r\n    else {\r\n        this.normalizeNormals(); // smooth normals\r\n    }\r\n    // helper functions\r\n    function subdivide(detail) {\r\n        var a = new Vector3();\r\n        var b = new Vector3();\r\n        var c = new Vector3();\r\n        // iterate over all faces and apply a subdivison with the given detail value\r\n        for (var i = 0; i < indices.length; i += 3) {\r\n            // get the vertices of the face\r\n            getVertexByIndex(indices[i + 0], a);\r\n            getVertexByIndex(indices[i + 1], b);\r\n            getVertexByIndex(indices[i + 2], c);\r\n            // perform subdivision\r\n            subdivideFace(a, b, c, detail);\r\n        }\r\n    }\r\n    function subdivideFace(a, b, c, detail) {\r\n        var cols = Math.pow(2, detail);\r\n        // we use this multidimensional array as a data structure for creating the subdivision\r\n        var v = [];\r\n        var i, j;\r\n        // construct all of the vertices for this subdivision\r\n        for (i = 0; i <= cols; i++) {\r\n            v[i] = [];\r\n            var aj = a.clone().lerp(c, i / cols);\r\n            var bj = b.clone().lerp(c, i / cols);\r\n            var rows = cols - i;\r\n            for (j = 0; j <= rows; j++) {\r\n                if (j === 0 && i === cols) {\r\n                    v[i][j] = aj;\r\n                }\r\n                else {\r\n                    v[i][j] = aj.clone().lerp(bj, j / rows);\r\n                }\r\n            }\r\n        }\r\n        // construct all of the faces\r\n        for (i = 0; i < cols; i++) {\r\n            for (j = 0; j < 2 * (cols - i) - 1; j++) {\r\n                var k = Math.floor(j / 2);\r\n                if (j % 2 === 0) {\r\n                    pushVertex(v[i][k + 1]);\r\n                    pushVertex(v[i + 1][k]);\r\n                    pushVertex(v[i][k]);\r\n                }\r\n                else {\r\n                    pushVertex(v[i][k + 1]);\r\n                    pushVertex(v[i + 1][k + 1]);\r\n                    pushVertex(v[i + 1][k]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function applyRadius(radius) {\r\n        var vertex = new Vector3();\r\n        // iterate over the entire buffer and apply the radius to each vertex\r\n        for (var i = 0; i < vertexBuffer.length; i += 3) {\r\n            vertex.x = vertexBuffer[i + 0];\r\n            vertex.y = vertexBuffer[i + 1];\r\n            vertex.z = vertexBuffer[i + 2];\r\n            vertex.normalize().multiplyScalar(radius);\r\n            vertexBuffer[i + 0] = vertex.x;\r\n            vertexBuffer[i + 1] = vertex.y;\r\n            vertexBuffer[i + 2] = vertex.z;\r\n        }\r\n    }\r\n    function generateUVs() {\r\n        var vertex = new Vector3();\r\n        for (var i = 0; i < vertexBuffer.length; i += 3) {\r\n            vertex.x = vertexBuffer[i + 0];\r\n            vertex.y = vertexBuffer[i + 1];\r\n            vertex.z = vertexBuffer[i + 2];\r\n            var u = azimuth(vertex) / 2 / Math.PI + 0.5;\r\n            var v = inclination(vertex) / Math.PI + 0.5;\r\n            uvBuffer.push(u, 1 - v);\r\n        }\r\n        correctUVs();\r\n        correctSeam();\r\n    }\r\n    function correctSeam() {\r\n        // handle case when face straddles the seam, see #3269\r\n        for (var i = 0; i < uvBuffer.length; i += 6) {\r\n            // uv data of a single face\r\n            var x0 = uvBuffer[i + 0];\r\n            var x1 = uvBuffer[i + 2];\r\n            var x2 = uvBuffer[i + 4];\r\n            var max = Math.max(x0, x1, x2);\r\n            var min = Math.min(x0, x1, x2);\r\n            // 0.9 is somewhat arbitrary\r\n            if (max > 0.9 && min < 0.1) {\r\n                if (x0 < 0.2)\r\n                    uvBuffer[i + 0] += 1;\r\n                if (x1 < 0.2)\r\n                    uvBuffer[i + 2] += 1;\r\n                if (x2 < 0.2)\r\n                    uvBuffer[i + 4] += 1;\r\n            }\r\n        }\r\n    }\r\n    function pushVertex(vertex) {\r\n        vertexBuffer.push(vertex.x, vertex.y, vertex.z);\r\n    }\r\n    function getVertexByIndex(index, vertex) {\r\n        var stride = index * 3;\r\n        vertex.x = vertices[stride + 0];\r\n        vertex.y = vertices[stride + 1];\r\n        vertex.z = vertices[stride + 2];\r\n    }\r\n    function correctUVs() {\r\n        var a = new Vector3();\r\n        var b = new Vector3();\r\n        var c = new Vector3();\r\n        var centroid = new Vector3();\r\n        var uvA = new Vector2();\r\n        var uvB = new Vector2();\r\n        var uvC = new Vector2();\r\n        for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\r\n            a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\r\n            b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\r\n            c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\r\n            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\r\n            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\r\n            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\r\n            centroid.copy(a).add(b).add(c).divideScalar(3);\r\n            var azi = azimuth(centroid);\r\n            correctUV(uvA, j + 0, a, azi);\r\n            correctUV(uvB, j + 2, b, azi);\r\n            correctUV(uvC, j + 4, c, azi);\r\n        }\r\n    }\r\n    function correctUV(uv, stride, vector, azimuth) {\r\n        if ((azimuth < 0) && (uv.x === 1)) {\r\n            uvBuffer[stride] = uv.x - 1;\r\n        }\r\n        if ((vector.x === 0) && (vector.z === 0)) {\r\n            uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\r\n        }\r\n    }\r\n    // Angle around the Y axis, counter-clockwise when looking from above.\r\n    function azimuth(vector) {\r\n        return Math.atan2(vector.z, -vector.x);\r\n    }\r\n    // Angle above the XZ plane.\r\n    function inclination(vector) {\r\n        return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));\r\n    }\r\n}\r\nPolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// TetrahedronGeometry\r\nfunction TetrahedronGeometry(radius, detail) {\r\n    Geometry.call(this);\r\n    this.type = 'TetrahedronGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));\r\n    this.mergeVertices();\r\n}\r\nTetrahedronGeometry.prototype = Object.create(Geometry.prototype);\r\nTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\r\n// TetrahedronBufferGeometry\r\nfunction TetrahedronBufferGeometry(radius, detail) {\r\n    var vertices = [\r\n        1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1\r\n    ];\r\n    var indices = [\r\n        2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1\r\n    ];\r\n    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);\r\n    this.type = 'TetrahedronBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n}\r\nTetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);\r\nTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// OctahedronGeometry\r\nfunction OctahedronGeometry(radius, detail) {\r\n    Geometry.call(this);\r\n    this.type = 'OctahedronGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));\r\n    this.mergeVertices();\r\n}\r\nOctahedronGeometry.prototype = Object.create(Geometry.prototype);\r\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\r\n// OctahedronBufferGeometry\r\nfunction OctahedronBufferGeometry(radius, detail) {\r\n    var vertices = [\r\n        1, 0, 0, -1, 0, 0, 0, 1, 0,\r\n        0, -1, 0, 0, 0, 1, 0, 0, -1\r\n    ];\r\n    var indices = [\r\n        0, 2, 4, 0, 4, 3, 0, 3, 5,\r\n        0, 5, 2, 1, 2, 5, 1, 5, 3,\r\n        1, 3, 4, 1, 4, 2\r\n    ];\r\n    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);\r\n    this.type = 'OctahedronBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n}\r\nOctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);\r\nOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// IcosahedronGeometry\r\nfunction IcosahedronGeometry(radius, detail) {\r\n    Geometry.call(this);\r\n    this.type = 'IcosahedronGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));\r\n    this.mergeVertices();\r\n}\r\nIcosahedronGeometry.prototype = Object.create(Geometry.prototype);\r\nIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\r\n// IcosahedronBufferGeometry\r\nfunction IcosahedronBufferGeometry(radius, detail) {\r\n    var t = (1 + Math.sqrt(5)) / 2;\r\n    var vertices = [\r\n        -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,\r\n        0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,\r\n        t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1\r\n    ];\r\n    var indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,\r\n        1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,\r\n        3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,\r\n        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1\r\n    ];\r\n    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);\r\n    this.type = 'IcosahedronBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n}\r\nIcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);\r\nIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// DodecahedronGeometry\r\nfunction DodecahedronGeometry(radius, detail) {\r\n    Geometry.call(this);\r\n    this.type = 'DodecahedronGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));\r\n    this.mergeVertices();\r\n}\r\nDodecahedronGeometry.prototype = Object.create(Geometry.prototype);\r\nDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\r\n// DodecahedronBufferGeometry\r\nfunction DodecahedronBufferGeometry(radius, detail) {\r\n    var t = (1 + Math.sqrt(5)) / 2;\r\n    var r = 1 / t;\r\n    var vertices = [\r\n        // (±1, ±1, ±1)\r\n        -1, -1, -1, -1, -1, 1,\r\n        -1, 1, -1, -1, 1, 1,\r\n        1, -1, -1, 1, -1, 1,\r\n        1, 1, -1, 1, 1, 1,\r\n        // (0, ±1/φ, ±φ)\r\n        0, -r, -t, 0, -r, t,\r\n        0, r, -t, 0, r, t,\r\n        // (±1/φ, ±φ, 0)\r\n        -r, -t, 0, -r, t, 0,\r\n        r, -t, 0, r, t, 0,\r\n        // (±φ, 0, ±1/φ)\r\n        -t, 0, -r, t, 0, -r,\r\n        -t, 0, r, t, 0, r\r\n    ];\r\n    var indices = [\r\n        3, 11, 7, 3, 7, 15, 3, 15, 13,\r\n        7, 19, 17, 7, 17, 6, 7, 6, 15,\r\n        17, 4, 8, 17, 8, 10, 17, 10, 6,\r\n        8, 0, 16, 8, 16, 2, 8, 2, 10,\r\n        0, 12, 1, 0, 1, 18, 0, 18, 16,\r\n        6, 10, 2, 6, 2, 13, 6, 13, 15,\r\n        2, 16, 18, 2, 18, 3, 2, 3, 13,\r\n        18, 1, 9, 18, 9, 11, 18, 11, 3,\r\n        4, 14, 12, 4, 12, 0, 4, 0, 8,\r\n        11, 9, 5, 11, 5, 19, 11, 19, 7,\r\n        19, 5, 14, 19, 14, 4, 19, 4, 17,\r\n        1, 12, 14, 1, 14, 5, 1, 5, 9\r\n    ];\r\n    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);\r\n    this.type = 'DodecahedronBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        detail: detail\r\n    };\r\n}\r\nDodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);\r\nDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\r\n/**\r\n * @author oosmoxiecode / https://github.com/oosmoxiecode\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n */\r\n// TubeGeometry\r\nfunction TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {\r\n    Geometry.call(this);\r\n    this.type = 'TubeGeometry';\r\n    this.parameters = {\r\n        path: path,\r\n        tubularSegments: tubularSegments,\r\n        radius: radius,\r\n        radialSegments: radialSegments,\r\n        closed: closed\r\n    };\r\n    if (taper !== undefined)\r\n        console.warn('THREE.TubeGeometry: taper has been removed.');\r\n    var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);\r\n    // expose internals\r\n    this.tangents = bufferGeometry.tangents;\r\n    this.normals = bufferGeometry.normals;\r\n    this.binormals = bufferGeometry.binormals;\r\n    // create geometry\r\n    this.fromBufferGeometry(bufferGeometry);\r\n    this.mergeVertices();\r\n}\r\nTubeGeometry.prototype = Object.create(Geometry.prototype);\r\nTubeGeometry.prototype.constructor = TubeGeometry;\r\n// TubeBufferGeometry\r\nfunction TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'TubeBufferGeometry';\r\n    this.parameters = {\r\n        path: path,\r\n        tubularSegments: tubularSegments,\r\n        radius: radius,\r\n        radialSegments: radialSegments,\r\n        closed: closed\r\n    };\r\n    tubularSegments = tubularSegments || 64;\r\n    radius = radius || 1;\r\n    radialSegments = radialSegments || 8;\r\n    closed = closed || false;\r\n    var frames = path.computeFrenetFrames(tubularSegments, closed);\r\n    // expose internals\r\n    this.tangents = frames.tangents;\r\n    this.normals = frames.normals;\r\n    this.binormals = frames.binormals;\r\n    // helper variables\r\n    var vertex = new Vector3();\r\n    var normal = new Vector3();\r\n    var uv = new Vector2();\r\n    var P = new Vector3();\r\n    var i, j;\r\n    // buffer\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var indices = [];\r\n    // create buffer data\r\n    generateBufferData();\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    // functions\r\n    function generateBufferData() {\r\n        for (i = 0; i < tubularSegments; i++) {\r\n            generateSegment(i);\r\n        }\r\n        // if the geometry is not closed, generate the last row of vertices and normals\r\n        // at the regular position on the given path\r\n        //\r\n        // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\r\n        generateSegment((closed === false) ? tubularSegments : 0);\r\n        // uvs are generated in a separate function.\r\n        // this makes it easy compute correct values for closed geometries\r\n        generateUVs();\r\n        // finally create faces\r\n        generateIndices();\r\n    }\r\n    function generateSegment(i) {\r\n        // we use getPointAt to sample evenly distributed points from the given path\r\n        P = path.getPointAt(i / tubularSegments, P);\r\n        // retrieve corresponding normal and binormal\r\n        var N = frames.normals[i];\r\n        var B = frames.binormals[i];\r\n        // generate normals and vertices for the current segment\r\n        for (j = 0; j <= radialSegments; j++) {\r\n            var v = j / radialSegments * Math.PI * 2;\r\n            var sin = Math.sin(v);\r\n            var cos = -Math.cos(v);\r\n            // normal\r\n            normal.x = (cos * N.x + sin * B.x);\r\n            normal.y = (cos * N.y + sin * B.y);\r\n            normal.z = (cos * N.z + sin * B.z);\r\n            normal.normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // vertex\r\n            vertex.x = P.x + radius * normal.x;\r\n            vertex.y = P.y + radius * normal.y;\r\n            vertex.z = P.z + radius * normal.z;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n        }\r\n    }\r\n    function generateIndices() {\r\n        for (j = 1; j <= tubularSegments; j++) {\r\n            for (i = 1; i <= radialSegments; i++) {\r\n                var a = (radialSegments + 1) * (j - 1) + (i - 1);\r\n                var b = (radialSegments + 1) * j + (i - 1);\r\n                var c = (radialSegments + 1) * j + i;\r\n                var d = (radialSegments + 1) * (j - 1) + i;\r\n                // faces\r\n                indices.push(a, b, d);\r\n                indices.push(b, c, d);\r\n            }\r\n        }\r\n    }\r\n    function generateUVs() {\r\n        for (i = 0; i <= tubularSegments; i++) {\r\n            for (j = 0; j <= radialSegments; j++) {\r\n                uv.x = i / tubularSegments;\r\n                uv.y = j / radialSegments;\r\n                uvs.push(uv.x, uv.y);\r\n            }\r\n        }\r\n    }\r\n}\r\nTubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\r\nTubeBufferGeometry.prototype.toJSON = function () {\r\n    var data = BufferGeometry.prototype.toJSON.call(this);\r\n    data.path = this.parameters.path.toJSON();\r\n    return data;\r\n};\r\n/**\r\n * @author oosmoxiecode\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * based on http://www.blackpawn.com/texts/pqtorus/\r\n */\r\n// TorusKnotGeometry\r\nfunction TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {\r\n    Geometry.call(this);\r\n    this.type = 'TorusKnotGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        tube: tube,\r\n        tubularSegments: tubularSegments,\r\n        radialSegments: radialSegments,\r\n        p: p,\r\n        q: q\r\n    };\r\n    if (heightScale !== undefined)\r\n        console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');\r\n    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));\r\n    this.mergeVertices();\r\n}\r\nTorusKnotGeometry.prototype = Object.create(Geometry.prototype);\r\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\r\n// TorusKnotBufferGeometry\r\nfunction TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'TorusKnotBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        tube: tube,\r\n        tubularSegments: tubularSegments,\r\n        radialSegments: radialSegments,\r\n        p: p,\r\n        q: q\r\n    };\r\n    radius = radius || 1;\r\n    tube = tube || 0.4;\r\n    tubularSegments = Math.floor(tubularSegments) || 64;\r\n    radialSegments = Math.floor(radialSegments) || 8;\r\n    p = p || 2;\r\n    q = q || 3;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var i, j;\r\n    var vertex = new Vector3();\r\n    var normal = new Vector3();\r\n    var P1 = new Vector3();\r\n    var P2 = new Vector3();\r\n    var B = new Vector3();\r\n    var T = new Vector3();\r\n    var N = new Vector3();\r\n    // generate vertices, normals and uvs\r\n    for (i = 0; i <= tubularSegments; ++i) {\r\n        // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n        var u = i / tubularSegments * p * Math.PI * 2;\r\n        // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n        // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n        calculatePositionOnCurve(u, p, q, radius, P1);\r\n        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);\r\n        // calculate orthonormal basis\r\n        T.subVectors(P2, P1);\r\n        N.addVectors(P2, P1);\r\n        B.crossVectors(T, N);\r\n        N.crossVectors(B, T);\r\n        // normalize B, N. T can be ignored, we don't use it\r\n        B.normalize();\r\n        N.normalize();\r\n        for (j = 0; j <= radialSegments; ++j) {\r\n            // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n            // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n            var v = j / radialSegments * Math.PI * 2;\r\n            var cx = -tube * Math.cos(v);\r\n            var cy = tube * Math.sin(v);\r\n            // now calculate the final vertex position.\r\n            // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n            vertex.x = P1.x + (cx * N.x + cy * B.x);\r\n            vertex.y = P1.y + (cx * N.y + cy * B.y);\r\n            vertex.z = P1.z + (cx * N.z + cy * B.z);\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n            normal.subVectors(vertex, P1).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(i / tubularSegments);\r\n            uvs.push(j / radialSegments);\r\n        }\r\n    }\r\n    // generate indices\r\n    for (j = 1; j <= tubularSegments; j++) {\r\n        for (i = 1; i <= radialSegments; i++) {\r\n            // indices\r\n            var a = (radialSegments + 1) * (j - 1) + (i - 1);\r\n            var b = (radialSegments + 1) * j + (i - 1);\r\n            var c = (radialSegments + 1) * j + i;\r\n            var d = (radialSegments + 1) * (j - 1) + i;\r\n            // faces\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    // this function calculates the current position on the torus curve\r\n    function calculatePositionOnCurve(u, p, q, radius, position) {\r\n        var cu = Math.cos(u);\r\n        var su = Math.sin(u);\r\n        var quOverP = q / p * u;\r\n        var cs = Math.cos(quOverP);\r\n        position.x = radius * (2 + cs) * 0.5 * cu;\r\n        position.y = radius * (2 + cs) * su * 0.5;\r\n        position.z = radius * Math.sin(quOverP) * 0.5;\r\n    }\r\n}\r\nTorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// TorusGeometry\r\nfunction TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {\r\n    Geometry.call(this);\r\n    this.type = 'TorusGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        tube: tube,\r\n        radialSegments: radialSegments,\r\n        tubularSegments: tubularSegments,\r\n        arc: arc\r\n    };\r\n    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));\r\n    this.mergeVertices();\r\n}\r\nTorusGeometry.prototype = Object.create(Geometry.prototype);\r\nTorusGeometry.prototype.constructor = TorusGeometry;\r\n// TorusBufferGeometry\r\nfunction TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'TorusBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        tube: tube,\r\n        radialSegments: radialSegments,\r\n        tubularSegments: tubularSegments,\r\n        arc: arc\r\n    };\r\n    radius = radius || 1;\r\n    tube = tube || 0.4;\r\n    radialSegments = Math.floor(radialSegments) || 8;\r\n    tubularSegments = Math.floor(tubularSegments) || 6;\r\n    arc = arc || Math.PI * 2;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var center = new Vector3();\r\n    var vertex = new Vector3();\r\n    var normal = new Vector3();\r\n    var j, i;\r\n    // generate vertices, normals and uvs\r\n    for (j = 0; j <= radialSegments; j++) {\r\n        for (i = 0; i <= tubularSegments; i++) {\r\n            var u = i / tubularSegments * arc;\r\n            var v = j / radialSegments * Math.PI * 2;\r\n            // vertex\r\n            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\r\n            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\r\n            vertex.z = tube * Math.sin(v);\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            center.x = radius * Math.cos(u);\r\n            center.y = radius * Math.sin(u);\r\n            normal.subVectors(vertex, center).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(i / tubularSegments);\r\n            uvs.push(j / radialSegments);\r\n        }\r\n    }\r\n    // generate indices\r\n    for (j = 1; j <= radialSegments; j++) {\r\n        for (i = 1; i <= tubularSegments; i++) {\r\n            // indices\r\n            var a = (tubularSegments + 1) * j + i - 1;\r\n            var b = (tubularSegments + 1) * (j - 1) + i - 1;\r\n            var c = (tubularSegments + 1) * (j - 1) + i;\r\n            var d = (tubularSegments + 1) * j + i;\r\n            // faces\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nTorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * Port from https://github.com/mapbox/earcut (v2.1.5)\r\n */\r\nvar Earcut = {\r\n    triangulate: function (data, holeIndices, dim) {\r\n        dim = dim || 2;\r\n        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];\r\n        if (!outerNode || outerNode.next === outerNode.prev)\r\n            return triangles;\r\n        var minX, minY, maxX, maxY, x, y, invSize;\r\n        if (hasHoles)\r\n            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\r\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n        if (data.length > 80 * dim) {\r\n            minX = maxX = data[0];\r\n            minY = maxY = data[1];\r\n            for (var i = dim; i < outerLen; i += dim) {\r\n                x = data[i];\r\n                y = data[i + 1];\r\n                if (x < minX)\r\n                    minX = x;\r\n                if (y < minY)\r\n                    minY = y;\r\n                if (x > maxX)\r\n                    maxX = x;\r\n                if (y > maxY)\r\n                    maxY = y;\r\n            }\r\n            // minX, minY and invSize are later used to transform coords into integers for z-order calculation\r\n            invSize = Math.max(maxX - minX, maxY - minY);\r\n            invSize = invSize !== 0 ? 1 / invSize : 0;\r\n        }\r\n        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\r\n        return triangles;\r\n    }\r\n};\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\nfunction linkedList(data, start, end, dim, clockwise) {\r\n    var i, last;\r\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\r\n        for (i = start; i < end; i += dim)\r\n            last = insertNode(i, data[i], data[i + 1], last);\r\n    }\r\n    else {\r\n        for (i = end - dim; i >= start; i -= dim)\r\n            last = insertNode(i, data[i], data[i + 1], last);\r\n    }\r\n    if (last && equals(last, last.next)) {\r\n        removeNode(last);\r\n        last = last.next;\r\n    }\r\n    return last;\r\n}\r\n// eliminate colinear or duplicate points\r\nfunction filterPoints(start, end) {\r\n    if (!start)\r\n        return start;\r\n    if (!end)\r\n        end = start;\r\n    var p = start, again;\r\n    do {\r\n        again = false;\r\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\r\n            removeNode(p);\r\n            p = end = p.prev;\r\n            if (p === p.next)\r\n                break;\r\n            again = true;\r\n        }\r\n        else {\r\n            p = p.next;\r\n        }\r\n    } while (again || p !== end);\r\n    return end;\r\n}\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\r\n    if (!ear)\r\n        return;\r\n    // interlink polygon nodes in z-order\r\n    if (!pass && invSize)\r\n        indexCurve(ear, minX, minY, invSize);\r\n    var stop = ear, prev, next;\r\n    // iterate through ears, slicing them one by one\r\n    while (ear.prev !== ear.next) {\r\n        prev = ear.prev;\r\n        next = ear.next;\r\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\r\n            // cut off the triangle\r\n            triangles.push(prev.i / dim);\r\n            triangles.push(ear.i / dim);\r\n            triangles.push(next.i / dim);\r\n            removeNode(ear);\r\n            // skipping the next vertex leads to less sliver triangles\r\n            ear = next.next;\r\n            stop = next.next;\r\n            continue;\r\n        }\r\n        ear = next;\r\n        // if we looped through the whole remaining polygon and can't find any more ears\r\n        if (ear === stop) {\r\n            // try filtering points and slicing again\r\n            if (!pass) {\r\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\r\n                // if this didn't work, try curing all small self-intersections locally\r\n            }\r\n            else if (pass === 1) {\r\n                ear = cureLocalIntersections(ear, triangles, dim);\r\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\r\n                // as a last resort, try splitting the remaining polygon into two\r\n            }\r\n            else if (pass === 2) {\r\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\nfunction isEar(ear) {\r\n    var a = ear.prev, b = ear, c = ear.next;\r\n    if (area(a, b, c) >= 0)\r\n        return false; // reflex, can't be an ear\r\n    // now make sure we don't have other points inside the potential ear\r\n    var p = ear.next.next;\r\n    while (p !== ear.prev) {\r\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0)\r\n            return false;\r\n        p = p.next;\r\n    }\r\n    return true;\r\n}\r\nfunction isEarHashed(ear, minX, minY, invSize) {\r\n    var a = ear.prev, b = ear, c = ear.next;\r\n    if (area(a, b, c) >= 0)\r\n        return false; // reflex, can't be an ear\r\n    // triangle bbox; min & max are calculated like this for speed\r\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\r\n    // z-order range for the current triangle bbox;\r\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\r\n    var p = ear.prevZ, n = ear.nextZ;\r\n    // look for points inside the triangle in both directions\r\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\r\n        if (p !== ear.prev && p !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0)\r\n            return false;\r\n        p = p.prevZ;\r\n        if (n !== ear.prev && n !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\r\n            area(n.prev, n, n.next) >= 0)\r\n            return false;\r\n        n = n.nextZ;\r\n    }\r\n    // look for remaining points in decreasing z-order\r\n    while (p && p.z >= minZ) {\r\n        if (p !== ear.prev && p !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\r\n            area(p.prev, p, p.next) >= 0)\r\n            return false;\r\n        p = p.prevZ;\r\n    }\r\n    // look for remaining points in increasing z-order\r\n    while (n && n.z <= maxZ) {\r\n        if (n !== ear.prev && n !== ear.next &&\r\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\r\n            area(n.prev, n, n.next) >= 0)\r\n            return false;\r\n        n = n.nextZ;\r\n    }\r\n    return true;\r\n}\r\n// go through all polygon nodes and cure small local self-intersections\r\nfunction cureLocalIntersections(start, triangles, dim) {\r\n    var p = start;\r\n    do {\r\n        var a = p.prev, b = p.next.next;\r\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\r\n            triangles.push(a.i / dim);\r\n            triangles.push(p.i / dim);\r\n            triangles.push(b.i / dim);\r\n            // remove two nodes involved\r\n            removeNode(p);\r\n            removeNode(p.next);\r\n            p = start = b;\r\n        }\r\n        p = p.next;\r\n    } while (p !== start);\r\n    return p;\r\n}\r\n// try splitting polygon into two and triangulate them independently\r\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\r\n    // look for a valid diagonal that divides the polygon into two\r\n    var a = start;\r\n    do {\r\n        var b = a.next.next;\r\n        while (b !== a.prev) {\r\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\r\n                // split the polygon in two by the diagonal\r\n                var c = splitPolygon(a, b);\r\n                // filter colinear points around the cuts\r\n                a = filterPoints(a, a.next);\r\n                c = filterPoints(c, c.next);\r\n                // run earcut on each half\r\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\r\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\r\n                return;\r\n            }\r\n            b = b.next;\r\n        }\r\n        a = a.next;\r\n    } while (a !== start);\r\n}\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\r\n    var queue = [], i, len, start, end, list;\r\n    for (i = 0, len = holeIndices.length; i < len; i++) {\r\n        start = holeIndices[i] * dim;\r\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\r\n        list = linkedList(data, start, end, dim, false);\r\n        if (list === list.next)\r\n            list.steiner = true;\r\n        queue.push(getLeftmost(list));\r\n    }\r\n    queue.sort(compareX);\r\n    // process holes from left to right\r\n    for (i = 0; i < queue.length; i++) {\r\n        eliminateHole(queue[i], outerNode);\r\n        outerNode = filterPoints(outerNode, outerNode.next);\r\n    }\r\n    return outerNode;\r\n}\r\nfunction compareX(a, b) {\r\n    return a.x - b.x;\r\n}\r\n// find a bridge between vertices that connects hole with an outer ring and and link it\r\nfunction eliminateHole(hole, outerNode) {\r\n    outerNode = findHoleBridge(hole, outerNode);\r\n    if (outerNode) {\r\n        var b = splitPolygon(outerNode, hole);\r\n        filterPoints(b, b.next);\r\n    }\r\n}\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\nfunction findHoleBridge(hole, outerNode) {\r\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\r\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\r\n    // segment's endpoint with lesser x will be potential connection point\r\n    do {\r\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\r\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\r\n            if (x <= hx && x > qx) {\r\n                qx = x;\r\n                if (x === hx) {\r\n                    if (hy === p.y)\r\n                        return p;\r\n                    if (hy === p.next.y)\r\n                        return p.next;\r\n                }\r\n                m = p.x < p.next.x ? p : p.next;\r\n            }\r\n        }\r\n        p = p.next;\r\n    } while (p !== outerNode);\r\n    if (!m)\r\n        return null;\r\n    if (hx === qx)\r\n        return m.prev; // hole touches outer segment; pick lower endpoint\r\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\r\n    // if there are no points found, we have a valid connection;\r\n    // otherwise choose the point of the minimum angle with the ray as connection point\r\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\r\n    p = m.next;\r\n    while (p !== stop) {\r\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\r\n            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\r\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\r\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\r\n                m = p;\r\n                tanMin = tan;\r\n            }\r\n        }\r\n        p = p.next;\r\n    }\r\n    return m;\r\n}\r\n// interlink polygon nodes in z-order\r\nfunction indexCurve(start, minX, minY, invSize) {\r\n    var p = start;\r\n    do {\r\n        if (p.z === null)\r\n            p.z = zOrder(p.x, p.y, minX, minY, invSize);\r\n        p.prevZ = p.prev;\r\n        p.nextZ = p.next;\r\n        p = p.next;\r\n    } while (p !== start);\r\n    p.prevZ.nextZ = null;\r\n    p.prevZ = null;\r\n    sortLinked(p);\r\n}\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\nfunction sortLinked(list) {\r\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\r\n    do {\r\n        p = list;\r\n        list = null;\r\n        tail = null;\r\n        numMerges = 0;\r\n        while (p) {\r\n            numMerges++;\r\n            q = p;\r\n            pSize = 0;\r\n            for (i = 0; i < inSize; i++) {\r\n                pSize++;\r\n                q = q.nextZ;\r\n                if (!q)\r\n                    break;\r\n            }\r\n            qSize = inSize;\r\n            while (pSize > 0 || (qSize > 0 && q)) {\r\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\r\n                    e = p;\r\n                    p = p.nextZ;\r\n                    pSize--;\r\n                }\r\n                else {\r\n                    e = q;\r\n                    q = q.nextZ;\r\n                    qSize--;\r\n                }\r\n                if (tail)\r\n                    tail.nextZ = e;\r\n                else\r\n                    list = e;\r\n                e.prevZ = tail;\r\n                tail = e;\r\n            }\r\n            p = q;\r\n        }\r\n        tail.nextZ = null;\r\n        inSize *= 2;\r\n    } while (numMerges > 1);\r\n    return list;\r\n}\r\n// z-order of a point given coords and inverse of the longer side of data bbox\r\nfunction zOrder(x, y, minX, minY, invSize) {\r\n    // coords are transformed into non-negative 15-bit integer range\r\n    x = 32767 * (x - minX) * invSize;\r\n    y = 32767 * (y - minY) * invSize;\r\n    x = (x | (x << 8)) & 0x00FF00FF;\r\n    x = (x | (x << 4)) & 0x0F0F0F0F;\r\n    x = (x | (x << 2)) & 0x33333333;\r\n    x = (x | (x << 1)) & 0x55555555;\r\n    y = (y | (y << 8)) & 0x00FF00FF;\r\n    y = (y | (y << 4)) & 0x0F0F0F0F;\r\n    y = (y | (y << 2)) & 0x33333333;\r\n    y = (y | (y << 1)) & 0x55555555;\r\n    return x | (y << 1);\r\n}\r\n// find the leftmost node of a polygon ring\r\nfunction getLeftmost(start) {\r\n    var p = start, leftmost = start;\r\n    do {\r\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))\r\n            leftmost = p;\r\n        p = p.next;\r\n    } while (p !== start);\r\n    return leftmost;\r\n}\r\n// check if a point lies within a convex triangle\r\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\r\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\r\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\r\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\r\n}\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\nfunction isValidDiagonal(a, b) {\r\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\r\n        locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\r\n}\r\n// signed area of a triangle\r\nfunction area(p, q, r) {\r\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\r\n}\r\n// check if two points are equal\r\nfunction equals(p1, p2) {\r\n    return p1.x === p2.x && p1.y === p2.y;\r\n}\r\n// check if two segments intersect\r\nfunction intersects(p1, q1, p2, q2) {\r\n    if ((equals(p1, p2) && equals(q1, q2)) ||\r\n        (equals(p1, q2) && equals(p2, q1)))\r\n        return true;\r\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\r\n        area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\r\n}\r\n// check if a polygon diagonal intersects any polygon segments\r\nfunction intersectsPolygon(a, b) {\r\n    var p = a;\r\n    do {\r\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n            intersects(p, p.next, a, b))\r\n            return true;\r\n        p = p.next;\r\n    } while (p !== a);\r\n    return false;\r\n}\r\n// check if a polygon diagonal is locally inside the polygon\r\nfunction locallyInside(a, b) {\r\n    return area(a.prev, a, a.next) < 0 ?\r\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\r\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\r\n}\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\nfunction middleInside(a, b) {\r\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\r\n    do {\r\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\r\n            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\r\n            inside = !inside;\r\n        p = p.next;\r\n    } while (p !== a);\r\n    return inside;\r\n}\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\nfunction splitPolygon(a, b) {\r\n    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\r\n    a.next = b;\r\n    b.prev = a;\r\n    a2.next = an;\r\n    an.prev = a2;\r\n    b2.next = a2;\r\n    a2.prev = b2;\r\n    bp.next = b2;\r\n    b2.prev = bp;\r\n    return b2;\r\n}\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\nfunction insertNode(i, x, y, last) {\r\n    var p = new Node(i, x, y);\r\n    if (!last) {\r\n        p.prev = p;\r\n        p.next = p;\r\n    }\r\n    else {\r\n        p.next = last.next;\r\n        p.prev = last;\r\n        last.next.prev = p;\r\n        last.next = p;\r\n    }\r\n    return p;\r\n}\r\nfunction removeNode(p) {\r\n    p.next.prev = p.prev;\r\n    p.prev.next = p.next;\r\n    if (p.prevZ)\r\n        p.prevZ.nextZ = p.nextZ;\r\n    if (p.nextZ)\r\n        p.nextZ.prevZ = p.prevZ;\r\n}\r\nfunction Node(i, x, y) {\r\n    // vertex index in coordinates array\r\n    this.i = i;\r\n    // vertex coordinates\r\n    this.x = x;\r\n    this.y = y;\r\n    // previous and next vertex nodes in a polygon ring\r\n    this.prev = null;\r\n    this.next = null;\r\n    // z-order curve value\r\n    this.z = null;\r\n    // previous and next nodes in z-order\r\n    this.prevZ = null;\r\n    this.nextZ = null;\r\n    // indicates whether this is a steiner point\r\n    this.steiner = false;\r\n}\r\nfunction signedArea(data, start, end, dim) {\r\n    var sum = 0;\r\n    for (var i = start, j = end - dim; i < end; i += dim) {\r\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\r\n        j = i;\r\n    }\r\n    return sum;\r\n}\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\nvar ShapeUtils = {\r\n    // calculate area of the contour polygon\r\n    area: function (contour) {\r\n        var n = contour.length;\r\n        var a = 0.0;\r\n        for (var p = n - 1, q = 0; q < n; p = q++) {\r\n            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\r\n        }\r\n        return a * 0.5;\r\n    },\r\n    isClockWise: function (pts) {\r\n        return ShapeUtils.area(pts) < 0;\r\n    },\r\n    triangulateShape: function (contour, holes) {\r\n        var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\r\n        var holeIndices = []; // array of hole indices\r\n        var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\r\n        removeDupEndPts(contour);\r\n        addContour(vertices, contour);\r\n        //\r\n        var holeIndex = contour.length;\r\n        holes.forEach(removeDupEndPts);\r\n        for (var i = 0; i < holes.length; i++) {\r\n            holeIndices.push(holeIndex);\r\n            holeIndex += holes[i].length;\r\n            addContour(vertices, holes[i]);\r\n        }\r\n        //\r\n        var triangles = Earcut.triangulate(vertices, holeIndices);\r\n        //\r\n        for (var i = 0; i < triangles.length; i += 3) {\r\n            faces.push(triangles.slice(i, i + 3));\r\n        }\r\n        return faces;\r\n    }\r\n};\r\nfunction removeDupEndPts(points) {\r\n    var l = points.length;\r\n    if (l > 2 && points[l - 1].equals(points[0])) {\r\n        points.pop();\r\n    }\r\n}\r\nfunction addContour(vertices, contour) {\r\n    for (var i = 0; i < contour.length; i++) {\r\n        vertices.push(contour[i].x);\r\n        vertices.push(contour[i].y);\r\n    }\r\n}\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  depth: <float>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\r\n *  bevelOffset: <float>, // how far from shape outline does bevel start\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\r\n *\r\n *  UVGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n */\r\n// ExtrudeGeometry\r\nfunction ExtrudeGeometry(shapes, options) {\r\n    Geometry.call(this);\r\n    this.type = 'ExtrudeGeometry';\r\n    this.parameters = {\r\n        shapes: shapes,\r\n        options: options\r\n    };\r\n    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));\r\n    this.mergeVertices();\r\n}\r\nExtrudeGeometry.prototype = Object.create(Geometry.prototype);\r\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\r\nExtrudeGeometry.prototype.toJSON = function () {\r\n    var data = Geometry.prototype.toJSON.call(this);\r\n    var shapes = this.parameters.shapes;\r\n    var options = this.parameters.options;\r\n    return toJSON(shapes, options, data);\r\n};\r\n// ExtrudeBufferGeometry\r\nfunction ExtrudeBufferGeometry(shapes, options) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'ExtrudeBufferGeometry';\r\n    this.parameters = {\r\n        shapes: shapes,\r\n        options: options\r\n    };\r\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\r\n    var scope = this;\r\n    var verticesArray = [];\r\n    var uvArray = [];\r\n    for (var i = 0, l = shapes.length; i < l; i++) {\r\n        var shape = shapes[i];\r\n        addShape(shape);\r\n    }\r\n    // build geometry\r\n    this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));\r\n    this.computeVertexNormals();\r\n    // functions\r\n    function addShape(shape) {\r\n        var placeholder = [];\r\n        // options\r\n        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n        var steps = options.steps !== undefined ? options.steps : 1;\r\n        var depth = options.depth !== undefined ? options.depth : 100;\r\n        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\r\n        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\r\n        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\r\n        var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\r\n        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n        var extrudePath = options.extrudePath;\r\n        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\r\n        // deprecated options\r\n        if (options.amount !== undefined) {\r\n            console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\r\n            depth = options.amount;\r\n        }\r\n        //\r\n        var extrudePts, extrudeByPath = false;\r\n        var splineTube, binormal, normal, position2;\r\n        if (extrudePath) {\r\n            extrudePts = extrudePath.getSpacedPoints(steps);\r\n            extrudeByPath = true;\r\n            bevelEnabled = false; // bevels not supported for path extrusion\r\n            // SETUP TNB variables\r\n            // TODO1 - have a .isClosed in spline?\r\n            splineTube = extrudePath.computeFrenetFrames(steps, false);\r\n            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n            binormal = new Vector3();\r\n            normal = new Vector3();\r\n            position2 = new Vector3();\r\n        }\r\n        // Safeguards if bevels are not enabled\r\n        if (!bevelEnabled) {\r\n            bevelSegments = 0;\r\n            bevelThickness = 0;\r\n            bevelSize = 0;\r\n            bevelOffset = 0;\r\n        }\r\n        // Variables initialization\r\n        var ahole, h, hl; // looping of holes\r\n        var shapePoints = shape.extractPoints(curveSegments);\r\n        var vertices = shapePoints.shape;\r\n        var holes = shapePoints.holes;\r\n        var reverse = !ShapeUtils.isClockWise(vertices);\r\n        if (reverse) {\r\n            vertices = vertices.reverse();\r\n            // Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n            for (h = 0, hl = holes.length; h < hl; h++) {\r\n                ahole = holes[h];\r\n                if (ShapeUtils.isClockWise(ahole)) {\r\n                    holes[h] = ahole.reverse();\r\n                }\r\n            }\r\n        }\r\n        var faces = ShapeUtils.triangulateShape(vertices, holes);\r\n        /* Vertices */\r\n        var contour = vertices; // vertices has all points but contour has only points of circumference\r\n        for (h = 0, hl = holes.length; h < hl; h++) {\r\n            ahole = holes[h];\r\n            vertices = vertices.concat(ahole);\r\n        }\r\n        function scalePt2(pt, vec, size) {\r\n            if (!vec)\r\n                console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\r\n            return vec.clone().multiplyScalar(size).add(pt);\r\n        }\r\n        var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;\r\n        // Find directions for point movement\r\n        function getBevelVec(inPt, inPrev, inNext) {\r\n            // computes for inPt the corresponding point inPt' on a new contour\r\n            //   shifted by 1 unit (length of normalized vector) to the left\r\n            // if we walk along contour clockwise, this new contour is outside the old one\r\n            //\r\n            // inPt' is the intersection of the two lines parallel to the two\r\n            //  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n            var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\r\n            // good reading for geometry algorithms (here: line-line intersection)\r\n            // http://geomalgorithms.com/a05-_intersect-1.html\r\n            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n            var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);\r\n            // check for collinear edges\r\n            var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);\r\n            if (Math.abs(collinear0) > Number.EPSILON) {\r\n                // not collinear\r\n                // length of vectors for normalizing\r\n                var v_prev_len = Math.sqrt(v_prev_lensq);\r\n                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\r\n                // shift adjacent points by unit vectors to the left\r\n                var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);\r\n                var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);\r\n                var ptNextShift_x = (inNext.x - v_next_y / v_next_len);\r\n                var ptNextShift_y = (inNext.y + v_next_x / v_next_len);\r\n                // scaling factor for v_prev to intersection point\r\n                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -\r\n                    (ptNextShift_y - ptPrevShift_y) * v_next_x) /\r\n                    (v_prev_x * v_next_y - v_prev_y * v_next_x);\r\n                // vector from inPt to intersection point\r\n                v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);\r\n                v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);\r\n                // Don't normalize!, otherwise sharp corners become ugly\r\n                //  but prevent crazy spikes\r\n                var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);\r\n                if (v_trans_lensq <= 2) {\r\n                    return new Vector2(v_trans_x, v_trans_y);\r\n                }\r\n                else {\r\n                    shrink_by = Math.sqrt(v_trans_lensq / 2);\r\n                }\r\n            }\r\n            else {\r\n                // handle special case of collinear edges\r\n                var direction_eq = false; // assumes: opposite\r\n                if (v_prev_x > Number.EPSILON) {\r\n                    if (v_next_x > Number.EPSILON) {\r\n                        direction_eq = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (v_prev_x < -Number.EPSILON) {\r\n                        if (v_next_x < -Number.EPSILON) {\r\n                            direction_eq = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\r\n                            direction_eq = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (direction_eq) {\r\n                    // console.log(\"Warning: lines are a straight sequence\");\r\n                    v_trans_x = -v_prev_y;\r\n                    v_trans_y = v_prev_x;\r\n                    shrink_by = Math.sqrt(v_prev_lensq);\r\n                }\r\n                else {\r\n                    // console.log(\"Warning: lines are a straight spike\");\r\n                    v_trans_x = v_prev_x;\r\n                    v_trans_y = v_prev_y;\r\n                    shrink_by = Math.sqrt(v_prev_lensq / 2);\r\n                }\r\n            }\r\n            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\r\n        }\r\n        var contourMovements = [];\r\n        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\r\n            if (j === il)\r\n                j = 0;\r\n            if (k === il)\r\n                k = 0;\r\n            //  (j)---(i)---(k)\r\n            // console.log('i,j,k', i, j , k)\r\n            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\r\n        }\r\n        var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n        for (h = 0, hl = holes.length; h < hl; h++) {\r\n            ahole = holes[h];\r\n            oneHoleMovements = [];\r\n            for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\r\n                if (j === il)\r\n                    j = 0;\r\n                if (k === il)\r\n                    k = 0;\r\n                //  (j)---(i)---(k)\r\n                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\r\n            }\r\n            holesMovements.push(oneHoleMovements);\r\n            verticesMovements = verticesMovements.concat(oneHoleMovements);\r\n        }\r\n        // Loop bevelSegments, 1 for the front, 1 for the back\r\n        for (b = 0; b < bevelSegments; b++) {\r\n            //for ( b = bevelSegments; b > 0; b -- ) {\r\n            t = b / bevelSegments;\r\n            z = bevelThickness * Math.cos(t * Math.PI / 2);\r\n            bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\r\n            // contract shape\r\n            for (i = 0, il = contour.length; i < il; i++) {\r\n                vert = scalePt2(contour[i], contourMovements[i], bs);\r\n                v(vert.x, vert.y, -z);\r\n            }\r\n            // expand holes\r\n            for (h = 0, hl = holes.length; h < hl; h++) {\r\n                ahole = holes[h];\r\n                oneHoleMovements = holesMovements[h];\r\n                for (i = 0, il = ahole.length; i < il; i++) {\r\n                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\r\n                    v(vert.x, vert.y, -z);\r\n                }\r\n            }\r\n        }\r\n        bs = bevelSize + bevelOffset;\r\n        // Back facing vertices\r\n        for (i = 0; i < vlen; i++) {\r\n            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\r\n            if (!extrudeByPath) {\r\n                v(vert.x, vert.y, 0);\r\n            }\r\n            else {\r\n                // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\r\n                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\r\n                position2.copy(extrudePts[0]).add(normal).add(binormal);\r\n                v(position2.x, position2.y, position2.z);\r\n            }\r\n        }\r\n        // Add stepped vertices...\r\n        // Including front facing vertices\r\n        var s;\r\n        for (s = 1; s <= steps; s++) {\r\n            for (i = 0; i < vlen; i++) {\r\n                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\r\n                if (!extrudeByPath) {\r\n                    v(vert.x, vert.y, depth / steps * s);\r\n                }\r\n                else {\r\n                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\r\n                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\r\n                    position2.copy(extrudePts[s]).add(normal).add(binormal);\r\n                    v(position2.x, position2.y, position2.z);\r\n                }\r\n            }\r\n        }\r\n        // Add bevel segments planes\r\n        //for ( b = 1; b <= bevelSegments; b ++ ) {\r\n        for (b = bevelSegments - 1; b >= 0; b--) {\r\n            t = b / bevelSegments;\r\n            z = bevelThickness * Math.cos(t * Math.PI / 2);\r\n            bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\r\n            // contract shape\r\n            for (i = 0, il = contour.length; i < il; i++) {\r\n                vert = scalePt2(contour[i], contourMovements[i], bs);\r\n                v(vert.x, vert.y, depth + z);\r\n            }\r\n            // expand holes\r\n            for (h = 0, hl = holes.length; h < hl; h++) {\r\n                ahole = holes[h];\r\n                oneHoleMovements = holesMovements[h];\r\n                for (i = 0, il = ahole.length; i < il; i++) {\r\n                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\r\n                    if (!extrudeByPath) {\r\n                        v(vert.x, vert.y, depth + z);\r\n                    }\r\n                    else {\r\n                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /* Faces */\r\n        // Top and bottom faces\r\n        buildLidFaces();\r\n        // Sides faces\r\n        buildSideFaces();\r\n        /////  Internal functions\r\n        function buildLidFaces() {\r\n            var start = verticesArray.length / 3;\r\n            if (bevelEnabled) {\r\n                var layer = 0; // steps + 1\r\n                var offset = vlen * layer;\r\n                // Bottom faces\r\n                for (i = 0; i < flen; i++) {\r\n                    face = faces[i];\r\n                    f3(face[2] + offset, face[1] + offset, face[0] + offset);\r\n                }\r\n                layer = steps + bevelSegments * 2;\r\n                offset = vlen * layer;\r\n                // Top faces\r\n                for (i = 0; i < flen; i++) {\r\n                    face = faces[i];\r\n                    f3(face[0] + offset, face[1] + offset, face[2] + offset);\r\n                }\r\n            }\r\n            else {\r\n                // Bottom faces\r\n                for (i = 0; i < flen; i++) {\r\n                    face = faces[i];\r\n                    f3(face[2], face[1], face[0]);\r\n                }\r\n                // Top faces\r\n                for (i = 0; i < flen; i++) {\r\n                    face = faces[i];\r\n                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\r\n                }\r\n            }\r\n            scope.addGroup(start, verticesArray.length / 3 - start, 0);\r\n        }\r\n        // Create faces for the z-sides of the shape\r\n        function buildSideFaces() {\r\n            var start = verticesArray.length / 3;\r\n            var layeroffset = 0;\r\n            sidewalls(contour, layeroffset);\r\n            layeroffset += contour.length;\r\n            for (h = 0, hl = holes.length; h < hl; h++) {\r\n                ahole = holes[h];\r\n                sidewalls(ahole, layeroffset);\r\n                //, true\r\n                layeroffset += ahole.length;\r\n            }\r\n            scope.addGroup(start, verticesArray.length / 3 - start, 1);\r\n        }\r\n        function sidewalls(contour, layeroffset) {\r\n            var j, k;\r\n            i = contour.length;\r\n            while (--i >= 0) {\r\n                j = i;\r\n                k = i - 1;\r\n                if (k < 0)\r\n                    k = contour.length - 1;\r\n                //console.log('b', i,j, i-1, k,vertices.length);\r\n                var s = 0, sl = steps + bevelSegments * 2;\r\n                for (s = 0; s < sl; s++) {\r\n                    var slen1 = vlen * s;\r\n                    var slen2 = vlen * (s + 1);\r\n                    var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;\r\n                    f4(a, b, c, d);\r\n                }\r\n            }\r\n        }\r\n        function v(x, y, z) {\r\n            placeholder.push(x);\r\n            placeholder.push(y);\r\n            placeholder.push(z);\r\n        }\r\n        function f3(a, b, c) {\r\n            addVertex(a);\r\n            addVertex(b);\r\n            addVertex(c);\r\n            var nextIndex = verticesArray.length / 3;\r\n            var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\r\n            addUV(uvs[0]);\r\n            addUV(uvs[1]);\r\n            addUV(uvs[2]);\r\n        }\r\n        function f4(a, b, c, d) {\r\n            addVertex(a);\r\n            addVertex(b);\r\n            addVertex(d);\r\n            addVertex(b);\r\n            addVertex(c);\r\n            addVertex(d);\r\n            var nextIndex = verticesArray.length / 3;\r\n            var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\r\n            addUV(uvs[0]);\r\n            addUV(uvs[1]);\r\n            addUV(uvs[3]);\r\n            addUV(uvs[1]);\r\n            addUV(uvs[2]);\r\n            addUV(uvs[3]);\r\n        }\r\n        function addVertex(index) {\r\n            verticesArray.push(placeholder[index * 3 + 0]);\r\n            verticesArray.push(placeholder[index * 3 + 1]);\r\n            verticesArray.push(placeholder[index * 3 + 2]);\r\n        }\r\n        function addUV(vector2) {\r\n            uvArray.push(vector2.x);\r\n            uvArray.push(vector2.y);\r\n        }\r\n    }\r\n}\r\nExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\r\nExtrudeBufferGeometry.prototype.toJSON = function () {\r\n    var data = BufferGeometry.prototype.toJSON.call(this);\r\n    var shapes = this.parameters.shapes;\r\n    var options = this.parameters.options;\r\n    return toJSON(shapes, options, data);\r\n};\r\n//\r\nvar WorldUVGenerator = {\r\n    generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\r\n        var a_x = vertices[indexA * 3];\r\n        var a_y = vertices[indexA * 3 + 1];\r\n        var b_x = vertices[indexB * 3];\r\n        var b_y = vertices[indexB * 3 + 1];\r\n        var c_x = vertices[indexC * 3];\r\n        var c_y = vertices[indexC * 3 + 1];\r\n        return [\r\n            new Vector2(a_x, a_y),\r\n            new Vector2(b_x, b_y),\r\n            new Vector2(c_x, c_y)\r\n        ];\r\n    },\r\n    generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\r\n        var a_x = vertices[indexA * 3];\r\n        var a_y = vertices[indexA * 3 + 1];\r\n        var a_z = vertices[indexA * 3 + 2];\r\n        var b_x = vertices[indexB * 3];\r\n        var b_y = vertices[indexB * 3 + 1];\r\n        var b_z = vertices[indexB * 3 + 2];\r\n        var c_x = vertices[indexC * 3];\r\n        var c_y = vertices[indexC * 3 + 1];\r\n        var c_z = vertices[indexC * 3 + 2];\r\n        var d_x = vertices[indexD * 3];\r\n        var d_y = vertices[indexD * 3 + 1];\r\n        var d_z = vertices[indexD * 3 + 2];\r\n        if (Math.abs(a_y - b_y) < 0.01) {\r\n            return [\r\n                new Vector2(a_x, 1 - a_z),\r\n                new Vector2(b_x, 1 - b_z),\r\n                new Vector2(c_x, 1 - c_z),\r\n                new Vector2(d_x, 1 - d_z)\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                new Vector2(a_y, 1 - a_z),\r\n                new Vector2(b_y, 1 - b_z),\r\n                new Vector2(c_y, 1 - c_z),\r\n                new Vector2(d_y, 1 - d_z)\r\n            ];\r\n        }\r\n    }\r\n};\r\nfunction toJSON(shapes, options, data) {\r\n    //\r\n    data.shapes = [];\r\n    if (Array.isArray(shapes)) {\r\n        for (var i = 0, l = shapes.length; i < l; i++) {\r\n            var shape = shapes[i];\r\n            data.shapes.push(shape.uuid);\r\n        }\r\n    }\r\n    else {\r\n        data.shapes.push(shapes.uuid);\r\n    }\r\n    //\r\n    if (options.extrudePath !== undefined)\r\n        data.options.extrudePath = options.extrudePath.toJSON();\r\n    return data;\r\n}\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  font: <THREE.Font>, // font\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\r\n *  bevelOffset: <float> // how far from text outline does bevel start\r\n * }\r\n */\r\n// TextGeometry\r\nfunction TextGeometry(text, parameters) {\r\n    Geometry.call(this);\r\n    this.type = 'TextGeometry';\r\n    this.parameters = {\r\n        text: text,\r\n        parameters: parameters\r\n    };\r\n    this.fromBufferGeometry(new TextBufferGeometry(text, parameters));\r\n    this.mergeVertices();\r\n}\r\nTextGeometry.prototype = Object.create(Geometry.prototype);\r\nTextGeometry.prototype.constructor = TextGeometry;\r\n// TextBufferGeometry\r\nfunction TextBufferGeometry(text, parameters) {\r\n    parameters = parameters || {};\r\n    var font = parameters.font;\r\n    if (!(font && font.isFont)) {\r\n        console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');\r\n        return new Geometry();\r\n    }\r\n    var shapes = font.generateShapes(text, parameters.size);\r\n    // translate parameters to ExtrudeGeometry API\r\n    parameters.depth = parameters.height !== undefined ? parameters.height : 50;\r\n    // defaults\r\n    if (parameters.bevelThickness === undefined)\r\n        parameters.bevelThickness = 10;\r\n    if (parameters.bevelSize === undefined)\r\n        parameters.bevelSize = 8;\r\n    if (parameters.bevelEnabled === undefined)\r\n        parameters.bevelEnabled = false;\r\n    ExtrudeBufferGeometry.call(this, shapes, parameters);\r\n    this.type = 'TextBufferGeometry';\r\n}\r\nTextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);\r\nTextBufferGeometry.prototype.constructor = TextBufferGeometry;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// SphereGeometry\r\nfunction SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\r\n    Geometry.call(this);\r\n    this.type = 'SphereGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments,\r\n        phiStart: phiStart,\r\n        phiLength: phiLength,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));\r\n    this.mergeVertices();\r\n}\r\nSphereGeometry.prototype = Object.create(Geometry.prototype);\r\nSphereGeometry.prototype.constructor = SphereGeometry;\r\n// SphereBufferGeometry\r\nfunction SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'SphereBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        widthSegments: widthSegments,\r\n        heightSegments: heightSegments,\r\n        phiStart: phiStart,\r\n        phiLength: phiLength,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    radius = radius || 1;\r\n    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);\r\n    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);\r\n    phiStart = phiStart !== undefined ? phiStart : 0;\r\n    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\r\n    var ix, iy;\r\n    var index = 0;\r\n    var grid = [];\r\n    var vertex = new Vector3();\r\n    var normal = new Vector3();\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // generate vertices, normals and uvs\r\n    for (iy = 0; iy <= heightSegments; iy++) {\r\n        var verticesRow = [];\r\n        var v = iy / heightSegments;\r\n        // special case for the poles\r\n        var uOffset = 0;\r\n        if (iy == 0 && thetaStart == 0) {\r\n            uOffset = 0.5 / widthSegments;\r\n        }\r\n        else if (iy == heightSegments && thetaEnd == Math.PI) {\r\n            uOffset = -0.5 / widthSegments;\r\n        }\r\n        for (ix = 0; ix <= widthSegments; ix++) {\r\n            var u = ix / widthSegments;\r\n            // vertex\r\n            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\r\n            vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\r\n            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.copy(vertex).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u + uOffset, 1 - v);\r\n            verticesRow.push(index++);\r\n        }\r\n        grid.push(verticesRow);\r\n    }\r\n    // indices\r\n    for (iy = 0; iy < heightSegments; iy++) {\r\n        for (ix = 0; ix < widthSegments; ix++) {\r\n            var a = grid[iy][ix + 1];\r\n            var b = grid[iy][ix];\r\n            var c = grid[iy + 1][ix];\r\n            var d = grid[iy + 1][ix + 1];\r\n            if (iy !== 0 || thetaStart > 0)\r\n                indices.push(a, b, d);\r\n            if (iy !== heightSegments - 1 || thetaEnd < Math.PI)\r\n                indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nSphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\r\n/**\r\n * @author Kaleb Murphy\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// RingGeometry\r\nfunction RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {\r\n    Geometry.call(this);\r\n    this.type = 'RingGeometry';\r\n    this.parameters = {\r\n        innerRadius: innerRadius,\r\n        outerRadius: outerRadius,\r\n        thetaSegments: thetaSegments,\r\n        phiSegments: phiSegments,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));\r\n    this.mergeVertices();\r\n}\r\nRingGeometry.prototype = Object.create(Geometry.prototype);\r\nRingGeometry.prototype.constructor = RingGeometry;\r\n// RingBufferGeometry\r\nfunction RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'RingBufferGeometry';\r\n    this.parameters = {\r\n        innerRadius: innerRadius,\r\n        outerRadius: outerRadius,\r\n        thetaSegments: thetaSegments,\r\n        phiSegments: phiSegments,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    innerRadius = innerRadius || 0.5;\r\n    outerRadius = outerRadius || 1;\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;\r\n    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // some helper variables\r\n    var segment;\r\n    var radius = innerRadius;\r\n    var radiusStep = ((outerRadius - innerRadius) / phiSegments);\r\n    var vertex = new Vector3();\r\n    var uv = new Vector2();\r\n    var j, i;\r\n    // generate vertices, normals and uvs\r\n    for (j = 0; j <= phiSegments; j++) {\r\n        for (i = 0; i <= thetaSegments; i++) {\r\n            // values are generate from the inside of the ring to the outside\r\n            segment = thetaStart + i / thetaSegments * thetaLength;\r\n            // vertex\r\n            vertex.x = radius * Math.cos(segment);\r\n            vertex.y = radius * Math.sin(segment);\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normals.push(0, 0, 1);\r\n            // uv\r\n            uv.x = (vertex.x / outerRadius + 1) / 2;\r\n            uv.y = (vertex.y / outerRadius + 1) / 2;\r\n            uvs.push(uv.x, uv.y);\r\n        }\r\n        // increase the radius for next row of vertices\r\n        radius += radiusStep;\r\n    }\r\n    // indices\r\n    for (j = 0; j < phiSegments; j++) {\r\n        var thetaSegmentLevel = j * (thetaSegments + 1);\r\n        for (i = 0; i < thetaSegments; i++) {\r\n            segment = i + thetaSegmentLevel;\r\n            var a = segment;\r\n            var b = segment + thetaSegments + 1;\r\n            var c = segment + thetaSegments + 2;\r\n            var d = segment + 1;\r\n            // faces\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nRingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nRingBufferGeometry.prototype.constructor = RingBufferGeometry;\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// LatheGeometry\r\nfunction LatheGeometry(points, segments, phiStart, phiLength) {\r\n    Geometry.call(this);\r\n    this.type = 'LatheGeometry';\r\n    this.parameters = {\r\n        points: points,\r\n        segments: segments,\r\n        phiStart: phiStart,\r\n        phiLength: phiLength\r\n    };\r\n    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));\r\n    this.mergeVertices();\r\n}\r\nLatheGeometry.prototype = Object.create(Geometry.prototype);\r\nLatheGeometry.prototype.constructor = LatheGeometry;\r\n// LatheBufferGeometry\r\nfunction LatheBufferGeometry(points, segments, phiStart, phiLength) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'LatheBufferGeometry';\r\n    this.parameters = {\r\n        points: points,\r\n        segments: segments,\r\n        phiStart: phiStart,\r\n        phiLength: phiLength\r\n    };\r\n    segments = Math.floor(segments) || 12;\r\n    phiStart = phiStart || 0;\r\n    phiLength = phiLength || Math.PI * 2;\r\n    // clamp phiLength so it's in range of [ 0, 2PI ]\r\n    phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var base;\r\n    var inverseSegments = 1.0 / segments;\r\n    var vertex = new Vector3();\r\n    var uv = new Vector2();\r\n    var i, j;\r\n    // generate vertices and uvs\r\n    for (i = 0; i <= segments; i++) {\r\n        var phi = phiStart + i * inverseSegments * phiLength;\r\n        var sin = Math.sin(phi);\r\n        var cos = Math.cos(phi);\r\n        for (j = 0; j <= (points.length - 1); j++) {\r\n            // vertex\r\n            vertex.x = points[j].x * sin;\r\n            vertex.y = points[j].y;\r\n            vertex.z = points[j].x * cos;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // uv\r\n            uv.x = i / segments;\r\n            uv.y = j / (points.length - 1);\r\n            uvs.push(uv.x, uv.y);\r\n        }\r\n    }\r\n    // indices\r\n    for (i = 0; i < segments; i++) {\r\n        for (j = 0; j < (points.length - 1); j++) {\r\n            base = j + i * points.length;\r\n            var a = base;\r\n            var b = base + points.length;\r\n            var c = base + points.length + 1;\r\n            var d = base + 1;\r\n            // faces\r\n            indices.push(a, b, d);\r\n            indices.push(b, c, d);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    // generate normals\r\n    this.computeVertexNormals();\r\n    // if the geometry is closed, we need to average the normals along the seam.\r\n    // because the corresponding vertices are identical (but still have different UVs).\r\n    if (phiLength === Math.PI * 2) {\r\n        var normals = this.attributes.normal.array;\r\n        var n1 = new Vector3();\r\n        var n2 = new Vector3();\r\n        var n = new Vector3();\r\n        // this is the buffer offset for the last line of vertices\r\n        base = segments * points.length * 3;\r\n        for (i = 0, j = 0; i < points.length; i++, j += 3) {\r\n            // select the normal of the vertex in the first line\r\n            n1.x = normals[j + 0];\r\n            n1.y = normals[j + 1];\r\n            n1.z = normals[j + 2];\r\n            // select the normal of the vertex in the last line\r\n            n2.x = normals[base + j + 0];\r\n            n2.y = normals[base + j + 1];\r\n            n2.z = normals[base + j + 2];\r\n            // average normals\r\n            n.addVectors(n1, n2).normalize();\r\n            // assign the new values to both normals\r\n            normals[j + 0] = normals[base + j + 0] = n.x;\r\n            normals[j + 1] = normals[base + j + 1] = n.y;\r\n            normals[j + 2] = normals[base + j + 2] = n.z;\r\n        }\r\n    }\r\n}\r\nLatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// ShapeGeometry\r\nfunction ShapeGeometry(shapes, curveSegments) {\r\n    Geometry.call(this);\r\n    this.type = 'ShapeGeometry';\r\n    if (typeof curveSegments === 'object') {\r\n        console.warn('THREE.ShapeGeometry: Options parameter has been removed.');\r\n        curveSegments = curveSegments.curveSegments;\r\n    }\r\n    this.parameters = {\r\n        shapes: shapes,\r\n        curveSegments: curveSegments\r\n    };\r\n    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));\r\n    this.mergeVertices();\r\n}\r\nShapeGeometry.prototype = Object.create(Geometry.prototype);\r\nShapeGeometry.prototype.constructor = ShapeGeometry;\r\nShapeGeometry.prototype.toJSON = function () {\r\n    var data = Geometry.prototype.toJSON.call(this);\r\n    var shapes = this.parameters.shapes;\r\n    return toJSON$1(shapes, data);\r\n};\r\n// ShapeBufferGeometry\r\nfunction ShapeBufferGeometry(shapes, curveSegments) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'ShapeBufferGeometry';\r\n    this.parameters = {\r\n        shapes: shapes,\r\n        curveSegments: curveSegments\r\n    };\r\n    curveSegments = curveSegments || 12;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var groupStart = 0;\r\n    var groupCount = 0;\r\n    // allow single and array values for \"shapes\" parameter\r\n    if (Array.isArray(shapes) === false) {\r\n        addShape(shapes);\r\n    }\r\n    else {\r\n        for (var i = 0; i < shapes.length; i++) {\r\n            addShape(shapes[i]);\r\n            this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\r\n            groupStart += groupCount;\r\n            groupCount = 0;\r\n        }\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    // helper functions\r\n    function addShape(shape) {\r\n        var i, l, shapeHole;\r\n        var indexOffset = vertices.length / 3;\r\n        var points = shape.extractPoints(curveSegments);\r\n        var shapeVertices = points.shape;\r\n        var shapeHoles = points.holes;\r\n        // check direction of vertices\r\n        if (ShapeUtils.isClockWise(shapeVertices) === false) {\r\n            shapeVertices = shapeVertices.reverse();\r\n        }\r\n        for (i = 0, l = shapeHoles.length; i < l; i++) {\r\n            shapeHole = shapeHoles[i];\r\n            if (ShapeUtils.isClockWise(shapeHole) === true) {\r\n                shapeHoles[i] = shapeHole.reverse();\r\n            }\r\n        }\r\n        var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\r\n        // join vertices of inner and outer paths to a single array\r\n        for (i = 0, l = shapeHoles.length; i < l; i++) {\r\n            shapeHole = shapeHoles[i];\r\n            shapeVertices = shapeVertices.concat(shapeHole);\r\n        }\r\n        // vertices, normals, uvs\r\n        for (i = 0, l = shapeVertices.length; i < l; i++) {\r\n            var vertex = shapeVertices[i];\r\n            vertices.push(vertex.x, vertex.y, 0);\r\n            normals.push(0, 0, 1);\r\n            uvs.push(vertex.x, vertex.y); // world uvs\r\n        }\r\n        // incides\r\n        for (i = 0, l = faces.length; i < l; i++) {\r\n            var face = faces[i];\r\n            var a = face[0] + indexOffset;\r\n            var b = face[1] + indexOffset;\r\n            var c = face[2] + indexOffset;\r\n            indices.push(a, b, c);\r\n            groupCount += 3;\r\n        }\r\n    }\r\n}\r\nShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\r\nShapeBufferGeometry.prototype.toJSON = function () {\r\n    var data = BufferGeometry.prototype.toJSON.call(this);\r\n    var shapes = this.parameters.shapes;\r\n    return toJSON$1(shapes, data);\r\n};\r\n//\r\nfunction toJSON$1(shapes, data) {\r\n    data.shapes = [];\r\n    if (Array.isArray(shapes)) {\r\n        for (var i = 0, l = shapes.length; i < l; i++) {\r\n            var shape = shapes[i];\r\n            data.shapes.push(shape.uuid);\r\n        }\r\n    }\r\n    else {\r\n        data.shapes.push(shapes.uuid);\r\n    }\r\n    return data;\r\n}\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction EdgesGeometry(geometry, thresholdAngle) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'EdgesGeometry';\r\n    this.parameters = {\r\n        thresholdAngle: thresholdAngle\r\n    };\r\n    thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;\r\n    // buffer\r\n    var vertices = [];\r\n    // helper variables\r\n    var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);\r\n    var edge = [0, 0], edges = {}, edge1, edge2;\r\n    var key, keys = ['a', 'b', 'c'];\r\n    // prepare source geometry\r\n    var geometry2;\r\n    if (geometry.isBufferGeometry) {\r\n        geometry2 = new Geometry();\r\n        geometry2.fromBufferGeometry(geometry);\r\n    }\r\n    else {\r\n        geometry2 = geometry.clone();\r\n    }\r\n    geometry2.mergeVertices();\r\n    geometry2.computeFaceNormals();\r\n    var sourceVertices = geometry2.vertices;\r\n    var faces = geometry2.faces;\r\n    // now create a data structure where each entry represents an edge with its adjoining faces\r\n    for (var i = 0, l = faces.length; i < l; i++) {\r\n        var face = faces[i];\r\n        for (var j = 0; j < 3; j++) {\r\n            edge1 = face[keys[j]];\r\n            edge2 = face[keys[(j + 1) % 3]];\r\n            edge[0] = Math.min(edge1, edge2);\r\n            edge[1] = Math.max(edge1, edge2);\r\n            key = edge[0] + ',' + edge[1];\r\n            if (edges[key] === undefined) {\r\n                edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };\r\n            }\r\n            else {\r\n                edges[key].face2 = i;\r\n            }\r\n        }\r\n    }\r\n    // generate vertices\r\n    for (key in edges) {\r\n        var e = edges[key];\r\n        // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\r\n        if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {\r\n            var vertex = sourceVertices[e.index1];\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            vertex = sourceVertices[e.index2];\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n        }\r\n    }\r\n    // build geometry\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n}\r\nEdgesGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nEdgesGeometry.prototype.constructor = EdgesGeometry;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n// CylinderGeometry\r\nfunction CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\r\n    Geometry.call(this);\r\n    this.type = 'CylinderGeometry';\r\n    this.parameters = {\r\n        radiusTop: radiusTop,\r\n        radiusBottom: radiusBottom,\r\n        height: height,\r\n        radialSegments: radialSegments,\r\n        heightSegments: heightSegments,\r\n        openEnded: openEnded,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));\r\n    this.mergeVertices();\r\n}\r\nCylinderGeometry.prototype = Object.create(Geometry.prototype);\r\nCylinderGeometry.prototype.constructor = CylinderGeometry;\r\n// CylinderBufferGeometry\r\nfunction CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'CylinderBufferGeometry';\r\n    this.parameters = {\r\n        radiusTop: radiusTop,\r\n        radiusBottom: radiusBottom,\r\n        height: height,\r\n        radialSegments: radialSegments,\r\n        heightSegments: heightSegments,\r\n        openEnded: openEnded,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    var scope = this;\r\n    radiusTop = radiusTop !== undefined ? radiusTop : 1;\r\n    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\r\n    height = height || 1;\r\n    radialSegments = Math.floor(radialSegments) || 8;\r\n    heightSegments = Math.floor(heightSegments) || 1;\r\n    openEnded = openEnded !== undefined ? openEnded : false;\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var index = 0;\r\n    var indexArray = [];\r\n    var halfHeight = height / 2;\r\n    var groupStart = 0;\r\n    // generate geometry\r\n    generateTorso();\r\n    if (openEnded === false) {\r\n        if (radiusTop > 0)\r\n            generateCap(true);\r\n        if (radiusBottom > 0)\r\n            generateCap(false);\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n    function generateTorso() {\r\n        var x, y;\r\n        var normal = new Vector3();\r\n        var vertex = new Vector3();\r\n        var groupCount = 0;\r\n        // this will be used to calculate the normal\r\n        var slope = (radiusBottom - radiusTop) / height;\r\n        // generate vertices, normals and uvs\r\n        for (y = 0; y <= heightSegments; y++) {\r\n            var indexRow = [];\r\n            var v = y / heightSegments;\r\n            // calculate the radius of the current row\r\n            var radius = v * (radiusBottom - radiusTop) + radiusTop;\r\n            for (x = 0; x <= radialSegments; x++) {\r\n                var u = x / radialSegments;\r\n                var theta = u * thetaLength + thetaStart;\r\n                var sinTheta = Math.sin(theta);\r\n                var cosTheta = Math.cos(theta);\r\n                // vertex\r\n                vertex.x = radius * sinTheta;\r\n                vertex.y = -v * height + halfHeight;\r\n                vertex.z = radius * cosTheta;\r\n                vertices.push(vertex.x, vertex.y, vertex.z);\r\n                // normal\r\n                normal.set(sinTheta, slope, cosTheta).normalize();\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                // uv\r\n                uvs.push(u, 1 - v);\r\n                // save index of vertex in respective row\r\n                indexRow.push(index++);\r\n            }\r\n            // now save vertices of the row in our index array\r\n            indexArray.push(indexRow);\r\n        }\r\n        // generate indices\r\n        for (x = 0; x < radialSegments; x++) {\r\n            for (y = 0; y < heightSegments; y++) {\r\n                // we use the index array to access the correct indices\r\n                var a = indexArray[y][x];\r\n                var b = indexArray[y + 1][x];\r\n                var c = indexArray[y + 1][x + 1];\r\n                var d = indexArray[y][x + 1];\r\n                // faces\r\n                indices.push(a, b, d);\r\n                indices.push(b, c, d);\r\n                // update group counter\r\n                groupCount += 6;\r\n            }\r\n        }\r\n        // add a group to the geometry. this will ensure multi material support\r\n        scope.addGroup(groupStart, groupCount, 0);\r\n        // calculate new start value for groups\r\n        groupStart += groupCount;\r\n    }\r\n    function generateCap(top) {\r\n        var x, centerIndexStart, centerIndexEnd;\r\n        var uv = new Vector2();\r\n        var vertex = new Vector3();\r\n        var groupCount = 0;\r\n        var radius = (top === true) ? radiusTop : radiusBottom;\r\n        var sign = (top === true) ? 1 : -1;\r\n        // save the index of the first center vertex\r\n        centerIndexStart = index;\r\n        // first we generate the center vertex data of the cap.\r\n        // because the geometry needs one set of uvs per face,\r\n        // we must generate a center vertex per face/segment\r\n        for (x = 1; x <= radialSegments; x++) {\r\n            // vertex\r\n            vertices.push(0, halfHeight * sign, 0);\r\n            // normal\r\n            normals.push(0, sign, 0);\r\n            // uv\r\n            uvs.push(0.5, 0.5);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // save the index of the last center vertex\r\n        centerIndexEnd = index;\r\n        // now we generate the surrounding vertices, normals and uvs\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            var u = x / radialSegments;\r\n            var theta = u * thetaLength + thetaStart;\r\n            var cosTheta = Math.cos(theta);\r\n            var sinTheta = Math.sin(theta);\r\n            // vertex\r\n            vertex.x = radius * sinTheta;\r\n            vertex.y = halfHeight * sign;\r\n            vertex.z = radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normals.push(0, sign, 0);\r\n            // uv\r\n            uv.x = (cosTheta * 0.5) + 0.5;\r\n            uv.y = (sinTheta * 0.5 * sign) + 0.5;\r\n            uvs.push(uv.x, uv.y);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // generate indices\r\n        for (x = 0; x < radialSegments; x++) {\r\n            var c = centerIndexStart + x;\r\n            var i = centerIndexEnd + x;\r\n            if (top === true) {\r\n                // face top\r\n                indices.push(i, i + 1, c);\r\n            }\r\n            else {\r\n                // face bottom\r\n                indices.push(i + 1, i, c);\r\n            }\r\n            groupCount += 3;\r\n        }\r\n        // add a group to the geometry. this will ensure multi material support\r\n        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);\r\n        // calculate new start value for groups\r\n        groupStart += groupCount;\r\n    }\r\n}\r\nCylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\r\n/**\r\n * @author abelnation / http://github.com/abelnation\r\n */\r\n// ConeGeometry\r\nfunction ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\r\n    CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\r\n    this.type = 'ConeGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        height: height,\r\n        radialSegments: radialSegments,\r\n        heightSegments: heightSegments,\r\n        openEnded: openEnded,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n}\r\nConeGeometry.prototype = Object.create(CylinderGeometry.prototype);\r\nConeGeometry.prototype.constructor = ConeGeometry;\r\n// ConeBufferGeometry\r\nfunction ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\r\n    CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\r\n    this.type = 'ConeBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        height: height,\r\n        radialSegments: radialSegments,\r\n        heightSegments: heightSegments,\r\n        openEnded: openEnded,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n}\r\nConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);\r\nConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * @author hughes\r\n */\r\n// CircleGeometry\r\nfunction CircleGeometry(radius, segments, thetaStart, thetaLength) {\r\n    Geometry.call(this);\r\n    this.type = 'CircleGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        segments: segments,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));\r\n    this.mergeVertices();\r\n}\r\nCircleGeometry.prototype = Object.create(Geometry.prototype);\r\nCircleGeometry.prototype.constructor = CircleGeometry;\r\n// CircleBufferGeometry\r\nfunction CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {\r\n    BufferGeometry.call(this);\r\n    this.type = 'CircleBufferGeometry';\r\n    this.parameters = {\r\n        radius: radius,\r\n        segments: segments,\r\n        thetaStart: thetaStart,\r\n        thetaLength: thetaLength\r\n    };\r\n    radius = radius || 1;\r\n    segments = segments !== undefined ? Math.max(3, segments) : 8;\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    // helper variables\r\n    var i, s;\r\n    var vertex = new Vector3();\r\n    var uv = new Vector2();\r\n    // center point\r\n    vertices.push(0, 0, 0);\r\n    normals.push(0, 0, 1);\r\n    uvs.push(0.5, 0.5);\r\n    for (s = 0, i = 3; s <= segments; s++, i += 3) {\r\n        var segment = thetaStart + s / segments * thetaLength;\r\n        // vertex\r\n        vertex.x = radius * Math.cos(segment);\r\n        vertex.y = radius * Math.sin(segment);\r\n        vertices.push(vertex.x, vertex.y, vertex.z);\r\n        // normal\r\n        normals.push(0, 0, 1);\r\n        // uvs\r\n        uv.x = (vertices[i] / radius + 1) / 2;\r\n        uv.y = (vertices[i + 1] / radius + 1) / 2;\r\n        uvs.push(uv.x, uv.y);\r\n    }\r\n    // indices\r\n    for (i = 1; i <= segments; i++) {\r\n        indices.push(i, i + 1, 0);\r\n    }\r\n    // build geometry\r\n    this.setIndex(indices);\r\n    this.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.addAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n}\r\nCircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\r\nCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\r\nvar Geometries = /*#__PURE__*/ Object.freeze({\r\n    WireframeGeometry: WireframeGeometry,\r\n    ParametricGeometry: ParametricGeometry,\r\n    ParametricBufferGeometry: ParametricBufferGeometry,\r\n    TetrahedronGeometry: TetrahedronGeometry,\r\n    TetrahedronBufferGeometry: TetrahedronBufferGeometry,\r\n    OctahedronGeometry: OctahedronGeometry,\r\n    OctahedronBufferGeometry: OctahedronBufferGeometry,\r\n    IcosahedronGeometry: IcosahedronGeometry,\r\n    IcosahedronBufferGeometry: IcosahedronBufferGeometry,\r\n    DodecahedronGeometry: DodecahedronGeometry,\r\n    DodecahedronBufferGeometry: DodecahedronBufferGeometry,\r\n    PolyhedronGeometry: PolyhedronGeometry,\r\n    PolyhedronBufferGeometry: PolyhedronBufferGeometry,\r\n    TubeGeometry: TubeGeometry,\r\n    TubeBufferGeometry: TubeBufferGeometry,\r\n    TorusKnotGeometry: TorusKnotGeometry,\r\n    TorusKnotBufferGeometry: TorusKnotBufferGeometry,\r\n    TorusGeometry: TorusGeometry,\r\n    TorusBufferGeometry: TorusBufferGeometry,\r\n    TextGeometry: TextGeometry,\r\n    TextBufferGeometry: TextBufferGeometry,\r\n    SphereGeometry: SphereGeometry,\r\n    SphereBufferGeometry: SphereBufferGeometry,\r\n    RingGeometry: RingGeometry,\r\n    RingBufferGeometry: RingBufferGeometry,\r\n    PlaneGeometry: PlaneGeometry,\r\n    PlaneBufferGeometry: PlaneBufferGeometry,\r\n    LatheGeometry: LatheGeometry,\r\n    LatheBufferGeometry: LatheBufferGeometry,\r\n    ShapeGeometry: ShapeGeometry,\r\n    ShapeBufferGeometry: ShapeBufferGeometry,\r\n    ExtrudeGeometry: ExtrudeGeometry,\r\n    ExtrudeBufferGeometry: ExtrudeBufferGeometry,\r\n    EdgesGeometry: EdgesGeometry,\r\n    ConeGeometry: ConeGeometry,\r\n    ConeBufferGeometry: ConeBufferGeometry,\r\n    CylinderGeometry: CylinderGeometry,\r\n    CylinderBufferGeometry: CylinderBufferGeometry,\r\n    CircleGeometry: CircleGeometry,\r\n    CircleBufferGeometry: CircleBufferGeometry,\r\n    BoxGeometry: BoxGeometry,\r\n    BoxBufferGeometry: BoxBufferGeometry\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  color: <THREE.Color>\r\n * }\r\n */\r\nfunction ShadowMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'ShadowMaterial';\r\n    this.color = new Color(0x000000);\r\n    this.transparent = true;\r\n    this.setValues(parameters);\r\n}\r\nShadowMaterial.prototype = Object.create(Material$1.prototype);\r\nShadowMaterial.prototype.constructor = ShadowMaterial;\r\nShadowMaterial.prototype.isShadowMaterial = true;\r\nShadowMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction RawShaderMaterial(parameters) {\r\n    ShaderMaterial.call(this, parameters);\r\n    this.type = 'RawShaderMaterial';\r\n}\r\nRawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);\r\nRawShaderMaterial.prototype.constructor = RawShaderMaterial;\r\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  roughness: <float>,\r\n *  metalness: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalMapType: THREE.TangentSpaceNormalMap,\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  roughnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  metalnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  envMapIntensity: <float>\r\n *\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction MeshStandardMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.defines = { 'STANDARD': '' };\r\n    this.type = 'MeshStandardMaterial';\r\n    this.color = new Color(0xffffff); // diffuse\r\n    this.roughness = 0.5;\r\n    this.metalness = 0.5;\r\n    this.map = null;\r\n    this.lightMap = null;\r\n    this.lightMapIntensity = 1.0;\r\n    this.aoMap = null;\r\n    this.aoMapIntensity = 1.0;\r\n    this.emissive = new Color(0x000000);\r\n    this.emissiveIntensity = 1.0;\r\n    this.emissiveMap = null;\r\n    this.bumpMap = null;\r\n    this.bumpScale = 1;\r\n    this.normalMap = null;\r\n    this.normalMapType = TangentSpaceNormalMap;\r\n    this.normalScale = new Vector2(1, 1);\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.roughnessMap = null;\r\n    this.metalnessMap = null;\r\n    this.alphaMap = null;\r\n    this.envMap = null;\r\n    this.envMapIntensity = 1.0;\r\n    this.refractionRatio = 0.98;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.wireframeLinecap = 'round';\r\n    this.wireframeLinejoin = 'round';\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.morphNormals = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshStandardMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\r\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\r\nMeshStandardMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.defines = { 'STANDARD': '' };\r\n    this.color.copy(source.color);\r\n    this.roughness = source.roughness;\r\n    this.metalness = source.metalness;\r\n    this.map = source.map;\r\n    this.lightMap = source.lightMap;\r\n    this.lightMapIntensity = source.lightMapIntensity;\r\n    this.aoMap = source.aoMap;\r\n    this.aoMapIntensity = source.aoMapIntensity;\r\n    this.emissive.copy(source.emissive);\r\n    this.emissiveMap = source.emissiveMap;\r\n    this.emissiveIntensity = source.emissiveIntensity;\r\n    this.bumpMap = source.bumpMap;\r\n    this.bumpScale = source.bumpScale;\r\n    this.normalMap = source.normalMap;\r\n    this.normalMapType = source.normalMapType;\r\n    this.normalScale.copy(source.normalScale);\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    this.roughnessMap = source.roughnessMap;\r\n    this.metalnessMap = source.metalnessMap;\r\n    this.alphaMap = source.alphaMap;\r\n    this.envMap = source.envMap;\r\n    this.envMapIntensity = source.envMapIntensity;\r\n    this.refractionRatio = source.refractionRatio;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.wireframeLinecap = source.wireframeLinecap;\r\n    this.wireframeLinejoin = source.wireframeLinejoin;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    return this;\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  reflectivity: <float>\r\n *  clearCoat: <float>\r\n *  clearCoatRoughness: <float>\r\n * }\r\n */\r\nfunction MeshPhysicalMaterial(parameters) {\r\n    MeshStandardMaterial.call(this);\r\n    this.defines = { 'PHYSICAL': '' };\r\n    this.type = 'MeshPhysicalMaterial';\r\n    this.reflectivity = 0.5; // maps to F0 = 0.04\r\n    this.clearCoat = 0.0;\r\n    this.clearCoatRoughness = 0.0;\r\n    this.setValues(parameters);\r\n}\r\nMeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);\r\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\r\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\r\nMeshPhysicalMaterial.prototype.copy = function (source) {\r\n    MeshStandardMaterial.prototype.copy.call(this, source);\r\n    this.defines = { 'PHYSICAL': '' };\r\n    this.reflectivity = source.reflectivity;\r\n    this.clearCoat = source.clearCoat;\r\n    this.clearCoatRoughness = source.clearCoatRoughness;\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalMapType: THREE.TangentSpaceNormalMap,\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction MeshPhongMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshPhongMaterial';\r\n    this.color = new Color(0xffffff); // diffuse\r\n    this.specular = new Color(0x111111);\r\n    this.shininess = 30;\r\n    this.map = null;\r\n    this.lightMap = null;\r\n    this.lightMapIntensity = 1.0;\r\n    this.aoMap = null;\r\n    this.aoMapIntensity = 1.0;\r\n    this.emissive = new Color(0x000000);\r\n    this.emissiveIntensity = 1.0;\r\n    this.emissiveMap = null;\r\n    this.bumpMap = null;\r\n    this.bumpScale = 1;\r\n    this.normalMap = null;\r\n    this.normalMapType = TangentSpaceNormalMap;\r\n    this.normalScale = new Vector2(1, 1);\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.specularMap = null;\r\n    this.alphaMap = null;\r\n    this.envMap = null;\r\n    this.combine = MultiplyOperation;\r\n    this.reflectivity = 1;\r\n    this.refractionRatio = 0.98;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.wireframeLinecap = 'round';\r\n    this.wireframeLinejoin = 'round';\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.morphNormals = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshPhongMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\r\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\r\nMeshPhongMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.specular.copy(source.specular);\r\n    this.shininess = source.shininess;\r\n    this.map = source.map;\r\n    this.lightMap = source.lightMap;\r\n    this.lightMapIntensity = source.lightMapIntensity;\r\n    this.aoMap = source.aoMap;\r\n    this.aoMapIntensity = source.aoMapIntensity;\r\n    this.emissive.copy(source.emissive);\r\n    this.emissiveMap = source.emissiveMap;\r\n    this.emissiveIntensity = source.emissiveIntensity;\r\n    this.bumpMap = source.bumpMap;\r\n    this.bumpScale = source.bumpScale;\r\n    this.normalMap = source.normalMap;\r\n    this.normalMapType = source.normalMapType;\r\n    this.normalScale.copy(source.normalScale);\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    this.specularMap = source.specularMap;\r\n    this.alphaMap = source.alphaMap;\r\n    this.envMap = source.envMap;\r\n    this.combine = source.combine;\r\n    this.reflectivity = source.reflectivity;\r\n    this.refractionRatio = source.refractionRatio;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.wireframeLinecap = source.wireframeLinecap;\r\n    this.wireframeLinejoin = source.wireframeLinejoin;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    return this;\r\n};\r\n/**\r\n * @author takahirox / http://github.com/takahirox\r\n *\r\n * parameters = {\r\n *  gradientMap: new THREE.Texture( <Image> )\r\n * }\r\n */\r\nfunction MeshToonMaterial(parameters) {\r\n    MeshPhongMaterial.call(this);\r\n    this.defines = { 'TOON': '' };\r\n    this.type = 'MeshToonMaterial';\r\n    this.gradientMap = null;\r\n    this.setValues(parameters);\r\n}\r\nMeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);\r\nMeshToonMaterial.prototype.constructor = MeshToonMaterial;\r\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\r\nMeshToonMaterial.prototype.copy = function (source) {\r\n    MeshPhongMaterial.prototype.copy.call(this, source);\r\n    this.gradientMap = source.gradientMap;\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalMapType: THREE.TangentSpaceNormalMap,\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction MeshNormalMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshNormalMaterial';\r\n    this.bumpMap = null;\r\n    this.bumpScale = 1;\r\n    this.normalMap = null;\r\n    this.normalMapType = TangentSpaceNormalMap;\r\n    this.normalScale = new Vector2(1, 1);\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.fog = false;\r\n    this.lights = false;\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.morphNormals = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshNormalMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\r\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\r\nMeshNormalMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.bumpMap = source.bumpMap;\r\n    this.bumpScale = source.bumpScale;\r\n    this.normalMap = source.normalMap;\r\n    this.normalMapType = source.normalMapType;\r\n    this.normalScale.copy(source.normalScale);\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    return this;\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction MeshLambertMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.type = 'MeshLambertMaterial';\r\n    this.color = new Color(0xffffff); // diffuse\r\n    this.map = null;\r\n    this.lightMap = null;\r\n    this.lightMapIntensity = 1.0;\r\n    this.aoMap = null;\r\n    this.aoMapIntensity = 1.0;\r\n    this.emissive = new Color(0x000000);\r\n    this.emissiveIntensity = 1.0;\r\n    this.emissiveMap = null;\r\n    this.specularMap = null;\r\n    this.alphaMap = null;\r\n    this.envMap = null;\r\n    this.combine = MultiplyOperation;\r\n    this.reflectivity = 1;\r\n    this.refractionRatio = 0.98;\r\n    this.wireframe = false;\r\n    this.wireframeLinewidth = 1;\r\n    this.wireframeLinecap = 'round';\r\n    this.wireframeLinejoin = 'round';\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.morphNormals = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshLambertMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\r\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\r\nMeshLambertMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.color.copy(source.color);\r\n    this.map = source.map;\r\n    this.lightMap = source.lightMap;\r\n    this.lightMapIntensity = source.lightMapIntensity;\r\n    this.aoMap = source.aoMap;\r\n    this.aoMapIntensity = source.aoMapIntensity;\r\n    this.emissive.copy(source.emissive);\r\n    this.emissiveMap = source.emissiveMap;\r\n    this.emissiveIntensity = source.emissiveIntensity;\r\n    this.specularMap = source.specularMap;\r\n    this.alphaMap = source.alphaMap;\r\n    this.envMap = source.envMap;\r\n    this.combine = source.combine;\r\n    this.reflectivity = source.reflectivity;\r\n    this.refractionRatio = source.refractionRatio;\r\n    this.wireframe = source.wireframe;\r\n    this.wireframeLinewidth = source.wireframeLinewidth;\r\n    this.wireframeLinecap = source.wireframeLinecap;\r\n    this.wireframeLinejoin = source.wireframeLinejoin;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    return this;\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  matcap: new THREE.Texture( <Image> ),\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalMapType: THREE.TangentSpaceNormalMap,\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\nfunction MeshMatcapMaterial(parameters) {\r\n    Material$1.call(this);\r\n    this.defines = { 'MATCAP': '' };\r\n    this.type = 'MeshMatcapMaterial';\r\n    this.color = new Color(0xffffff); // diffuse\r\n    this.matcap = null;\r\n    this.map = null;\r\n    this.bumpMap = null;\r\n    this.bumpScale = 1;\r\n    this.normalMap = null;\r\n    this.normalMapType = TangentSpaceNormalMap;\r\n    this.normalScale = new Vector2(1, 1);\r\n    this.displacementMap = null;\r\n    this.displacementScale = 1;\r\n    this.displacementBias = 0;\r\n    this.alphaMap = null;\r\n    this.skinning = false;\r\n    this.morphTargets = false;\r\n    this.morphNormals = false;\r\n    this.lights = false;\r\n    this.setValues(parameters);\r\n}\r\nMeshMatcapMaterial.prototype = Object.create(Material$1.prototype);\r\nMeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;\r\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\r\nMeshMatcapMaterial.prototype.copy = function (source) {\r\n    Material$1.prototype.copy.call(this, source);\r\n    this.defines = { 'MATCAP': '' };\r\n    this.color.copy(source.color);\r\n    this.matcap = source.matcap;\r\n    this.map = source.map;\r\n    this.bumpMap = source.bumpMap;\r\n    this.bumpScale = source.bumpScale;\r\n    this.normalMap = source.normalMap;\r\n    this.normalMapType = source.normalMapType;\r\n    this.normalScale.copy(source.normalScale);\r\n    this.displacementMap = source.displacementMap;\r\n    this.displacementScale = source.displacementScale;\r\n    this.displacementBias = source.displacementBias;\r\n    this.alphaMap = source.alphaMap;\r\n    this.skinning = source.skinning;\r\n    this.morphTargets = source.morphTargets;\r\n    this.morphNormals = source.morphNormals;\r\n    return this;\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>\r\n * }\r\n */\r\nfunction LineDashedMaterial(parameters) {\r\n    LineBasicMaterial.call(this);\r\n    this.type = 'LineDashedMaterial';\r\n    this.scale = 1;\r\n    this.dashSize = 3;\r\n    this.gapSize = 1;\r\n    this.setValues(parameters);\r\n}\r\nLineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);\r\nLineDashedMaterial.prototype.constructor = LineDashedMaterial;\r\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\r\nLineDashedMaterial.prototype.copy = function (source) {\r\n    LineBasicMaterial.prototype.copy.call(this, source);\r\n    this.scale = source.scale;\r\n    this.dashSize = source.dashSize;\r\n    this.gapSize = source.gapSize;\r\n    return this;\r\n};\r\nvar Materials = /*#__PURE__*/ Object.freeze({\r\n    ShadowMaterial: ShadowMaterial,\r\n    SpriteMaterial: SpriteMaterial,\r\n    RawShaderMaterial: RawShaderMaterial,\r\n    ShaderMaterial: ShaderMaterial,\r\n    PointsMaterial: PointsMaterial,\r\n    MeshPhysicalMaterial: MeshPhysicalMaterial,\r\n    MeshStandardMaterial: MeshStandardMaterial,\r\n    MeshPhongMaterial: MeshPhongMaterial,\r\n    MeshToonMaterial: MeshToonMaterial,\r\n    MeshNormalMaterial: MeshNormalMaterial,\r\n    MeshLambertMaterial: MeshLambertMaterial,\r\n    MeshDepthMaterial: MeshDepthMaterial,\r\n    MeshDistanceMaterial: MeshDistanceMaterial,\r\n    MeshBasicMaterial: MeshBasicMaterial,\r\n    MeshMatcapMaterial: MeshMatcapMaterial,\r\n    LineDashedMaterial: LineDashedMaterial,\r\n    LineBasicMaterial: LineBasicMaterial,\r\n    Material: Material$1\r\n});\r\n/**\r\n * @author tschw\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\nvar AnimationUtils = {\r\n    // same as Array.prototype.slice, but also works on typed arrays\r\n    arraySlice: function (array, from, to) {\r\n        if (AnimationUtils.isTypedArray(array)) {\r\n            // in ios9 array.subarray(from, undefined) will return empty array\r\n            // but array.subarray(from) or array.subarray(from, len) is correct\r\n            return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\r\n        }\r\n        return array.slice(from, to);\r\n    },\r\n    // converts an array to a specific type\r\n    convertArray: function (array, type, forceClone) {\r\n        if (!array || // let 'undefined' and 'null' pass\r\n            !forceClone && array.constructor === type)\r\n            return array;\r\n        if (typeof type.BYTES_PER_ELEMENT === 'number') {\r\n            return new type(array); // create typed array\r\n        }\r\n        return Array.prototype.slice.call(array); // create Array\r\n    },\r\n    isTypedArray: function (object) {\r\n        return ArrayBuffer.isView(object) &&\r\n            !(object instanceof DataView);\r\n    },\r\n    // returns an array by which times and values can be sorted\r\n    getKeyframeOrder: function (times) {\r\n        function compareTime(i, j) {\r\n            return times[i] - times[j];\r\n        }\r\n        var n = times.length;\r\n        var result = new Array(n);\r\n        for (var i = 0; i !== n; ++i)\r\n            result[i] = i;\r\n        result.sort(compareTime);\r\n        return result;\r\n    },\r\n    // uses the array previously returned by 'getKeyframeOrder' to sort data\r\n    sortedArray: function (values, stride, order) {\r\n        var nValues = values.length;\r\n        var result = new values.constructor(nValues);\r\n        for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\r\n            var srcOffset = order[i] * stride;\r\n            for (var j = 0; j !== stride; ++j) {\r\n                result[dstOffset++] = values[srcOffset + j];\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    // function for parsing AOS keyframe formats\r\n    flattenJSON: function (jsonKeys, times, values, valuePropertyName) {\r\n        var i = 1, key = jsonKeys[0];\r\n        while (key !== undefined && key[valuePropertyName] === undefined) {\r\n            key = jsonKeys[i++];\r\n        }\r\n        if (key === undefined)\r\n            return; // no data\r\n        var value = key[valuePropertyName];\r\n        if (value === undefined)\r\n            return; // no data\r\n        if (Array.isArray(value)) {\r\n            do {\r\n                value = key[valuePropertyName];\r\n                if (value !== undefined) {\r\n                    times.push(key.time);\r\n                    values.push.apply(values, value); // push all elements\r\n                }\r\n                key = jsonKeys[i++];\r\n            } while (key !== undefined);\r\n        }\r\n        else if (value.toArray !== undefined) {\r\n            // ...assume THREE.Math-ish\r\n            do {\r\n                value = key[valuePropertyName];\r\n                if (value !== undefined) {\r\n                    times.push(key.time);\r\n                    value.toArray(values, values.length);\r\n                }\r\n                key = jsonKeys[i++];\r\n            } while (key !== undefined);\r\n        }\r\n        else {\r\n            // otherwise push as-is\r\n            do {\r\n                value = key[valuePropertyName];\r\n                if (value !== undefined) {\r\n                    times.push(key.time);\r\n                    values.push(value);\r\n                }\r\n                key = jsonKeys[i++];\r\n            } while (key !== undefined);\r\n        }\r\n    }\r\n};\r\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n * @author tschw\r\n */\r\nfunction Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    this.parameterPositions = parameterPositions;\r\n    this._cachedIndex = 0;\r\n    this.resultBuffer = resultBuffer !== undefined ?\r\n        resultBuffer : new sampleValues.constructor(sampleSize);\r\n    this.sampleValues = sampleValues;\r\n    this.valueSize = sampleSize;\r\n}\r\nObject.assign(Interpolant.prototype, {\r\n    evaluate: function (t) {\r\n        var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];\r\n        validate_interval: {\r\n            seek: {\r\n                var right;\r\n                linear_scan: {\r\n                    //- See http://jsperf.com/comparison-to-undefined/3\r\n                    //- slower code:\r\n                    //-\r\n                    //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n                    forward_scan: if (!(t < t1)) {\r\n                        for (var giveUpAt = i1 + 2;;) {\r\n                            if (t1 === undefined) {\r\n                                if (t < t0)\r\n                                    break forward_scan;\r\n                                // after end\r\n                                i1 = pp.length;\r\n                                this._cachedIndex = i1;\r\n                                return this.afterEnd_(i1 - 1, t, t0);\r\n                            }\r\n                            if (i1 === giveUpAt)\r\n                                break; // this loop\r\n                            t0 = t1;\r\n                            t1 = pp[++i1];\r\n                            if (t < t1) {\r\n                                // we have arrived at the sought interval\r\n                                break seek;\r\n                            }\r\n                        }\r\n                        // prepare binary search on the right side of the index\r\n                        right = pp.length;\r\n                        break linear_scan;\r\n                    }\r\n                    //- slower code:\r\n                    //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n                    if (!(t >= t0)) {\r\n                        // looping?\r\n                        var t1global = pp[1];\r\n                        if (t < t1global) {\r\n                            i1 = 2; // + 1, using the scan for the details\r\n                            t0 = t1global;\r\n                        }\r\n                        // linear reverse scan\r\n                        for (var giveUpAt = i1 - 2;;) {\r\n                            if (t0 === undefined) {\r\n                                // before start\r\n                                this._cachedIndex = 0;\r\n                                return this.beforeStart_(0, t, t1);\r\n                            }\r\n                            if (i1 === giveUpAt)\r\n                                break; // this loop\r\n                            t1 = t0;\r\n                            t0 = pp[--i1 - 1];\r\n                            if (t >= t0) {\r\n                                // we have arrived at the sought interval\r\n                                break seek;\r\n                            }\r\n                        }\r\n                        // prepare binary search on the left side of the index\r\n                        right = i1;\r\n                        i1 = 0;\r\n                        break linear_scan;\r\n                    }\r\n                    // the interval is valid\r\n                    break validate_interval;\r\n                } // linear scan\r\n                // binary search\r\n                while (i1 < right) {\r\n                    var mid = (i1 + right) >>> 1;\r\n                    if (t < pp[mid]) {\r\n                        right = mid;\r\n                    }\r\n                    else {\r\n                        i1 = mid + 1;\r\n                    }\r\n                }\r\n                t1 = pp[i1];\r\n                t0 = pp[i1 - 1];\r\n                // check boundary cases, again\r\n                if (t0 === undefined) {\r\n                    this._cachedIndex = 0;\r\n                    return this.beforeStart_(0, t, t1);\r\n                }\r\n                if (t1 === undefined) {\r\n                    i1 = pp.length;\r\n                    this._cachedIndex = i1;\r\n                    return this.afterEnd_(i1 - 1, t0, t);\r\n                }\r\n            } // seek\r\n            this._cachedIndex = i1;\r\n            this.intervalChanged_(i1, t0, t1);\r\n        } // validate_interval\r\n        return this.interpolate_(i1, t0, t, t1);\r\n    },\r\n    settings: null,\r\n    // Note: The indirection allows central control of many interpolants.\r\n    // --- Protected interface\r\n    DefaultSettings_: {},\r\n    getSettings_: function () {\r\n        return this.settings || this.DefaultSettings_;\r\n    },\r\n    copySampleValue_: function (index) {\r\n        // copies a sample value to the result buffer\r\n        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;\r\n        for (var i = 0; i !== stride; ++i) {\r\n            result[i] = values[offset + i];\r\n        }\r\n        return result;\r\n    },\r\n    // Template methods for derived classes:\r\n    interpolate_: function ( /* i1, t0, t, t1 */) {\r\n        throw new Error('call to abstract method');\r\n        // implementations shall return this.resultBuffer\r\n    },\r\n    intervalChanged_: function ( /* i1, t0, t1 */) {\r\n        // empty\r\n    }\r\n});\r\n//!\\ DECLARE ALIAS AFTER assign prototype !\r\nObject.assign(Interpolant.prototype, {\r\n    //( 0, t, t0 ), returns this.resultBuffer\r\n    beforeStart_: Interpolant.prototype.copySampleValue_,\r\n    //( N-1, tN-1, t ), returns this.resultBuffer\r\n    afterEnd_: Interpolant.prototype.copySampleValue_,\r\n});\r\n/**\r\n * Fast and simple cubic spline interpolant.\r\n *\r\n * It was derived from a Hermitian construction setting the first derivative\r\n * at each sample position to the linear slope between neighboring positions\r\n * over their parameter interval.\r\n *\r\n * @author tschw\r\n */\r\nfunction CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n    this._weightPrev = -0;\r\n    this._offsetPrev = -0;\r\n    this._weightNext = -0;\r\n    this._offsetNext = -0;\r\n}\r\nCubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {\r\n    constructor: CubicInterpolant,\r\n    DefaultSettings_: {\r\n        endingStart: ZeroCurvatureEnding,\r\n        endingEnd: ZeroCurvatureEnding\r\n    },\r\n    intervalChanged_: function (i1, t0, t1) {\r\n        var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];\r\n        if (tPrev === undefined) {\r\n            switch (this.getSettings_().endingStart) {\r\n                case ZeroSlopeEnding:\r\n                    // f'(t0) = 0\r\n                    iPrev = i1;\r\n                    tPrev = 2 * t0 - t1;\r\n                    break;\r\n                case WrapAroundEnding:\r\n                    // use the other end of the curve\r\n                    iPrev = pp.length - 2;\r\n                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\r\n                    break;\r\n                default: // ZeroCurvatureEnding\r\n                    // f''(t0) = 0 a.k.a. Natural Spline\r\n                    iPrev = i1;\r\n                    tPrev = t1;\r\n            }\r\n        }\r\n        if (tNext === undefined) {\r\n            switch (this.getSettings_().endingEnd) {\r\n                case ZeroSlopeEnding:\r\n                    // f'(tN) = 0\r\n                    iNext = i1;\r\n                    tNext = 2 * t1 - t0;\r\n                    break;\r\n                case WrapAroundEnding:\r\n                    // use the other end of the curve\r\n                    iNext = 1;\r\n                    tNext = t1 + pp[1] - pp[0];\r\n                    break;\r\n                default: // ZeroCurvatureEnding\r\n                    // f''(tN) = 0, a.k.a. Natural Spline\r\n                    iNext = i1 - 1;\r\n                    tNext = t0;\r\n            }\r\n        }\r\n        var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;\r\n        this._weightPrev = halfDt / (t0 - tPrev);\r\n        this._weightNext = halfDt / (tNext - t1);\r\n        this._offsetPrev = iPrev * stride;\r\n        this._offsetNext = iNext * stride;\r\n    },\r\n    interpolate_: function (i1, t0, t, t1) {\r\n        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;\r\n        // evaluate polynomials\r\n        var sP = -wP * ppp + 2 * wP * pp - wP * p;\r\n        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\r\n        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\r\n        var sN = wN * ppp - wN * pp;\r\n        // combine data linearly\r\n        for (var i = 0; i !== stride; ++i) {\r\n            result[i] =\r\n                sP * values[oP + i] +\r\n                    s0 * values[o0 + i] +\r\n                    s1 * values[o1 + i] +\r\n                    sN * values[oN + i];\r\n        }\r\n        return result;\r\n    }\r\n});\r\n/**\r\n * @author tschw\r\n */\r\nfunction LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n}\r\nLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {\r\n    constructor: LinearInterpolant,\r\n    interpolate_: function (i1, t0, t, t1) {\r\n        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;\r\n        for (var i = 0; i !== stride; ++i) {\r\n            result[i] =\r\n                values[offset0 + i] * weight0 +\r\n                    values[offset1 + i] * weight1;\r\n        }\r\n        return result;\r\n    }\r\n});\r\n/**\r\n *\r\n * Interpolant that evaluates to the sample value at the position preceeding\r\n * the parameter.\r\n *\r\n * @author tschw\r\n */\r\nfunction DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n}\r\nDiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {\r\n    constructor: DiscreteInterpolant,\r\n    interpolate_: function (i1 /*, t0, t, t1 */) {\r\n        return this.copySampleValue_(i1 - 1);\r\n    }\r\n});\r\n/**\r\n *\r\n * A timed sequence of keyframes for a specific property.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction KeyframeTrack(name, times, values, interpolation) {\r\n    if (name === undefined)\r\n        throw new Error('THREE.KeyframeTrack: track name is undefined');\r\n    if (times === undefined || times.length === 0)\r\n        throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\r\n    this.name = name;\r\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\r\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\r\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\r\n}\r\n// Static methods\r\nObject.assign(KeyframeTrack, {\r\n    // Serialization (in static context, because of constructor invocation\r\n    // and automatic invocation of .toJSON):\r\n    toJSON: function (track) {\r\n        var trackType = track.constructor;\r\n        var json;\r\n        // derived classes can define a static toJSON method\r\n        if (trackType.toJSON !== undefined) {\r\n            json = trackType.toJSON(track);\r\n        }\r\n        else {\r\n            // by default, we assume the data can be serialized as-is\r\n            json = {\r\n                'name': track.name,\r\n                'times': AnimationUtils.convertArray(track.times, Array),\r\n                'values': AnimationUtils.convertArray(track.values, Array)\r\n            };\r\n            var interpolation = track.getInterpolation();\r\n            if (interpolation !== track.DefaultInterpolation) {\r\n                json.interpolation = interpolation;\r\n            }\r\n        }\r\n        json.type = track.ValueTypeName; // mandatory\r\n        return json;\r\n    }\r\n});\r\nObject.assign(KeyframeTrack.prototype, {\r\n    constructor: KeyframeTrack,\r\n    TimeBufferType: Float32Array,\r\n    ValueBufferType: Float32Array,\r\n    DefaultInterpolation: InterpolateLinear,\r\n    InterpolantFactoryMethodDiscrete: function (result) {\r\n        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\r\n    },\r\n    InterpolantFactoryMethodLinear: function (result) {\r\n        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\r\n    },\r\n    InterpolantFactoryMethodSmooth: function (result) {\r\n        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\r\n    },\r\n    setInterpolation: function (interpolation) {\r\n        var factoryMethod;\r\n        switch (interpolation) {\r\n            case InterpolateDiscrete:\r\n                factoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n                break;\r\n            case InterpolateLinear:\r\n                factoryMethod = this.InterpolantFactoryMethodLinear;\r\n                break;\r\n            case InterpolateSmooth:\r\n                factoryMethod = this.InterpolantFactoryMethodSmooth;\r\n                break;\r\n        }\r\n        if (factoryMethod === undefined) {\r\n            var message = \"unsupported interpolation for \" +\r\n                this.ValueTypeName + \" keyframe track named \" + this.name;\r\n            if (this.createInterpolant === undefined) {\r\n                // fall back to default, unless the default itself is messed up\r\n                if (interpolation !== this.DefaultInterpolation) {\r\n                    this.setInterpolation(this.DefaultInterpolation);\r\n                }\r\n                else {\r\n                    throw new Error(message); // fatal, in this case\r\n                }\r\n            }\r\n            console.warn('THREE.KeyframeTrack:', message);\r\n            return this;\r\n        }\r\n        this.createInterpolant = factoryMethod;\r\n        return this;\r\n    },\r\n    getInterpolation: function () {\r\n        switch (this.createInterpolant) {\r\n            case this.InterpolantFactoryMethodDiscrete:\r\n                return InterpolateDiscrete;\r\n            case this.InterpolantFactoryMethodLinear:\r\n                return InterpolateLinear;\r\n            case this.InterpolantFactoryMethodSmooth:\r\n                return InterpolateSmooth;\r\n        }\r\n    },\r\n    getValueSize: function () {\r\n        return this.values.length / this.times.length;\r\n    },\r\n    // move all keyframes either forwards or backwards in time\r\n    shift: function (timeOffset) {\r\n        if (timeOffset !== 0.0) {\r\n            var times = this.times;\r\n            for (var i = 0, n = times.length; i !== n; ++i) {\r\n                times[i] += timeOffset;\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n    scale: function (timeScale) {\r\n        if (timeScale !== 1.0) {\r\n            var times = this.times;\r\n            for (var i = 0, n = times.length; i !== n; ++i) {\r\n                times[i] *= timeScale;\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n    trim: function (startTime, endTime) {\r\n        var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;\r\n        while (from !== nKeys && times[from] < startTime) {\r\n            ++from;\r\n        }\r\n        while (to !== -1 && times[to] > endTime) {\r\n            --to;\r\n        }\r\n        ++to; // inclusive -> exclusive bound\r\n        if (from !== 0 || to !== nKeys) {\r\n            // empty tracks are forbidden, so keep at least one keyframe\r\n            if (from >= to)\r\n                to = Math.max(to, 1), from = to - 1;\r\n            var stride = this.getValueSize();\r\n            this.times = AnimationUtils.arraySlice(times, from, to);\r\n            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\r\n        }\r\n        return this;\r\n    },\r\n    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n    validate: function () {\r\n        var valid = true;\r\n        var valueSize = this.getValueSize();\r\n        if (valueSize - Math.floor(valueSize) !== 0) {\r\n            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\r\n            valid = false;\r\n        }\r\n        var times = this.times, values = this.values, nKeys = times.length;\r\n        if (nKeys === 0) {\r\n            console.error('THREE.KeyframeTrack: Track is empty.', this);\r\n            valid = false;\r\n        }\r\n        var prevTime = null;\r\n        for (var i = 0; i !== nKeys; i++) {\r\n            var currTime = times[i];\r\n            if (typeof currTime === 'number' && isNaN(currTime)) {\r\n                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\r\n                valid = false;\r\n                break;\r\n            }\r\n            if (prevTime !== null && prevTime > currTime) {\r\n                console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\r\n                valid = false;\r\n                break;\r\n            }\r\n            prevTime = currTime;\r\n        }\r\n        if (values !== undefined) {\r\n            if (AnimationUtils.isTypedArray(values)) {\r\n                for (var i = 0, n = values.length; i !== n; ++i) {\r\n                    var value = values[i];\r\n                    if (isNaN(value)) {\r\n                        console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\r\n                        valid = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return valid;\r\n    },\r\n    // removes equivalent sequential keys as common in morph target sequences\r\n    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n    optimize: function () {\r\n        var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;\r\n        for (var i = 1; i < lastIndex; ++i) {\r\n            var keep = false;\r\n            var time = times[i];\r\n            var timeNext = times[i + 1];\r\n            // remove adjacent keyframes scheduled at the same time\r\n            if (time !== timeNext && (i !== 1 || time !== time[0])) {\r\n                if (!smoothInterpolation) {\r\n                    // remove unnecessary keyframes same as their neighbors\r\n                    var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;\r\n                    for (var j = 0; j !== stride; ++j) {\r\n                        var value = values[offset + j];\r\n                        if (value !== values[offsetP + j] ||\r\n                            value !== values[offsetN + j]) {\r\n                            keep = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    keep = true;\r\n                }\r\n            }\r\n            // in-place compaction\r\n            if (keep) {\r\n                if (i !== writeIndex) {\r\n                    times[writeIndex] = times[i];\r\n                    var readOffset = i * stride, writeOffset = writeIndex * stride;\r\n                    for (var j = 0; j !== stride; ++j) {\r\n                        values[writeOffset + j] = values[readOffset + j];\r\n                    }\r\n                }\r\n                ++writeIndex;\r\n            }\r\n        }\r\n        // flush last keyframe (compaction looks ahead)\r\n        if (lastIndex > 0) {\r\n            times[writeIndex] = times[lastIndex];\r\n            for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\r\n                values[writeOffset + j] = values[readOffset + j];\r\n            }\r\n            ++writeIndex;\r\n        }\r\n        if (writeIndex !== times.length) {\r\n            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\r\n            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\r\n        }\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        var times = AnimationUtils.arraySlice(this.times, 0);\r\n        var values = AnimationUtils.arraySlice(this.values, 0);\r\n        var TypedKeyframeTrack = this.constructor;\r\n        var track = new TypedKeyframeTrack(this.name, times, values);\r\n        // Interpolant argument to constructor is not saved, so copy the factory method directly.\r\n        track.createInterpolant = this.createInterpolant;\r\n        return track;\r\n    }\r\n});\r\n/**\r\n *\r\n * A Track of Boolean keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction BooleanKeyframeTrack(name, times, values) {\r\n    KeyframeTrack.call(this, name, times, values);\r\n}\r\nBooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: BooleanKeyframeTrack,\r\n    ValueTypeName: 'bool',\r\n    ValueBufferType: Array,\r\n    DefaultInterpolation: InterpolateDiscrete,\r\n    InterpolantFactoryMethodLinear: undefined,\r\n    InterpolantFactoryMethodSmooth: undefined\r\n    // Note: Actually this track could have a optimized / compressed\r\n    // representation of a single value and a custom interpolant that\r\n    // computes \"firstValue ^ isOdd( index )\".\r\n});\r\n/**\r\n *\r\n * A Track of keyframe values that represent color.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction ColorKeyframeTrack(name, times, values, interpolation) {\r\n    KeyframeTrack.call(this, name, times, values, interpolation);\r\n}\r\nColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: ColorKeyframeTrack,\r\n    ValueTypeName: 'color'\r\n    // ValueBufferType is inherited\r\n    // DefaultInterpolation is inherited\r\n    // Note: Very basic implementation and nothing special yet.\r\n    // However, this is the place for color space parameterization.\r\n});\r\n/**\r\n *\r\n * A Track of numeric keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction NumberKeyframeTrack(name, times, values, interpolation) {\r\n    KeyframeTrack.call(this, name, times, values, interpolation);\r\n}\r\nNumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: NumberKeyframeTrack,\r\n    ValueTypeName: 'number'\r\n    // ValueBufferType is inherited\r\n    // DefaultInterpolation is inherited\r\n});\r\n/**\r\n * Spherical linear unit quaternion interpolant.\r\n *\r\n * @author tschw\r\n */\r\nfunction QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n}\r\nQuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {\r\n    constructor: QuaternionLinearInterpolant,\r\n    interpolate_: function (i1, t0, t, t1) {\r\n        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);\r\n        for (var end = offset + stride; offset !== end; offset += 4) {\r\n            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\r\n        }\r\n        return result;\r\n    }\r\n});\r\n/**\r\n *\r\n * A Track of quaternion keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction QuaternionKeyframeTrack(name, times, values, interpolation) {\r\n    KeyframeTrack.call(this, name, times, values, interpolation);\r\n}\r\nQuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: QuaternionKeyframeTrack,\r\n    ValueTypeName: 'quaternion',\r\n    // ValueBufferType is inherited\r\n    DefaultInterpolation: InterpolateLinear,\r\n    InterpolantFactoryMethodLinear: function (result) {\r\n        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\r\n    },\r\n    InterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n});\r\n/**\r\n *\r\n * A Track that interpolates Strings\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction StringKeyframeTrack(name, times, values, interpolation) {\r\n    KeyframeTrack.call(this, name, times, values, interpolation);\r\n}\r\nStringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: StringKeyframeTrack,\r\n    ValueTypeName: 'string',\r\n    ValueBufferType: Array,\r\n    DefaultInterpolation: InterpolateDiscrete,\r\n    InterpolantFactoryMethodLinear: undefined,\r\n    InterpolantFactoryMethodSmooth: undefined\r\n});\r\n/**\r\n *\r\n * A Track of vectored keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction VectorKeyframeTrack(name, times, values, interpolation) {\r\n    KeyframeTrack.call(this, name, times, values, interpolation);\r\n}\r\nVectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {\r\n    constructor: VectorKeyframeTrack,\r\n    ValueTypeName: 'vector'\r\n    // ValueBufferType is inherited\r\n    // DefaultInterpolation is inherited\r\n});\r\n/**\r\n *\r\n * Reusable set of Tracks that represent an animation.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\nfunction AnimationClip(name, duration, tracks) {\r\n    this.name = name;\r\n    this.tracks = tracks;\r\n    this.duration = (duration !== undefined) ? duration : -1;\r\n    this.uuid = _Math.generateUUID();\r\n    // this means it should figure out its duration by scanning the tracks\r\n    if (this.duration < 0) {\r\n        this.resetDuration();\r\n    }\r\n}\r\nfunction getTrackTypeForValueTypeName(typeName) {\r\n    switch (typeName.toLowerCase()) {\r\n        case 'scalar':\r\n        case 'double':\r\n        case 'float':\r\n        case 'number':\r\n        case 'integer':\r\n            return NumberKeyframeTrack;\r\n        case 'vector':\r\n        case 'vector2':\r\n        case 'vector3':\r\n        case 'vector4':\r\n            return VectorKeyframeTrack;\r\n        case 'color':\r\n            return ColorKeyframeTrack;\r\n        case 'quaternion':\r\n            return QuaternionKeyframeTrack;\r\n        case 'bool':\r\n        case 'boolean':\r\n            return BooleanKeyframeTrack;\r\n        case 'string':\r\n            return StringKeyframeTrack;\r\n    }\r\n    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\r\n}\r\nfunction parseKeyframeTrack(json) {\r\n    if (json.type === undefined) {\r\n        throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\r\n    }\r\n    var trackType = getTrackTypeForValueTypeName(json.type);\r\n    if (json.times === undefined) {\r\n        var times = [], values = [];\r\n        AnimationUtils.flattenJSON(json.keys, times, values, 'value');\r\n        json.times = times;\r\n        json.values = values;\r\n    }\r\n    // derived classes can define a static parse method\r\n    if (trackType.parse !== undefined) {\r\n        return trackType.parse(json);\r\n    }\r\n    else {\r\n        // by default, we assume a constructor compatible with the base\r\n        return new trackType(json.name, json.times, json.values, json.interpolation);\r\n    }\r\n}\r\nObject.assign(AnimationClip, {\r\n    parse: function (json) {\r\n        var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);\r\n        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {\r\n            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\r\n        }\r\n        return new AnimationClip(json.name, json.duration, tracks);\r\n    },\r\n    toJSON: function (clip) {\r\n        var tracks = [], clipTracks = clip.tracks;\r\n        var json = {\r\n            'name': clip.name,\r\n            'duration': clip.duration,\r\n            'tracks': tracks,\r\n            'uuid': clip.uuid\r\n        };\r\n        for (var i = 0, n = clipTracks.length; i !== n; ++i) {\r\n            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\r\n        }\r\n        return json;\r\n    },\r\n    CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {\r\n        var numMorphTargets = morphTargetSequence.length;\r\n        var tracks = [];\r\n        for (var i = 0; i < numMorphTargets; i++) {\r\n            var times = [];\r\n            var values = [];\r\n            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\r\n            values.push(0, 1, 0);\r\n            var order = AnimationUtils.getKeyframeOrder(times);\r\n            times = AnimationUtils.sortedArray(times, 1, order);\r\n            values = AnimationUtils.sortedArray(values, 1, order);\r\n            // if there is a key at the first frame, duplicate it as the\r\n            // last frame as well for perfect loop.\r\n            if (!noLoop && times[0] === 0) {\r\n                times.push(numMorphTargets);\r\n                values.push(values[0]);\r\n            }\r\n            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\r\n        }\r\n        return new AnimationClip(name, -1, tracks);\r\n    },\r\n    findByName: function (objectOrClipArray, name) {\r\n        var clipArray = objectOrClipArray;\r\n        if (!Array.isArray(objectOrClipArray)) {\r\n            var o = objectOrClipArray;\r\n            clipArray = o.geometry && o.geometry.animations || o.animations;\r\n        }\r\n        for (var i = 0; i < clipArray.length; i++) {\r\n            if (clipArray[i].name === name) {\r\n                return clipArray[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n    CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {\r\n        var animationToMorphTargets = {};\r\n        // tested with https://regex101.com/ on trick sequences\r\n        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n        var pattern = /^([\\w-]*?)([\\d]+)$/;\r\n        // sort morph target names into animation groups based\r\n        // patterns like Walk_001, Walk_002, Run_001, Run_002\r\n        for (var i = 0, il = morphTargets.length; i < il; i++) {\r\n            var morphTarget = morphTargets[i];\r\n            var parts = morphTarget.name.match(pattern);\r\n            if (parts && parts.length > 1) {\r\n                var name = parts[1];\r\n                var animationMorphTargets = animationToMorphTargets[name];\r\n                if (!animationMorphTargets) {\r\n                    animationToMorphTargets[name] = animationMorphTargets = [];\r\n                }\r\n                animationMorphTargets.push(morphTarget);\r\n            }\r\n        }\r\n        var clips = [];\r\n        for (var name in animationToMorphTargets) {\r\n            clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\r\n        }\r\n        return clips;\r\n    },\r\n    // parse the animation.hierarchy format\r\n    parseAnimation: function (animation, bones) {\r\n        if (!animation) {\r\n            console.error('THREE.AnimationClip: No animation in JSONLoader data.');\r\n            return null;\r\n        }\r\n        var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\r\n            // only return track if there are actually keys.\r\n            if (animationKeys.length !== 0) {\r\n                var times = [];\r\n                var values = [];\r\n                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);\r\n                // empty keys are filtered out, so check again\r\n                if (times.length !== 0) {\r\n                    destTracks.push(new trackType(trackName, times, values));\r\n                }\r\n            }\r\n        };\r\n        var tracks = [];\r\n        var clipName = animation.name || 'default';\r\n        // automatic length determination in AnimationClip.\r\n        var duration = animation.length || -1;\r\n        var fps = animation.fps || 30;\r\n        var hierarchyTracks = animation.hierarchy || [];\r\n        for (var h = 0; h < hierarchyTracks.length; h++) {\r\n            var animationKeys = hierarchyTracks[h].keys;\r\n            // skip empty tracks\r\n            if (!animationKeys || animationKeys.length === 0)\r\n                continue;\r\n            // process morph targets\r\n            if (animationKeys[0].morphTargets) {\r\n                // figure out all morph targets used in this track\r\n                var morphTargetNames = {};\r\n                for (var k = 0; k < animationKeys.length; k++) {\r\n                    if (animationKeys[k].morphTargets) {\r\n                        for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {\r\n                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\r\n                        }\r\n                    }\r\n                }\r\n                // create a track for each morph target with all zero\r\n                // morphTargetInfluences except for the keys in which\r\n                // the morphTarget is named.\r\n                for (var morphTargetName in morphTargetNames) {\r\n                    var times = [];\r\n                    var values = [];\r\n                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\r\n                        var animationKey = animationKeys[k];\r\n                        times.push(animationKey.time);\r\n                        values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);\r\n                    }\r\n                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\r\n                }\r\n                duration = morphTargetNames.length * (fps || 1.0);\r\n            }\r\n            else {\r\n                // ...assume skeletal animation\r\n                var boneName = '.bones[' + bones[h].name + ']';\r\n                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\r\n                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\r\n                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\r\n            }\r\n        }\r\n        if (tracks.length === 0) {\r\n            return null;\r\n        }\r\n        var clip = new AnimationClip(clipName, duration, tracks);\r\n        return clip;\r\n    }\r\n});\r\nObject.assign(AnimationClip.prototype, {\r\n    resetDuration: function () {\r\n        var tracks = this.tracks, duration = 0;\r\n        for (var i = 0, n = tracks.length; i !== n; ++i) {\r\n            var track = this.tracks[i];\r\n            duration = Math.max(duration, track.times[track.times.length - 1]);\r\n        }\r\n        this.duration = duration;\r\n        return this;\r\n    },\r\n    trim: function () {\r\n        for (var i = 0; i < this.tracks.length; i++) {\r\n            this.tracks[i].trim(0, this.duration);\r\n        }\r\n        return this;\r\n    },\r\n    validate: function () {\r\n        var valid = true;\r\n        for (var i = 0; i < this.tracks.length; i++) {\r\n            valid = valid && this.tracks[i].validate();\r\n        }\r\n        return valid;\r\n    },\r\n    optimize: function () {\r\n        for (var i = 0; i < this.tracks.length; i++) {\r\n            this.tracks[i].optimize();\r\n        }\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        var tracks = [];\r\n        for (var i = 0; i < this.tracks.length; i++) {\r\n            tracks.push(this.tracks[i].clone());\r\n        }\r\n        return new AnimationClip(this.name, this.duration, tracks);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar Cache = {\r\n    enabled: false,\r\n    files: {},\r\n    add: function (key, file) {\r\n        if (this.enabled === false)\r\n            return;\r\n        // console.log( 'THREE.Cache', 'Adding key:', key );\r\n        this.files[key] = file;\r\n    },\r\n    get: function (key) {\r\n        if (this.enabled === false)\r\n            return;\r\n        // console.log( 'THREE.Cache', 'Checking key:', key );\r\n        return this.files[key];\r\n    },\r\n    remove: function (key) {\r\n        delete this.files[key];\r\n    },\r\n    clear: function () {\r\n        this.files = {};\r\n    }\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction LoadingManager(onLoad, onProgress, onError) {\r\n    var scope = this;\r\n    var isLoading = false;\r\n    var itemsLoaded = 0;\r\n    var itemsTotal = 0;\r\n    var urlModifier = undefined;\r\n    // Refer to #5689 for the reason why we don't set .onStart\r\n    // in the constructor\r\n    this.onStart = undefined;\r\n    this.onLoad = onLoad;\r\n    this.onProgress = onProgress;\r\n    this.onError = onError;\r\n    this.itemStart = function (url) {\r\n        itemsTotal++;\r\n        if (isLoading === false) {\r\n            if (scope.onStart !== undefined) {\r\n                scope.onStart(url, itemsLoaded, itemsTotal);\r\n            }\r\n        }\r\n        isLoading = true;\r\n    };\r\n    this.itemEnd = function (url) {\r\n        itemsLoaded++;\r\n        if (scope.onProgress !== undefined) {\r\n            scope.onProgress(url, itemsLoaded, itemsTotal);\r\n        }\r\n        if (itemsLoaded === itemsTotal) {\r\n            isLoading = false;\r\n            if (scope.onLoad !== undefined) {\r\n                scope.onLoad();\r\n            }\r\n        }\r\n    };\r\n    this.itemError = function (url) {\r\n        if (scope.onError !== undefined) {\r\n            scope.onError(url);\r\n        }\r\n    };\r\n    this.resolveURL = function (url) {\r\n        if (urlModifier) {\r\n            return urlModifier(url);\r\n        }\r\n        return url;\r\n    };\r\n    this.setURLModifier = function (transform) {\r\n        urlModifier = transform;\r\n        return this;\r\n    };\r\n}\r\nvar DefaultLoadingManager = new LoadingManager();\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar loading = {};\r\nfunction FileLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(FileLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        if (url === undefined)\r\n            url = '';\r\n        if (this.path !== undefined)\r\n            url = this.path + url;\r\n        url = this.manager.resolveURL(url);\r\n        var scope = this;\r\n        var cached = Cache.get(url);\r\n        if (cached !== undefined) {\r\n            scope.manager.itemStart(url);\r\n            setTimeout(function () {\r\n                if (onLoad)\r\n                    onLoad(cached);\r\n                scope.manager.itemEnd(url);\r\n            }, 0);\r\n            return cached;\r\n        }\r\n        // Check if request is duplicate\r\n        if (loading[url] !== undefined) {\r\n            loading[url].push({\r\n                onLoad: onLoad,\r\n                onProgress: onProgress,\r\n                onError: onError\r\n            });\r\n            return;\r\n        }\r\n        // Check for data: URI\r\n        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\r\n        var dataUriRegexResult = url.match(dataUriRegex);\r\n        // Safari can not handle Data URIs through XMLHttpRequest so process manually\r\n        if (dataUriRegexResult) {\r\n            var mimeType = dataUriRegexResult[1];\r\n            var isBase64 = !!dataUriRegexResult[2];\r\n            var data = dataUriRegexResult[3];\r\n            data = decodeURIComponent(data);\r\n            if (isBase64)\r\n                data = atob(data);\r\n            try {\r\n                var response;\r\n                var responseType = (this.responseType || '').toLowerCase();\r\n                switch (responseType) {\r\n                    case 'arraybuffer':\r\n                    case 'blob':\r\n                        var view = new Uint8Array(data.length);\r\n                        for (var i = 0; i < data.length; i++) {\r\n                            view[i] = data.charCodeAt(i);\r\n                        }\r\n                        if (responseType === 'blob') {\r\n                            response = new Blob([view.buffer], { type: mimeType });\r\n                        }\r\n                        else {\r\n                            response = view.buffer;\r\n                        }\r\n                        break;\r\n                    case 'document':\r\n                        var parser = new DOMParser();\r\n                        response = parser.parseFromString(data, mimeType);\r\n                        break;\r\n                    case 'json':\r\n                        response = JSON.parse(data);\r\n                        break;\r\n                    default: // 'text' or other\r\n                        response = data;\r\n                        break;\r\n                }\r\n                // Wait for next browser tick like standard XMLHttpRequest event dispatching does\r\n                setTimeout(function () {\r\n                    if (onLoad)\r\n                        onLoad(response);\r\n                    scope.manager.itemEnd(url);\r\n                }, 0);\r\n            }\r\n            catch (error) {\r\n                // Wait for next browser tick like standard XMLHttpRequest event dispatching does\r\n                setTimeout(function () {\r\n                    if (onError)\r\n                        onError(error);\r\n                    scope.manager.itemError(url);\r\n                    scope.manager.itemEnd(url);\r\n                }, 0);\r\n            }\r\n        }\r\n        else {\r\n            // Initialise array for duplicate requests\r\n            loading[url] = [];\r\n            loading[url].push({\r\n                onLoad: onLoad,\r\n                onProgress: onProgress,\r\n                onError: onError\r\n            });\r\n            var request = new XMLHttpRequest();\r\n            request.open('GET', url, true);\r\n            request.addEventListener('load', function (event) {\r\n                var response = this.response;\r\n                Cache.add(url, response);\r\n                var callbacks = loading[url];\r\n                delete loading[url];\r\n                if (this.status === 200 || this.status === 0) {\r\n                    // Some browsers return HTTP Status 0 when using non-http protocol\r\n                    // e.g. 'file://' or 'data://'. Handle as success.\r\n                    if (this.status === 0)\r\n                        console.warn('THREE.FileLoader: HTTP Status 0 received.');\r\n                    for (var i = 0, il = callbacks.length; i < il; i++) {\r\n                        var callback = callbacks[i];\r\n                        if (callback.onLoad)\r\n                            callback.onLoad(response);\r\n                    }\r\n                    scope.manager.itemEnd(url);\r\n                }\r\n                else {\r\n                    for (var i = 0, il = callbacks.length; i < il; i++) {\r\n                        var callback = callbacks[i];\r\n                        if (callback.onError)\r\n                            callback.onError(event);\r\n                    }\r\n                    scope.manager.itemError(url);\r\n                    scope.manager.itemEnd(url);\r\n                }\r\n            }, false);\r\n            request.addEventListener('progress', function (event) {\r\n                var callbacks = loading[url];\r\n                for (var i = 0, il = callbacks.length; i < il; i++) {\r\n                    var callback = callbacks[i];\r\n                    if (callback.onProgress)\r\n                        callback.onProgress(event);\r\n                }\r\n            }, false);\r\n            request.addEventListener('error', function (event) {\r\n                var callbacks = loading[url];\r\n                delete loading[url];\r\n                for (var i = 0, il = callbacks.length; i < il; i++) {\r\n                    var callback = callbacks[i];\r\n                    if (callback.onError)\r\n                        callback.onError(event);\r\n                }\r\n                scope.manager.itemError(url);\r\n                scope.manager.itemEnd(url);\r\n            }, false);\r\n            request.addEventListener('abort', function (event) {\r\n                var callbacks = loading[url];\r\n                delete loading[url];\r\n                for (var i = 0, il = callbacks.length; i < il; i++) {\r\n                    var callback = callbacks[i];\r\n                    if (callback.onError)\r\n                        callback.onError(event);\r\n                }\r\n                scope.manager.itemError(url);\r\n                scope.manager.itemEnd(url);\r\n            }, false);\r\n            if (this.responseType !== undefined)\r\n                request.responseType = this.responseType;\r\n            if (this.withCredentials !== undefined)\r\n                request.withCredentials = this.withCredentials;\r\n            if (request.overrideMimeType)\r\n                request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\r\n            for (var header in this.requestHeader) {\r\n                request.setRequestHeader(header, this.requestHeader[header]);\r\n            }\r\n            request.send(null);\r\n        }\r\n        scope.manager.itemStart(url);\r\n        return request;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    },\r\n    setResponseType: function (value) {\r\n        this.responseType = value;\r\n        return this;\r\n    },\r\n    setWithCredentials: function (value) {\r\n        this.withCredentials = value;\r\n        return this;\r\n    },\r\n    setMimeType: function (value) {\r\n        this.mimeType = value;\r\n        return this;\r\n    },\r\n    setRequestHeader: function (value) {\r\n        this.requestHeader = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io/\r\n */\r\nfunction AnimationLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(AnimationLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var loader = new FileLoader(scope.manager);\r\n        loader.setPath(scope.path);\r\n        loader.load(url, function (text) {\r\n            onLoad(scope.parse(JSON.parse(text)));\r\n        }, onProgress, onError);\r\n    },\r\n    parse: function (json) {\r\n        var animations = [];\r\n        for (var i = 0; i < json.length; i++) {\r\n            var clip = AnimationClip.parse(json[i]);\r\n            animations.push(clip);\r\n        }\r\n        return animations;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\nfunction CompressedTextureLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n    // override in sub classes\r\n    this._parser = null;\r\n}\r\nObject.assign(CompressedTextureLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var images = [];\r\n        var texture = new CompressedTexture();\r\n        texture.image = images;\r\n        var loader = new FileLoader(this.manager);\r\n        loader.setPath(this.path);\r\n        loader.setResponseType('arraybuffer');\r\n        function loadTexture(i) {\r\n            loader.load(url[i], function (buffer) {\r\n                var texDatas = scope._parser(buffer, true);\r\n                images[i] = {\r\n                    width: texDatas.width,\r\n                    height: texDatas.height,\r\n                    format: texDatas.format,\r\n                    mipmaps: texDatas.mipmaps\r\n                };\r\n                loaded += 1;\r\n                if (loaded === 6) {\r\n                    if (texDatas.mipmapCount === 1)\r\n                        texture.minFilter = LinearFilter;\r\n                    texture.format = texDatas.format;\r\n                    texture.needsUpdate = true;\r\n                    if (onLoad)\r\n                        onLoad(texture);\r\n                }\r\n            }, onProgress, onError);\r\n        }\r\n        if (Array.isArray(url)) {\r\n            var loaded = 0;\r\n            for (var i = 0, il = url.length; i < il; ++i) {\r\n                loadTexture(i);\r\n            }\r\n        }\r\n        else {\r\n            // compressed cubemap texture stored in a single DDS file\r\n            loader.load(url, function (buffer) {\r\n                var texDatas = scope._parser(buffer, true);\r\n                if (texDatas.isCubemap) {\r\n                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n                    for (var f = 0; f < faces; f++) {\r\n                        images[f] = { mipmaps: [] };\r\n                        for (var i = 0; i < texDatas.mipmapCount; i++) {\r\n                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\r\n                            images[f].format = texDatas.format;\r\n                            images[f].width = texDatas.width;\r\n                            images[f].height = texDatas.height;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    texture.image.width = texDatas.width;\r\n                    texture.image.height = texDatas.height;\r\n                    texture.mipmaps = texDatas.mipmaps;\r\n                }\r\n                if (texDatas.mipmapCount === 1) {\r\n                    texture.minFilter = LinearFilter;\r\n                }\r\n                texture.format = texDatas.format;\r\n                texture.needsUpdate = true;\r\n                if (onLoad)\r\n                    onLoad(texture);\r\n            }, onProgress, onError);\r\n        }\r\n        return texture;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\nfunction DataTextureLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n    // override in sub classes\r\n    this._parser = null;\r\n}\r\nObject.assign(DataTextureLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var texture = new DataTexture();\r\n        var loader = new FileLoader(this.manager);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.setPath(this.path);\r\n        loader.load(url, function (buffer) {\r\n            var texData = scope._parser(buffer);\r\n            if (!texData)\r\n                return;\r\n            if (texData.image !== undefined) {\r\n                texture.image = texData.image;\r\n            }\r\n            else if (texData.data !== undefined) {\r\n                texture.image.width = texData.width;\r\n                texture.image.height = texData.height;\r\n                texture.image.data = texData.data;\r\n            }\r\n            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\r\n            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\r\n            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\r\n            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipmapLinearFilter;\r\n            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\r\n            if (texData.format !== undefined) {\r\n                texture.format = texData.format;\r\n            }\r\n            if (texData.type !== undefined) {\r\n                texture.type = texData.type;\r\n            }\r\n            if (texData.mipmaps !== undefined) {\r\n                texture.mipmaps = texData.mipmaps;\r\n            }\r\n            if (texData.mipmapCount === 1) {\r\n                texture.minFilter = LinearFilter;\r\n            }\r\n            texture.needsUpdate = true;\r\n            if (onLoad)\r\n                onLoad(texture, texData);\r\n        }, onProgress, onError);\r\n        return texture;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction ImageLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(ImageLoader.prototype, {\r\n    crossOrigin: 'anonymous',\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        if (url === undefined)\r\n            url = '';\r\n        if (this.path !== undefined)\r\n            url = this.path + url;\r\n        url = this.manager.resolveURL(url);\r\n        var scope = this;\r\n        var cached = Cache.get(url);\r\n        if (cached !== undefined) {\r\n            scope.manager.itemStart(url);\r\n            setTimeout(function () {\r\n                if (onLoad)\r\n                    onLoad(cached);\r\n                scope.manager.itemEnd(url);\r\n            }, 0);\r\n            return cached;\r\n        }\r\n        var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');\r\n        function onImageLoad() {\r\n            image.removeEventListener('load', onImageLoad, false);\r\n            image.removeEventListener('error', onImageError, false);\r\n            Cache.add(url, this);\r\n            if (onLoad)\r\n                onLoad(this);\r\n            scope.manager.itemEnd(url);\r\n        }\r\n        function onImageError(event) {\r\n            image.removeEventListener('load', onImageLoad, false);\r\n            image.removeEventListener('error', onImageError, false);\r\n            if (onError)\r\n                onError(event);\r\n            scope.manager.itemError(url);\r\n            scope.manager.itemEnd(url);\r\n        }\r\n        image.addEventListener('load', onImageLoad, false);\r\n        image.addEventListener('error', onImageError, false);\r\n        if (url.substr(0, 5) !== 'data:') {\r\n            if (this.crossOrigin !== undefined)\r\n                image.crossOrigin = this.crossOrigin;\r\n        }\r\n        scope.manager.itemStart(url);\r\n        image.src = url;\r\n        return image;\r\n    },\r\n    setCrossOrigin: function (value) {\r\n        this.crossOrigin = value;\r\n        return this;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction CubeTextureLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(CubeTextureLoader.prototype, {\r\n    crossOrigin: 'anonymous',\r\n    load: function (urls, onLoad, onProgress, onError) {\r\n        var texture = new CubeTexture();\r\n        var loader = new ImageLoader(this.manager);\r\n        loader.setCrossOrigin(this.crossOrigin);\r\n        loader.setPath(this.path);\r\n        var loaded = 0;\r\n        function loadTexture(i) {\r\n            loader.load(urls[i], function (image) {\r\n                texture.images[i] = image;\r\n                loaded++;\r\n                if (loaded === 6) {\r\n                    texture.needsUpdate = true;\r\n                    if (onLoad)\r\n                        onLoad(texture);\r\n                }\r\n            }, undefined, onError);\r\n        }\r\n        for (var i = 0; i < urls.length; ++i) {\r\n            loadTexture(i);\r\n        }\r\n        return texture;\r\n    },\r\n    setCrossOrigin: function (value) {\r\n        this.crossOrigin = value;\r\n        return this;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction TextureLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(TextureLoader.prototype, {\r\n    crossOrigin: 'anonymous',\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var texture = new Texture();\r\n        var loader = new ImageLoader(this.manager);\r\n        loader.setCrossOrigin(this.crossOrigin);\r\n        loader.setPath(this.path);\r\n        loader.load(url, function (image) {\r\n            texture.image = image;\r\n            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\r\n            var isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\r\n            texture.format = isJPEG ? RGBFormat : RGBAFormat;\r\n            texture.needsUpdate = true;\r\n            if (onLoad !== undefined) {\r\n                onLoad(texture);\r\n            }\r\n        }, onProgress, onError);\r\n        return texture;\r\n    },\r\n    setCrossOrigin: function (value) {\r\n        this.crossOrigin = value;\r\n        return this;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of curve methods:\r\n * .getPoint( t, optionalTarget ), .getTangent( t )\r\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following curves inherit from THREE.Curve:\r\n *\r\n * -- 2D curves --\r\n * THREE.ArcCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.EllipseCurve\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.SplineCurve\r\n *\r\n * -- 3D curves --\r\n * THREE.CatmullRomCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath.\r\n *\r\n **/\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\nfunction Curve() {\r\n    this.type = 'Curve';\r\n    this.arcLengthDivisions = 200;\r\n}\r\nObject.assign(Curve.prototype, {\r\n    // Virtual base class method to overwrite and implement in subclasses\r\n    //\t- t [0 .. 1]\r\n    getPoint: function ( /* t, optionalTarget */) {\r\n        console.warn('THREE.Curve: .getPoint() not implemented.');\r\n        return null;\r\n    },\r\n    // Get point at relative position in curve according to arc length\r\n    // - u [0 .. 1]\r\n    getPointAt: function (u, optionalTarget) {\r\n        var t = this.getUtoTmapping(u);\r\n        return this.getPoint(t, optionalTarget);\r\n    },\r\n    // Get sequence of points using getPoint( t )\r\n    getPoints: function (divisions) {\r\n        if (divisions === undefined)\r\n            divisions = 5;\r\n        var points = [];\r\n        for (var d = 0; d <= divisions; d++) {\r\n            points.push(this.getPoint(d / divisions));\r\n        }\r\n        return points;\r\n    },\r\n    // Get sequence of points using getPointAt( u )\r\n    getSpacedPoints: function (divisions) {\r\n        if (divisions === undefined)\r\n            divisions = 5;\r\n        var points = [];\r\n        for (var d = 0; d <= divisions; d++) {\r\n            points.push(this.getPointAt(d / divisions));\r\n        }\r\n        return points;\r\n    },\r\n    // Get total curve arc length\r\n    getLength: function () {\r\n        var lengths = this.getLengths();\r\n        return lengths[lengths.length - 1];\r\n    },\r\n    // Get list of cumulative segment lengths\r\n    getLengths: function (divisions) {\r\n        if (divisions === undefined)\r\n            divisions = this.arcLengthDivisions;\r\n        if (this.cacheArcLengths &&\r\n            (this.cacheArcLengths.length === divisions + 1) &&\r\n            !this.needsUpdate) {\r\n            return this.cacheArcLengths;\r\n        }\r\n        this.needsUpdate = false;\r\n        var cache = [];\r\n        var current, last = this.getPoint(0);\r\n        var p, sum = 0;\r\n        cache.push(0);\r\n        for (p = 1; p <= divisions; p++) {\r\n            current = this.getPoint(p / divisions);\r\n            sum += current.distanceTo(last);\r\n            cache.push(sum);\r\n            last = current;\r\n        }\r\n        this.cacheArcLengths = cache;\r\n        return cache; // { sums: cache, sum: sum }; Sum is in the last element.\r\n    },\r\n    updateArcLengths: function () {\r\n        this.needsUpdate = true;\r\n        this.getLengths();\r\n    },\r\n    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n    getUtoTmapping: function (u, distance) {\r\n        var arcLengths = this.getLengths();\r\n        var i = 0, il = arcLengths.length;\r\n        var targetArcLength; // The targeted u distance value to get\r\n        if (distance) {\r\n            targetArcLength = distance;\r\n        }\r\n        else {\r\n            targetArcLength = u * arcLengths[il - 1];\r\n        }\r\n        // binary search for the index with largest value smaller than target u distance\r\n        var low = 0, high = il - 1, comparison;\r\n        while (low <= high) {\r\n            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n            comparison = arcLengths[i] - targetArcLength;\r\n            if (comparison < 0) {\r\n                low = i + 1;\r\n            }\r\n            else if (comparison > 0) {\r\n                high = i - 1;\r\n            }\r\n            else {\r\n                high = i;\r\n                break;\r\n                // DONE\r\n            }\r\n        }\r\n        i = high;\r\n        if (arcLengths[i] === targetArcLength) {\r\n            return i / (il - 1);\r\n        }\r\n        // we could get finer grain at lengths, or use simple interpolation between two points\r\n        var lengthBefore = arcLengths[i];\r\n        var lengthAfter = arcLengths[i + 1];\r\n        var segmentLength = lengthAfter - lengthBefore;\r\n        // determine where we are between the 'before' and 'after' points\r\n        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\r\n        // add that fractional amount to t\r\n        var t = (i + segmentFraction) / (il - 1);\r\n        return t;\r\n    },\r\n    // Returns a unit vector tangent at t\r\n    // In case any sub curve does not implement its tangent derivation,\r\n    // 2 points a small delta apart will be used to find its gradient\r\n    // which seems to give a reasonable approximation\r\n    getTangent: function (t) {\r\n        var delta = 0.0001;\r\n        var t1 = t - delta;\r\n        var t2 = t + delta;\r\n        // Capping in case of danger\r\n        if (t1 < 0)\r\n            t1 = 0;\r\n        if (t2 > 1)\r\n            t2 = 1;\r\n        var pt1 = this.getPoint(t1);\r\n        var pt2 = this.getPoint(t2);\r\n        var vec = pt2.clone().sub(pt1);\r\n        return vec.normalize();\r\n    },\r\n    getTangentAt: function (u) {\r\n        var t = this.getUtoTmapping(u);\r\n        return this.getTangent(t);\r\n    },\r\n    computeFrenetFrames: function (segments, closed) {\r\n        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n        var normal = new Vector3();\r\n        var tangents = [];\r\n        var normals = [];\r\n        var binormals = [];\r\n        var vec = new Vector3();\r\n        var mat = new Matrix4();\r\n        var i, u, theta;\r\n        // compute the tangent vectors for each segment on the curve\r\n        for (i = 0; i <= segments; i++) {\r\n            u = i / segments;\r\n            tangents[i] = this.getTangentAt(u);\r\n            tangents[i].normalize();\r\n        }\r\n        // select an initial normal vector perpendicular to the first tangent vector,\r\n        // and in the direction of the minimum tangent xyz component\r\n        normals[0] = new Vector3();\r\n        binormals[0] = new Vector3();\r\n        var min = Number.MAX_VALUE;\r\n        var tx = Math.abs(tangents[0].x);\r\n        var ty = Math.abs(tangents[0].y);\r\n        var tz = Math.abs(tangents[0].z);\r\n        if (tx <= min) {\r\n            min = tx;\r\n            normal.set(1, 0, 0);\r\n        }\r\n        if (ty <= min) {\r\n            min = ty;\r\n            normal.set(0, 1, 0);\r\n        }\r\n        if (tz <= min) {\r\n            normal.set(0, 0, 1);\r\n        }\r\n        vec.crossVectors(tangents[0], normal).normalize();\r\n        normals[0].crossVectors(tangents[0], vec);\r\n        binormals[0].crossVectors(tangents[0], normals[0]);\r\n        // compute the slowly-varying normal and binormal vectors for each segment on the curve\r\n        for (i = 1; i <= segments; i++) {\r\n            normals[i] = normals[i - 1].clone();\r\n            binormals[i] = binormals[i - 1].clone();\r\n            vec.crossVectors(tangents[i - 1], tangents[i]);\r\n            if (vec.length() > Number.EPSILON) {\r\n                vec.normalize();\r\n                theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\r\n                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\r\n            }\r\n            binormals[i].crossVectors(tangents[i], normals[i]);\r\n        }\r\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n        if (closed === true) {\r\n            theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));\r\n            theta /= segments;\r\n            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\r\n                theta = -theta;\r\n            }\r\n            for (i = 1; i <= segments; i++) {\r\n                // twist a little...\r\n                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\r\n                binormals[i].crossVectors(tangents[i], normals[i]);\r\n            }\r\n        }\r\n        return {\r\n            tangents: tangents,\r\n            normals: normals,\r\n            binormals: binormals\r\n        };\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (source) {\r\n        this.arcLengthDivisions = source.arcLengthDivisions;\r\n        return this;\r\n    },\r\n    toJSON: function () {\r\n        var data = {\r\n            metadata: {\r\n                version: 4.5,\r\n                type: 'Curve',\r\n                generator: 'Curve.toJSON'\r\n            }\r\n        };\r\n        data.arcLengthDivisions = this.arcLengthDivisions;\r\n        data.type = this.type;\r\n        return data;\r\n    },\r\n    fromJSON: function (json) {\r\n        this.arcLengthDivisions = json.arcLengthDivisions;\r\n        return this;\r\n    }\r\n});\r\nfunction EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\r\n    Curve.call(this);\r\n    this.type = 'EllipseCurve';\r\n    this.aX = aX || 0;\r\n    this.aY = aY || 0;\r\n    this.xRadius = xRadius || 1;\r\n    this.yRadius = yRadius || 1;\r\n    this.aStartAngle = aStartAngle || 0;\r\n    this.aEndAngle = aEndAngle || 2 * Math.PI;\r\n    this.aClockwise = aClockwise || false;\r\n    this.aRotation = aRotation || 0;\r\n}\r\nEllipseCurve.prototype = Object.create(Curve.prototype);\r\nEllipseCurve.prototype.constructor = EllipseCurve;\r\nEllipseCurve.prototype.isEllipseCurve = true;\r\nEllipseCurve.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector2();\r\n    var twoPi = Math.PI * 2;\r\n    var deltaAngle = this.aEndAngle - this.aStartAngle;\r\n    var samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n    // ensures that deltaAngle is 0 .. 2 PI\r\n    while (deltaAngle < 0)\r\n        deltaAngle += twoPi;\r\n    while (deltaAngle > twoPi)\r\n        deltaAngle -= twoPi;\r\n    if (deltaAngle < Number.EPSILON) {\r\n        if (samePoints) {\r\n            deltaAngle = 0;\r\n        }\r\n        else {\r\n            deltaAngle = twoPi;\r\n        }\r\n    }\r\n    if (this.aClockwise === true && !samePoints) {\r\n        if (deltaAngle === twoPi) {\r\n            deltaAngle = -twoPi;\r\n        }\r\n        else {\r\n            deltaAngle = deltaAngle - twoPi;\r\n        }\r\n    }\r\n    var angle = this.aStartAngle + t * deltaAngle;\r\n    var x = this.aX + this.xRadius * Math.cos(angle);\r\n    var y = this.aY + this.yRadius * Math.sin(angle);\r\n    if (this.aRotation !== 0) {\r\n        var cos = Math.cos(this.aRotation);\r\n        var sin = Math.sin(this.aRotation);\r\n        var tx = x - this.aX;\r\n        var ty = y - this.aY;\r\n        // Rotate the point about the center of the ellipse.\r\n        x = tx * cos - ty * sin + this.aX;\r\n        y = tx * sin + ty * cos + this.aY;\r\n    }\r\n    return point.set(x, y);\r\n};\r\nEllipseCurve.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.aX = source.aX;\r\n    this.aY = source.aY;\r\n    this.xRadius = source.xRadius;\r\n    this.yRadius = source.yRadius;\r\n    this.aStartAngle = source.aStartAngle;\r\n    this.aEndAngle = source.aEndAngle;\r\n    this.aClockwise = source.aClockwise;\r\n    this.aRotation = source.aRotation;\r\n    return this;\r\n};\r\nEllipseCurve.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.aX = this.aX;\r\n    data.aY = this.aY;\r\n    data.xRadius = this.xRadius;\r\n    data.yRadius = this.yRadius;\r\n    data.aStartAngle = this.aStartAngle;\r\n    data.aEndAngle = this.aEndAngle;\r\n    data.aClockwise = this.aClockwise;\r\n    data.aRotation = this.aRotation;\r\n    return data;\r\n};\r\nEllipseCurve.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.aX = json.aX;\r\n    this.aY = json.aY;\r\n    this.xRadius = json.xRadius;\r\n    this.yRadius = json.yRadius;\r\n    this.aStartAngle = json.aStartAngle;\r\n    this.aEndAngle = json.aEndAngle;\r\n    this.aClockwise = json.aClockwise;\r\n    this.aRotation = json.aRotation;\r\n    return this;\r\n};\r\nfunction ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\r\n    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n    this.type = 'ArcCurve';\r\n}\r\nArcCurve.prototype = Object.create(EllipseCurve.prototype);\r\nArcCurve.prototype.constructor = ArcCurve;\r\nArcCurve.prototype.isArcCurve = true;\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n/*\r\nBased on an optimized c++ solution in\r\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n - http://ideone.com/NoEbVM\r\n\r\nThis CubicPoly class could be used for reusing some variables and calculations,\r\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\nwhich can be placed in CurveUtils.\r\n*/\r\nfunction CubicPoly() {\r\n    var c0 = 0, c1 = 0, c2 = 0, c3 = 0;\r\n    /*\r\n     * Compute coefficients for a cubic polynomial\r\n     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n     * such that\r\n     *   p(0) = x0, p(1) = x1\r\n     *  and\r\n     *   p'(0) = t0, p'(1) = t1.\r\n     */\r\n    function init(x0, x1, t0, t1) {\r\n        c0 = x0;\r\n        c1 = t0;\r\n        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n        c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n    }\r\n    return {\r\n        initCatmullRom: function (x0, x1, x2, x3, tension) {\r\n            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\r\n        },\r\n        initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\r\n            // compute tangents when parameterized in [t1,t2]\r\n            var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\r\n            var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\r\n            // rescale tangents for parametrization in [0,1]\r\n            t1 *= dt1;\r\n            t2 *= dt1;\r\n            init(x1, x2, t1, t2);\r\n        },\r\n        calc: function (t) {\r\n            var t2 = t * t;\r\n            var t3 = t2 * t;\r\n            return c0 + c1 * t + c2 * t2 + c3 * t3;\r\n        }\r\n    };\r\n}\r\n//\r\nvar tmp = new Vector3();\r\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\r\nfunction CatmullRomCurve3(points, closed, curveType, tension) {\r\n    Curve.call(this);\r\n    this.type = 'CatmullRomCurve3';\r\n    this.points = points || [];\r\n    this.closed = closed || false;\r\n    this.curveType = curveType || 'centripetal';\r\n    this.tension = tension || 0.5;\r\n}\r\nCatmullRomCurve3.prototype = Object.create(Curve.prototype);\r\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\r\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\r\nCatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector3();\r\n    var points = this.points;\r\n    var l = points.length;\r\n    var p = (l - (this.closed ? 0 : 1)) * t;\r\n    var intPoint = Math.floor(p);\r\n    var weight = p - intPoint;\r\n    if (this.closed) {\r\n        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\r\n    }\r\n    else if (weight === 0 && intPoint === l - 1) {\r\n        intPoint = l - 2;\r\n        weight = 1;\r\n    }\r\n    var p0, p1, p2, p3; // 4 points\r\n    if (this.closed || intPoint > 0) {\r\n        p0 = points[(intPoint - 1) % l];\r\n    }\r\n    else {\r\n        // extrapolate first point\r\n        tmp.subVectors(points[0], points[1]).add(points[0]);\r\n        p0 = tmp;\r\n    }\r\n    p1 = points[intPoint % l];\r\n    p2 = points[(intPoint + 1) % l];\r\n    if (this.closed || intPoint + 2 < l) {\r\n        p3 = points[(intPoint + 2) % l];\r\n    }\r\n    else {\r\n        // extrapolate last point\r\n        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\r\n        p3 = tmp;\r\n    }\r\n    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {\r\n        // init Centripetal / Chordal Catmull-Rom\r\n        var pow = this.curveType === 'chordal' ? 0.5 : 0.25;\r\n        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);\r\n        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);\r\n        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);\r\n        // safety check for repeated points\r\n        if (dt1 < 1e-4)\r\n            dt1 = 1.0;\r\n        if (dt0 < 1e-4)\r\n            dt0 = dt1;\r\n        if (dt2 < 1e-4)\r\n            dt2 = dt1;\r\n        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\r\n        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\r\n        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\r\n    }\r\n    else if (this.curveType === 'catmullrom') {\r\n        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\r\n        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\r\n        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\r\n    }\r\n    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\r\n    return point;\r\n};\r\nCatmullRomCurve3.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.points = [];\r\n    for (var i = 0, l = source.points.length; i < l; i++) {\r\n        var point = source.points[i];\r\n        this.points.push(point.clone());\r\n    }\r\n    this.closed = source.closed;\r\n    this.curveType = source.curveType;\r\n    this.tension = source.tension;\r\n    return this;\r\n};\r\nCatmullRomCurve3.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.points = [];\r\n    for (var i = 0, l = this.points.length; i < l; i++) {\r\n        var point = this.points[i];\r\n        data.points.push(point.toArray());\r\n    }\r\n    data.closed = this.closed;\r\n    data.curveType = this.curveType;\r\n    data.tension = this.tension;\r\n    return data;\r\n};\r\nCatmullRomCurve3.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.points = [];\r\n    for (var i = 0, l = json.points.length; i < l; i++) {\r\n        var point = json.points[i];\r\n        this.points.push(new Vector3().fromArray(point));\r\n    }\r\n    this.closed = json.closed;\r\n    this.curveType = json.curveType;\r\n    this.tension = json.tension;\r\n    return this;\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Bezier Curves formulas obtained from\r\n * http://en.wikipedia.org/wiki/Bézier_curve\r\n */\r\nfunction CatmullRom(t, p0, p1, p2, p3) {\r\n    var v0 = (p2 - p0) * 0.5;\r\n    var v1 = (p3 - p1) * 0.5;\r\n    var t2 = t * t;\r\n    var t3 = t * t2;\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n}\r\n//\r\nfunction QuadraticBezierP0(t, p) {\r\n    var k = 1 - t;\r\n    return k * k * p;\r\n}\r\nfunction QuadraticBezierP1(t, p) {\r\n    return 2 * (1 - t) * t * p;\r\n}\r\nfunction QuadraticBezierP2(t, p) {\r\n    return t * t * p;\r\n}\r\nfunction QuadraticBezier(t, p0, p1, p2) {\r\n    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +\r\n        QuadraticBezierP2(t, p2);\r\n}\r\n//\r\nfunction CubicBezierP0(t, p) {\r\n    var k = 1 - t;\r\n    return k * k * k * p;\r\n}\r\nfunction CubicBezierP1(t, p) {\r\n    var k = 1 - t;\r\n    return 3 * k * k * t * p;\r\n}\r\nfunction CubicBezierP2(t, p) {\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\nfunction CubicBezierP3(t, p) {\r\n    return t * t * t * p;\r\n}\r\nfunction CubicBezier(t, p0, p1, p2, p3) {\r\n    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +\r\n        CubicBezierP3(t, p3);\r\n}\r\nfunction CubicBezierCurve(v0, v1, v2, v3) {\r\n    Curve.call(this);\r\n    this.type = 'CubicBezierCurve';\r\n    this.v0 = v0 || new Vector2();\r\n    this.v1 = v1 || new Vector2();\r\n    this.v2 = v2 || new Vector2();\r\n    this.v3 = v3 || new Vector2();\r\n}\r\nCubicBezierCurve.prototype = Object.create(Curve.prototype);\r\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\r\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\r\nCubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector2();\r\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\r\n    return point;\r\n};\r\nCubicBezierCurve.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v0.copy(source.v0);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    this.v3.copy(source.v3);\r\n    return this;\r\n};\r\nCubicBezierCurve.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v0 = this.v0.toArray();\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    data.v3 = this.v3.toArray();\r\n    return data;\r\n};\r\nCubicBezierCurve.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v0.fromArray(json.v0);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    this.v3.fromArray(json.v3);\r\n    return this;\r\n};\r\nfunction CubicBezierCurve3(v0, v1, v2, v3) {\r\n    Curve.call(this);\r\n    this.type = 'CubicBezierCurve3';\r\n    this.v0 = v0 || new Vector3();\r\n    this.v1 = v1 || new Vector3();\r\n    this.v2 = v2 || new Vector3();\r\n    this.v3 = v3 || new Vector3();\r\n}\r\nCubicBezierCurve3.prototype = Object.create(Curve.prototype);\r\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\r\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\r\nCubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector3();\r\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\r\n    return point;\r\n};\r\nCubicBezierCurve3.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v0.copy(source.v0);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    this.v3.copy(source.v3);\r\n    return this;\r\n};\r\nCubicBezierCurve3.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v0 = this.v0.toArray();\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    data.v3 = this.v3.toArray();\r\n    return data;\r\n};\r\nCubicBezierCurve3.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v0.fromArray(json.v0);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    this.v3.fromArray(json.v3);\r\n    return this;\r\n};\r\nfunction LineCurve(v1, v2) {\r\n    Curve.call(this);\r\n    this.type = 'LineCurve';\r\n    this.v1 = v1 || new Vector2();\r\n    this.v2 = v2 || new Vector2();\r\n}\r\nLineCurve.prototype = Object.create(Curve.prototype);\r\nLineCurve.prototype.constructor = LineCurve;\r\nLineCurve.prototype.isLineCurve = true;\r\nLineCurve.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector2();\r\n    if (t === 1) {\r\n        point.copy(this.v2);\r\n    }\r\n    else {\r\n        point.copy(this.v2).sub(this.v1);\r\n        point.multiplyScalar(t).add(this.v1);\r\n    }\r\n    return point;\r\n};\r\n// Line curve is linear, so we can overwrite default getPointAt\r\nLineCurve.prototype.getPointAt = function (u, optionalTarget) {\r\n    return this.getPoint(u, optionalTarget);\r\n};\r\nLineCurve.prototype.getTangent = function ( /* t */) {\r\n    var tangent = this.v2.clone().sub(this.v1);\r\n    return tangent.normalize();\r\n};\r\nLineCurve.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    return this;\r\n};\r\nLineCurve.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    return data;\r\n};\r\nLineCurve.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    return this;\r\n};\r\nfunction LineCurve3(v1, v2) {\r\n    Curve.call(this);\r\n    this.type = 'LineCurve3';\r\n    this.v1 = v1 || new Vector3();\r\n    this.v2 = v2 || new Vector3();\r\n}\r\nLineCurve3.prototype = Object.create(Curve.prototype);\r\nLineCurve3.prototype.constructor = LineCurve3;\r\nLineCurve3.prototype.isLineCurve3 = true;\r\nLineCurve3.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector3();\r\n    if (t === 1) {\r\n        point.copy(this.v2);\r\n    }\r\n    else {\r\n        point.copy(this.v2).sub(this.v1);\r\n        point.multiplyScalar(t).add(this.v1);\r\n    }\r\n    return point;\r\n};\r\n// Line curve is linear, so we can overwrite default getPointAt\r\nLineCurve3.prototype.getPointAt = function (u, optionalTarget) {\r\n    return this.getPoint(u, optionalTarget);\r\n};\r\nLineCurve3.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    return this;\r\n};\r\nLineCurve3.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    return data;\r\n};\r\nLineCurve3.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    return this;\r\n};\r\nfunction QuadraticBezierCurve(v0, v1, v2) {\r\n    Curve.call(this);\r\n    this.type = 'QuadraticBezierCurve';\r\n    this.v0 = v0 || new Vector2();\r\n    this.v1 = v1 || new Vector2();\r\n    this.v2 = v2 || new Vector2();\r\n}\r\nQuadraticBezierCurve.prototype = Object.create(Curve.prototype);\r\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\r\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\r\nQuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector2();\r\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\r\n    return point;\r\n};\r\nQuadraticBezierCurve.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v0.copy(source.v0);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    return this;\r\n};\r\nQuadraticBezierCurve.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v0 = this.v0.toArray();\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    return data;\r\n};\r\nQuadraticBezierCurve.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v0.fromArray(json.v0);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    return this;\r\n};\r\nfunction QuadraticBezierCurve3(v0, v1, v2) {\r\n    Curve.call(this);\r\n    this.type = 'QuadraticBezierCurve3';\r\n    this.v0 = v0 || new Vector3();\r\n    this.v1 = v1 || new Vector3();\r\n    this.v2 = v2 || new Vector3();\r\n}\r\nQuadraticBezierCurve3.prototype = Object.create(Curve.prototype);\r\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\r\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\r\nQuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector3();\r\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\r\n    return point;\r\n};\r\nQuadraticBezierCurve3.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.v0.copy(source.v0);\r\n    this.v1.copy(source.v1);\r\n    this.v2.copy(source.v2);\r\n    return this;\r\n};\r\nQuadraticBezierCurve3.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.v0 = this.v0.toArray();\r\n    data.v1 = this.v1.toArray();\r\n    data.v2 = this.v2.toArray();\r\n    return data;\r\n};\r\nQuadraticBezierCurve3.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.v0.fromArray(json.v0);\r\n    this.v1.fromArray(json.v1);\r\n    this.v2.fromArray(json.v2);\r\n    return this;\r\n};\r\nfunction SplineCurve(points /* array of Vector2 */) {\r\n    Curve.call(this);\r\n    this.type = 'SplineCurve';\r\n    this.points = points || [];\r\n}\r\nSplineCurve.prototype = Object.create(Curve.prototype);\r\nSplineCurve.prototype.constructor = SplineCurve;\r\nSplineCurve.prototype.isSplineCurve = true;\r\nSplineCurve.prototype.getPoint = function (t, optionalTarget) {\r\n    var point = optionalTarget || new Vector2();\r\n    var points = this.points;\r\n    var p = (points.length - 1) * t;\r\n    var intPoint = Math.floor(p);\r\n    var weight = p - intPoint;\r\n    var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\r\n    var p1 = points[intPoint];\r\n    var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\r\n    var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\r\n    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\r\n    return point;\r\n};\r\nSplineCurve.prototype.copy = function (source) {\r\n    Curve.prototype.copy.call(this, source);\r\n    this.points = [];\r\n    for (var i = 0, l = source.points.length; i < l; i++) {\r\n        var point = source.points[i];\r\n        this.points.push(point.clone());\r\n    }\r\n    return this;\r\n};\r\nSplineCurve.prototype.toJSON = function () {\r\n    var data = Curve.prototype.toJSON.call(this);\r\n    data.points = [];\r\n    for (var i = 0, l = this.points.length; i < l; i++) {\r\n        var point = this.points[i];\r\n        data.points.push(point.toArray());\r\n    }\r\n    return data;\r\n};\r\nSplineCurve.prototype.fromJSON = function (json) {\r\n    Curve.prototype.fromJSON.call(this, json);\r\n    this.points = [];\r\n    for (var i = 0, l = json.points.length; i < l; i++) {\r\n        var point = json.points[i];\r\n        this.points.push(new Vector2().fromArray(point));\r\n    }\r\n    return this;\r\n};\r\nvar Curves = /*#__PURE__*/ Object.freeze({\r\n    ArcCurve: ArcCurve,\r\n    CatmullRomCurve3: CatmullRomCurve3,\r\n    CubicBezierCurve: CubicBezierCurve,\r\n    CubicBezierCurve3: CubicBezierCurve3,\r\n    EllipseCurve: EllipseCurve,\r\n    LineCurve: LineCurve,\r\n    LineCurve3: LineCurve3,\r\n    QuadraticBezierCurve: QuadraticBezierCurve,\r\n    QuadraticBezierCurve3: QuadraticBezierCurve3,\r\n    SplineCurve: SplineCurve\r\n});\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\nfunction CurvePath() {\r\n    Curve.call(this);\r\n    this.type = 'CurvePath';\r\n    this.curves = [];\r\n    this.autoClose = false; // Automatically closes the path\r\n}\r\nCurvePath.prototype = Object.assign(Object.create(Curve.prototype), {\r\n    constructor: CurvePath,\r\n    add: function (curve) {\r\n        this.curves.push(curve);\r\n    },\r\n    closePath: function () {\r\n        // Add a line curve if start and end of lines are not connected\r\n        var startPoint = this.curves[0].getPoint(0);\r\n        var endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n        if (!startPoint.equals(endPoint)) {\r\n            this.curves.push(new LineCurve(endPoint, startPoint));\r\n        }\r\n    },\r\n    // To get accurate point with reference to\r\n    // entire path distance at time t,\r\n    // following has to be done:\r\n    // 1. Length of each sub path have to be known\r\n    // 2. Locate and identify type of curve\r\n    // 3. Get t for the curve\r\n    // 4. Return curve.getPointAt(t')\r\n    getPoint: function (t) {\r\n        var d = t * this.getLength();\r\n        var curveLengths = this.getCurveLengths();\r\n        var i = 0;\r\n        // To think about boundaries points.\r\n        while (i < curveLengths.length) {\r\n            if (curveLengths[i] >= d) {\r\n                var diff = curveLengths[i] - d;\r\n                var curve = this.curves[i];\r\n                var segmentLength = curve.getLength();\r\n                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\r\n                return curve.getPointAt(u);\r\n            }\r\n            i++;\r\n        }\r\n        return null;\r\n        // loop where sum != 0, sum > d , sum+1 <d\r\n    },\r\n    // We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n    // getPoint() depends on getLength\r\n    getLength: function () {\r\n        var lens = this.getCurveLengths();\r\n        return lens[lens.length - 1];\r\n    },\r\n    // cacheLengths must be recalculated.\r\n    updateArcLengths: function () {\r\n        this.needsUpdate = true;\r\n        this.cacheLengths = null;\r\n        this.getCurveLengths();\r\n    },\r\n    // Compute lengths and cache them\r\n    // We cannot overwrite getLengths() because UtoT mapping uses it.\r\n    getCurveLengths: function () {\r\n        // We use cache values if curves and cache array are same length\r\n        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\r\n            return this.cacheLengths;\r\n        }\r\n        // Get length of sub-curve\r\n        // Push sums into cached array\r\n        var lengths = [], sums = 0;\r\n        for (var i = 0, l = this.curves.length; i < l; i++) {\r\n            sums += this.curves[i].getLength();\r\n            lengths.push(sums);\r\n        }\r\n        this.cacheLengths = lengths;\r\n        return lengths;\r\n    },\r\n    getSpacedPoints: function (divisions) {\r\n        if (divisions === undefined)\r\n            divisions = 40;\r\n        var points = [];\r\n        for (var i = 0; i <= divisions; i++) {\r\n            points.push(this.getPoint(i / divisions));\r\n        }\r\n        if (this.autoClose) {\r\n            points.push(points[0]);\r\n        }\r\n        return points;\r\n    },\r\n    getPoints: function (divisions) {\r\n        divisions = divisions || 12;\r\n        var points = [], last;\r\n        for (var i = 0, curves = this.curves; i < curves.length; i++) {\r\n            var curve = curves[i];\r\n            var resolution = (curve && curve.isEllipseCurve) ? divisions * 2\r\n                : (curve && (curve.isLineCurve || curve.isLineCurve3)) ? 1\r\n                    : (curve && curve.isSplineCurve) ? divisions * curve.points.length\r\n                        : divisions;\r\n            var pts = curve.getPoints(resolution);\r\n            for (var j = 0; j < pts.length; j++) {\r\n                var point = pts[j];\r\n                if (last && last.equals(point))\r\n                    continue; // ensures no consecutive points are duplicates\r\n                points.push(point);\r\n                last = point;\r\n            }\r\n        }\r\n        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\r\n            points.push(points[0]);\r\n        }\r\n        return points;\r\n    },\r\n    copy: function (source) {\r\n        Curve.prototype.copy.call(this, source);\r\n        this.curves = [];\r\n        for (var i = 0, l = source.curves.length; i < l; i++) {\r\n            var curve = source.curves[i];\r\n            this.curves.push(curve.clone());\r\n        }\r\n        this.autoClose = source.autoClose;\r\n        return this;\r\n    },\r\n    toJSON: function () {\r\n        var data = Curve.prototype.toJSON.call(this);\r\n        data.autoClose = this.autoClose;\r\n        data.curves = [];\r\n        for (var i = 0, l = this.curves.length; i < l; i++) {\r\n            var curve = this.curves[i];\r\n            data.curves.push(curve.toJSON());\r\n        }\r\n        return data;\r\n    },\r\n    fromJSON: function (json) {\r\n        Curve.prototype.fromJSON.call(this, json);\r\n        this.autoClose = json.autoClose;\r\n        this.curves = [];\r\n        for (var i = 0, l = json.curves.length; i < l; i++) {\r\n            var curve = json.curves[i];\r\n            this.curves.push(new Curves[curve.type]().fromJSON(curve));\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n **/\r\nfunction Path(points) {\r\n    CurvePath.call(this);\r\n    this.type = 'Path';\r\n    this.currentPoint = new Vector2();\r\n    if (points) {\r\n        this.setFromPoints(points);\r\n    }\r\n}\r\nPath.prototype = Object.assign(Object.create(CurvePath.prototype), {\r\n    constructor: Path,\r\n    setFromPoints: function (points) {\r\n        this.moveTo(points[0].x, points[0].y);\r\n        for (var i = 1, l = points.length; i < l; i++) {\r\n            this.lineTo(points[i].x, points[i].y);\r\n        }\r\n    },\r\n    moveTo: function (x, y) {\r\n        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\r\n    },\r\n    lineTo: function (x, y) {\r\n        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\r\n        this.curves.push(curve);\r\n        this.currentPoint.set(x, y);\r\n    },\r\n    quadraticCurveTo: function (aCPx, aCPy, aX, aY) {\r\n        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\r\n        this.curves.push(curve);\r\n        this.currentPoint.set(aX, aY);\r\n    },\r\n    bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\r\n        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\r\n        this.curves.push(curve);\r\n        this.currentPoint.set(aX, aY);\r\n    },\r\n    splineThru: function (pts /*Array of Vector*/) {\r\n        var npts = [this.currentPoint.clone()].concat(pts);\r\n        var curve = new SplineCurve(npts);\r\n        this.curves.push(curve);\r\n        this.currentPoint.copy(pts[pts.length - 1]);\r\n    },\r\n    arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\r\n        var x0 = this.currentPoint.x;\r\n        var y0 = this.currentPoint.y;\r\n        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n    },\r\n    absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\r\n        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n    },\r\n    ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\r\n        var x0 = this.currentPoint.x;\r\n        var y0 = this.currentPoint.y;\r\n        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\r\n    },\r\n    absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\r\n        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\r\n        if (this.curves.length > 0) {\r\n            // if a previous curve is present, attempt to join\r\n            var firstPoint = curve.getPoint(0);\r\n            if (!firstPoint.equals(this.currentPoint)) {\r\n                this.lineTo(firstPoint.x, firstPoint.y);\r\n            }\r\n        }\r\n        this.curves.push(curve);\r\n        var lastPoint = curve.getPoint(1);\r\n        this.currentPoint.copy(lastPoint);\r\n    },\r\n    copy: function (source) {\r\n        CurvePath.prototype.copy.call(this, source);\r\n        this.currentPoint.copy(source.currentPoint);\r\n        return this;\r\n    },\r\n    toJSON: function () {\r\n        var data = CurvePath.prototype.toJSON.call(this);\r\n        data.currentPoint = this.currentPoint.toArray();\r\n        return data;\r\n    },\r\n    fromJSON: function (json) {\r\n        CurvePath.prototype.fromJSON.call(this, json);\r\n        this.currentPoint.fromArray(json.currentPoint);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\nfunction Shape(points) {\r\n    Path.call(this, points);\r\n    this.uuid = _Math.generateUUID();\r\n    this.type = 'Shape';\r\n    this.holes = [];\r\n}\r\nShape.prototype = Object.assign(Object.create(Path.prototype), {\r\n    constructor: Shape,\r\n    getPointsHoles: function (divisions) {\r\n        var holesPts = [];\r\n        for (var i = 0, l = this.holes.length; i < l; i++) {\r\n            holesPts[i] = this.holes[i].getPoints(divisions);\r\n        }\r\n        return holesPts;\r\n    },\r\n    // get points of shape and holes (keypoints based on segments parameter)\r\n    extractPoints: function (divisions) {\r\n        return {\r\n            shape: this.getPoints(divisions),\r\n            holes: this.getPointsHoles(divisions)\r\n        };\r\n    },\r\n    copy: function (source) {\r\n        Path.prototype.copy.call(this, source);\r\n        this.holes = [];\r\n        for (var i = 0, l = source.holes.length; i < l; i++) {\r\n            var hole = source.holes[i];\r\n            this.holes.push(hole.clone());\r\n        }\r\n        return this;\r\n    },\r\n    toJSON: function () {\r\n        var data = Path.prototype.toJSON.call(this);\r\n        data.uuid = this.uuid;\r\n        data.holes = [];\r\n        for (var i = 0, l = this.holes.length; i < l; i++) {\r\n            var hole = this.holes[i];\r\n            data.holes.push(hole.toJSON());\r\n        }\r\n        return data;\r\n    },\r\n    fromJSON: function (json) {\r\n        Path.prototype.fromJSON.call(this, json);\r\n        this.uuid = json.uuid;\r\n        this.holes = [];\r\n        for (var i = 0, l = json.holes.length; i < l; i++) {\r\n            var hole = json.holes[i];\r\n            this.holes.push(new Path().fromJSON(hole));\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Light(color, intensity) {\r\n    Object3D.call(this);\r\n    this.type = 'Light';\r\n    this.color = new Color(color);\r\n    this.intensity = intensity !== undefined ? intensity : 1;\r\n    this.receiveShadow = undefined;\r\n}\r\nLight.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Light,\r\n    isLight: true,\r\n    copy: function (source) {\r\n        Object3D.prototype.copy.call(this, source);\r\n        this.color.copy(source.color);\r\n        this.intensity = source.intensity;\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Object3D.prototype.toJSON.call(this, meta);\r\n        data.object.color = this.color.getHex();\r\n        data.object.intensity = this.intensity;\r\n        if (this.groundColor !== undefined)\r\n            data.object.groundColor = this.groundColor.getHex();\r\n        if (this.distance !== undefined)\r\n            data.object.distance = this.distance;\r\n        if (this.angle !== undefined)\r\n            data.object.angle = this.angle;\r\n        if (this.decay !== undefined)\r\n            data.object.decay = this.decay;\r\n        if (this.penumbra !== undefined)\r\n            data.object.penumbra = this.penumbra;\r\n        if (this.shadow !== undefined)\r\n            data.object.shadow = this.shadow.toJSON();\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction HemisphereLight(skyColor, groundColor, intensity) {\r\n    Light.call(this, skyColor, intensity);\r\n    this.type = 'HemisphereLight';\r\n    this.castShadow = undefined;\r\n    this.position.copy(Object3D.DefaultUp);\r\n    this.updateMatrix();\r\n    this.groundColor = new Color(groundColor);\r\n}\r\nHemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: HemisphereLight,\r\n    isHemisphereLight: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.groundColor.copy(source.groundColor);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction LightShadow(camera) {\r\n    this.camera = camera;\r\n    this.bias = 0;\r\n    this.radius = 1;\r\n    this.mapSize = new Vector2(512, 512);\r\n    this.map = null;\r\n    this.matrix = new Matrix4();\r\n}\r\nObject.assign(LightShadow.prototype, {\r\n    copy: function (source) {\r\n        this.camera = source.camera.clone();\r\n        this.bias = source.bias;\r\n        this.radius = source.radius;\r\n        this.mapSize.copy(source.mapSize);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    toJSON: function () {\r\n        var object = {};\r\n        if (this.bias !== 0)\r\n            object.bias = this.bias;\r\n        if (this.radius !== 1)\r\n            object.radius = this.radius;\r\n        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)\r\n            object.mapSize = this.mapSize.toArray();\r\n        object.camera = this.camera.toJSON(false).object;\r\n        delete object.camera.matrix;\r\n        return object;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction SpotLightShadow() {\r\n    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));\r\n}\r\nSpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {\r\n    constructor: SpotLightShadow,\r\n    isSpotLightShadow: true,\r\n    update: function (light) {\r\n        var camera = this.camera;\r\n        var fov = _Math.RAD2DEG * 2 * light.angle;\r\n        var aspect = this.mapSize.width / this.mapSize.height;\r\n        var far = light.distance || camera.far;\r\n        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\r\n            camera.fov = fov;\r\n            camera.aspect = aspect;\r\n            camera.far = far;\r\n            camera.updateProjectionMatrix();\r\n        }\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction SpotLight(color, intensity, distance, angle, penumbra, decay) {\r\n    Light.call(this, color, intensity);\r\n    this.type = 'SpotLight';\r\n    this.position.copy(Object3D.DefaultUp);\r\n    this.updateMatrix();\r\n    this.target = new Object3D();\r\n    Object.defineProperty(this, 'power', {\r\n        get: function () {\r\n            // intensity = power per solid angle.\r\n            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n            return this.intensity * Math.PI;\r\n        },\r\n        set: function (power) {\r\n            // intensity = power per solid angle.\r\n            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n            this.intensity = power / Math.PI;\r\n        }\r\n    });\r\n    this.distance = (distance !== undefined) ? distance : 0;\r\n    this.angle = (angle !== undefined) ? angle : Math.PI / 3;\r\n    this.penumbra = (penumbra !== undefined) ? penumbra : 0;\r\n    this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.\r\n    this.shadow = new SpotLightShadow();\r\n}\r\nSpotLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: SpotLight,\r\n    isSpotLight: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.distance = source.distance;\r\n        this.angle = source.angle;\r\n        this.penumbra = source.penumbra;\r\n        this.decay = source.decay;\r\n        this.target = source.target.clone();\r\n        this.shadow = source.shadow.clone();\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction PointLight(color, intensity, distance, decay) {\r\n    Light.call(this, color, intensity);\r\n    this.type = 'PointLight';\r\n    Object.defineProperty(this, 'power', {\r\n        get: function () {\r\n            // intensity = power per solid angle.\r\n            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n            return this.intensity * 4 * Math.PI;\r\n        },\r\n        set: function (power) {\r\n            // intensity = power per solid angle.\r\n            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n            this.intensity = power / (4 * Math.PI);\r\n        }\r\n    });\r\n    this.distance = (distance !== undefined) ? distance : 0;\r\n    this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.\r\n    this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));\r\n}\r\nPointLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: PointLight,\r\n    isPointLight: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.distance = source.distance;\r\n        this.decay = source.decay;\r\n        this.shadow = source.shadow.clone();\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author arose / http://github.com/arose\r\n */\r\nfunction OrthographicCamera(left, right, top, bottom, near, far) {\r\n    Camera.call(this);\r\n    this.type = 'OrthographicCamera';\r\n    this.zoom = 1;\r\n    this.view = null;\r\n    this.left = (left !== undefined) ? left : -1;\r\n    this.right = (right !== undefined) ? right : 1;\r\n    this.top = (top !== undefined) ? top : 1;\r\n    this.bottom = (bottom !== undefined) ? bottom : -1;\r\n    this.near = (near !== undefined) ? near : 0.1;\r\n    this.far = (far !== undefined) ? far : 2000;\r\n    this.updateProjectionMatrix();\r\n}\r\nOrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {\r\n    constructor: OrthographicCamera,\r\n    isOrthographicCamera: true,\r\n    copy: function (source, recursive) {\r\n        Camera.prototype.copy.call(this, source, recursive);\r\n        this.left = source.left;\r\n        this.right = source.right;\r\n        this.top = source.top;\r\n        this.bottom = source.bottom;\r\n        this.near = source.near;\r\n        this.far = source.far;\r\n        this.zoom = source.zoom;\r\n        this.view = source.view === null ? null : Object.assign({}, source.view);\r\n        return this;\r\n    },\r\n    setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {\r\n        if (this.view === null) {\r\n            this.view = {\r\n                enabled: true,\r\n                fullWidth: 1,\r\n                fullHeight: 1,\r\n                offsetX: 0,\r\n                offsetY: 0,\r\n                width: 1,\r\n                height: 1\r\n            };\r\n        }\r\n        this.view.enabled = true;\r\n        this.view.fullWidth = fullWidth;\r\n        this.view.fullHeight = fullHeight;\r\n        this.view.offsetX = x;\r\n        this.view.offsetY = y;\r\n        this.view.width = width;\r\n        this.view.height = height;\r\n        this.updateProjectionMatrix();\r\n    },\r\n    clearViewOffset: function () {\r\n        if (this.view !== null) {\r\n            this.view.enabled = false;\r\n        }\r\n        this.updateProjectionMatrix();\r\n    },\r\n    updateProjectionMatrix: function () {\r\n        var dx = (this.right - this.left) / (2 * this.zoom);\r\n        var dy = (this.top - this.bottom) / (2 * this.zoom);\r\n        var cx = (this.right + this.left) / 2;\r\n        var cy = (this.top + this.bottom) / 2;\r\n        var left = cx - dx;\r\n        var right = cx + dx;\r\n        var top = cy + dy;\r\n        var bottom = cy - dy;\r\n        if (this.view !== null && this.view.enabled) {\r\n            var zoomW = this.zoom / (this.view.width / this.view.fullWidth);\r\n            var zoomH = this.zoom / (this.view.height / this.view.fullHeight);\r\n            var scaleW = (this.right - this.left) / this.view.width;\r\n            var scaleH = (this.top - this.bottom) / this.view.height;\r\n            left += scaleW * (this.view.offsetX / zoomW);\r\n            right = left + scaleW * (this.view.width / zoomW);\r\n            top -= scaleH * (this.view.offsetY / zoomH);\r\n            bottom = top - scaleH * (this.view.height / zoomH);\r\n        }\r\n        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\r\n        this.projectionMatrixInverse.getInverse(this.projectionMatrix);\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Object3D.prototype.toJSON.call(this, meta);\r\n        data.object.zoom = this.zoom;\r\n        data.object.left = this.left;\r\n        data.object.right = this.right;\r\n        data.object.top = this.top;\r\n        data.object.bottom = this.bottom;\r\n        data.object.near = this.near;\r\n        data.object.far = this.far;\r\n        if (this.view !== null)\r\n            data.object.view = Object.assign({}, this.view);\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction DirectionalLightShadow() {\r\n    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\r\n}\r\nDirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {\r\n    constructor: DirectionalLightShadow\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction DirectionalLight(color, intensity) {\r\n    Light.call(this, color, intensity);\r\n    this.type = 'DirectionalLight';\r\n    this.position.copy(Object3D.DefaultUp);\r\n    this.updateMatrix();\r\n    this.target = new Object3D();\r\n    this.shadow = new DirectionalLightShadow();\r\n}\r\nDirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: DirectionalLight,\r\n    isDirectionalLight: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.target = source.target.clone();\r\n        this.shadow = source.shadow.clone();\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction AmbientLight(color, intensity) {\r\n    Light.call(this, color, intensity);\r\n    this.type = 'AmbientLight';\r\n    this.castShadow = undefined;\r\n}\r\nAmbientLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: AmbientLight,\r\n    isAmbientLight: true\r\n});\r\n/**\r\n * @author abelnation / http://github.com/abelnation\r\n */\r\nfunction RectAreaLight(color, intensity, width, height) {\r\n    Light.call(this, color, intensity);\r\n    this.type = 'RectAreaLight';\r\n    this.width = (width !== undefined) ? width : 10;\r\n    this.height = (height !== undefined) ? height : 10;\r\n}\r\nRectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: RectAreaLight,\r\n    isRectAreaLight: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.width = source.width;\r\n        this.height = source.height;\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Light.prototype.toJSON.call(this, meta);\r\n        data.object.width = this.width;\r\n        data.object.height = this.height;\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction MaterialLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n    this.textures = {};\r\n}\r\nObject.assign(MaterialLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var loader = new FileLoader(scope.manager);\r\n        loader.setPath(scope.path);\r\n        loader.load(url, function (text) {\r\n            onLoad(scope.parse(JSON.parse(text)));\r\n        }, onProgress, onError);\r\n    },\r\n    parse: function (json) {\r\n        var textures = this.textures;\r\n        function getTexture(name) {\r\n            if (textures[name] === undefined) {\r\n                console.warn('THREE.MaterialLoader: Undefined texture', name);\r\n            }\r\n            return textures[name];\r\n        }\r\n        var material = new Materials[json.type]();\r\n        if (json.uuid !== undefined)\r\n            material.uuid = json.uuid;\r\n        if (json.name !== undefined)\r\n            material.name = json.name;\r\n        if (json.color !== undefined)\r\n            material.color.setHex(json.color);\r\n        if (json.roughness !== undefined)\r\n            material.roughness = json.roughness;\r\n        if (json.metalness !== undefined)\r\n            material.metalness = json.metalness;\r\n        if (json.emissive !== undefined)\r\n            material.emissive.setHex(json.emissive);\r\n        if (json.specular !== undefined)\r\n            material.specular.setHex(json.specular);\r\n        if (json.shininess !== undefined)\r\n            material.shininess = json.shininess;\r\n        if (json.clearCoat !== undefined)\r\n            material.clearCoat = json.clearCoat;\r\n        if (json.clearCoatRoughness !== undefined)\r\n            material.clearCoatRoughness = json.clearCoatRoughness;\r\n        if (json.vertexColors !== undefined)\r\n            material.vertexColors = json.vertexColors;\r\n        if (json.fog !== undefined)\r\n            material.fog = json.fog;\r\n        if (json.flatShading !== undefined)\r\n            material.flatShading = json.flatShading;\r\n        if (json.blending !== undefined)\r\n            material.blending = json.blending;\r\n        if (json.combine !== undefined)\r\n            material.combine = json.combine;\r\n        if (json.side !== undefined)\r\n            material.side = json.side;\r\n        if (json.opacity !== undefined)\r\n            material.opacity = json.opacity;\r\n        if (json.transparent !== undefined)\r\n            material.transparent = json.transparent;\r\n        if (json.alphaTest !== undefined)\r\n            material.alphaTest = json.alphaTest;\r\n        if (json.depthTest !== undefined)\r\n            material.depthTest = json.depthTest;\r\n        if (json.depthWrite !== undefined)\r\n            material.depthWrite = json.depthWrite;\r\n        if (json.colorWrite !== undefined)\r\n            material.colorWrite = json.colorWrite;\r\n        if (json.wireframe !== undefined)\r\n            material.wireframe = json.wireframe;\r\n        if (json.wireframeLinewidth !== undefined)\r\n            material.wireframeLinewidth = json.wireframeLinewidth;\r\n        if (json.wireframeLinecap !== undefined)\r\n            material.wireframeLinecap = json.wireframeLinecap;\r\n        if (json.wireframeLinejoin !== undefined)\r\n            material.wireframeLinejoin = json.wireframeLinejoin;\r\n        if (json.rotation !== undefined)\r\n            material.rotation = json.rotation;\r\n        if (json.linewidth !== 1)\r\n            material.linewidth = json.linewidth;\r\n        if (json.dashSize !== undefined)\r\n            material.dashSize = json.dashSize;\r\n        if (json.gapSize !== undefined)\r\n            material.gapSize = json.gapSize;\r\n        if (json.scale !== undefined)\r\n            material.scale = json.scale;\r\n        if (json.polygonOffset !== undefined)\r\n            material.polygonOffset = json.polygonOffset;\r\n        if (json.polygonOffsetFactor !== undefined)\r\n            material.polygonOffsetFactor = json.polygonOffsetFactor;\r\n        if (json.polygonOffsetUnits !== undefined)\r\n            material.polygonOffsetUnits = json.polygonOffsetUnits;\r\n        if (json.skinning !== undefined)\r\n            material.skinning = json.skinning;\r\n        if (json.morphTargets !== undefined)\r\n            material.morphTargets = json.morphTargets;\r\n        if (json.morphNormals !== undefined)\r\n            material.morphNormals = json.morphNormals;\r\n        if (json.dithering !== undefined)\r\n            material.dithering = json.dithering;\r\n        if (json.visible !== undefined)\r\n            material.visible = json.visible;\r\n        if (json.userData !== undefined)\r\n            material.userData = json.userData;\r\n        // Shader Material\r\n        if (json.uniforms !== undefined) {\r\n            for (var name in json.uniforms) {\r\n                var uniform = json.uniforms[name];\r\n                material.uniforms[name] = {};\r\n                switch (uniform.type) {\r\n                    case 't':\r\n                        material.uniforms[name].value = getTexture(uniform.value);\r\n                        break;\r\n                    case 'c':\r\n                        material.uniforms[name].value = new Color().setHex(uniform.value);\r\n                        break;\r\n                    case 'v2':\r\n                        material.uniforms[name].value = new Vector2().fromArray(uniform.value);\r\n                        break;\r\n                    case 'v3':\r\n                        material.uniforms[name].value = new Vector3().fromArray(uniform.value);\r\n                        break;\r\n                    case 'v4':\r\n                        material.uniforms[name].value = new Vector4().fromArray(uniform.value);\r\n                        break;\r\n                    case 'm3':\r\n                        material.uniforms[name].value = new Matrix3().fromArray(uniform.value);\r\n                    case 'm4':\r\n                        material.uniforms[name].value = new Matrix4().fromArray(uniform.value);\r\n                        break;\r\n                    default:\r\n                        material.uniforms[name].value = uniform.value;\r\n                }\r\n            }\r\n        }\r\n        if (json.defines !== undefined)\r\n            material.defines = json.defines;\r\n        if (json.vertexShader !== undefined)\r\n            material.vertexShader = json.vertexShader;\r\n        if (json.fragmentShader !== undefined)\r\n            material.fragmentShader = json.fragmentShader;\r\n        if (json.extensions !== undefined) {\r\n            for (var key in json.extensions) {\r\n                material.extensions[key] = json.extensions[key];\r\n            }\r\n        }\r\n        // Deprecated\r\n        if (json.shading !== undefined)\r\n            material.flatShading = json.shading === 1; // THREE.FlatShading\r\n        // for PointsMaterial\r\n        if (json.size !== undefined)\r\n            material.size = json.size;\r\n        if (json.sizeAttenuation !== undefined)\r\n            material.sizeAttenuation = json.sizeAttenuation;\r\n        // maps\r\n        if (json.map !== undefined)\r\n            material.map = getTexture(json.map);\r\n        if (json.matcap !== undefined)\r\n            material.matcap = getTexture(json.matcap);\r\n        if (json.alphaMap !== undefined) {\r\n            material.alphaMap = getTexture(json.alphaMap);\r\n            material.transparent = true;\r\n        }\r\n        if (json.bumpMap !== undefined)\r\n            material.bumpMap = getTexture(json.bumpMap);\r\n        if (json.bumpScale !== undefined)\r\n            material.bumpScale = json.bumpScale;\r\n        if (json.normalMap !== undefined)\r\n            material.normalMap = getTexture(json.normalMap);\r\n        if (json.normalMapType !== undefined)\r\n            material.normalMapType = json.normalMapType;\r\n        if (json.normalScale !== undefined) {\r\n            var normalScale = json.normalScale;\r\n            if (Array.isArray(normalScale) === false) {\r\n                // Blender exporter used to export a scalar. See #7459\r\n                normalScale = [normalScale, normalScale];\r\n            }\r\n            material.normalScale = new Vector2().fromArray(normalScale);\r\n        }\r\n        if (json.displacementMap !== undefined)\r\n            material.displacementMap = getTexture(json.displacementMap);\r\n        if (json.displacementScale !== undefined)\r\n            material.displacementScale = json.displacementScale;\r\n        if (json.displacementBias !== undefined)\r\n            material.displacementBias = json.displacementBias;\r\n        if (json.roughnessMap !== undefined)\r\n            material.roughnessMap = getTexture(json.roughnessMap);\r\n        if (json.metalnessMap !== undefined)\r\n            material.metalnessMap = getTexture(json.metalnessMap);\r\n        if (json.emissiveMap !== undefined)\r\n            material.emissiveMap = getTexture(json.emissiveMap);\r\n        if (json.emissiveIntensity !== undefined)\r\n            material.emissiveIntensity = json.emissiveIntensity;\r\n        if (json.specularMap !== undefined)\r\n            material.specularMap = getTexture(json.specularMap);\r\n        if (json.envMap !== undefined)\r\n            material.envMap = getTexture(json.envMap);\r\n        if (json.envMapIntensity !== undefined)\r\n            material.envMapIntensity = json.envMapIntensity;\r\n        if (json.reflectivity !== undefined)\r\n            material.reflectivity = json.reflectivity;\r\n        if (json.refractionRatio !== undefined)\r\n            material.refractionRatio = json.refractionRatio;\r\n        if (json.lightMap !== undefined)\r\n            material.lightMap = getTexture(json.lightMap);\r\n        if (json.lightMapIntensity !== undefined)\r\n            material.lightMapIntensity = json.lightMapIntensity;\r\n        if (json.aoMap !== undefined)\r\n            material.aoMap = getTexture(json.aoMap);\r\n        if (json.aoMapIntensity !== undefined)\r\n            material.aoMapIntensity = json.aoMapIntensity;\r\n        if (json.gradientMap !== undefined)\r\n            material.gradientMap = getTexture(json.gradientMap);\r\n        return material;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    },\r\n    setTextures: function (value) {\r\n        this.textures = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author Don McCurdy / https://www.donmccurdy.com\r\n */\r\nvar LoaderUtils = {\r\n    decodeText: function (array) {\r\n        if (typeof TextDecoder !== 'undefined') {\r\n            return new TextDecoder().decode(array);\r\n        }\r\n        // Avoid the String.fromCharCode.apply(null, array) shortcut, which\r\n        // throws a \"maximum call stack size exceeded\" error for large arrays.\r\n        var s = '';\r\n        for (var i = 0, il = array.length; i < il; i++) {\r\n            // Implicitly assumes little-endian.\r\n            s += String.fromCharCode(array[i]);\r\n        }\r\n        try {\r\n            // merges multi-byte utf-8 characters.\r\n            return decodeURIComponent(escape(s));\r\n        }\r\n        catch (e) { // see #16358\r\n            return s;\r\n        }\r\n    },\r\n    extractUrlBase: function (url) {\r\n        var index = url.lastIndexOf('/');\r\n        if (index === -1)\r\n            return './';\r\n        return url.substr(0, index + 1);\r\n    }\r\n};\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\nfunction InstancedBufferGeometry() {\r\n    BufferGeometry.call(this);\r\n    this.type = 'InstancedBufferGeometry';\r\n    this.maxInstancedCount = undefined;\r\n}\r\nInstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {\r\n    constructor: InstancedBufferGeometry,\r\n    isInstancedBufferGeometry: true,\r\n    copy: function (source) {\r\n        BufferGeometry.prototype.copy.call(this, source);\r\n        this.maxInstancedCount = source.maxInstancedCount;\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    toJSON: function () {\r\n        var data = BufferGeometry.prototype.toJSON.call(this);\r\n        data.maxInstancedCount = this.maxInstancedCount;\r\n        data.isInstancedBufferGeometry = true;\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\nfunction InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {\r\n    if (typeof (normalized) === 'number') {\r\n        meshPerAttribute = normalized;\r\n        normalized = false;\r\n        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');\r\n    }\r\n    BufferAttribute.call(this, array, itemSize, normalized);\r\n    this.meshPerAttribute = meshPerAttribute || 1;\r\n}\r\nInstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {\r\n    constructor: InstancedBufferAttribute,\r\n    isInstancedBufferAttribute: true,\r\n    copy: function (source) {\r\n        BufferAttribute.prototype.copy.call(this, source);\r\n        this.meshPerAttribute = source.meshPerAttribute;\r\n        return this;\r\n    },\r\n    toJSON: function () {\r\n        var data = BufferAttribute.prototype.toJSON.call(this);\r\n        data.meshPerAttribute = this.meshPerAttribute;\r\n        data.isInstancedBufferAttribute = true;\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction BufferGeometryLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(BufferGeometryLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var loader = new FileLoader(scope.manager);\r\n        loader.setPath(scope.path);\r\n        loader.load(url, function (text) {\r\n            onLoad(scope.parse(JSON.parse(text)));\r\n        }, onProgress, onError);\r\n    },\r\n    parse: function (json) {\r\n        var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\r\n        var index = json.data.index;\r\n        if (index !== undefined) {\r\n            var typedArray = new TYPED_ARRAYS[index.type](index.array);\r\n            geometry.setIndex(new BufferAttribute(typedArray, 1));\r\n        }\r\n        var attributes = json.data.attributes;\r\n        for (var key in attributes) {\r\n            var attribute = attributes[key];\r\n            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);\r\n            var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\r\n            var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\r\n            if (attribute.name !== undefined)\r\n                bufferAttribute.name = attribute.name;\r\n            geometry.addAttribute(key, bufferAttribute);\r\n        }\r\n        var morphAttributes = json.data.morphAttributes;\r\n        if (morphAttributes) {\r\n            for (var key in morphAttributes) {\r\n                var attributeArray = morphAttributes[key];\r\n                var array = [];\r\n                for (var i = 0, il = attributeArray.length; i < il; i++) {\r\n                    var attribute = attributeArray[i];\r\n                    var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);\r\n                    var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\r\n                    if (attribute.name !== undefined)\r\n                        bufferAttribute.name = attribute.name;\r\n                    array.push(bufferAttribute);\r\n                }\r\n                geometry.morphAttributes[key] = array;\r\n            }\r\n        }\r\n        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n        if (groups !== undefined) {\r\n            for (var i = 0, n = groups.length; i !== n; ++i) {\r\n                var group = groups[i];\r\n                geometry.addGroup(group.start, group.count, group.materialIndex);\r\n            }\r\n        }\r\n        var boundingSphere = json.data.boundingSphere;\r\n        if (boundingSphere !== undefined) {\r\n            var center = new Vector3();\r\n            if (boundingSphere.center !== undefined) {\r\n                center.fromArray(boundingSphere.center);\r\n            }\r\n            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\r\n        }\r\n        if (json.name)\r\n            geometry.name = json.name;\r\n        if (json.userData)\r\n            geometry.userData = json.userData;\r\n        return geometry;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\nvar TYPED_ARRAYS = {\r\n    Int8Array: Int8Array,\r\n    Uint8Array: Uint8Array,\r\n    // Workaround for IE11 pre KB2929437. See #11440\r\n    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\r\n    Int16Array: Int16Array,\r\n    Uint16Array: Uint16Array,\r\n    Int32Array: Int32Array,\r\n    Uint32Array: Uint32Array,\r\n    Float32Array: Float32Array,\r\n    Float64Array: Float64Array\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction ObjectLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n    this.resourcePath = '';\r\n}\r\nObject.assign(ObjectLoader.prototype, {\r\n    crossOrigin: 'anonymous',\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var path = (this.path === undefined) ? LoaderUtils.extractUrlBase(url) : this.path;\r\n        this.resourcePath = this.resourcePath || path;\r\n        var loader = new FileLoader(scope.manager);\r\n        loader.setPath(this.path);\r\n        loader.load(url, function (text) {\r\n            var json = null;\r\n            try {\r\n                json = JSON.parse(text);\r\n            }\r\n            catch (error) {\r\n                if (onError !== undefined)\r\n                    onError(error);\r\n                console.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\r\n                return;\r\n            }\r\n            var metadata = json.metadata;\r\n            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\r\n                console.error('THREE.ObjectLoader: Can\\'t load ' + url);\r\n                return;\r\n            }\r\n            scope.parse(json, onLoad);\r\n        }, onProgress, onError);\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    },\r\n    setResourcePath: function (value) {\r\n        this.resourcePath = value;\r\n        return this;\r\n    },\r\n    setCrossOrigin: function (value) {\r\n        this.crossOrigin = value;\r\n        return this;\r\n    },\r\n    parse: function (json, onLoad) {\r\n        var shapes = this.parseShape(json.shapes);\r\n        var geometries = this.parseGeometries(json.geometries, shapes);\r\n        var images = this.parseImages(json.images, function () {\r\n            if (onLoad !== undefined)\r\n                onLoad(object);\r\n        });\r\n        var textures = this.parseTextures(json.textures, images);\r\n        var materials = this.parseMaterials(json.materials, textures);\r\n        var object = this.parseObject(json.object, geometries, materials);\r\n        if (json.animations) {\r\n            object.animations = this.parseAnimations(json.animations);\r\n        }\r\n        if (json.images === undefined || json.images.length === 0) {\r\n            if (onLoad !== undefined)\r\n                onLoad(object);\r\n        }\r\n        return object;\r\n    },\r\n    parseShape: function (json) {\r\n        var shapes = {};\r\n        if (json !== undefined) {\r\n            for (var i = 0, l = json.length; i < l; i++) {\r\n                var shape = new Shape().fromJSON(json[i]);\r\n                shapes[shape.uuid] = shape;\r\n            }\r\n        }\r\n        return shapes;\r\n    },\r\n    parseGeometries: function (json, shapes) {\r\n        var geometries = {};\r\n        if (json !== undefined) {\r\n            var bufferGeometryLoader = new BufferGeometryLoader();\r\n            for (var i = 0, l = json.length; i < l; i++) {\r\n                var geometry;\r\n                var data = json[i];\r\n                switch (data.type) {\r\n                    case 'PlaneGeometry':\r\n                    case 'PlaneBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\r\n                        break;\r\n                    case 'BoxGeometry':\r\n                    case 'BoxBufferGeometry':\r\n                    case 'CubeGeometry': // backwards compatible\r\n                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\r\n                        break;\r\n                    case 'CircleGeometry':\r\n                    case 'CircleBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);\r\n                        break;\r\n                    case 'CylinderGeometry':\r\n                    case 'CylinderBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\r\n                        break;\r\n                    case 'ConeGeometry':\r\n                    case 'ConeBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\r\n                        break;\r\n                    case 'SphereGeometry':\r\n                    case 'SphereBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\r\n                        break;\r\n                    case 'DodecahedronGeometry':\r\n                    case 'DodecahedronBufferGeometry':\r\n                    case 'IcosahedronGeometry':\r\n                    case 'IcosahedronBufferGeometry':\r\n                    case 'OctahedronGeometry':\r\n                    case 'OctahedronBufferGeometry':\r\n                    case 'TetrahedronGeometry':\r\n                    case 'TetrahedronBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.detail);\r\n                        break;\r\n                    case 'RingGeometry':\r\n                    case 'RingBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\r\n                        break;\r\n                    case 'TorusGeometry':\r\n                    case 'TorusBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\r\n                        break;\r\n                    case 'TorusKnotGeometry':\r\n                    case 'TorusKnotBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\r\n                        break;\r\n                    case 'TubeGeometry':\r\n                    case 'TubeBufferGeometry':\r\n                        // This only works for built-in curves (e.g. CatmullRomCurve3).\r\n                        // User defined curves or instances of CurvePath will not be deserialized.\r\n                        geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\r\n                        break;\r\n                    case 'LatheGeometry':\r\n                    case 'LatheBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);\r\n                        break;\r\n                    case 'PolyhedronGeometry':\r\n                    case 'PolyhedronBufferGeometry':\r\n                        geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);\r\n                        break;\r\n                    case 'ShapeGeometry':\r\n                    case 'ShapeBufferGeometry':\r\n                        var geometryShapes = [];\r\n                        for (var j = 0, jl = data.shapes.length; j < jl; j++) {\r\n                            var shape = shapes[data.shapes[j]];\r\n                            geometryShapes.push(shape);\r\n                        }\r\n                        geometry = new Geometries[data.type](geometryShapes, data.curveSegments);\r\n                        break;\r\n                    case 'ExtrudeGeometry':\r\n                    case 'ExtrudeBufferGeometry':\r\n                        var geometryShapes = [];\r\n                        for (var j = 0, jl = data.shapes.length; j < jl; j++) {\r\n                            var shape = shapes[data.shapes[j]];\r\n                            geometryShapes.push(shape);\r\n                        }\r\n                        var extrudePath = data.options.extrudePath;\r\n                        if (extrudePath !== undefined) {\r\n                            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\r\n                        }\r\n                        geometry = new Geometries[data.type](geometryShapes, data.options);\r\n                        break;\r\n                    case 'BufferGeometry':\r\n                    case 'InstancedBufferGeometry':\r\n                        geometry = bufferGeometryLoader.parse(data);\r\n                        break;\r\n                    case 'Geometry':\r\n                        if ('THREE' in window && 'LegacyJSONLoader' in THREE) {\r\n                            var geometryLoader = new THREE.LegacyJSONLoader();\r\n                            geometry = geometryLoader.parse(data, this.resourcePath).geometry;\r\n                        }\r\n                        else {\r\n                            console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".');\r\n                        }\r\n                        break;\r\n                    default:\r\n                        console.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\r\n                        continue;\r\n                }\r\n                geometry.uuid = data.uuid;\r\n                if (data.name !== undefined)\r\n                    geometry.name = data.name;\r\n                if (geometry.isBufferGeometry === true && data.userData !== undefined)\r\n                    geometry.userData = data.userData;\r\n                geometries[data.uuid] = geometry;\r\n            }\r\n        }\r\n        return geometries;\r\n    },\r\n    parseMaterials: function (json, textures) {\r\n        var cache = {}; // MultiMaterial\r\n        var materials = {};\r\n        if (json !== undefined) {\r\n            var loader = new MaterialLoader();\r\n            loader.setTextures(textures);\r\n            for (var i = 0, l = json.length; i < l; i++) {\r\n                var data = json[i];\r\n                if (data.type === 'MultiMaterial') {\r\n                    // Deprecated\r\n                    var array = [];\r\n                    for (var j = 0; j < data.materials.length; j++) {\r\n                        var material = data.materials[j];\r\n                        if (cache[material.uuid] === undefined) {\r\n                            cache[material.uuid] = loader.parse(material);\r\n                        }\r\n                        array.push(cache[material.uuid]);\r\n                    }\r\n                    materials[data.uuid] = array;\r\n                }\r\n                else {\r\n                    if (cache[data.uuid] === undefined) {\r\n                        cache[data.uuid] = loader.parse(data);\r\n                    }\r\n                    materials[data.uuid] = cache[data.uuid];\r\n                }\r\n            }\r\n        }\r\n        return materials;\r\n    },\r\n    parseAnimations: function (json) {\r\n        var animations = [];\r\n        for (var i = 0; i < json.length; i++) {\r\n            var data = json[i];\r\n            var clip = AnimationClip.parse(data);\r\n            if (data.uuid !== undefined)\r\n                clip.uuid = data.uuid;\r\n            animations.push(clip);\r\n        }\r\n        return animations;\r\n    },\r\n    parseImages: function (json, onLoad) {\r\n        var scope = this;\r\n        var images = {};\r\n        function loadImage(url) {\r\n            scope.manager.itemStart(url);\r\n            return loader.load(url, function () {\r\n                scope.manager.itemEnd(url);\r\n            }, undefined, function () {\r\n                scope.manager.itemError(url);\r\n                scope.manager.itemEnd(url);\r\n            });\r\n        }\r\n        if (json !== undefined && json.length > 0) {\r\n            var manager = new LoadingManager(onLoad);\r\n            var loader = new ImageLoader(manager);\r\n            loader.setCrossOrigin(this.crossOrigin);\r\n            for (var i = 0, il = json.length; i < il; i++) {\r\n                var image = json[i];\r\n                var url = image.url;\r\n                if (Array.isArray(url)) {\r\n                    // load array of images e.g CubeTexture\r\n                    images[image.uuid] = [];\r\n                    for (var j = 0, jl = url.length; j < jl; j++) {\r\n                        var currentUrl = url[j];\r\n                        var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;\r\n                        images[image.uuid].push(loadImage(path));\r\n                    }\r\n                }\r\n                else {\r\n                    // load single image\r\n                    var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;\r\n                    images[image.uuid] = loadImage(path);\r\n                }\r\n            }\r\n        }\r\n        return images;\r\n    },\r\n    parseTextures: function (json, images) {\r\n        function parseConstant(value, type) {\r\n            if (typeof value === 'number')\r\n                return value;\r\n            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\r\n            return type[value];\r\n        }\r\n        var textures = {};\r\n        if (json !== undefined) {\r\n            for (var i = 0, l = json.length; i < l; i++) {\r\n                var data = json[i];\r\n                if (data.image === undefined) {\r\n                    console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\r\n                }\r\n                if (images[data.image] === undefined) {\r\n                    console.warn('THREE.ObjectLoader: Undefined image', data.image);\r\n                }\r\n                var texture;\r\n                if (Array.isArray(images[data.image])) {\r\n                    texture = new CubeTexture(images[data.image]);\r\n                }\r\n                else {\r\n                    texture = new Texture(images[data.image]);\r\n                }\r\n                texture.needsUpdate = true;\r\n                texture.uuid = data.uuid;\r\n                if (data.name !== undefined)\r\n                    texture.name = data.name;\r\n                if (data.mapping !== undefined)\r\n                    texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\r\n                if (data.offset !== undefined)\r\n                    texture.offset.fromArray(data.offset);\r\n                if (data.repeat !== undefined)\r\n                    texture.repeat.fromArray(data.repeat);\r\n                if (data.center !== undefined)\r\n                    texture.center.fromArray(data.center);\r\n                if (data.rotation !== undefined)\r\n                    texture.rotation = data.rotation;\r\n                if (data.wrap !== undefined) {\r\n                    texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\r\n                    texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\r\n                }\r\n                if (data.format !== undefined)\r\n                    texture.format = data.format;\r\n                if (data.type !== undefined)\r\n                    texture.type = data.type;\r\n                if (data.encoding !== undefined)\r\n                    texture.encoding = data.encoding;\r\n                if (data.minFilter !== undefined)\r\n                    texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\r\n                if (data.magFilter !== undefined)\r\n                    texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\r\n                if (data.anisotropy !== undefined)\r\n                    texture.anisotropy = data.anisotropy;\r\n                if (data.flipY !== undefined)\r\n                    texture.flipY = data.flipY;\r\n                if (data.premultiplyAlpha !== undefined)\r\n                    texture.premultiplyAlpha = data.premultiplyAlpha;\r\n                if (data.unpackAlignment !== undefined)\r\n                    texture.unpackAlignment = data.unpackAlignment;\r\n                textures[data.uuid] = texture;\r\n            }\r\n        }\r\n        return textures;\r\n    },\r\n    parseObject: function (data, geometries, materials) {\r\n        var object;\r\n        function getGeometry(name) {\r\n            if (geometries[name] === undefined) {\r\n                console.warn('THREE.ObjectLoader: Undefined geometry', name);\r\n            }\r\n            return geometries[name];\r\n        }\r\n        function getMaterial(name) {\r\n            if (name === undefined)\r\n                return undefined;\r\n            if (Array.isArray(name)) {\r\n                var array = [];\r\n                for (var i = 0, l = name.length; i < l; i++) {\r\n                    var uuid = name[i];\r\n                    if (materials[uuid] === undefined) {\r\n                        console.warn('THREE.ObjectLoader: Undefined material', uuid);\r\n                    }\r\n                    array.push(materials[uuid]);\r\n                }\r\n                return array;\r\n            }\r\n            if (materials[name] === undefined) {\r\n                console.warn('THREE.ObjectLoader: Undefined material', name);\r\n            }\r\n            return materials[name];\r\n        }\r\n        switch (data.type) {\r\n            case 'Scene':\r\n                object = new Scene();\r\n                if (data.background !== undefined) {\r\n                    if (Number.isInteger(data.background)) {\r\n                        object.background = new Color(data.background);\r\n                    }\r\n                }\r\n                if (data.fog !== undefined) {\r\n                    if (data.fog.type === 'Fog') {\r\n                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\r\n                    }\r\n                    else if (data.fog.type === 'FogExp2') {\r\n                        object.fog = new FogExp2(data.fog.color, data.fog.density);\r\n                    }\r\n                }\r\n                break;\r\n            case 'PerspectiveCamera':\r\n                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\r\n                if (data.focus !== undefined)\r\n                    object.focus = data.focus;\r\n                if (data.zoom !== undefined)\r\n                    object.zoom = data.zoom;\r\n                if (data.filmGauge !== undefined)\r\n                    object.filmGauge = data.filmGauge;\r\n                if (data.filmOffset !== undefined)\r\n                    object.filmOffset = data.filmOffset;\r\n                if (data.view !== undefined)\r\n                    object.view = Object.assign({}, data.view);\r\n                break;\r\n            case 'OrthographicCamera':\r\n                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\r\n                if (data.zoom !== undefined)\r\n                    object.zoom = data.zoom;\r\n                if (data.view !== undefined)\r\n                    object.view = Object.assign({}, data.view);\r\n                break;\r\n            case 'AmbientLight':\r\n                object = new AmbientLight(data.color, data.intensity);\r\n                break;\r\n            case 'DirectionalLight':\r\n                object = new DirectionalLight(data.color, data.intensity);\r\n                break;\r\n            case 'PointLight':\r\n                object = new PointLight(data.color, data.intensity, data.distance, data.decay);\r\n                break;\r\n            case 'RectAreaLight':\r\n                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\r\n                break;\r\n            case 'SpotLight':\r\n                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\r\n                break;\r\n            case 'HemisphereLight':\r\n                object = new HemisphereLight(data.color, data.groundColor, data.intensity);\r\n                break;\r\n            case 'SkinnedMesh':\r\n                console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');\r\n            case 'Mesh':\r\n                var geometry = getGeometry(data.geometry);\r\n                var material = getMaterial(data.material);\r\n                if (geometry.bones && geometry.bones.length > 0) {\r\n                    object = new SkinnedMesh(geometry, material);\r\n                }\r\n                else {\r\n                    object = new Mesh(geometry, material);\r\n                }\r\n                if (data.drawMode !== undefined)\r\n                    object.setDrawMode(data.drawMode);\r\n                break;\r\n            case 'LOD':\r\n                object = new LOD();\r\n                break;\r\n            case 'Line':\r\n                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);\r\n                break;\r\n            case 'LineLoop':\r\n                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\r\n                break;\r\n            case 'LineSegments':\r\n                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\r\n                break;\r\n            case 'PointCloud':\r\n            case 'Points':\r\n                object = new Points(getGeometry(data.geometry), getMaterial(data.material));\r\n                break;\r\n            case 'Sprite':\r\n                object = new Sprite(getMaterial(data.material));\r\n                break;\r\n            case 'Group':\r\n                object = new Group();\r\n                break;\r\n            default:\r\n                object = new Object3D();\r\n        }\r\n        object.uuid = data.uuid;\r\n        if (data.name !== undefined)\r\n            object.name = data.name;\r\n        if (data.matrix !== undefined) {\r\n            object.matrix.fromArray(data.matrix);\r\n            if (data.matrixAutoUpdate !== undefined)\r\n                object.matrixAutoUpdate = data.matrixAutoUpdate;\r\n            if (object.matrixAutoUpdate)\r\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\r\n        }\r\n        else {\r\n            if (data.position !== undefined)\r\n                object.position.fromArray(data.position);\r\n            if (data.rotation !== undefined)\r\n                object.rotation.fromArray(data.rotation);\r\n            if (data.quaternion !== undefined)\r\n                object.quaternion.fromArray(data.quaternion);\r\n            if (data.scale !== undefined)\r\n                object.scale.fromArray(data.scale);\r\n        }\r\n        if (data.castShadow !== undefined)\r\n            object.castShadow = data.castShadow;\r\n        if (data.receiveShadow !== undefined)\r\n            object.receiveShadow = data.receiveShadow;\r\n        if (data.shadow) {\r\n            if (data.shadow.bias !== undefined)\r\n                object.shadow.bias = data.shadow.bias;\r\n            if (data.shadow.radius !== undefined)\r\n                object.shadow.radius = data.shadow.radius;\r\n            if (data.shadow.mapSize !== undefined)\r\n                object.shadow.mapSize.fromArray(data.shadow.mapSize);\r\n            if (data.shadow.camera !== undefined)\r\n                object.shadow.camera = this.parseObject(data.shadow.camera);\r\n        }\r\n        if (data.visible !== undefined)\r\n            object.visible = data.visible;\r\n        if (data.frustumCulled !== undefined)\r\n            object.frustumCulled = data.frustumCulled;\r\n        if (data.renderOrder !== undefined)\r\n            object.renderOrder = data.renderOrder;\r\n        if (data.userData !== undefined)\r\n            object.userData = data.userData;\r\n        if (data.layers !== undefined)\r\n            object.layers.mask = data.layers;\r\n        if (data.children !== undefined) {\r\n            var children = data.children;\r\n            for (var i = 0; i < children.length; i++) {\r\n                object.add(this.parseObject(children[i], geometries, materials));\r\n            }\r\n        }\r\n        if (data.type === 'LOD') {\r\n            var levels = data.levels;\r\n            for (var l = 0; l < levels.length; l++) {\r\n                var level = levels[l];\r\n                var child = object.getObjectByProperty('uuid', level.object);\r\n                if (child !== undefined) {\r\n                    object.addLevel(child, level.distance);\r\n                }\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n});\r\nvar TEXTURE_MAPPING = {\r\n    UVMapping: UVMapping,\r\n    CubeReflectionMapping: CubeReflectionMapping,\r\n    CubeRefractionMapping: CubeRefractionMapping,\r\n    EquirectangularReflectionMapping: EquirectangularReflectionMapping,\r\n    EquirectangularRefractionMapping: EquirectangularRefractionMapping,\r\n    SphericalReflectionMapping: SphericalReflectionMapping,\r\n    CubeUVReflectionMapping: CubeUVReflectionMapping,\r\n    CubeUVRefractionMapping: CubeUVRefractionMapping\r\n};\r\nvar TEXTURE_WRAPPING = {\r\n    RepeatWrapping: RepeatWrapping,\r\n    ClampToEdgeWrapping: ClampToEdgeWrapping,\r\n    MirroredRepeatWrapping: MirroredRepeatWrapping\r\n};\r\nvar TEXTURE_FILTER = {\r\n    NearestFilter: NearestFilter,\r\n    NearestMipmapNearestFilter: NearestMipmapNearestFilter,\r\n    NearestMipmapLinearFilter: NearestMipmapLinearFilter,\r\n    LinearFilter: LinearFilter,\r\n    LinearMipmapNearestFilter: LinearMipmapNearestFilter,\r\n    LinearMipmapLinearFilter: LinearMipmapLinearFilter\r\n};\r\n/**\r\n * @author thespite / http://clicktorelease.com/\r\n */\r\nfunction ImageBitmapLoader(manager) {\r\n    if (typeof createImageBitmap === 'undefined') {\r\n        console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\r\n    }\r\n    if (typeof fetch === 'undefined') {\r\n        console.warn('THREE.ImageBitmapLoader: fetch() not supported.');\r\n    }\r\n    this.manager = manager !== undefined ? manager : DefaultLoadingManager;\r\n    this.options = undefined;\r\n}\r\nImageBitmapLoader.prototype = {\r\n    constructor: ImageBitmapLoader,\r\n    setOptions: function setOptions(options) {\r\n        this.options = options;\r\n        return this;\r\n    },\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        if (url === undefined)\r\n            url = '';\r\n        if (this.path !== undefined)\r\n            url = this.path + url;\r\n        url = this.manager.resolveURL(url);\r\n        var scope = this;\r\n        var cached = Cache.get(url);\r\n        if (cached !== undefined) {\r\n            scope.manager.itemStart(url);\r\n            setTimeout(function () {\r\n                if (onLoad)\r\n                    onLoad(cached);\r\n                scope.manager.itemEnd(url);\r\n            }, 0);\r\n            return cached;\r\n        }\r\n        fetch(url).then(function (res) {\r\n            return res.blob();\r\n        }).then(function (blob) {\r\n            if (scope.options === undefined) {\r\n                // Workaround for FireFox. It causes an error if you pass options.\r\n                return createImageBitmap(blob);\r\n            }\r\n            else {\r\n                return createImageBitmap(blob, scope.options);\r\n            }\r\n        }).then(function (imageBitmap) {\r\n            Cache.add(url, imageBitmap);\r\n            if (onLoad)\r\n                onLoad(imageBitmap);\r\n            scope.manager.itemEnd(url);\r\n        }).catch(function (e) {\r\n            if (onError)\r\n                onError(e);\r\n            scope.manager.itemError(url);\r\n            scope.manager.itemEnd(url);\r\n        });\r\n        scope.manager.itemStart(url);\r\n    },\r\n    setCrossOrigin: function ( /* value */) {\r\n        return this;\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\r\n **/\r\nfunction ShapePath() {\r\n    this.type = 'ShapePath';\r\n    this.color = new Color();\r\n    this.subPaths = [];\r\n    this.currentPath = null;\r\n}\r\nObject.assign(ShapePath.prototype, {\r\n    moveTo: function (x, y) {\r\n        this.currentPath = new Path();\r\n        this.subPaths.push(this.currentPath);\r\n        this.currentPath.moveTo(x, y);\r\n    },\r\n    lineTo: function (x, y) {\r\n        this.currentPath.lineTo(x, y);\r\n    },\r\n    quadraticCurveTo: function (aCPx, aCPy, aX, aY) {\r\n        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\r\n    },\r\n    bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\r\n        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\r\n    },\r\n    splineThru: function (pts) {\r\n        this.currentPath.splineThru(pts);\r\n    },\r\n    toShapes: function (isCCW, noHoles) {\r\n        function toShapesNoHoles(inSubpaths) {\r\n            var shapes = [];\r\n            for (var i = 0, l = inSubpaths.length; i < l; i++) {\r\n                var tmpPath = inSubpaths[i];\r\n                var tmpShape = new Shape();\r\n                tmpShape.curves = tmpPath.curves;\r\n                shapes.push(tmpShape);\r\n            }\r\n            return shapes;\r\n        }\r\n        function isPointInsidePolygon(inPt, inPolygon) {\r\n            var polyLen = inPolygon.length;\r\n            // inPt on polygon contour => immediate success    or\r\n            // toggling of inside/outside at every single! intersection point of an edge\r\n            //  with the horizontal line through inPt, left of inPt\r\n            //  not counting lowerY endpoints of edges and whole edges on that line\r\n            var inside = false;\r\n            for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {\r\n                var edgeLowPt = inPolygon[p];\r\n                var edgeHighPt = inPolygon[q];\r\n                var edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n                var edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n                if (Math.abs(edgeDy) > Number.EPSILON) {\r\n                    // not parallel\r\n                    if (edgeDy < 0) {\r\n                        edgeLowPt = inPolygon[q];\r\n                        edgeDx = -edgeDx;\r\n                        edgeHighPt = inPolygon[p];\r\n                        edgeDy = -edgeDy;\r\n                    }\r\n                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))\r\n                        continue;\r\n                    if (inPt.y === edgeLowPt.y) {\r\n                        if (inPt.x === edgeLowPt.x)\r\n                            return true; // inPt is on contour ?\r\n                        // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n                    }\r\n                    else {\r\n                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n                        if (perpEdge === 0)\r\n                            return true; // inPt is on contour ?\r\n                        if (perpEdge < 0)\r\n                            continue;\r\n                        inside = !inside; // true intersection left of inPt\r\n                    }\r\n                }\r\n                else {\r\n                    // parallel or collinear\r\n                    if (inPt.y !== edgeLowPt.y)\r\n                        continue; // parallel\r\n                    // edge lies on the same horizontal line as inPt\r\n                    if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||\r\n                        ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))\r\n                        return true; // inPt: Point on contour !\r\n                    // continue;\r\n                }\r\n            }\r\n            return inside;\r\n        }\r\n        var isClockWise = ShapeUtils.isClockWise;\r\n        var subPaths = this.subPaths;\r\n        if (subPaths.length === 0)\r\n            return [];\r\n        if (noHoles === true)\r\n            return toShapesNoHoles(subPaths);\r\n        var solid, tmpPath, tmpShape, shapes = [];\r\n        if (subPaths.length === 1) {\r\n            tmpPath = subPaths[0];\r\n            tmpShape = new Shape();\r\n            tmpShape.curves = tmpPath.curves;\r\n            shapes.push(tmpShape);\r\n            return shapes;\r\n        }\r\n        var holesFirst = !isClockWise(subPaths[0].getPoints());\r\n        holesFirst = isCCW ? !holesFirst : holesFirst;\r\n        // console.log(\"Holes first\", holesFirst);\r\n        var betterShapeHoles = [];\r\n        var newShapes = [];\r\n        var newShapeHoles = [];\r\n        var mainIdx = 0;\r\n        var tmpPoints;\r\n        newShapes[mainIdx] = undefined;\r\n        newShapeHoles[mainIdx] = [];\r\n        for (var i = 0, l = subPaths.length; i < l; i++) {\r\n            tmpPath = subPaths[i];\r\n            tmpPoints = tmpPath.getPoints();\r\n            solid = isClockWise(tmpPoints);\r\n            solid = isCCW ? !solid : solid;\r\n            if (solid) {\r\n                if ((!holesFirst) && (newShapes[mainIdx]))\r\n                    mainIdx++;\r\n                newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };\r\n                newShapes[mainIdx].s.curves = tmpPath.curves;\r\n                if (holesFirst)\r\n                    mainIdx++;\r\n                newShapeHoles[mainIdx] = [];\r\n                //console.log('cw', i);\r\n            }\r\n            else {\r\n                newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });\r\n                //console.log('ccw', i);\r\n            }\r\n        }\r\n        // only Holes? -> probably all Shapes with wrong orientation\r\n        if (!newShapes[0])\r\n            return toShapesNoHoles(subPaths);\r\n        if (newShapes.length > 1) {\r\n            var ambiguous = false;\r\n            var toChange = [];\r\n            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\r\n                betterShapeHoles[sIdx] = [];\r\n            }\r\n            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\r\n                var sho = newShapeHoles[sIdx];\r\n                for (var hIdx = 0; hIdx < sho.length; hIdx++) {\r\n                    var ho = sho[hIdx];\r\n                    var hole_unassigned = true;\r\n                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\r\n                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\r\n                            if (sIdx !== s2Idx)\r\n                                toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });\r\n                            if (hole_unassigned) {\r\n                                hole_unassigned = false;\r\n                                betterShapeHoles[s2Idx].push(ho);\r\n                            }\r\n                            else {\r\n                                ambiguous = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (hole_unassigned) {\r\n                        betterShapeHoles[sIdx].push(ho);\r\n                    }\r\n                }\r\n            }\r\n            // console.log(\"ambiguous: \", ambiguous);\r\n            if (toChange.length > 0) {\r\n                // console.log(\"to change: \", toChange);\r\n                if (!ambiguous)\r\n                    newShapeHoles = betterShapeHoles;\r\n            }\r\n        }\r\n        var tmpHoles;\r\n        for (var i = 0, il = newShapes.length; i < il; i++) {\r\n            tmpShape = newShapes[i].s;\r\n            shapes.push(tmpShape);\r\n            tmpHoles = newShapeHoles[i];\r\n            for (var j = 0, jl = tmpHoles.length; j < jl; j++) {\r\n                tmpShape.holes.push(tmpHoles[j].h);\r\n            }\r\n        }\r\n        //console.log(\"shape\", shapes);\r\n        return shapes;\r\n    }\r\n});\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Font(data) {\r\n    this.type = 'Font';\r\n    this.data = data;\r\n}\r\nObject.assign(Font.prototype, {\r\n    isFont: true,\r\n    generateShapes: function (text, size) {\r\n        if (size === undefined)\r\n            size = 100;\r\n        var shapes = [];\r\n        var paths = createPaths(text, size, this.data);\r\n        for (var p = 0, pl = paths.length; p < pl; p++) {\r\n            Array.prototype.push.apply(shapes, paths[p].toShapes());\r\n        }\r\n        return shapes;\r\n    }\r\n});\r\nfunction createPaths(text, size, data) {\r\n    var chars = Array.from ? Array.from(text) : String(text).split(''); // see #13988\r\n    var scale = size / data.resolution;\r\n    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\r\n    var paths = [];\r\n    var offsetX = 0, offsetY = 0;\r\n    for (var i = 0; i < chars.length; i++) {\r\n        var char = chars[i];\r\n        if (char === '\\n') {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        }\r\n        else {\r\n            var ret = createPath(char, scale, offsetX, offsetY, data);\r\n            offsetX += ret.offsetX;\r\n            paths.push(ret.path);\r\n        }\r\n    }\r\n    return paths;\r\n}\r\nfunction createPath(char, scale, offsetX, offsetY, data) {\r\n    var glyph = data.glyphs[char] || data.glyphs['?'];\r\n    if (!glyph) {\r\n        console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\r\n        return;\r\n    }\r\n    var path = new ShapePath();\r\n    var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\r\n    if (glyph.o) {\r\n        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\r\n        for (var i = 0, l = outline.length; i < l;) {\r\n            var action = outline[i++];\r\n            switch (action) {\r\n                case 'm': // moveTo\r\n                    x = outline[i++] * scale + offsetX;\r\n                    y = outline[i++] * scale + offsetY;\r\n                    path.moveTo(x, y);\r\n                    break;\r\n                case 'l': // lineTo\r\n                    x = outline[i++] * scale + offsetX;\r\n                    y = outline[i++] * scale + offsetY;\r\n                    path.lineTo(x, y);\r\n                    break;\r\n                case 'q': // quadraticCurveTo\r\n                    cpx = outline[i++] * scale + offsetX;\r\n                    cpy = outline[i++] * scale + offsetY;\r\n                    cpx1 = outline[i++] * scale + offsetX;\r\n                    cpy1 = outline[i++] * scale + offsetY;\r\n                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                case 'b': // bezierCurveTo\r\n                    cpx = outline[i++] * scale + offsetX;\r\n                    cpy = outline[i++] * scale + offsetY;\r\n                    cpx1 = outline[i++] * scale + offsetX;\r\n                    cpy1 = outline[i++] * scale + offsetY;\r\n                    cpx2 = outline[i++] * scale + offsetX;\r\n                    cpy2 = outline[i++] * scale + offsetY;\r\n                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return { offsetX: glyph.ha * scale, path: path };\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction FontLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(FontLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var loader = new FileLoader(this.manager);\r\n        loader.setPath(this.path);\r\n        loader.load(url, function (text) {\r\n            var json;\r\n            try {\r\n                json = JSON.parse(text);\r\n            }\r\n            catch (e) {\r\n                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');\r\n                json = JSON.parse(text.substring(65, text.length - 2));\r\n            }\r\n            var font = scope.parse(json);\r\n            if (onLoad)\r\n                onLoad(font);\r\n        }, onProgress, onError);\r\n    },\r\n    parse: function (json) {\r\n        return new Font(json);\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Loader() { }\r\nLoader.Handlers = {\r\n    handlers: [],\r\n    add: function (regex, loader) {\r\n        this.handlers.push(regex, loader);\r\n    },\r\n    get: function (file) {\r\n        var handlers = this.handlers;\r\n        for (var i = 0, l = handlers.length; i < l; i += 2) {\r\n            var regex = handlers[i];\r\n            var loader = handlers[i + 1];\r\n            if (regex.test(file)) {\r\n                return loader;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n};\r\nObject.assign(Loader.prototype, {\r\n    crossOrigin: 'anonymous',\r\n    onLoadStart: function () { },\r\n    onLoadProgress: function () { },\r\n    onLoadComplete: function () { },\r\n    initMaterials: function (materials, texturePath, crossOrigin) {\r\n        var array = [];\r\n        for (var i = 0; i < materials.length; ++i) {\r\n            array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);\r\n        }\r\n        return array;\r\n    },\r\n    createMaterial: (function () {\r\n        var BlendingMode = {\r\n            NoBlending: NoBlending,\r\n            NormalBlending: NormalBlending,\r\n            AdditiveBlending: AdditiveBlending,\r\n            SubtractiveBlending: SubtractiveBlending,\r\n            MultiplyBlending: MultiplyBlending,\r\n            CustomBlending: CustomBlending\r\n        };\r\n        var color = new Color();\r\n        var textureLoader = new TextureLoader();\r\n        var materialLoader = new MaterialLoader();\r\n        return function createMaterial(m, texturePath, crossOrigin) {\r\n            // convert from old material format\r\n            var textures = {};\r\n            function loadTexture(path, repeat, offset, wrap, anisotropy) {\r\n                var fullPath = texturePath + path;\r\n                var loader = Loader.Handlers.get(fullPath);\r\n                var texture;\r\n                if (loader !== null) {\r\n                    texture = loader.load(fullPath);\r\n                }\r\n                else {\r\n                    textureLoader.setCrossOrigin(crossOrigin);\r\n                    texture = textureLoader.load(fullPath);\r\n                }\r\n                if (repeat !== undefined) {\r\n                    texture.repeat.fromArray(repeat);\r\n                    if (repeat[0] !== 1)\r\n                        texture.wrapS = RepeatWrapping;\r\n                    if (repeat[1] !== 1)\r\n                        texture.wrapT = RepeatWrapping;\r\n                }\r\n                if (offset !== undefined) {\r\n                    texture.offset.fromArray(offset);\r\n                }\r\n                if (wrap !== undefined) {\r\n                    if (wrap[0] === 'repeat')\r\n                        texture.wrapS = RepeatWrapping;\r\n                    if (wrap[0] === 'mirror')\r\n                        texture.wrapS = MirroredRepeatWrapping;\r\n                    if (wrap[1] === 'repeat')\r\n                        texture.wrapT = RepeatWrapping;\r\n                    if (wrap[1] === 'mirror')\r\n                        texture.wrapT = MirroredRepeatWrapping;\r\n                }\r\n                if (anisotropy !== undefined) {\r\n                    texture.anisotropy = anisotropy;\r\n                }\r\n                var uuid = _Math.generateUUID();\r\n                textures[uuid] = texture;\r\n                return uuid;\r\n            }\r\n            //\r\n            var json = {\r\n                uuid: _Math.generateUUID(),\r\n                type: 'MeshLambertMaterial'\r\n            };\r\n            for (var name in m) {\r\n                var value = m[name];\r\n                switch (name) {\r\n                    case 'DbgColor':\r\n                    case 'DbgIndex':\r\n                    case 'opticalDensity':\r\n                    case 'illumination':\r\n                        break;\r\n                    case 'DbgName':\r\n                        json.name = value;\r\n                        break;\r\n                    case 'blending':\r\n                        json.blending = BlendingMode[value];\r\n                        break;\r\n                    case 'colorAmbient':\r\n                    case 'mapAmbient':\r\n                        console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');\r\n                        break;\r\n                    case 'colorDiffuse':\r\n                        json.color = color.fromArray(value).getHex();\r\n                        break;\r\n                    case 'colorSpecular':\r\n                        json.specular = color.fromArray(value).getHex();\r\n                        break;\r\n                    case 'colorEmissive':\r\n                        json.emissive = color.fromArray(value).getHex();\r\n                        break;\r\n                    case 'specularCoef':\r\n                        json.shininess = value;\r\n                        break;\r\n                    case 'shading':\r\n                        if (value.toLowerCase() === 'basic')\r\n                            json.type = 'MeshBasicMaterial';\r\n                        if (value.toLowerCase() === 'phong')\r\n                            json.type = 'MeshPhongMaterial';\r\n                        if (value.toLowerCase() === 'standard')\r\n                            json.type = 'MeshStandardMaterial';\r\n                        break;\r\n                    case 'mapDiffuse':\r\n                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);\r\n                        break;\r\n                    case 'mapDiffuseRepeat':\r\n                    case 'mapDiffuseOffset':\r\n                    case 'mapDiffuseWrap':\r\n                    case 'mapDiffuseAnisotropy':\r\n                        break;\r\n                    case 'mapEmissive':\r\n                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);\r\n                        break;\r\n                    case 'mapEmissiveRepeat':\r\n                    case 'mapEmissiveOffset':\r\n                    case 'mapEmissiveWrap':\r\n                    case 'mapEmissiveAnisotropy':\r\n                        break;\r\n                    case 'mapLight':\r\n                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);\r\n                        break;\r\n                    case 'mapLightRepeat':\r\n                    case 'mapLightOffset':\r\n                    case 'mapLightWrap':\r\n                    case 'mapLightAnisotropy':\r\n                        break;\r\n                    case 'mapAO':\r\n                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);\r\n                        break;\r\n                    case 'mapAORepeat':\r\n                    case 'mapAOOffset':\r\n                    case 'mapAOWrap':\r\n                    case 'mapAOAnisotropy':\r\n                        break;\r\n                    case 'mapBump':\r\n                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);\r\n                        break;\r\n                    case 'mapBumpScale':\r\n                        json.bumpScale = value;\r\n                        break;\r\n                    case 'mapBumpRepeat':\r\n                    case 'mapBumpOffset':\r\n                    case 'mapBumpWrap':\r\n                    case 'mapBumpAnisotropy':\r\n                        break;\r\n                    case 'mapNormal':\r\n                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);\r\n                        break;\r\n                    case 'mapNormalFactor':\r\n                        json.normalScale = value;\r\n                        break;\r\n                    case 'mapNormalRepeat':\r\n                    case 'mapNormalOffset':\r\n                    case 'mapNormalWrap':\r\n                    case 'mapNormalAnisotropy':\r\n                        break;\r\n                    case 'mapSpecular':\r\n                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);\r\n                        break;\r\n                    case 'mapSpecularRepeat':\r\n                    case 'mapSpecularOffset':\r\n                    case 'mapSpecularWrap':\r\n                    case 'mapSpecularAnisotropy':\r\n                        break;\r\n                    case 'mapMetalness':\r\n                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);\r\n                        break;\r\n                    case 'mapMetalnessRepeat':\r\n                    case 'mapMetalnessOffset':\r\n                    case 'mapMetalnessWrap':\r\n                    case 'mapMetalnessAnisotropy':\r\n                        break;\r\n                    case 'mapRoughness':\r\n                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);\r\n                        break;\r\n                    case 'mapRoughnessRepeat':\r\n                    case 'mapRoughnessOffset':\r\n                    case 'mapRoughnessWrap':\r\n                    case 'mapRoughnessAnisotropy':\r\n                        break;\r\n                    case 'mapAlpha':\r\n                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);\r\n                        break;\r\n                    case 'mapAlphaRepeat':\r\n                    case 'mapAlphaOffset':\r\n                    case 'mapAlphaWrap':\r\n                    case 'mapAlphaAnisotropy':\r\n                        break;\r\n                    case 'flipSided':\r\n                        json.side = BackSide;\r\n                        break;\r\n                    case 'doubleSided':\r\n                        json.side = DoubleSide;\r\n                        break;\r\n                    case 'transparency':\r\n                        console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');\r\n                        json.opacity = value;\r\n                        break;\r\n                    case 'depthTest':\r\n                    case 'depthWrite':\r\n                    case 'colorWrite':\r\n                    case 'opacity':\r\n                    case 'reflectivity':\r\n                    case 'transparent':\r\n                    case 'visible':\r\n                    case 'wireframe':\r\n                        json[name] = value;\r\n                        break;\r\n                    case 'vertexColors':\r\n                        if (value === true)\r\n                            json.vertexColors = VertexColors;\r\n                        if (value === 'face')\r\n                            json.vertexColors = FaceColors;\r\n                        break;\r\n                    default:\r\n                        console.error('THREE.Loader.createMaterial: Unsupported', name, value);\r\n                        break;\r\n                }\r\n            }\r\n            if (json.type === 'MeshBasicMaterial')\r\n                delete json.emissive;\r\n            if (json.type !== 'MeshPhongMaterial')\r\n                delete json.specular;\r\n            if (json.opacity < 1)\r\n                json.transparent = true;\r\n            materialLoader.setTextures(textures);\r\n            return materialLoader.parse(json);\r\n        };\r\n    })()\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nvar context;\r\nvar AudioContext = {\r\n    getContext: function () {\r\n        if (context === undefined) {\r\n            context = new (window.AudioContext || window.webkitAudioContext)();\r\n        }\r\n        return context;\r\n    },\r\n    setContext: function (value) {\r\n        context = value;\r\n    }\r\n};\r\n/**\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\nfunction AudioLoader(manager) {\r\n    this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;\r\n}\r\nObject.assign(AudioLoader.prototype, {\r\n    load: function (url, onLoad, onProgress, onError) {\r\n        var loader = new FileLoader(this.manager);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.setPath(this.path);\r\n        loader.load(url, function (buffer) {\r\n            // Create a copy of the buffer. The `decodeAudioData` method\r\n            // detaches the buffer when complete, preventing reuse.\r\n            var bufferCopy = buffer.slice(0);\r\n            var context = AudioContext.getContext();\r\n            context.decodeAudioData(bufferCopy, function (audioBuffer) {\r\n                onLoad(audioBuffer);\r\n            });\r\n        }, onProgress, onError);\r\n    },\r\n    setPath: function (value) {\r\n        this.path = value;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * Primary reference:\r\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\r\n *\r\n * Secondary reference:\r\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\r\n */\r\n// 3-band SH defined by 9 coefficients\r\nfunction SphericalHarmonics3() {\r\n    this.coefficients = [];\r\n    for (var i = 0; i < 9; i++) {\r\n        this.coefficients.push(new Vector3());\r\n    }\r\n}\r\nObject.assign(SphericalHarmonics3.prototype, {\r\n    isSphericalHarmonics3: true,\r\n    set: function (coefficients) {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.coefficients[i].copy(coefficients[i]);\r\n        }\r\n        return this;\r\n    },\r\n    zero: function () {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.coefficients[i].set(0, 0, 0);\r\n        }\r\n        return this;\r\n    },\r\n    // get the radiance in the direction of the normal\r\n    // target is a Vector3\r\n    getAt: function (normal, target) {\r\n        // normal is assumed to be unit length\r\n        var x = normal.x, y = normal.y, z = normal.z;\r\n        var coeff = this.coefficients;\r\n        // band 0\r\n        target.copy(coeff[0]).multiplyScalar(0.282095);\r\n        // band 1\r\n        target.addScale(coeff[1], 0.488603 * y);\r\n        target.addScale(coeff[2], 0.488603 * z);\r\n        target.addScale(coeff[3], 0.488603 * x);\r\n        // band 2\r\n        target.addScale(coeff[4], 1.092548 * (x * y));\r\n        target.addScale(coeff[5], 1.092548 * (y * z));\r\n        target.addScale(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\r\n        target.addScale(coeff[7], 1.092548 * (x * z));\r\n        target.addScale(coeff[8], 0.546274 * (x * x - y * y));\r\n        return target;\r\n    },\r\n    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\r\n    // target is a Vector3\r\n    // https://graphics.stanford.edu/papers/envmap/envmap.pdf\r\n    getIrradianceAt: function (normal, target) {\r\n        // normal is assumed to be unit length\r\n        var x = normal.x, y = normal.y, z = normal.z;\r\n        var coeff = this.coefficients;\r\n        // band 0\r\n        target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\r\n        // band 1\r\n        target.addScale(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\r\n        target.addScale(coeff[2], 2.0 * 0.511664 * z);\r\n        target.addScale(coeff[3], 2.0 * 0.511664 * x);\r\n        // band 2\r\n        target.addScale(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\r\n        target.addScale(coeff[5], 2.0 * 0.429043 * y * z);\r\n        target.addScale(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\r\n        target.addScale(coeff[7], 2.0 * 0.429043 * x * z);\r\n        target.addScale(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\r\n        return target;\r\n    },\r\n    add: function (sh) {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.coefficients[i].add(sh.coefficients[i]);\r\n        }\r\n        return this;\r\n    },\r\n    scale: function (s) {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.coefficients[i].multiplyScalar(s);\r\n        }\r\n        return this;\r\n    },\r\n    lerp: function (sh, alpha) {\r\n        for (var i = 0; i < 9; i++) {\r\n            this.coefficients[i].lerp(sh.coefficients[i], alpha);\r\n        }\r\n        return this;\r\n    },\r\n    equals: function (sh) {\r\n        for (var i = 0; i < 9; i++) {\r\n            if (!this.coefficients[i].equals(sh.coefficients[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    copy: function (sh) {\r\n        return this.set(sh.coefficients);\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    fromArray: function (array) {\r\n        var coefficients = this.coefficients;\r\n        for (var i = 0; i < 9; i++) {\r\n            coefficients[i].fromArray(array, i * 3);\r\n        }\r\n        return this;\r\n    },\r\n    toArray: function () {\r\n        var array = [];\r\n        var coefficients = this.coefficients;\r\n        for (var i = 0; i < 9; i++) {\r\n            coefficients[i].toArray(array, i * 3);\r\n        }\r\n        return array;\r\n    }\r\n});\r\nObject.assign(SphericalHarmonics3, {\r\n    // evaluate the basis functions\r\n    // shBasis is an Array[ 9 ]\r\n    getBasisAt: function (normal, shBasis) {\r\n        // normal is assumed to be unit length\r\n        var x = normal.x, y = normal.y, z = normal.z;\r\n        // band 0\r\n        shBasis[0] = 0.282095;\r\n        // band 1\r\n        shBasis[1] = 0.488603 * y;\r\n        shBasis[2] = 0.488603 * z;\r\n        shBasis[3] = 0.488603 * x;\r\n        // band 2\r\n        shBasis[4] = 1.092548 * x * y;\r\n        shBasis[5] = 1.092548 * y * z;\r\n        shBasis[6] = 0.315392 * (3 * z * z - 1);\r\n        shBasis[7] = 1.092548 * x * z;\r\n        shBasis[8] = 0.546274 * (x * x - y * y);\r\n    }\r\n});\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * A LightProbe is a source of indirect-diffuse light\r\n */\r\nfunction LightProbe(sh, intensity) {\r\n    Light.call(this, undefined, intensity);\r\n    this.sh = (sh !== undefined) ? sh : new SphericalHarmonics3();\r\n}\r\nLightProbe.prototype = Object.assign(Object.create(Light.prototype), {\r\n    constructor: LightProbe,\r\n    isLightProbe: true,\r\n    copy: function (source) {\r\n        Light.prototype.copy.call(this, source);\r\n        this.sh.copy(source.sh);\r\n        this.intensity = source.intensity;\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = Light.prototype.toJSON.call(this, meta);\r\n        // data.sh = this.sh.toArray(); // todo\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction HemisphereLightProbe(skyColor, groundColor, intensity) {\r\n    LightProbe.call(this, undefined, intensity);\r\n    var color1 = new Color().set(skyColor);\r\n    var color2 = new Color().set(groundColor);\r\n    var sky = new Vector3(color1.r, color1.g, color1.b);\r\n    var ground = new Vector3(color2.r, color2.g, color2.b);\r\n    // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\r\n    var c0 = Math.sqrt(Math.PI);\r\n    var c1 = c0 * Math.sqrt(0.75);\r\n    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\r\n    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\r\n}\r\nHemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {\r\n    constructor: HemisphereLightProbe,\r\n    isHemisphereLightProbe: true,\r\n    copy: function (source) {\r\n        LightProbe.prototype.copy.call(this, source);\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = LightProbe.prototype.toJSON.call(this, meta);\r\n        // data.sh = this.sh.toArray(); // todo\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction AmbientLightProbe(color, intensity) {\r\n    LightProbe.call(this, undefined, intensity);\r\n    var color1 = new Color().set(color);\r\n    // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\r\n    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\r\n}\r\nAmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {\r\n    constructor: AmbientLightProbe,\r\n    isAmbientLightProbe: true,\r\n    copy: function (source) {\r\n        LightProbe.prototype.copy.call(this, source);\r\n        return this;\r\n    },\r\n    toJSON: function (meta) {\r\n        var data = LightProbe.prototype.toJSON.call(this, meta);\r\n        // data.sh = this.sh.toArray(); // todo\r\n        return data;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction StereoCamera() {\r\n    this.type = 'StereoCamera';\r\n    this.aspect = 1;\r\n    this.eyeSep = 0.064;\r\n    this.cameraL = new PerspectiveCamera();\r\n    this.cameraL.layers.enable(1);\r\n    this.cameraL.matrixAutoUpdate = false;\r\n    this.cameraR = new PerspectiveCamera();\r\n    this.cameraR.layers.enable(2);\r\n    this.cameraR.matrixAutoUpdate = false;\r\n}\r\nObject.assign(StereoCamera.prototype, {\r\n    update: (function () {\r\n        var instance, focus, fov, aspect, near, far, zoom, eyeSep;\r\n        var eyeRight = new Matrix4();\r\n        var eyeLeft = new Matrix4();\r\n        return function update(camera) {\r\n            var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\r\n                aspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n                far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\r\n            if (needsUpdate) {\r\n                instance = this;\r\n                focus = camera.focus;\r\n                fov = camera.fov;\r\n                aspect = camera.aspect * this.aspect;\r\n                near = camera.near;\r\n                far = camera.far;\r\n                zoom = camera.zoom;\r\n                // Off-axis stereoscopic effect based on\r\n                // http://paulbourke.net/stereographics/stereorender/\r\n                var projectionMatrix = camera.projectionMatrix.clone();\r\n                eyeSep = this.eyeSep / 2;\r\n                var eyeSepOnProjection = eyeSep * near / focus;\r\n                var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;\r\n                var xmin, xmax;\r\n                // translate xOffset\r\n                eyeLeft.elements[12] = -eyeSep;\r\n                eyeRight.elements[12] = eyeSep;\r\n                // for left eye\r\n                xmin = -ymax * aspect + eyeSepOnProjection;\r\n                xmax = ymax * aspect + eyeSepOnProjection;\r\n                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);\r\n                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\r\n                this.cameraL.projectionMatrix.copy(projectionMatrix);\r\n                // for right eye\r\n                xmin = -ymax * aspect - eyeSepOnProjection;\r\n                xmax = ymax * aspect - eyeSepOnProjection;\r\n                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);\r\n                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\r\n                this.cameraR.projectionMatrix.copy(projectionMatrix);\r\n            }\r\n            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);\r\n            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);\r\n        };\r\n    })()\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction Clock(autoStart) {\r\n    this.autoStart = (autoStart !== undefined) ? autoStart : true;\r\n    this.startTime = 0;\r\n    this.oldTime = 0;\r\n    this.elapsedTime = 0;\r\n    this.running = false;\r\n}\r\nObject.assign(Clock.prototype, {\r\n    start: function () {\r\n        this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\r\n        this.oldTime = this.startTime;\r\n        this.elapsedTime = 0;\r\n        this.running = true;\r\n    },\r\n    stop: function () {\r\n        this.getElapsedTime();\r\n        this.running = false;\r\n        this.autoStart = false;\r\n    },\r\n    getElapsedTime: function () {\r\n        this.getDelta();\r\n        return this.elapsedTime;\r\n    },\r\n    getDelta: function () {\r\n        var diff = 0;\r\n        if (this.autoStart && !this.running) {\r\n            this.start();\r\n            return 0;\r\n        }\r\n        if (this.running) {\r\n            var newTime = (typeof performance === 'undefined' ? Date : performance).now();\r\n            diff = (newTime - this.oldTime) / 1000;\r\n            this.oldTime = newTime;\r\n            this.elapsedTime += diff;\r\n        }\r\n        return diff;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction AudioListener() {\r\n    Object3D.call(this);\r\n    this.type = 'AudioListener';\r\n    this.context = AudioContext.getContext();\r\n    this.gain = this.context.createGain();\r\n    this.gain.connect(this.context.destination);\r\n    this.filter = null;\r\n    this.timeDelta = 0;\r\n}\r\nAudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: AudioListener,\r\n    getInput: function () {\r\n        return this.gain;\r\n    },\r\n    removeFilter: function () {\r\n        if (this.filter !== null) {\r\n            this.gain.disconnect(this.filter);\r\n            this.filter.disconnect(this.context.destination);\r\n            this.gain.connect(this.context.destination);\r\n            this.filter = null;\r\n        }\r\n        return this;\r\n    },\r\n    getFilter: function () {\r\n        return this.filter;\r\n    },\r\n    setFilter: function (value) {\r\n        if (this.filter !== null) {\r\n            this.gain.disconnect(this.filter);\r\n            this.filter.disconnect(this.context.destination);\r\n        }\r\n        else {\r\n            this.gain.disconnect(this.context.destination);\r\n        }\r\n        this.filter = value;\r\n        this.gain.connect(this.filter);\r\n        this.filter.connect(this.context.destination);\r\n        return this;\r\n    },\r\n    getMasterVolume: function () {\r\n        return this.gain.gain.value;\r\n    },\r\n    setMasterVolume: function (value) {\r\n        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\r\n        return this;\r\n    },\r\n    updateMatrixWorld: (function () {\r\n        var position = new Vector3();\r\n        var quaternion = new Quaternion();\r\n        var scale = new Vector3();\r\n        var orientation = new Vector3();\r\n        var clock = new Clock();\r\n        return function updateMatrixWorld(force) {\r\n            Object3D.prototype.updateMatrixWorld.call(this, force);\r\n            var listener = this.context.listener;\r\n            var up = this.up;\r\n            this.timeDelta = clock.getDelta();\r\n            this.matrixWorld.decompose(position, quaternion, scale);\r\n            orientation.set(0, 0, -1).applyQuaternion(quaternion);\r\n            if (listener.positionX) {\r\n                // code path for Chrome (see #14393)\r\n                var endTime = this.context.currentTime + this.timeDelta;\r\n                listener.positionX.linearRampToValueAtTime(position.x, endTime);\r\n                listener.positionY.linearRampToValueAtTime(position.y, endTime);\r\n                listener.positionZ.linearRampToValueAtTime(position.z, endTime);\r\n                listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);\r\n                listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);\r\n                listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);\r\n                listener.upX.linearRampToValueAtTime(up.x, endTime);\r\n                listener.upY.linearRampToValueAtTime(up.y, endTime);\r\n                listener.upZ.linearRampToValueAtTime(up.z, endTime);\r\n            }\r\n            else {\r\n                listener.setPosition(position.x, position.y, position.z);\r\n                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);\r\n            }\r\n        };\r\n    })()\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\nfunction Audio(listener) {\r\n    Object3D.call(this);\r\n    this.type = 'Audio';\r\n    this.listener = listener;\r\n    this.context = listener.context;\r\n    this.gain = this.context.createGain();\r\n    this.gain.connect(listener.getInput());\r\n    this.autoplay = false;\r\n    this.buffer = null;\r\n    this.detune = 0;\r\n    this.loop = false;\r\n    this.startTime = 0;\r\n    this.offset = 0;\r\n    this.playbackRate = 1;\r\n    this.isPlaying = false;\r\n    this.hasPlaybackControl = true;\r\n    this.sourceType = 'empty';\r\n    this.filters = [];\r\n}\r\nAudio.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: Audio,\r\n    getOutput: function () {\r\n        return this.gain;\r\n    },\r\n    setNodeSource: function (audioNode) {\r\n        this.hasPlaybackControl = false;\r\n        this.sourceType = 'audioNode';\r\n        this.source = audioNode;\r\n        this.connect();\r\n        return this;\r\n    },\r\n    setMediaElementSource: function (mediaElement) {\r\n        this.hasPlaybackControl = false;\r\n        this.sourceType = 'mediaNode';\r\n        this.source = this.context.createMediaElementSource(mediaElement);\r\n        this.connect();\r\n        return this;\r\n    },\r\n    setBuffer: function (audioBuffer) {\r\n        this.buffer = audioBuffer;\r\n        this.sourceType = 'buffer';\r\n        if (this.autoplay)\r\n            this.play();\r\n        return this;\r\n    },\r\n    play: function () {\r\n        if (this.isPlaying === true) {\r\n            console.warn('THREE.Audio: Audio is already playing.');\r\n            return;\r\n        }\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return;\r\n        }\r\n        var source = this.context.createBufferSource();\r\n        source.buffer = this.buffer;\r\n        source.loop = this.loop;\r\n        source.onended = this.onEnded.bind(this);\r\n        this.startTime = this.context.currentTime;\r\n        source.start(this.startTime, this.offset);\r\n        this.isPlaying = true;\r\n        this.source = source;\r\n        this.setDetune(this.detune);\r\n        this.setPlaybackRate(this.playbackRate);\r\n        return this.connect();\r\n    },\r\n    pause: function () {\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return;\r\n        }\r\n        if (this.isPlaying === true) {\r\n            this.source.stop();\r\n            this.source.onended = null;\r\n            this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;\r\n            this.isPlaying = false;\r\n        }\r\n        return this;\r\n    },\r\n    stop: function () {\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return;\r\n        }\r\n        this.source.stop();\r\n        this.source.onended = null;\r\n        this.offset = 0;\r\n        this.isPlaying = false;\r\n        return this;\r\n    },\r\n    connect: function () {\r\n        if (this.filters.length > 0) {\r\n            this.source.connect(this.filters[0]);\r\n            for (var i = 1, l = this.filters.length; i < l; i++) {\r\n                this.filters[i - 1].connect(this.filters[i]);\r\n            }\r\n            this.filters[this.filters.length - 1].connect(this.getOutput());\r\n        }\r\n        else {\r\n            this.source.connect(this.getOutput());\r\n        }\r\n        return this;\r\n    },\r\n    disconnect: function () {\r\n        if (this.filters.length > 0) {\r\n            this.source.disconnect(this.filters[0]);\r\n            for (var i = 1, l = this.filters.length; i < l; i++) {\r\n                this.filters[i - 1].disconnect(this.filters[i]);\r\n            }\r\n            this.filters[this.filters.length - 1].disconnect(this.getOutput());\r\n        }\r\n        else {\r\n            this.source.disconnect(this.getOutput());\r\n        }\r\n        return this;\r\n    },\r\n    getFilters: function () {\r\n        return this.filters;\r\n    },\r\n    setFilters: function (value) {\r\n        if (!value)\r\n            value = [];\r\n        if (this.isPlaying === true) {\r\n            this.disconnect();\r\n            this.filters = value;\r\n            this.connect();\r\n        }\r\n        else {\r\n            this.filters = value;\r\n        }\r\n        return this;\r\n    },\r\n    setDetune: function (value) {\r\n        this.detune = value;\r\n        if (this.source.detune === undefined)\r\n            return; // only set detune when available\r\n        if (this.isPlaying === true) {\r\n            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\r\n        }\r\n        return this;\r\n    },\r\n    getDetune: function () {\r\n        return this.detune;\r\n    },\r\n    getFilter: function () {\r\n        return this.getFilters()[0];\r\n    },\r\n    setFilter: function (filter) {\r\n        return this.setFilters(filter ? [filter] : []);\r\n    },\r\n    setPlaybackRate: function (value) {\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return;\r\n        }\r\n        this.playbackRate = value;\r\n        if (this.isPlaying === true) {\r\n            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\r\n        }\r\n        return this;\r\n    },\r\n    getPlaybackRate: function () {\r\n        return this.playbackRate;\r\n    },\r\n    onEnded: function () {\r\n        this.isPlaying = false;\r\n    },\r\n    getLoop: function () {\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return false;\r\n        }\r\n        return this.loop;\r\n    },\r\n    setLoop: function (value) {\r\n        if (this.hasPlaybackControl === false) {\r\n            console.warn('THREE.Audio: this Audio has no playback control.');\r\n            return;\r\n        }\r\n        this.loop = value;\r\n        if (this.isPlaying === true) {\r\n            this.source.loop = this.loop;\r\n        }\r\n        return this;\r\n    },\r\n    getVolume: function () {\r\n        return this.gain.gain.value;\r\n    },\r\n    setVolume: function (value) {\r\n        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction PositionalAudio(listener) {\r\n    Audio.call(this, listener);\r\n    this.panner = this.context.createPanner();\r\n    this.panner.panningModel = 'HRTF';\r\n    this.panner.connect(this.gain);\r\n}\r\nPositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {\r\n    constructor: PositionalAudio,\r\n    getOutput: function () {\r\n        return this.panner;\r\n    },\r\n    getRefDistance: function () {\r\n        return this.panner.refDistance;\r\n    },\r\n    setRefDistance: function (value) {\r\n        this.panner.refDistance = value;\r\n        return this;\r\n    },\r\n    getRolloffFactor: function () {\r\n        return this.panner.rolloffFactor;\r\n    },\r\n    setRolloffFactor: function (value) {\r\n        this.panner.rolloffFactor = value;\r\n        return this;\r\n    },\r\n    getDistanceModel: function () {\r\n        return this.panner.distanceModel;\r\n    },\r\n    setDistanceModel: function (value) {\r\n        this.panner.distanceModel = value;\r\n        return this;\r\n    },\r\n    getMaxDistance: function () {\r\n        return this.panner.maxDistance;\r\n    },\r\n    setMaxDistance: function (value) {\r\n        this.panner.maxDistance = value;\r\n        return this;\r\n    },\r\n    setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\r\n        this.panner.coneInnerAngle = coneInnerAngle;\r\n        this.panner.coneOuterAngle = coneOuterAngle;\r\n        this.panner.coneOuterGain = coneOuterGain;\r\n        return this;\r\n    },\r\n    updateMatrixWorld: (function () {\r\n        var position = new Vector3();\r\n        var quaternion = new Quaternion();\r\n        var scale = new Vector3();\r\n        var orientation = new Vector3();\r\n        return function updateMatrixWorld(force) {\r\n            Object3D.prototype.updateMatrixWorld.call(this, force);\r\n            if (this.hasPlaybackControl === true && this.isPlaying === false)\r\n                return;\r\n            this.matrixWorld.decompose(position, quaternion, scale);\r\n            orientation.set(0, 0, 1).applyQuaternion(quaternion);\r\n            var panner = this.panner;\r\n            if (panner.positionX) {\r\n                // code path for Chrome and Firefox (see #14393)\r\n                var endTime = this.context.currentTime + this.listener.timeDelta;\r\n                panner.positionX.linearRampToValueAtTime(position.x, endTime);\r\n                panner.positionY.linearRampToValueAtTime(position.y, endTime);\r\n                panner.positionZ.linearRampToValueAtTime(position.z, endTime);\r\n                panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);\r\n                panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);\r\n                panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);\r\n            }\r\n            else {\r\n                panner.setPosition(position.x, position.y, position.z);\r\n                panner.setOrientation(orientation.x, orientation.y, orientation.z);\r\n            }\r\n        };\r\n    })()\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction AudioAnalyser(audio, fftSize) {\r\n    this.analyser = audio.context.createAnalyser();\r\n    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n    this.data = new Uint8Array(this.analyser.frequencyBinCount);\r\n    audio.getOutput().connect(this.analyser);\r\n}\r\nObject.assign(AudioAnalyser.prototype, {\r\n    getFrequencyData: function () {\r\n        this.analyser.getByteFrequencyData(this.data);\r\n        return this.data;\r\n    },\r\n    getAverageFrequency: function () {\r\n        var value = 0, data = this.getFrequencyData();\r\n        for (var i = 0; i < data.length; i++) {\r\n            value += data[i];\r\n        }\r\n        return value / data.length;\r\n    }\r\n});\r\n/**\r\n *\r\n * Buffered scene graph property that allows weighted accumulation.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction PropertyMixer(binding, typeName, valueSize) {\r\n    this.binding = binding;\r\n    this.valueSize = valueSize;\r\n    var bufferType = Float64Array, mixFunction;\r\n    switch (typeName) {\r\n        case 'quaternion':\r\n            mixFunction = this._slerp;\r\n            break;\r\n        case 'string':\r\n        case 'bool':\r\n            bufferType = Array;\r\n            mixFunction = this._select;\r\n            break;\r\n        default:\r\n            mixFunction = this._lerp;\r\n    }\r\n    this.buffer = new bufferType(valueSize * 4);\r\n    // layout: [ incoming | accu0 | accu1 | orig ]\r\n    //\r\n    // interpolators can use .buffer as their .result\r\n    // the data then goes to 'incoming'\r\n    //\r\n    // 'accu0' and 'accu1' are used frame-interleaved for\r\n    // the cumulative result and are compared to detect\r\n    // changes\r\n    //\r\n    // 'orig' stores the original state of the property\r\n    this._mixBufferRegion = mixFunction;\r\n    this.cumulativeWeight = 0;\r\n    this.useCount = 0;\r\n    this.referenceCount = 0;\r\n}\r\nObject.assign(PropertyMixer.prototype, {\r\n    // accumulate data in the 'incoming' region into 'accu<i>'\r\n    accumulate: function (accuIndex, weight) {\r\n        // note: happily accumulating nothing when weight = 0, the caller knows\r\n        // the weight and shouldn't have made the call in the first place\r\n        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;\r\n        if (currentWeight === 0) {\r\n            // accuN := incoming * weight\r\n            for (var i = 0; i !== stride; ++i) {\r\n                buffer[offset + i] = buffer[i];\r\n            }\r\n            currentWeight = weight;\r\n        }\r\n        else {\r\n            // accuN := accuN + incoming * weight\r\n            currentWeight += weight;\r\n            var mix = weight / currentWeight;\r\n            this._mixBufferRegion(buffer, offset, 0, mix, stride);\r\n        }\r\n        this.cumulativeWeight = currentWeight;\r\n    },\r\n    // apply the state of 'accu<i>' to the binding when accus differ\r\n    apply: function (accuIndex) {\r\n        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;\r\n        this.cumulativeWeight = 0;\r\n        if (weight < 1) {\r\n            // accuN := accuN + original * ( 1 - cumulativeWeight )\r\n            var originalValueOffset = stride * 3;\r\n            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\r\n        }\r\n        for (var i = stride, e = stride + stride; i !== e; ++i) {\r\n            if (buffer[i] !== buffer[i + stride]) {\r\n                // value has changed -> update scene graph\r\n                binding.setValue(buffer, offset);\r\n                break;\r\n            }\r\n        }\r\n    },\r\n    // remember the state of the bound property and copy it to both accus\r\n    saveOriginalState: function () {\r\n        var binding = this.binding;\r\n        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;\r\n        binding.getValue(buffer, originalValueOffset);\r\n        // accu[0..1] := orig -- initially detect changes against the original\r\n        for (var i = stride, e = originalValueOffset; i !== e; ++i) {\r\n            buffer[i] = buffer[originalValueOffset + (i % stride)];\r\n        }\r\n        this.cumulativeWeight = 0;\r\n    },\r\n    // apply the state previously taken via 'saveOriginalState' to the binding\r\n    restoreOriginalState: function () {\r\n        var originalValueOffset = this.valueSize * 3;\r\n        this.binding.setValue(this.buffer, originalValueOffset);\r\n    },\r\n    // mix functions\r\n    _select: function (buffer, dstOffset, srcOffset, t, stride) {\r\n        if (t >= 0.5) {\r\n            for (var i = 0; i !== stride; ++i) {\r\n                buffer[dstOffset + i] = buffer[srcOffset + i];\r\n            }\r\n        }\r\n    },\r\n    _slerp: function (buffer, dstOffset, srcOffset, t) {\r\n        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\r\n    },\r\n    _lerp: function (buffer, dstOffset, srcOffset, t, stride) {\r\n        var s = 1 - t;\r\n        for (var i = 0; i !== stride; ++i) {\r\n            var j = dstOffset + i;\r\n            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\r\n        }\r\n    }\r\n});\r\n/**\r\n *\r\n * A reference to a real property in the scene graph.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n// Characters [].:/ are reserved for track binding syntax.\r\nvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\r\nfunction Composite(targetGroup, path, optionalParsedPath) {\r\n    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\r\n    this._targetGroup = targetGroup;\r\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\r\n}\r\nObject.assign(Composite.prototype, {\r\n    getValue: function (array, offset) {\r\n        this.bind(); // bind all binding\r\n        var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];\r\n        // and only call .getValue on the first\r\n        if (binding !== undefined)\r\n            binding.getValue(array, offset);\r\n    },\r\n    setValue: function (array, offset) {\r\n        var bindings = this._bindings;\r\n        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\r\n            bindings[i].setValue(array, offset);\r\n        }\r\n    },\r\n    bind: function () {\r\n        var bindings = this._bindings;\r\n        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\r\n            bindings[i].bind();\r\n        }\r\n    },\r\n    unbind: function () {\r\n        var bindings = this._bindings;\r\n        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\r\n            bindings[i].unbind();\r\n        }\r\n    }\r\n});\r\nfunction PropertyBinding(rootNode, path, parsedPath) {\r\n    this.path = path;\r\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\r\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\r\n    this.rootNode = rootNode;\r\n}\r\nObject.assign(PropertyBinding, {\r\n    Composite: Composite,\r\n    create: function (root, path, parsedPath) {\r\n        if (!(root && root.isAnimationObjectGroup)) {\r\n            return new PropertyBinding(root, path, parsedPath);\r\n        }\r\n        else {\r\n            return new PropertyBinding.Composite(root, path, parsedPath);\r\n        }\r\n    },\r\n    /**\r\n     * Replaces spaces with underscores and removes unsupported characters from\r\n     * node names, to ensure compatibility with parseTrackName().\r\n     *\r\n     * @param {string} name Node name to be sanitized.\r\n     * @return {string}\r\n     */\r\n    sanitizeNodeName: (function () {\r\n        var reservedRe = new RegExp('[' + RESERVED_CHARS_RE + ']', 'g');\r\n        return function sanitizeNodeName(name) {\r\n            return name.replace(/\\s/g, '_').replace(reservedRe, '');\r\n        };\r\n    }()),\r\n    parseTrackName: function () {\r\n        // Attempts to allow node names from any language. ES5's `\\w` regexp matches\r\n        // only latin characters, and the unicode \\p{L} is not yet supported. So\r\n        // instead, we exclude reserved characters and match everything else.\r\n        var wordChar = '[^' + RESERVED_CHARS_RE + ']';\r\n        var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace('\\\\.', '') + ']';\r\n        // Parent directories, delimited by '/' or ':'. Currently unused, but must\r\n        // be matched to parse the rest of the track name.\r\n        var directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', wordChar);\r\n        // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\r\n        var nodeRe = /(WCOD+)?/.source.replace('WCOD', wordCharOrDot);\r\n        // Object on target node, and accessor. May not contain reserved\r\n        // characters. Accessor may contain any character except closing bracket.\r\n        var objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', wordChar);\r\n        // Property and accessor. May not contain reserved characters. Accessor may\r\n        // contain any non-bracket characters.\r\n        var propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', wordChar);\r\n        var trackRe = new RegExp(''\r\n            + '^'\r\n            + directoryRe\r\n            + nodeRe\r\n            + objectRe\r\n            + propertyRe\r\n            + '$');\r\n        var supportedObjectNames = ['material', 'materials', 'bones'];\r\n        return function parseTrackName(trackName) {\r\n            var matches = trackRe.exec(trackName);\r\n            if (!matches) {\r\n                throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\r\n            }\r\n            var results = {\r\n                // directoryName: matches[ 1 ], // (tschw) currently unused\r\n                nodeName: matches[2],\r\n                objectName: matches[3],\r\n                objectIndex: matches[4],\r\n                propertyName: matches[5],\r\n                propertyIndex: matches[6]\r\n            };\r\n            var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\r\n            if (lastDot !== undefined && lastDot !== -1) {\r\n                var objectName = results.nodeName.substring(lastDot + 1);\r\n                // Object names must be checked against a whitelist. Otherwise, there\r\n                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\r\n                // 'bar' could be the objectName, or part of a nodeName (which can\r\n                // include '.' characters).\r\n                if (supportedObjectNames.indexOf(objectName) !== -1) {\r\n                    results.nodeName = results.nodeName.substring(0, lastDot);\r\n                    results.objectName = objectName;\r\n                }\r\n            }\r\n            if (results.propertyName === null || results.propertyName.length === 0) {\r\n                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\r\n            }\r\n            return results;\r\n        };\r\n    }(),\r\n    findNode: function (root, nodeName) {\r\n        if (!nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\r\n            return root;\r\n        }\r\n        // search into skeleton bones.\r\n        if (root.skeleton) {\r\n            var bone = root.skeleton.getBoneByName(nodeName);\r\n            if (bone !== undefined) {\r\n                return bone;\r\n            }\r\n        }\r\n        // search into node subtree.\r\n        if (root.children) {\r\n            var searchNodeSubtree = function (children) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    var childNode = children[i];\r\n                    if (childNode.name === nodeName || childNode.uuid === nodeName) {\r\n                        return childNode;\r\n                    }\r\n                    var result = searchNodeSubtree(childNode.children);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n                return null;\r\n            };\r\n            var subTreeNode = searchNodeSubtree(root.children);\r\n            if (subTreeNode) {\r\n                return subTreeNode;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n});\r\nObject.assign(PropertyBinding.prototype, {\r\n    // these are used to \"bind\" a nonexistent property\r\n    _getValue_unavailable: function () { },\r\n    _setValue_unavailable: function () { },\r\n    BindingType: {\r\n        Direct: 0,\r\n        EntireArray: 1,\r\n        ArrayElement: 2,\r\n        HasFromToArray: 3\r\n    },\r\n    Versioning: {\r\n        None: 0,\r\n        NeedsUpdate: 1,\r\n        MatrixWorldNeedsUpdate: 2\r\n    },\r\n    GetterByBindingType: [\r\n        function getValue_direct(buffer, offset) {\r\n            buffer[offset] = this.node[this.propertyName];\r\n        },\r\n        function getValue_array(buffer, offset) {\r\n            var source = this.resolvedProperty;\r\n            for (var i = 0, n = source.length; i !== n; ++i) {\r\n                buffer[offset++] = source[i];\r\n            }\r\n        },\r\n        function getValue_arrayElement(buffer, offset) {\r\n            buffer[offset] = this.resolvedProperty[this.propertyIndex];\r\n        },\r\n        function getValue_toArray(buffer, offset) {\r\n            this.resolvedProperty.toArray(buffer, offset);\r\n        }\r\n    ],\r\n    SetterByBindingTypeAndVersioning: [\r\n        [\r\n            // Direct\r\n            function setValue_direct(buffer, offset) {\r\n                this.targetObject[this.propertyName] = buffer[offset];\r\n            },\r\n            function setValue_direct_setNeedsUpdate(buffer, offset) {\r\n                this.targetObject[this.propertyName] = buffer[offset];\r\n                this.targetObject.needsUpdate = true;\r\n            },\r\n            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\r\n                this.targetObject[this.propertyName] = buffer[offset];\r\n                this.targetObject.matrixWorldNeedsUpdate = true;\r\n            }\r\n        ], [\r\n            // EntireArray\r\n            function setValue_array(buffer, offset) {\r\n                var dest = this.resolvedProperty;\r\n                for (var i = 0, n = dest.length; i !== n; ++i) {\r\n                    dest[i] = buffer[offset++];\r\n                }\r\n            },\r\n            function setValue_array_setNeedsUpdate(buffer, offset) {\r\n                var dest = this.resolvedProperty;\r\n                for (var i = 0, n = dest.length; i !== n; ++i) {\r\n                    dest[i] = buffer[offset++];\r\n                }\r\n                this.targetObject.needsUpdate = true;\r\n            },\r\n            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\r\n                var dest = this.resolvedProperty;\r\n                for (var i = 0, n = dest.length; i !== n; ++i) {\r\n                    dest[i] = buffer[offset++];\r\n                }\r\n                this.targetObject.matrixWorldNeedsUpdate = true;\r\n            }\r\n        ], [\r\n            // ArrayElement\r\n            function setValue_arrayElement(buffer, offset) {\r\n                this.resolvedProperty[this.propertyIndex] = buffer[offset];\r\n            },\r\n            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {\r\n                this.resolvedProperty[this.propertyIndex] = buffer[offset];\r\n                this.targetObject.needsUpdate = true;\r\n            },\r\n            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\r\n                this.resolvedProperty[this.propertyIndex] = buffer[offset];\r\n                this.targetObject.matrixWorldNeedsUpdate = true;\r\n            }\r\n        ], [\r\n            // HasToFromArray\r\n            function setValue_fromArray(buffer, offset) {\r\n                this.resolvedProperty.fromArray(buffer, offset);\r\n            },\r\n            function setValue_fromArray_setNeedsUpdate(buffer, offset) {\r\n                this.resolvedProperty.fromArray(buffer, offset);\r\n                this.targetObject.needsUpdate = true;\r\n            },\r\n            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\r\n                this.resolvedProperty.fromArray(buffer, offset);\r\n                this.targetObject.matrixWorldNeedsUpdate = true;\r\n            }\r\n        ]\r\n    ],\r\n    getValue: function getValue_unbound(targetArray, offset) {\r\n        this.bind();\r\n        this.getValue(targetArray, offset);\r\n        // Note: This class uses a State pattern on a per-method basis:\r\n        // 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n        // prototype version of these methods with one that represents\r\n        // the bound state. When the property is not found, the methods\r\n        // become no-ops.\r\n    },\r\n    setValue: function getValue_unbound(sourceArray, offset) {\r\n        this.bind();\r\n        this.setValue(sourceArray, offset);\r\n    },\r\n    // create getter / setter pair for a property in the scene graph\r\n    bind: function () {\r\n        var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;\r\n        if (!targetObject) {\r\n            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\r\n            this.node = targetObject;\r\n        }\r\n        // set fail state so we can just 'return' on error\r\n        this.getValue = this._getValue_unavailable;\r\n        this.setValue = this._setValue_unavailable;\r\n        // ensure there is a value node\r\n        if (!targetObject) {\r\n            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\r\n            return;\r\n        }\r\n        if (objectName) {\r\n            var objectIndex = parsedPath.objectIndex;\r\n            // special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n            switch (objectName) {\r\n                case 'materials':\r\n                    if (!targetObject.material) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\r\n                        return;\r\n                    }\r\n                    if (!targetObject.material.materials) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\r\n                        return;\r\n                    }\r\n                    targetObject = targetObject.material.materials;\r\n                    break;\r\n                case 'bones':\r\n                    if (!targetObject.skeleton) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\r\n                        return;\r\n                    }\r\n                    // potential future optimization: skip this if propertyIndex is already an integer\r\n                    // and convert the integer string to a true integer.\r\n                    targetObject = targetObject.skeleton.bones;\r\n                    // support resolving morphTarget names into indices.\r\n                    for (var i = 0; i < targetObject.length; i++) {\r\n                        if (targetObject[i].name === objectIndex) {\r\n                            objectIndex = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (targetObject[objectName] === undefined) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\r\n                        return;\r\n                    }\r\n                    targetObject = targetObject[objectName];\r\n            }\r\n            if (objectIndex !== undefined) {\r\n                if (targetObject[objectIndex] === undefined) {\r\n                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\r\n                    return;\r\n                }\r\n                targetObject = targetObject[objectIndex];\r\n            }\r\n        }\r\n        // resolve property\r\n        var nodeProperty = targetObject[propertyName];\r\n        if (nodeProperty === undefined) {\r\n            var nodeName = parsedPath.nodeName;\r\n            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\r\n                '.' + propertyName + ' but it wasn\\'t found.', targetObject);\r\n            return;\r\n        }\r\n        // determine versioning scheme\r\n        var versioning = this.Versioning.None;\r\n        this.targetObject = targetObject;\r\n        if (targetObject.needsUpdate !== undefined) { // material\r\n            versioning = this.Versioning.NeedsUpdate;\r\n        }\r\n        else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform\r\n            versioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n        }\r\n        // determine how the property gets bound\r\n        var bindingType = this.BindingType.Direct;\r\n        if (propertyIndex !== undefined) {\r\n            // access a sub element of the property array (only primitives are supported right now)\r\n            if (propertyName === \"morphTargetInfluences\") {\r\n                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n                // support resolving morphTarget names into indices.\r\n                if (!targetObject.geometry) {\r\n                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\r\n                    return;\r\n                }\r\n                if (targetObject.geometry.isBufferGeometry) {\r\n                    if (!targetObject.geometry.morphAttributes) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\r\n                        return;\r\n                    }\r\n                    for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {\r\n                        if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {\r\n                            propertyIndex = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (!targetObject.geometry.morphTargets) {\r\n                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);\r\n                        return;\r\n                    }\r\n                    for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {\r\n                        if (targetObject.geometry.morphTargets[i].name === propertyIndex) {\r\n                            propertyIndex = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            bindingType = this.BindingType.ArrayElement;\r\n            this.resolvedProperty = nodeProperty;\r\n            this.propertyIndex = propertyIndex;\r\n        }\r\n        else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\r\n            // must use copy for Object3D.Euler/Quaternion\r\n            bindingType = this.BindingType.HasFromToArray;\r\n            this.resolvedProperty = nodeProperty;\r\n        }\r\n        else if (Array.isArray(nodeProperty)) {\r\n            bindingType = this.BindingType.EntireArray;\r\n            this.resolvedProperty = nodeProperty;\r\n        }\r\n        else {\r\n            this.propertyName = propertyName;\r\n        }\r\n        // select getter / setter\r\n        this.getValue = this.GetterByBindingType[bindingType];\r\n        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\r\n    },\r\n    unbind: function () {\r\n        this.node = null;\r\n        // back to the prototype version of getValue / setValue\r\n        // note: avoiding to mutate the shape of 'this' via 'delete'\r\n        this.getValue = this._getValue_unbound;\r\n        this.setValue = this._setValue_unbound;\r\n    }\r\n});\r\n//!\\ DECLARE ALIAS AFTER assign prototype !\r\nObject.assign(PropertyBinding.prototype, {\r\n    // initial state of these methods that calls 'bind'\r\n    _getValue_unbound: PropertyBinding.prototype.getValue,\r\n    _setValue_unbound: PropertyBinding.prototype.setValue,\r\n});\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n *  - Add objects you would otherwise pass as 'root' to the\r\n *    constructor or the .clipAction method of AnimationMixer.\r\n *\r\n *  - Instead pass this object as 'root'.\r\n *\r\n *  - You can also add and remove objects later when the mixer\r\n *    is running.\r\n *\r\n * Note:\r\n *\r\n *    Objects of this class appear as one object to the mixer,\r\n *    so cache control of the individual objects must be done\r\n *    on the group.\r\n *\r\n * Limitation:\r\n *\r\n *  - The animated properties must be compatible among the\r\n *    all objects in the group.\r\n *\r\n *  - A single property can either be controlled through a\r\n *    target group or directly, but not both.\r\n *\r\n * @author tschw\r\n */\r\nfunction AnimationObjectGroup() {\r\n    this.uuid = _Math.generateUUID();\r\n    // cached objects followed by the active ones\r\n    this._objects = Array.prototype.slice.call(arguments);\r\n    this.nCachedObjects_ = 0; // threshold\r\n    // note: read by PropertyBinding.Composite\r\n    var indices = {};\r\n    this._indicesByUUID = indices; // for bookkeeping\r\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\r\n        indices[arguments[i].uuid] = i;\r\n    }\r\n    this._paths = []; // inside: string\r\n    this._parsedPaths = []; // inside: { we don't care, here }\r\n    this._bindings = []; // inside: Array< PropertyBinding >\r\n    this._bindingsIndicesByPath = {}; // inside: indices in these arrays\r\n    var scope = this;\r\n    this.stats = {\r\n        objects: {\r\n            get total() {\r\n                return scope._objects.length;\r\n            },\r\n            get inUse() {\r\n                return this.total - scope.nCachedObjects_;\r\n            }\r\n        },\r\n        get bindingsPerObject() {\r\n            return scope._bindings.length;\r\n        }\r\n    };\r\n}\r\nObject.assign(AnimationObjectGroup.prototype, {\r\n    isAnimationObjectGroup: true,\r\n    add: function () {\r\n        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined;\r\n        for (var i = 0, n = arguments.length; i !== n; ++i) {\r\n            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];\r\n            if (index === undefined) {\r\n                // unknown object -> add it to the ACTIVE region\r\n                index = nObjects++;\r\n                indicesByUUID[uuid] = index;\r\n                objects.push(object);\r\n                // accounting is done, now do the same for all bindings\r\n                for (var j = 0, m = nBindings; j !== m; ++j) {\r\n                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\r\n                }\r\n            }\r\n            else if (index < nCachedObjects) {\r\n                knownObject = objects[index];\r\n                // move existing object to the ACTIVE region\r\n                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];\r\n                indicesByUUID[lastCachedObject.uuid] = index;\r\n                objects[index] = lastCachedObject;\r\n                indicesByUUID[uuid] = firstActiveIndex;\r\n                objects[firstActiveIndex] = object;\r\n                // accounting is done, now do the same for all bindings\r\n                for (var j = 0, m = nBindings; j !== m; ++j) {\r\n                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];\r\n                    bindingsForPath[index] = lastCached;\r\n                    if (binding === undefined) {\r\n                        // since we do not bother to create new bindings\r\n                        // for objects that are cached, the binding may\r\n                        // or may not exist\r\n                        binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\r\n                    }\r\n                    bindingsForPath[firstActiveIndex] = binding;\r\n                }\r\n            }\r\n            else if (objects[index] !== knownObject) {\r\n                console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +\r\n                    'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\r\n            } // else the object is already where we want it to be\r\n        } // for arguments\r\n        this.nCachedObjects_ = nCachedObjects;\r\n    },\r\n    remove: function () {\r\n        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;\r\n        for (var i = 0, n = arguments.length; i !== n; ++i) {\r\n            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];\r\n            if (index !== undefined && index >= nCachedObjects) {\r\n                // move existing object into the CACHED region\r\n                var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];\r\n                indicesByUUID[firstActiveObject.uuid] = index;\r\n                objects[index] = firstActiveObject;\r\n                indicesByUUID[uuid] = lastCachedIndex;\r\n                objects[lastCachedIndex] = object;\r\n                // accounting is done, now do the same for all bindings\r\n                for (var j = 0, m = nBindings; j !== m; ++j) {\r\n                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];\r\n                    bindingsForPath[index] = firstActive;\r\n                    bindingsForPath[lastCachedIndex] = binding;\r\n                }\r\n            }\r\n        } // for arguments\r\n        this.nCachedObjects_ = nCachedObjects;\r\n    },\r\n    // remove & forget\r\n    uncache: function () {\r\n        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;\r\n        for (var i = 0, n = arguments.length; i !== n; ++i) {\r\n            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];\r\n            if (index !== undefined) {\r\n                delete indicesByUUID[uuid];\r\n                if (index < nCachedObjects) {\r\n                    // object is cached, shrink the CACHED region\r\n                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];\r\n                    // last cached object takes this object's place\r\n                    indicesByUUID[lastCachedObject.uuid] = index;\r\n                    objects[index] = lastCachedObject;\r\n                    // last object goes to the activated slot and pop\r\n                    indicesByUUID[lastObject.uuid] = firstActiveIndex;\r\n                    objects[firstActiveIndex] = lastObject;\r\n                    objects.pop();\r\n                    // accounting is done, now do the same for all bindings\r\n                    for (var j = 0, m = nBindings; j !== m; ++j) {\r\n                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];\r\n                        bindingsForPath[index] = lastCached;\r\n                        bindingsForPath[firstActiveIndex] = last;\r\n                        bindingsForPath.pop();\r\n                    }\r\n                }\r\n                else {\r\n                    // object is active, just swap with the last and pop\r\n                    var lastIndex = --nObjects, lastObject = objects[lastIndex];\r\n                    indicesByUUID[lastObject.uuid] = index;\r\n                    objects[index] = lastObject;\r\n                    objects.pop();\r\n                    // accounting is done, now do the same for all bindings\r\n                    for (var j = 0, m = nBindings; j !== m; ++j) {\r\n                        var bindingsForPath = bindings[j];\r\n                        bindingsForPath[index] = bindingsForPath[lastIndex];\r\n                        bindingsForPath.pop();\r\n                    }\r\n                } // cached or active\r\n            } // if object is known\r\n        } // for arguments\r\n        this.nCachedObjects_ = nCachedObjects;\r\n    },\r\n    // Internal interface used by befriended PropertyBinding.Composite:\r\n    subscribe_: function (path, parsedPath) {\r\n        // returns an array of bindings for the given path that is changed\r\n        // according to the contained objects in the group\r\n        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;\r\n        if (index !== undefined)\r\n            return bindings[index];\r\n        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);\r\n        index = bindings.length;\r\n        indicesByPath[path] = index;\r\n        paths.push(path);\r\n        parsedPaths.push(parsedPath);\r\n        bindings.push(bindingsForPath);\r\n        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {\r\n            var object = objects[i];\r\n            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\r\n        }\r\n        return bindingsForPath;\r\n    },\r\n    unsubscribe_: function (path) {\r\n        // tells the group to forget about a property path and no longer\r\n        // update the array previously obtained with 'subscribe_'\r\n        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];\r\n        if (index !== undefined) {\r\n            var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];\r\n            indicesByPath[lastBindingsPath] = index;\r\n            bindings[index] = lastBindings;\r\n            bindings.pop();\r\n            parsedPaths[index] = parsedPaths[lastBindingsIndex];\r\n            parsedPaths.pop();\r\n            paths[index] = paths[lastBindingsIndex];\r\n            paths.pop();\r\n        }\r\n    }\r\n});\r\n/**\r\n *\r\n * Action provided by AnimationMixer for scheduling clip playback on specific\r\n * objects.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n *\r\n */\r\nfunction AnimationAction(mixer, clip, localRoot) {\r\n    this._mixer = mixer;\r\n    this._clip = clip;\r\n    this._localRoot = localRoot || null;\r\n    var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);\r\n    var interpolantSettings = {\r\n        endingStart: ZeroCurvatureEnding,\r\n        endingEnd: ZeroCurvatureEnding\r\n    };\r\n    for (var i = 0; i !== nTracks; ++i) {\r\n        var interpolant = tracks[i].createInterpolant(null);\r\n        interpolants[i] = interpolant;\r\n        interpolant.settings = interpolantSettings;\r\n    }\r\n    this._interpolantSettings = interpolantSettings;\r\n    this._interpolants = interpolants; // bound by the mixer\r\n    // inside: PropertyMixer (managed by the mixer)\r\n    this._propertyBindings = new Array(nTracks);\r\n    this._cacheIndex = null; // for the memory manager\r\n    this._byClipCacheIndex = null; // for the memory manager\r\n    this._timeScaleInterpolant = null;\r\n    this._weightInterpolant = null;\r\n    this.loop = LoopRepeat;\r\n    this._loopCount = -1;\r\n    // global mixer time when the action is to be started\r\n    // it's set back to 'null' upon start of the action\r\n    this._startTime = null;\r\n    // scaled local time of the action\r\n    // gets clamped or wrapped to 0..clip.duration according to loop\r\n    this.time = 0;\r\n    this.timeScale = 1;\r\n    this._effectiveTimeScale = 1;\r\n    this.weight = 1;\r\n    this._effectiveWeight = 1;\r\n    this.repetitions = Infinity; // no. of repetitions when looping\r\n    this.paused = false; // true -> zero effective time scale\r\n    this.enabled = true; // false -> zero effective weight\r\n    this.clampWhenFinished = false; // keep feeding the last frame?\r\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\r\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\r\n}\r\nObject.assign(AnimationAction.prototype, {\r\n    // State & Scheduling\r\n    play: function () {\r\n        this._mixer._activateAction(this);\r\n        return this;\r\n    },\r\n    stop: function () {\r\n        this._mixer._deactivateAction(this);\r\n        return this.reset();\r\n    },\r\n    reset: function () {\r\n        this.paused = false;\r\n        this.enabled = true;\r\n        this.time = 0; // restart clip\r\n        this._loopCount = -1; // forget previous loops\r\n        this._startTime = null; // forget scheduling\r\n        return this.stopFading().stopWarping();\r\n    },\r\n    isRunning: function () {\r\n        return this.enabled && !this.paused && this.timeScale !== 0 &&\r\n            this._startTime === null && this._mixer._isActiveAction(this);\r\n    },\r\n    // return true when play has been called\r\n    isScheduled: function () {\r\n        return this._mixer._isActiveAction(this);\r\n    },\r\n    startAt: function (time) {\r\n        this._startTime = time;\r\n        return this;\r\n    },\r\n    setLoop: function (mode, repetitions) {\r\n        this.loop = mode;\r\n        this.repetitions = repetitions;\r\n        return this;\r\n    },\r\n    // Weight\r\n    // set the weight stopping any scheduled fading\r\n    // although .enabled = false yields an effective weight of zero, this\r\n    // method does *not* change .enabled, because it would be confusing\r\n    setEffectiveWeight: function (weight) {\r\n        this.weight = weight;\r\n        // note: same logic as when updated at runtime\r\n        this._effectiveWeight = this.enabled ? weight : 0;\r\n        return this.stopFading();\r\n    },\r\n    // return the weight considering fading and .enabled\r\n    getEffectiveWeight: function () {\r\n        return this._effectiveWeight;\r\n    },\r\n    fadeIn: function (duration) {\r\n        return this._scheduleFading(duration, 0, 1);\r\n    },\r\n    fadeOut: function (duration) {\r\n        return this._scheduleFading(duration, 1, 0);\r\n    },\r\n    crossFadeFrom: function (fadeOutAction, duration, warp) {\r\n        fadeOutAction.fadeOut(duration);\r\n        this.fadeIn(duration);\r\n        if (warp) {\r\n            var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;\r\n            fadeOutAction.warp(1.0, startEndRatio, duration);\r\n            this.warp(endStartRatio, 1.0, duration);\r\n        }\r\n        return this;\r\n    },\r\n    crossFadeTo: function (fadeInAction, duration, warp) {\r\n        return fadeInAction.crossFadeFrom(this, duration, warp);\r\n    },\r\n    stopFading: function () {\r\n        var weightInterpolant = this._weightInterpolant;\r\n        if (weightInterpolant !== null) {\r\n            this._weightInterpolant = null;\r\n            this._mixer._takeBackControlInterpolant(weightInterpolant);\r\n        }\r\n        return this;\r\n    },\r\n    // Time Scale Control\r\n    // set the time scale stopping any scheduled warping\r\n    // although .paused = true yields an effective time scale of zero, this\r\n    // method does *not* change .paused, because it would be confusing\r\n    setEffectiveTimeScale: function (timeScale) {\r\n        this.timeScale = timeScale;\r\n        this._effectiveTimeScale = this.paused ? 0 : timeScale;\r\n        return this.stopWarping();\r\n    },\r\n    // return the time scale considering warping and .paused\r\n    getEffectiveTimeScale: function () {\r\n        return this._effectiveTimeScale;\r\n    },\r\n    setDuration: function (duration) {\r\n        this.timeScale = this._clip.duration / duration;\r\n        return this.stopWarping();\r\n    },\r\n    syncWith: function (action) {\r\n        this.time = action.time;\r\n        this.timeScale = action.timeScale;\r\n        return this.stopWarping();\r\n    },\r\n    halt: function (duration) {\r\n        return this.warp(this._effectiveTimeScale, 0, duration);\r\n    },\r\n    warp: function (startTimeScale, endTimeScale, duration) {\r\n        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;\r\n        if (interpolant === null) {\r\n            interpolant = mixer._lendControlInterpolant();\r\n            this._timeScaleInterpolant = interpolant;\r\n        }\r\n        var times = interpolant.parameterPositions, values = interpolant.sampleValues;\r\n        times[0] = now;\r\n        times[1] = now + duration;\r\n        values[0] = startTimeScale / timeScale;\r\n        values[1] = endTimeScale / timeScale;\r\n        return this;\r\n    },\r\n    stopWarping: function () {\r\n        var timeScaleInterpolant = this._timeScaleInterpolant;\r\n        if (timeScaleInterpolant !== null) {\r\n            this._timeScaleInterpolant = null;\r\n            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\r\n        }\r\n        return this;\r\n    },\r\n    // Object Accessors\r\n    getMixer: function () {\r\n        return this._mixer;\r\n    },\r\n    getClip: function () {\r\n        return this._clip;\r\n    },\r\n    getRoot: function () {\r\n        return this._localRoot || this._mixer._root;\r\n    },\r\n    // Interna\r\n    _update: function (time, deltaTime, timeDirection, accuIndex) {\r\n        // called by the mixer\r\n        if (!this.enabled) {\r\n            // call ._updateWeight() to update ._effectiveWeight\r\n            this._updateWeight(time);\r\n            return;\r\n        }\r\n        var startTime = this._startTime;\r\n        if (startTime !== null) {\r\n            // check for scheduled start of action\r\n            var timeRunning = (time - startTime) * timeDirection;\r\n            if (timeRunning < 0 || timeDirection === 0) {\r\n                return; // yet to come / don't decide when delta = 0\r\n            }\r\n            // start\r\n            this._startTime = null; // unschedule\r\n            deltaTime = timeDirection * timeRunning;\r\n        }\r\n        // apply time scale and advance time\r\n        deltaTime *= this._updateTimeScale(time);\r\n        var clipTime = this._updateTime(deltaTime);\r\n        // note: _updateTime may disable the action resulting in\r\n        // an effective weight of 0\r\n        var weight = this._updateWeight(time);\r\n        if (weight > 0) {\r\n            var interpolants = this._interpolants;\r\n            var propertyMixers = this._propertyBindings;\r\n            for (var j = 0, m = interpolants.length; j !== m; ++j) {\r\n                interpolants[j].evaluate(clipTime);\r\n                propertyMixers[j].accumulate(accuIndex, weight);\r\n            }\r\n        }\r\n    },\r\n    _updateWeight: function (time) {\r\n        var weight = 0;\r\n        if (this.enabled) {\r\n            weight = this.weight;\r\n            var interpolant = this._weightInterpolant;\r\n            if (interpolant !== null) {\r\n                var interpolantValue = interpolant.evaluate(time)[0];\r\n                weight *= interpolantValue;\r\n                if (time > interpolant.parameterPositions[1]) {\r\n                    this.stopFading();\r\n                    if (interpolantValue === 0) {\r\n                        // faded out, disable\r\n                        this.enabled = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._effectiveWeight = weight;\r\n        return weight;\r\n    },\r\n    _updateTimeScale: function (time) {\r\n        var timeScale = 0;\r\n        if (!this.paused) {\r\n            timeScale = this.timeScale;\r\n            var interpolant = this._timeScaleInterpolant;\r\n            if (interpolant !== null) {\r\n                var interpolantValue = interpolant.evaluate(time)[0];\r\n                timeScale *= interpolantValue;\r\n                if (time > interpolant.parameterPositions[1]) {\r\n                    this.stopWarping();\r\n                    if (timeScale === 0) {\r\n                        // motion has halted, pause\r\n                        this.paused = true;\r\n                    }\r\n                    else {\r\n                        // warp done - apply final time scale\r\n                        this.timeScale = timeScale;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._effectiveTimeScale = timeScale;\r\n        return timeScale;\r\n    },\r\n    _updateTime: function (deltaTime) {\r\n        var time = this.time + deltaTime;\r\n        var duration = this._clip.duration;\r\n        var loop = this.loop;\r\n        var loopCount = this._loopCount;\r\n        var pingPong = (loop === LoopPingPong);\r\n        if (deltaTime === 0) {\r\n            if (loopCount === -1)\r\n                return time;\r\n            return (pingPong && (loopCount & 1) === 1) ? duration - time : time;\r\n        }\r\n        if (loop === LoopOnce) {\r\n            if (loopCount === -1) {\r\n                // just started\r\n                this._loopCount = 0;\r\n                this._setEndings(true, true, false);\r\n            }\r\n            handle_stop: {\r\n                if (time >= duration) {\r\n                    time = duration;\r\n                }\r\n                else if (time < 0) {\r\n                    time = 0;\r\n                }\r\n                else {\r\n                    this.time = time;\r\n                    break handle_stop;\r\n                }\r\n                if (this.clampWhenFinished)\r\n                    this.paused = true;\r\n                else\r\n                    this.enabled = false;\r\n                this.time = time;\r\n                this._mixer.dispatchEvent({\r\n                    type: 'finished', action: this,\r\n                    direction: deltaTime < 0 ? -1 : 1\r\n                });\r\n            }\r\n        }\r\n        else { // repetitive Repeat or PingPong\r\n            if (loopCount === -1) {\r\n                // just started\r\n                if (deltaTime >= 0) {\r\n                    loopCount = 0;\r\n                    this._setEndings(true, this.repetitions === 0, pingPong);\r\n                }\r\n                else {\r\n                    // when looping in reverse direction, the initial\r\n                    // transition through zero counts as a repetition,\r\n                    // so leave loopCount at -1\r\n                    this._setEndings(this.repetitions === 0, true, pingPong);\r\n                }\r\n            }\r\n            if (time >= duration || time < 0) {\r\n                // wrap around\r\n                var loopDelta = Math.floor(time / duration); // signed\r\n                time -= duration * loopDelta;\r\n                loopCount += Math.abs(loopDelta);\r\n                var pending = this.repetitions - loopCount;\r\n                if (pending <= 0) {\r\n                    // have to stop (switch state, clamp time, fire event)\r\n                    if (this.clampWhenFinished)\r\n                        this.paused = true;\r\n                    else\r\n                        this.enabled = false;\r\n                    time = deltaTime > 0 ? duration : 0;\r\n                    this.time = time;\r\n                    this._mixer.dispatchEvent({\r\n                        type: 'finished', action: this,\r\n                        direction: deltaTime > 0 ? 1 : -1\r\n                    });\r\n                }\r\n                else {\r\n                    // keep running\r\n                    if (pending === 1) {\r\n                        // entering the last round\r\n                        var atStart = deltaTime < 0;\r\n                        this._setEndings(atStart, !atStart, pingPong);\r\n                    }\r\n                    else {\r\n                        this._setEndings(false, false, pingPong);\r\n                    }\r\n                    this._loopCount = loopCount;\r\n                    this.time = time;\r\n                    this._mixer.dispatchEvent({\r\n                        type: 'loop', action: this, loopDelta: loopDelta\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                this.time = time;\r\n            }\r\n            if (pingPong && (loopCount & 1) === 1) {\r\n                // invert time for the \"pong round\"\r\n                return duration - time;\r\n            }\r\n        }\r\n        return time;\r\n    },\r\n    _setEndings: function (atStart, atEnd, pingPong) {\r\n        var settings = this._interpolantSettings;\r\n        if (pingPong) {\r\n            settings.endingStart = ZeroSlopeEnding;\r\n            settings.endingEnd = ZeroSlopeEnding;\r\n        }\r\n        else {\r\n            // assuming for LoopOnce atStart == atEnd == true\r\n            if (atStart) {\r\n                settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\r\n            }\r\n            else {\r\n                settings.endingStart = WrapAroundEnding;\r\n            }\r\n            if (atEnd) {\r\n                settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\r\n            }\r\n            else {\r\n                settings.endingEnd = WrapAroundEnding;\r\n            }\r\n        }\r\n    },\r\n    _scheduleFading: function (duration, weightNow, weightThen) {\r\n        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;\r\n        if (interpolant === null) {\r\n            interpolant = mixer._lendControlInterpolant();\r\n            this._weightInterpolant = interpolant;\r\n        }\r\n        var times = interpolant.parameterPositions, values = interpolant.sampleValues;\r\n        times[0] = now;\r\n        values[0] = weightNow;\r\n        times[1] = now + duration;\r\n        values[1] = weightThen;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n *\r\n * Player for AnimationClips.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\nfunction AnimationMixer(root) {\r\n    this._root = root;\r\n    this._initMemoryManager();\r\n    this._accuIndex = 0;\r\n    this.time = 0;\r\n    this.timeScale = 1.0;\r\n}\r\nAnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\r\n    constructor: AnimationMixer,\r\n    _bindAction: function (action, prototypeAction) {\r\n        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];\r\n        if (bindingsByName === undefined) {\r\n            bindingsByName = {};\r\n            bindingsByRoot[rootUuid] = bindingsByName;\r\n        }\r\n        for (var i = 0; i !== nTracks; ++i) {\r\n            var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];\r\n            if (binding !== undefined) {\r\n                bindings[i] = binding;\r\n            }\r\n            else {\r\n                binding = bindings[i];\r\n                if (binding !== undefined) {\r\n                    // existing binding, make sure the cache knows\r\n                    if (binding._cacheIndex === null) {\r\n                        ++binding.referenceCount;\r\n                        this._addInactiveBinding(binding, rootUuid, trackName);\r\n                    }\r\n                    continue;\r\n                }\r\n                var path = prototypeAction && prototypeAction.\r\n                    _propertyBindings[i].binding.parsedPath;\r\n                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\r\n                ++binding.referenceCount;\r\n                this._addInactiveBinding(binding, rootUuid, trackName);\r\n                bindings[i] = binding;\r\n            }\r\n            interpolants[i].resultBuffer = binding.buffer;\r\n        }\r\n    },\r\n    _activateAction: function (action) {\r\n        if (!this._isActiveAction(action)) {\r\n            if (action._cacheIndex === null) {\r\n                // this action has been forgotten by the cache, but the user\r\n                // appears to be still using it -> rebind\r\n                var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];\r\n                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\r\n                this._addInactiveAction(action, clipUuid, rootUuid);\r\n            }\r\n            var bindings = action._propertyBindings;\r\n            // increment reference counts / sort out state\r\n            for (var i = 0, n = bindings.length; i !== n; ++i) {\r\n                var binding = bindings[i];\r\n                if (binding.useCount++ === 0) {\r\n                    this._lendBinding(binding);\r\n                    binding.saveOriginalState();\r\n                }\r\n            }\r\n            this._lendAction(action);\r\n        }\r\n    },\r\n    _deactivateAction: function (action) {\r\n        if (this._isActiveAction(action)) {\r\n            var bindings = action._propertyBindings;\r\n            // decrement reference counts / sort out state\r\n            for (var i = 0, n = bindings.length; i !== n; ++i) {\r\n                var binding = bindings[i];\r\n                if (--binding.useCount === 0) {\r\n                    binding.restoreOriginalState();\r\n                    this._takeBackBinding(binding);\r\n                }\r\n            }\r\n            this._takeBackAction(action);\r\n        }\r\n    },\r\n    // Memory manager\r\n    _initMemoryManager: function () {\r\n        this._actions = []; // 'nActiveActions' followed by inactive ones\r\n        this._nActiveActions = 0;\r\n        this._actionsByClip = {};\r\n        // inside:\r\n        // {\r\n        // \tknownActions: Array< AnimationAction > - used as prototypes\r\n        // \tactionByRoot: AnimationAction - lookup\r\n        // }\r\n        this._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n        this._nActiveBindings = 0;\r\n        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n        this._controlInterpolants = []; // same game as above\r\n        this._nActiveControlInterpolants = 0;\r\n        var scope = this;\r\n        this.stats = {\r\n            actions: {\r\n                get total() {\r\n                    return scope._actions.length;\r\n                },\r\n                get inUse() {\r\n                    return scope._nActiveActions;\r\n                }\r\n            },\r\n            bindings: {\r\n                get total() {\r\n                    return scope._bindings.length;\r\n                },\r\n                get inUse() {\r\n                    return scope._nActiveBindings;\r\n                }\r\n            },\r\n            controlInterpolants: {\r\n                get total() {\r\n                    return scope._controlInterpolants.length;\r\n                },\r\n                get inUse() {\r\n                    return scope._nActiveControlInterpolants;\r\n                }\r\n            }\r\n        };\r\n    },\r\n    // Memory management for AnimationAction objects\r\n    _isActiveAction: function (action) {\r\n        var index = action._cacheIndex;\r\n        return index !== null && index < this._nActiveActions;\r\n    },\r\n    _addInactiveAction: function (action, clipUuid, rootUuid) {\r\n        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];\r\n        if (actionsForClip === undefined) {\r\n            actionsForClip = {\r\n                knownActions: [action],\r\n                actionByRoot: {}\r\n            };\r\n            action._byClipCacheIndex = 0;\r\n            actionsByClip[clipUuid] = actionsForClip;\r\n        }\r\n        else {\r\n            var knownActions = actionsForClip.knownActions;\r\n            action._byClipCacheIndex = knownActions.length;\r\n            knownActions.push(action);\r\n        }\r\n        action._cacheIndex = actions.length;\r\n        actions.push(action);\r\n        actionsForClip.actionByRoot[rootUuid] = action;\r\n    },\r\n    _removeInactiveAction: function (action) {\r\n        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;\r\n        lastInactiveAction._cacheIndex = cacheIndex;\r\n        actions[cacheIndex] = lastInactiveAction;\r\n        actions.pop();\r\n        action._cacheIndex = null;\r\n        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;\r\n        lastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n        knownActionsForClip[byClipCacheIndex] = lastKnownAction;\r\n        knownActionsForClip.pop();\r\n        action._byClipCacheIndex = null;\r\n        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;\r\n        delete actionByRoot[rootUuid];\r\n        if (knownActionsForClip.length === 0) {\r\n            delete actionsByClip[clipUuid];\r\n        }\r\n        this._removeInactiveBindingsForAction(action);\r\n    },\r\n    _removeInactiveBindingsForAction: function (action) {\r\n        var bindings = action._propertyBindings;\r\n        for (var i = 0, n = bindings.length; i !== n; ++i) {\r\n            var binding = bindings[i];\r\n            if (--binding.referenceCount === 0) {\r\n                this._removeInactiveBinding(binding);\r\n            }\r\n        }\r\n    },\r\n    _lendAction: function (action) {\r\n        // [ active actions |  inactive actions  ]\r\n        // [  active actions >| inactive actions ]\r\n        //                 s        a\r\n        //                  <-swap->\r\n        //                 a        s\r\n        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];\r\n        action._cacheIndex = lastActiveIndex;\r\n        actions[lastActiveIndex] = action;\r\n        firstInactiveAction._cacheIndex = prevIndex;\r\n        actions[prevIndex] = firstInactiveAction;\r\n    },\r\n    _takeBackAction: function (action) {\r\n        // [  active actions  | inactive actions ]\r\n        // [ active actions |< inactive actions  ]\r\n        //        a        s\r\n        //         <-swap->\r\n        //        s        a\r\n        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];\r\n        action._cacheIndex = firstInactiveIndex;\r\n        actions[firstInactiveIndex] = action;\r\n        lastActiveAction._cacheIndex = prevIndex;\r\n        actions[prevIndex] = lastActiveAction;\r\n    },\r\n    // Memory management for PropertyMixer objects\r\n    _addInactiveBinding: function (binding, rootUuid, trackName) {\r\n        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;\r\n        if (bindingByName === undefined) {\r\n            bindingByName = {};\r\n            bindingsByRoot[rootUuid] = bindingByName;\r\n        }\r\n        bindingByName[trackName] = binding;\r\n        binding._cacheIndex = bindings.length;\r\n        bindings.push(binding);\r\n    },\r\n    _removeInactiveBinding: function (binding) {\r\n        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;\r\n        lastInactiveBinding._cacheIndex = cacheIndex;\r\n        bindings[cacheIndex] = lastInactiveBinding;\r\n        bindings.pop();\r\n        delete bindingByName[trackName];\r\n        if (Object.keys(bindingByName).length === 0) {\r\n            delete bindingsByRoot[rootUuid];\r\n        }\r\n    },\r\n    _lendBinding: function (binding) {\r\n        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];\r\n        binding._cacheIndex = lastActiveIndex;\r\n        bindings[lastActiveIndex] = binding;\r\n        firstInactiveBinding._cacheIndex = prevIndex;\r\n        bindings[prevIndex] = firstInactiveBinding;\r\n    },\r\n    _takeBackBinding: function (binding) {\r\n        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];\r\n        binding._cacheIndex = firstInactiveIndex;\r\n        bindings[firstInactiveIndex] = binding;\r\n        lastActiveBinding._cacheIndex = prevIndex;\r\n        bindings[prevIndex] = lastActiveBinding;\r\n    },\r\n    // Memory management of Interpolants for weight and time scale\r\n    _lendControlInterpolant: function () {\r\n        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];\r\n        if (interpolant === undefined) {\r\n            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\r\n            interpolant.__cacheIndex = lastActiveIndex;\r\n            interpolants[lastActiveIndex] = interpolant;\r\n        }\r\n        return interpolant;\r\n    },\r\n    _takeBackControlInterpolant: function (interpolant) {\r\n        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];\r\n        interpolant.__cacheIndex = firstInactiveIndex;\r\n        interpolants[firstInactiveIndex] = interpolant;\r\n        lastActiveInterpolant.__cacheIndex = prevIndex;\r\n        interpolants[prevIndex] = lastActiveInterpolant;\r\n    },\r\n    _controlInterpolantsResultBuffer: new Float32Array(1),\r\n    // return an action for a clip optionally using a custom root target\r\n    // object (this method allocates a lot of dynamic memory in case a\r\n    // previously unknown clip/root combination is specified)\r\n    clipAction: function (clip, optionalRoot) {\r\n        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?\r\n            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;\r\n        if (actionsForClip !== undefined) {\r\n            var existingAction = actionsForClip.actionByRoot[rootUuid];\r\n            if (existingAction !== undefined) {\r\n                return existingAction;\r\n            }\r\n            // we know the clip, so we don't have to parse all\r\n            // the bindings again but can just copy\r\n            prototypeAction = actionsForClip.knownActions[0];\r\n            // also, take the clip from the prototype action\r\n            if (clipObject === null)\r\n                clipObject = prototypeAction._clip;\r\n        }\r\n        // clip must be known when specified via string\r\n        if (clipObject === null)\r\n            return null;\r\n        // allocate all resources required to run it\r\n        var newAction = new AnimationAction(this, clipObject, optionalRoot);\r\n        this._bindAction(newAction, prototypeAction);\r\n        // and make the action known to the memory manager\r\n        this._addInactiveAction(newAction, clipUuid, rootUuid);\r\n        return newAction;\r\n    },\r\n    // get an existing action\r\n    existingAction: function (clip, optionalRoot) {\r\n        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?\r\n            AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];\r\n        if (actionsForClip !== undefined) {\r\n            return actionsForClip.actionByRoot[rootUuid] || null;\r\n        }\r\n        return null;\r\n    },\r\n    // deactivates all previously scheduled actions\r\n    stopAllAction: function () {\r\n        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;\r\n        this._nActiveActions = 0;\r\n        this._nActiveBindings = 0;\r\n        for (var i = 0; i !== nActions; ++i) {\r\n            actions[i].reset();\r\n        }\r\n        for (var i = 0; i !== nBindings; ++i) {\r\n            bindings[i].useCount = 0;\r\n        }\r\n        return this;\r\n    },\r\n    // advance the time and update apply the animation\r\n    update: function (deltaTime) {\r\n        deltaTime *= this.timeScale;\r\n        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;\r\n        // run active actions\r\n        for (var i = 0; i !== nActions; ++i) {\r\n            var action = actions[i];\r\n            action._update(time, deltaTime, timeDirection, accuIndex);\r\n        }\r\n        // update scene graph\r\n        var bindings = this._bindings, nBindings = this._nActiveBindings;\r\n        for (var i = 0; i !== nBindings; ++i) {\r\n            bindings[i].apply(accuIndex);\r\n        }\r\n        return this;\r\n    },\r\n    // return this mixer's root target object\r\n    getRoot: function () {\r\n        return this._root;\r\n    },\r\n    // free all resources specific to a particular clip\r\n    uncacheClip: function (clip) {\r\n        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];\r\n        if (actionsForClip !== undefined) {\r\n            // note: just calling _removeInactiveAction would mess up the\r\n            // iteration state and also require updating the state we can\r\n            // just throw away\r\n            var actionsToRemove = actionsForClip.knownActions;\r\n            for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {\r\n                var action = actionsToRemove[i];\r\n                this._deactivateAction(action);\r\n                var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];\r\n                action._cacheIndex = null;\r\n                action._byClipCacheIndex = null;\r\n                lastInactiveAction._cacheIndex = cacheIndex;\r\n                actions[cacheIndex] = lastInactiveAction;\r\n                actions.pop();\r\n                this._removeInactiveBindingsForAction(action);\r\n            }\r\n            delete actionsByClip[clipUuid];\r\n        }\r\n    },\r\n    // free all resources specific to a particular root target object\r\n    uncacheRoot: function (root) {\r\n        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;\r\n        for (var clipUuid in actionsByClip) {\r\n            var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];\r\n            if (action !== undefined) {\r\n                this._deactivateAction(action);\r\n                this._removeInactiveAction(action);\r\n            }\r\n        }\r\n        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];\r\n        if (bindingByName !== undefined) {\r\n            for (var trackName in bindingByName) {\r\n                var binding = bindingByName[trackName];\r\n                binding.restoreOriginalState();\r\n                this._removeInactiveBinding(binding);\r\n            }\r\n        }\r\n    },\r\n    // remove a targeted clip from the cache\r\n    uncacheAction: function (clip, optionalRoot) {\r\n        var action = this.existingAction(clip, optionalRoot);\r\n        if (action !== null) {\r\n            this._deactivateAction(action);\r\n            this._removeInactiveAction(action);\r\n        }\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Uniform(value) {\r\n    if (typeof value === 'string') {\r\n        console.warn('THREE.Uniform: Type parameter is no longer needed.');\r\n        value = arguments[1];\r\n    }\r\n    this.value = value;\r\n}\r\nUniform.prototype.clone = function () {\r\n    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\r\n};\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\nfunction InstancedInterleavedBuffer(array, stride, meshPerAttribute) {\r\n    InterleavedBuffer.call(this, array, stride);\r\n    this.meshPerAttribute = meshPerAttribute || 1;\r\n}\r\nInstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {\r\n    constructor: InstancedInterleavedBuffer,\r\n    isInstancedInterleavedBuffer: true,\r\n    copy: function (source) {\r\n        InterleavedBuffer.prototype.copy.call(this, source);\r\n        this.meshPerAttribute = source.meshPerAttribute;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\nfunction Raycaster(origin, direction, near, far) {\r\n    this.ray = new Ray(origin, direction);\r\n    // direction is assumed to be normalized (for accurate distance calculations)\r\n    this.near = near || 0;\r\n    this.far = far || Infinity;\r\n    this.params = {\r\n        Mesh: {},\r\n        Line: {},\r\n        LOD: {},\r\n        Points: { threshold: 1 },\r\n        Sprite: {}\r\n    };\r\n    Object.defineProperties(this.params, {\r\n        PointCloud: {\r\n            get: function () {\r\n                console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');\r\n                return this.Points;\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction ascSort(a, b) {\r\n    return a.distance - b.distance;\r\n}\r\nfunction intersectObject(object, raycaster, intersects, recursive) {\r\n    if (object.visible === false)\r\n        return;\r\n    object.raycast(raycaster, intersects);\r\n    if (recursive === true) {\r\n        var children = object.children;\r\n        for (var i = 0, l = children.length; i < l; i++) {\r\n            intersectObject(children[i], raycaster, intersects, true);\r\n        }\r\n    }\r\n}\r\nObject.assign(Raycaster.prototype, {\r\n    linePrecision: 1,\r\n    set: function (origin, direction) {\r\n        // direction is assumed to be normalized (for accurate distance calculations)\r\n        this.ray.set(origin, direction);\r\n    },\r\n    setFromCamera: function (coords, camera) {\r\n        if ((camera && camera.isPerspectiveCamera)) {\r\n            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\r\n            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\r\n            this._camera = camera;\r\n        }\r\n        else if ((camera && camera.isOrthographicCamera)) {\r\n            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\r\n            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\r\n            this._camera = camera;\r\n        }\r\n        else {\r\n            console.error('THREE.Raycaster: Unsupported camera type.');\r\n        }\r\n    },\r\n    intersectObject: function (object, recursive, optionalTarget) {\r\n        var intersects = optionalTarget || [];\r\n        intersectObject(object, this, intersects, recursive);\r\n        intersects.sort(ascSort);\r\n        return intersects;\r\n    },\r\n    intersectObjects: function (objects, recursive, optionalTarget) {\r\n        var intersects = optionalTarget || [];\r\n        if (Array.isArray(objects) === false) {\r\n            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');\r\n            return intersects;\r\n        }\r\n        for (var i = 0, l = objects.length; i < l; i++) {\r\n            intersectObject(objects[i], this, intersects, recursive);\r\n        }\r\n        intersects.sort(ascSort);\r\n        return intersects;\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\r\n * The azimuthal angle (theta) is measured from the positive z-axiz.\r\n */\r\nfunction Spherical(radius, phi, theta) {\r\n    this.radius = (radius !== undefined) ? radius : 1.0;\r\n    this.phi = (phi !== undefined) ? phi : 0; // polar angle\r\n    this.theta = (theta !== undefined) ? theta : 0; // azimuthal angle\r\n    return this;\r\n}\r\nObject.assign(Spherical.prototype, {\r\n    set: function (radius, phi, theta) {\r\n        this.radius = radius;\r\n        this.phi = phi;\r\n        this.theta = theta;\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (other) {\r\n        this.radius = other.radius;\r\n        this.phi = other.phi;\r\n        this.theta = other.theta;\r\n        return this;\r\n    },\r\n    // restrict phi to be betwee EPS and PI-EPS\r\n    makeSafe: function () {\r\n        var EPS = 0.000001;\r\n        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\r\n        return this;\r\n    },\r\n    setFromVector3: function (v) {\r\n        return this.setFromCartesianCoords(v.x, v.y, v.z);\r\n    },\r\n    setFromCartesianCoords: function (x, y, z) {\r\n        this.radius = Math.sqrt(x * x + y * y + z * z);\r\n        if (this.radius === 0) {\r\n            this.theta = 0;\r\n            this.phi = 0;\r\n        }\r\n        else {\r\n            this.theta = Math.atan2(x, z);\r\n            this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));\r\n        }\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\r\n *\r\n */\r\nfunction Cylindrical(radius, theta, y) {\r\n    this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane\r\n    this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\r\n    this.y = (y !== undefined) ? y : 0; // height above the x-z plane\r\n    return this;\r\n}\r\nObject.assign(Cylindrical.prototype, {\r\n    set: function (radius, theta, y) {\r\n        this.radius = radius;\r\n        this.theta = theta;\r\n        this.y = y;\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (other) {\r\n        this.radius = other.radius;\r\n        this.theta = other.theta;\r\n        this.y = other.y;\r\n        return this;\r\n    },\r\n    setFromVector3: function (v) {\r\n        return this.setFromCartesianCoords(v.x, v.y, v.z);\r\n    },\r\n    setFromCartesianCoords: function (x, y, z) {\r\n        this.radius = Math.sqrt(x * x + z * z);\r\n        this.theta = Math.atan2(x, z);\r\n        this.y = y;\r\n        return this;\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\nfunction Box2(min, max) {\r\n    this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);\r\n    this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);\r\n}\r\nObject.assign(Box2.prototype, {\r\n    set: function (min, max) {\r\n        this.min.copy(min);\r\n        this.max.copy(max);\r\n        return this;\r\n    },\r\n    setFromPoints: function (points) {\r\n        this.makeEmpty();\r\n        for (var i = 0, il = points.length; i < il; i++) {\r\n            this.expandByPoint(points[i]);\r\n        }\r\n        return this;\r\n    },\r\n    setFromCenterAndSize: function () {\r\n        var v1 = new Vector2();\r\n        return function setFromCenterAndSize(center, size) {\r\n            var halfSize = v1.copy(size).multiplyScalar(0.5);\r\n            this.min.copy(center).sub(halfSize);\r\n            this.max.copy(center).add(halfSize);\r\n            return this;\r\n        };\r\n    }(),\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (box) {\r\n        this.min.copy(box.min);\r\n        this.max.copy(box.max);\r\n        return this;\r\n    },\r\n    makeEmpty: function () {\r\n        this.min.x = this.min.y = +Infinity;\r\n        this.max.x = this.max.y = -Infinity;\r\n        return this;\r\n    },\r\n    isEmpty: function () {\r\n        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n        return (this.max.x < this.min.x) || (this.max.y < this.min.y);\r\n    },\r\n    getCenter: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box2: .getCenter() target is now required');\r\n            target = new Vector2();\r\n        }\r\n        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\r\n    },\r\n    getSize: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box2: .getSize() target is now required');\r\n            target = new Vector2();\r\n        }\r\n        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\r\n    },\r\n    expandByPoint: function (point) {\r\n        this.min.min(point);\r\n        this.max.max(point);\r\n        return this;\r\n    },\r\n    expandByVector: function (vector) {\r\n        this.min.sub(vector);\r\n        this.max.add(vector);\r\n        return this;\r\n    },\r\n    expandByScalar: function (scalar) {\r\n        this.min.addScalar(-scalar);\r\n        this.max.addScalar(scalar);\r\n        return this;\r\n    },\r\n    containsPoint: function (point) {\r\n        return point.x < this.min.x || point.x > this.max.x ||\r\n            point.y < this.min.y || point.y > this.max.y ? false : true;\r\n    },\r\n    containsBox: function (box) {\r\n        return this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n            this.min.y <= box.min.y && box.max.y <= this.max.y;\r\n    },\r\n    getParameter: function (point, target) {\r\n        // This can potentially have a divide by zero if the box\r\n        // has a size dimension of 0.\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box2: .getParameter() target is now required');\r\n            target = new Vector2();\r\n        }\r\n        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\r\n    },\r\n    intersectsBox: function (box) {\r\n        // using 4 splitting planes to rule out intersections\r\n        return box.max.x < this.min.x || box.min.x > this.max.x ||\r\n            box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\r\n    },\r\n    clampPoint: function (point, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Box2: .clampPoint() target is now required');\r\n            target = new Vector2();\r\n        }\r\n        return target.copy(point).clamp(this.min, this.max);\r\n    },\r\n    distanceToPoint: function () {\r\n        var v1 = new Vector2();\r\n        return function distanceToPoint(point) {\r\n            var clampedPoint = v1.copy(point).clamp(this.min, this.max);\r\n            return clampedPoint.sub(point).length();\r\n        };\r\n    }(),\r\n    intersect: function (box) {\r\n        this.min.max(box.min);\r\n        this.max.min(box.max);\r\n        return this;\r\n    },\r\n    union: function (box) {\r\n        this.min.min(box.min);\r\n        this.max.max(box.max);\r\n        return this;\r\n    },\r\n    translate: function (offset) {\r\n        this.min.add(offset);\r\n        this.max.add(offset);\r\n        return this;\r\n    },\r\n    equals: function (box) {\r\n        return box.min.equals(this.min) && box.max.equals(this.max);\r\n    }\r\n});\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\nvar _startP, _startEnd;\r\nfunction Line3(start, end) {\r\n    this.start = (start !== undefined) ? start : new Vector3();\r\n    this.end = (end !== undefined) ? end : new Vector3();\r\n}\r\nObject.assign(Line3.prototype, {\r\n    set: function (start, end) {\r\n        this.start.copy(start);\r\n        this.end.copy(end);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    },\r\n    copy: function (line) {\r\n        this.start.copy(line.start);\r\n        this.end.copy(line.end);\r\n        return this;\r\n    },\r\n    getCenter: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Line3: .getCenter() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.addVectors(this.start, this.end).multiplyScalar(0.5);\r\n    },\r\n    delta: function (target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Line3: .delta() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return target.subVectors(this.end, this.start);\r\n    },\r\n    distanceSq: function () {\r\n        return this.start.distanceToSquared(this.end);\r\n    },\r\n    distance: function () {\r\n        return this.start.distanceTo(this.end);\r\n    },\r\n    at: function (t, target) {\r\n        if (target === undefined) {\r\n            console.warn('THREE.Line3: .at() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return this.delta(target).multiplyScalar(t).add(this.start);\r\n    },\r\n    closestPointToPointParameter: function (point, clampToLine) {\r\n        if (_startP === undefined) {\r\n            _startP = new Vector3();\r\n            _startEnd = new Vector3();\r\n        }\r\n        _startP.subVectors(point, this.start);\r\n        _startEnd.subVectors(this.end, this.start);\r\n        var startEnd2 = _startEnd.dot(_startEnd);\r\n        var startEnd_startP = _startEnd.dot(_startP);\r\n        var t = startEnd_startP / startEnd2;\r\n        if (clampToLine) {\r\n            t = _Math.clamp(t, 0, 1);\r\n        }\r\n        return t;\r\n    },\r\n    closestPointToPoint: function (point, clampToLine, target) {\r\n        var t = this.closestPointToPointParameter(point, clampToLine);\r\n        if (target === undefined) {\r\n            console.warn('THREE.Line3: .closestPointToPoint() target is now required');\r\n            target = new Vector3();\r\n        }\r\n        return this.delta(target).multiplyScalar(t).add(this.start);\r\n    },\r\n    applyMatrix4: function (matrix) {\r\n        this.start.applyMatrix4(matrix);\r\n        this.end.applyMatrix4(matrix);\r\n        return this;\r\n    },\r\n    equals: function (line) {\r\n        return line.start.equals(this.start) && line.end.equals(this.end);\r\n    }\r\n});\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\nfunction ImmediateRenderObject(material) {\r\n    Object3D.call(this);\r\n    this.material = material;\r\n    this.render = function ( /* renderCallback */) { };\r\n}\r\nImmediateRenderObject.prototype = Object.create(Object3D.prototype);\r\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\r\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction VertexNormalsHelper(object, size, hex, linewidth) {\r\n    this.object = object;\r\n    this.size = (size !== undefined) ? size : 1;\r\n    var color = (hex !== undefined) ? hex : 0xff0000;\r\n    var width = (linewidth !== undefined) ? linewidth : 1;\r\n    //\r\n    var nNormals = 0;\r\n    var objGeometry = this.object.geometry;\r\n    if (objGeometry && objGeometry.isGeometry) {\r\n        nNormals = objGeometry.faces.length * 3;\r\n    }\r\n    else if (objGeometry && objGeometry.isBufferGeometry) {\r\n        nNormals = objGeometry.attributes.normal.count;\r\n    }\r\n    //\r\n    var geometry = new BufferGeometry();\r\n    var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\r\n    geometry.addAttribute('position', positions);\r\n    LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: width }));\r\n    //\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n}\r\nVertexNormalsHelper.prototype = Object.create(LineSegments.prototype);\r\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\r\nVertexNormalsHelper.prototype.update = (function () {\r\n    var v1 = new Vector3();\r\n    var v2 = new Vector3();\r\n    var normalMatrix = new Matrix3();\r\n    return function update() {\r\n        var keys = ['a', 'b', 'c'];\r\n        this.object.updateMatrixWorld(true);\r\n        normalMatrix.getNormalMatrix(this.object.matrixWorld);\r\n        var matrixWorld = this.object.matrixWorld;\r\n        var position = this.geometry.attributes.position;\r\n        //\r\n        var objGeometry = this.object.geometry;\r\n        if (objGeometry && objGeometry.isGeometry) {\r\n            var vertices = objGeometry.vertices;\r\n            var faces = objGeometry.faces;\r\n            var idx = 0;\r\n            for (var i = 0, l = faces.length; i < l; i++) {\r\n                var face = faces[i];\r\n                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\r\n                    var vertex = vertices[face[keys[j]]];\r\n                    var normal = face.vertexNormals[j];\r\n                    v1.copy(vertex).applyMatrix4(matrixWorld);\r\n                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\r\n                    position.setXYZ(idx, v1.x, v1.y, v1.z);\r\n                    idx = idx + 1;\r\n                    position.setXYZ(idx, v2.x, v2.y, v2.z);\r\n                    idx = idx + 1;\r\n                }\r\n            }\r\n        }\r\n        else if (objGeometry && objGeometry.isBufferGeometry) {\r\n            var objPos = objGeometry.attributes.position;\r\n            var objNorm = objGeometry.attributes.normal;\r\n            var idx = 0;\r\n            // for simplicity, ignore index and drawcalls, and render every normal\r\n            for (var j = 0, jl = objPos.count; j < jl; j++) {\r\n                v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\r\n                v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\r\n                v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\r\n                position.setXYZ(idx, v1.x, v1.y, v1.z);\r\n                idx = idx + 1;\r\n                position.setXYZ(idx, v2.x, v2.y, v2.z);\r\n                idx = idx + 1;\r\n            }\r\n        }\r\n        position.needsUpdate = true;\r\n    };\r\n}());\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction SpotLightHelper(light, color) {\r\n    Object3D.call(this);\r\n    this.light = light;\r\n    this.light.updateMatrixWorld();\r\n    this.matrix = light.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n    this.color = color;\r\n    var geometry = new BufferGeometry();\r\n    var positions = [\r\n        0, 0, 0, 0, 0, 1,\r\n        0, 0, 0, 1, 0, 1,\r\n        0, 0, 0, -1, 0, 1,\r\n        0, 0, 0, 0, 1, 1,\r\n        0, 0, 0, 0, -1, 1\r\n    ];\r\n    for (var i = 0, j = 1, l = 32; i < l; i++, j++) {\r\n        var p1 = (i / l) * Math.PI * 2;\r\n        var p2 = (j / l) * Math.PI * 2;\r\n        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\r\n    }\r\n    geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));\r\n    var material = new LineBasicMaterial({ fog: false });\r\n    this.cone = new LineSegments(geometry, material);\r\n    this.add(this.cone);\r\n    this.update();\r\n}\r\nSpotLightHelper.prototype = Object.create(Object3D.prototype);\r\nSpotLightHelper.prototype.constructor = SpotLightHelper;\r\nSpotLightHelper.prototype.dispose = function () {\r\n    this.cone.geometry.dispose();\r\n    this.cone.material.dispose();\r\n};\r\nSpotLightHelper.prototype.update = function () {\r\n    var vector = new Vector3();\r\n    return function update() {\r\n        this.light.updateMatrixWorld();\r\n        var coneLength = this.light.distance ? this.light.distance : 1000;\r\n        var coneWidth = coneLength * Math.tan(this.light.angle);\r\n        this.cone.scale.set(coneWidth, coneWidth, coneLength);\r\n        vector.setFromMatrixPosition(this.light.target.matrixWorld);\r\n        this.cone.lookAt(vector);\r\n        if (this.color !== undefined) {\r\n            this.cone.material.color.set(this.color);\r\n        }\r\n        else {\r\n            this.cone.material.color.copy(this.light.color);\r\n        }\r\n    };\r\n}();\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction getBoneList(object) {\r\n    var boneList = [];\r\n    if (object && object.isBone) {\r\n        boneList.push(object);\r\n    }\r\n    for (var i = 0; i < object.children.length; i++) {\r\n        boneList.push.apply(boneList, getBoneList(object.children[i]));\r\n    }\r\n    return boneList;\r\n}\r\nfunction SkeletonHelper(object) {\r\n    var bones = getBoneList(object);\r\n    var geometry = new BufferGeometry();\r\n    var vertices = [];\r\n    var colors = [];\r\n    var color1 = new Color(0, 0, 1);\r\n    var color2 = new Color(0, 1, 0);\r\n    for (var i = 0; i < bones.length; i++) {\r\n        var bone = bones[i];\r\n        if (bone.parent && bone.parent.isBone) {\r\n            vertices.push(0, 0, 0);\r\n            vertices.push(0, 0, 0);\r\n            colors.push(color1.r, color1.g, color1.b);\r\n            colors.push(color2.r, color2.g, color2.b);\r\n        }\r\n    }\r\n    geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\r\n    var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });\r\n    LineSegments.call(this, geometry, material);\r\n    this.root = object;\r\n    this.bones = bones;\r\n    this.matrix = object.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n}\r\nSkeletonHelper.prototype = Object.create(LineSegments.prototype);\r\nSkeletonHelper.prototype.constructor = SkeletonHelper;\r\nSkeletonHelper.prototype.updateMatrixWorld = function () {\r\n    var vector = new Vector3();\r\n    var boneMatrix = new Matrix4();\r\n    var matrixWorldInv = new Matrix4();\r\n    return function updateMatrixWorld(force) {\r\n        var bones = this.bones;\r\n        var geometry = this.geometry;\r\n        var position = geometry.getAttribute('position');\r\n        matrixWorldInv.getInverse(this.root.matrixWorld);\r\n        for (var i = 0, j = 0; i < bones.length; i++) {\r\n            var bone = bones[i];\r\n            if (bone.parent && bone.parent.isBone) {\r\n                boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);\r\n                vector.setFromMatrixPosition(boneMatrix);\r\n                position.setXYZ(j, vector.x, vector.y, vector.z);\r\n                boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);\r\n                vector.setFromMatrixPosition(boneMatrix);\r\n                position.setXYZ(j + 1, vector.x, vector.y, vector.z);\r\n                j += 2;\r\n            }\r\n        }\r\n        geometry.getAttribute('position').needsUpdate = true;\r\n        Object3D.prototype.updateMatrixWorld.call(this, force);\r\n    };\r\n}();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction PointLightHelper(light, sphereSize, color) {\r\n    this.light = light;\r\n    this.light.updateMatrixWorld();\r\n    this.color = color;\r\n    var geometry = new SphereBufferGeometry(sphereSize, 4, 2);\r\n    var material = new MeshBasicMaterial({ wireframe: true, fog: false });\r\n    Mesh.call(this, geometry, material);\r\n    this.matrix = this.light.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n    /*\r\n    var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\r\n    var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n    var d = light.distance;\r\n\r\n    if ( d === 0.0 ) {\r\n\r\n        this.lightDistance.visible = false;\r\n\r\n    } else {\r\n\r\n        this.lightDistance.scale.set( d, d, d );\r\n\r\n    }\r\n\r\n    this.add( this.lightDistance );\r\n    */\r\n}\r\nPointLightHelper.prototype = Object.create(Mesh.prototype);\r\nPointLightHelper.prototype.constructor = PointLightHelper;\r\nPointLightHelper.prototype.dispose = function () {\r\n    this.geometry.dispose();\r\n    this.material.dispose();\r\n};\r\nPointLightHelper.prototype.update = function () {\r\n    if (this.color !== undefined) {\r\n        this.material.color.set(this.color);\r\n    }\r\n    else {\r\n        this.material.color.copy(this.light.color);\r\n    }\r\n    /*\r\n    var d = this.light.distance;\r\n\r\n    if ( d === 0.0 ) {\r\n\r\n        this.lightDistance.visible = false;\r\n\r\n    } else {\r\n\r\n        this.lightDistance.visible = true;\r\n        this.lightDistance.scale.set( d, d, d );\r\n\r\n    }\r\n    */\r\n};\r\n/**\r\n * @author abelnation / http://github.com/abelnation\r\n * @author Mugen87 / http://github.com/Mugen87\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n *  This helper must be added as a child of the light\r\n */\r\nfunction RectAreaLightHelper(light, color) {\r\n    this.type = 'RectAreaLightHelper';\r\n    this.light = light;\r\n    this.color = color; // optional hardwired color for the helper\r\n    var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));\r\n    geometry.computeBoundingSphere();\r\n    var material = new LineBasicMaterial({ fog: false });\r\n    Line.call(this, geometry, material);\r\n    //\r\n    var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];\r\n    var geometry2 = new BufferGeometry();\r\n    geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));\r\n    geometry2.computeBoundingSphere();\r\n    this.add(new Mesh(geometry2, new MeshBasicMaterial({ side: BackSide, fog: false })));\r\n    this.update();\r\n}\r\nRectAreaLightHelper.prototype = Object.create(Line.prototype);\r\nRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\r\nRectAreaLightHelper.prototype.update = function () {\r\n    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);\r\n    if (this.color !== undefined) {\r\n        this.material.color.set(this.color);\r\n        this.children[0].material.color.set(this.color);\r\n    }\r\n    else {\r\n        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\r\n        // prevent hue shift\r\n        var c = this.material.color;\r\n        var max = Math.max(c.r, c.g, c.b);\r\n        if (max > 1)\r\n            c.multiplyScalar(1 / max);\r\n        this.children[0].material.color.copy(this.material.color);\r\n    }\r\n};\r\nRectAreaLightHelper.prototype.dispose = function () {\r\n    this.geometry.dispose();\r\n    this.material.dispose();\r\n    this.children[0].geometry.dispose();\r\n    this.children[0].material.dispose();\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\nfunction HemisphereLightHelper(light, size, color) {\r\n    Object3D.call(this);\r\n    this.light = light;\r\n    this.light.updateMatrixWorld();\r\n    this.matrix = light.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n    this.color = color;\r\n    var geometry = new OctahedronBufferGeometry(size);\r\n    geometry.rotateY(Math.PI * 0.5);\r\n    this.material = new MeshBasicMaterial({ wireframe: true, fog: false });\r\n    if (this.color === undefined)\r\n        this.material.vertexColors = VertexColors;\r\n    var position = geometry.getAttribute('position');\r\n    var colors = new Float32Array(position.count * 3);\r\n    geometry.addAttribute('color', new BufferAttribute(colors, 3));\r\n    this.add(new Mesh(geometry, this.material));\r\n    this.update();\r\n}\r\nHemisphereLightHelper.prototype = Object.create(Object3D.prototype);\r\nHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\r\nHemisphereLightHelper.prototype.dispose = function () {\r\n    this.children[0].geometry.dispose();\r\n    this.children[0].material.dispose();\r\n};\r\nHemisphereLightHelper.prototype.update = function () {\r\n    var vector = new Vector3();\r\n    var color1 = new Color();\r\n    var color2 = new Color();\r\n    return function update() {\r\n        var mesh = this.children[0];\r\n        if (this.color !== undefined) {\r\n            this.material.color.set(this.color);\r\n        }\r\n        else {\r\n            var colors = mesh.geometry.getAttribute('color');\r\n            color1.copy(this.light.color);\r\n            color2.copy(this.light.groundColor);\r\n            for (var i = 0, l = colors.count; i < l; i++) {\r\n                var color = (i < (l / 2)) ? color1 : color2;\r\n                colors.setXYZ(i, color.r, color.g, color.b);\r\n            }\r\n            colors.needsUpdate = true;\r\n        }\r\n        mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());\r\n    };\r\n}();\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction LightProbeHelper(lightProbe, size) {\r\n    this.lightProbe = lightProbe;\r\n    this.size = size;\r\n    var defines = {};\r\n    defines['GAMMA_OUTPUT'] = \"\";\r\n    // material\r\n    var material = new ShaderMaterial({\r\n        defines: defines,\r\n        uniforms: {\r\n            sh: { value: this.lightProbe.sh.coefficients },\r\n            intensity: { value: this.lightProbe.intensity }\r\n        },\r\n        vertexShader: [\r\n            'varying vec3 vNormal;',\r\n            'void main() {',\r\n            '\tvNormal = normalize( normalMatrix * normal );',\r\n            '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}',\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#define RECIPROCAL_PI 0.318309886',\r\n            'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',\r\n            '\t// matrix is assumed to be orthogonal',\r\n            '\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',\r\n            '}',\r\n            'vec3 linearToOutput( in vec3 a ) {',\r\n            '\t#ifdef GAMMA_OUTPUT',\r\n            '\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );',\r\n            '\t#else',\r\n            '\t\treturn a;',\r\n            '\t#endif',\r\n            '}',\r\n            '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',\r\n            'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',\r\n            '\t// normal is assumed to have unit length',\r\n            '\tfloat x = normal.x, y = normal.y, z = normal.z;',\r\n            '\t// band 0',\r\n            '\tvec3 result = shCoefficients[ 0 ] * 0.886227;',\r\n            '\t// band 1',\r\n            '\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',\r\n            '\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',\r\n            '\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',\r\n            '\t// band 2',\r\n            '\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',\r\n            '\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',\r\n            '\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',\r\n            '\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',\r\n            '\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',\r\n            '\treturn result;',\r\n            '}',\r\n            'uniform vec3 sh[ 9 ]; // sh coefficients',\r\n            'uniform float intensity; // light probe intensity',\r\n            'varying vec3 vNormal;',\r\n            'void main() {',\r\n            '\tvec3 normal = normalize( vNormal );',\r\n            '\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',\r\n            '\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );',\r\n            '\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',\r\n            '\toutgoingLight = linearToOutput( outgoingLight );',\r\n            '\tgl_FragColor = vec4( outgoingLight, 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    });\r\n    var geometry = new SphereBufferGeometry(1, 32, 16);\r\n    Mesh.call(this, geometry, material);\r\n    this.onBeforeRender();\r\n}\r\nLightProbeHelper.prototype = Object.create(Mesh.prototype);\r\nLightProbeHelper.prototype.constructor = LightProbeHelper;\r\nLightProbeHelper.prototype.dispose = function () {\r\n    this.geometry.dispose();\r\n    this.material.dispose();\r\n};\r\nLightProbeHelper.prototype.onBeforeRender = function () {\r\n    return function update() {\r\n        this.position.copy(this.lightProbe.position);\r\n        this.scale.set(1, 1, 1).multiplyScalar(this.size);\r\n        this.material.uniforms.intensity.value = this.lightProbe.intensity;\r\n    };\r\n}();\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction GridHelper(size, divisions, color1, color2) {\r\n    size = size || 10;\r\n    divisions = divisions || 10;\r\n    color1 = new Color(color1 !== undefined ? color1 : 0x444444);\r\n    color2 = new Color(color2 !== undefined ? color2 : 0x888888);\r\n    var center = divisions / 2;\r\n    var step = size / divisions;\r\n    var halfSize = size / 2;\r\n    var vertices = [], colors = [];\r\n    for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\r\n        vertices.push(-halfSize, 0, k, halfSize, 0, k);\r\n        vertices.push(k, 0, -halfSize, k, 0, halfSize);\r\n        var color = i === center ? color1 : color2;\r\n        color.toArray(colors, j);\r\n        j += 3;\r\n        color.toArray(colors, j);\r\n        j += 3;\r\n        color.toArray(colors, j);\r\n        j += 3;\r\n        color.toArray(colors, j);\r\n        j += 3;\r\n    }\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\r\n    var material = new LineBasicMaterial({ vertexColors: VertexColors });\r\n    LineSegments.call(this, geometry, material);\r\n}\r\nGridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {\r\n    constructor: GridHelper,\r\n    copy: function (source) {\r\n        LineSegments.prototype.copy.call(this, source);\r\n        this.geometry.copy(source.geometry);\r\n        this.material.copy(source.material);\r\n        return this;\r\n    },\r\n    clone: function () {\r\n        return new this.constructor().copy(this);\r\n    }\r\n});\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / http://github.com/Mugen87\r\n * @author Hectate / http://www.github.com/Hectate\r\n */\r\nfunction PolarGridHelper(radius, radials, circles, divisions, color1, color2) {\r\n    radius = radius || 10;\r\n    radials = radials || 16;\r\n    circles = circles || 8;\r\n    divisions = divisions || 64;\r\n    color1 = new Color(color1 !== undefined ? color1 : 0x444444);\r\n    color2 = new Color(color2 !== undefined ? color2 : 0x888888);\r\n    var vertices = [];\r\n    var colors = [];\r\n    var x, z;\r\n    var v, i, j, r, color;\r\n    // create the radials\r\n    for (i = 0; i <= radials; i++) {\r\n        v = (i / radials) * (Math.PI * 2);\r\n        x = Math.sin(v) * radius;\r\n        z = Math.cos(v) * radius;\r\n        vertices.push(0, 0, 0);\r\n        vertices.push(x, 0, z);\r\n        color = (i & 1) ? color1 : color2;\r\n        colors.push(color.r, color.g, color.b);\r\n        colors.push(color.r, color.g, color.b);\r\n    }\r\n    // create the circles\r\n    for (i = 0; i <= circles; i++) {\r\n        color = (i & 1) ? color1 : color2;\r\n        r = radius - (radius / circles * i);\r\n        for (j = 0; j < divisions; j++) {\r\n            // first vertex\r\n            v = (j / divisions) * (Math.PI * 2);\r\n            x = Math.sin(v) * r;\r\n            z = Math.cos(v) * r;\r\n            vertices.push(x, 0, z);\r\n            colors.push(color.r, color.g, color.b);\r\n            // second vertex\r\n            v = ((j + 1) / divisions) * (Math.PI * 2);\r\n            x = Math.sin(v) * r;\r\n            z = Math.cos(v) * r;\r\n            vertices.push(x, 0, z);\r\n            colors.push(color.r, color.g, color.b);\r\n        }\r\n    }\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\r\n    var material = new LineBasicMaterial({ vertexColors: VertexColors });\r\n    LineSegments.call(this, geometry, material);\r\n}\r\nPolarGridHelper.prototype = Object.create(LineSegments.prototype);\r\nPolarGridHelper.prototype.constructor = PolarGridHelper;\r\n/**\r\n * @author Mugen87 / http://github.com/Mugen87\r\n */\r\nfunction PositionalAudioHelper(audio, range, divisionsInnerAngle, divisionsOuterAngle) {\r\n    this.audio = audio;\r\n    this.range = range || 1;\r\n    this.divisionsInnerAngle = divisionsInnerAngle || 16;\r\n    this.divisionsOuterAngle = divisionsOuterAngle || 2;\r\n    var geometry = new BufferGeometry();\r\n    var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;\r\n    var positions = new Float32Array((divisions * 3 + 3) * 3);\r\n    geometry.addAttribute('position', new BufferAttribute(positions, 3));\r\n    var materialInnerAngle = new LineBasicMaterial({ color: 0x00ff00 });\r\n    var materialOuterAngle = new LineBasicMaterial({ color: 0xffff00 });\r\n    Line.call(this, geometry, [materialOuterAngle, materialInnerAngle]);\r\n    this.update();\r\n}\r\nPositionalAudioHelper.prototype = Object.create(Line.prototype);\r\nPositionalAudioHelper.prototype.constructor = PositionalAudioHelper;\r\nPositionalAudioHelper.prototype.update = function () {\r\n    var audio = this.audio;\r\n    var range = this.range;\r\n    var divisionsInnerAngle = this.divisionsInnerAngle;\r\n    var divisionsOuterAngle = this.divisionsOuterAngle;\r\n    var coneInnerAngle = _Math.degToRad(audio.panner.coneInnerAngle);\r\n    var coneOuterAngle = _Math.degToRad(audio.panner.coneOuterAngle);\r\n    var halfConeInnerAngle = coneInnerAngle / 2;\r\n    var halfConeOuterAngle = coneOuterAngle / 2;\r\n    var start = 0;\r\n    var count = 0;\r\n    var i, stride;\r\n    var geometry = this.geometry;\r\n    var positionAttribute = geometry.attributes.position;\r\n    geometry.clearGroups();\r\n    //\r\n    function generateSegment(from, to, divisions, materialIndex) {\r\n        var step = (to - from) / divisions;\r\n        positionAttribute.setXYZ(start, 0, 0, 0);\r\n        count++;\r\n        for (i = from; i < to; i += step) {\r\n            stride = start + count;\r\n            positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);\r\n            positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);\r\n            positionAttribute.setXYZ(stride + 2, 0, 0, 0);\r\n            count += 3;\r\n        }\r\n        geometry.addGroup(start, count, materialIndex);\r\n        start += count;\r\n        count = 0;\r\n    }\r\n    //\r\n    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);\r\n    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);\r\n    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);\r\n    //\r\n    positionAttribute.needsUpdate = true;\r\n    if (coneInnerAngle === coneOuterAngle)\r\n        this.material[0].visible = false;\r\n};\r\nPositionalAudioHelper.prototype.dispose = function () {\r\n    this.geometry.dispose();\r\n    this.material[0].dispose();\r\n    this.material[1].dispose();\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction FaceNormalsHelper(object, size, hex, linewidth) {\r\n    // FaceNormalsHelper only supports THREE.Geometry\r\n    this.object = object;\r\n    this.size = (size !== undefined) ? size : 1;\r\n    var color = (hex !== undefined) ? hex : 0xffff00;\r\n    var width = (linewidth !== undefined) ? linewidth : 1;\r\n    //\r\n    var nNormals = 0;\r\n    var objGeometry = this.object.geometry;\r\n    if (objGeometry && objGeometry.isGeometry) {\r\n        nNormals = objGeometry.faces.length;\r\n    }\r\n    else {\r\n        console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');\r\n    }\r\n    //\r\n    var geometry = new BufferGeometry();\r\n    var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\r\n    geometry.addAttribute('position', positions);\r\n    LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: width }));\r\n    //\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n}\r\nFaceNormalsHelper.prototype = Object.create(LineSegments.prototype);\r\nFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\r\nFaceNormalsHelper.prototype.update = (function () {\r\n    var v1 = new Vector3();\r\n    var v2 = new Vector3();\r\n    var normalMatrix = new Matrix3();\r\n    return function update() {\r\n        this.object.updateMatrixWorld(true);\r\n        normalMatrix.getNormalMatrix(this.object.matrixWorld);\r\n        var matrixWorld = this.object.matrixWorld;\r\n        var position = this.geometry.attributes.position;\r\n        //\r\n        var objGeometry = this.object.geometry;\r\n        var vertices = objGeometry.vertices;\r\n        var faces = objGeometry.faces;\r\n        var idx = 0;\r\n        for (var i = 0, l = faces.length; i < l; i++) {\r\n            var face = faces[i];\r\n            var normal = face.normal;\r\n            v1.copy(vertices[face.a])\r\n                .add(vertices[face.b])\r\n                .add(vertices[face.c])\r\n                .divideScalar(3)\r\n                .applyMatrix4(matrixWorld);\r\n            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\r\n            position.setXYZ(idx, v1.x, v1.y, v1.z);\r\n            idx = idx + 1;\r\n            position.setXYZ(idx, v2.x, v2.y, v2.z);\r\n            idx = idx + 1;\r\n        }\r\n        position.needsUpdate = true;\r\n    };\r\n}());\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction DirectionalLightHelper(light, size, color) {\r\n    Object3D.call(this);\r\n    this.light = light;\r\n    this.light.updateMatrixWorld();\r\n    this.matrix = light.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n    this.color = color;\r\n    if (size === undefined)\r\n        size = 1;\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute([\r\n        -size, size, 0,\r\n        size, size, 0,\r\n        size, -size, 0,\r\n        -size, -size, 0,\r\n        -size, size, 0\r\n    ], 3));\r\n    var material = new LineBasicMaterial({ fog: false });\r\n    this.lightPlane = new Line(geometry, material);\r\n    this.add(this.lightPlane);\r\n    geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\r\n    this.targetLine = new Line(geometry, material);\r\n    this.add(this.targetLine);\r\n    this.update();\r\n}\r\nDirectionalLightHelper.prototype = Object.create(Object3D.prototype);\r\nDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\r\nDirectionalLightHelper.prototype.dispose = function () {\r\n    this.lightPlane.geometry.dispose();\r\n    this.lightPlane.material.dispose();\r\n    this.targetLine.geometry.dispose();\r\n    this.targetLine.material.dispose();\r\n};\r\nDirectionalLightHelper.prototype.update = function () {\r\n    var v1 = new Vector3();\r\n    var v2 = new Vector3();\r\n    var v3 = new Vector3();\r\n    return function update() {\r\n        v1.setFromMatrixPosition(this.light.matrixWorld);\r\n        v2.setFromMatrixPosition(this.light.target.matrixWorld);\r\n        v3.subVectors(v2, v1);\r\n        this.lightPlane.lookAt(v2);\r\n        if (this.color !== undefined) {\r\n            this.lightPlane.material.color.set(this.color);\r\n            this.targetLine.material.color.set(this.color);\r\n        }\r\n        else {\r\n            this.lightPlane.material.color.copy(this.light.color);\r\n            this.targetLine.material.color.copy(this.light.color);\r\n        }\r\n        this.targetLine.lookAt(v2);\r\n        this.targetLine.scale.z = v3.length();\r\n    };\r\n}();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\nfunction CameraHelper(camera) {\r\n    var geometry = new BufferGeometry();\r\n    var material = new LineBasicMaterial({ color: 0xffffff, vertexColors: FaceColors });\r\n    var vertices = [];\r\n    var colors = [];\r\n    var pointMap = {};\r\n    // colors\r\n    var colorFrustum = new Color(0xffaa00);\r\n    var colorCone = new Color(0xff0000);\r\n    var colorUp = new Color(0x00aaff);\r\n    var colorTarget = new Color(0xffffff);\r\n    var colorCross = new Color(0x333333);\r\n    // near\r\n    addLine('n1', 'n2', colorFrustum);\r\n    addLine('n2', 'n4', colorFrustum);\r\n    addLine('n4', 'n3', colorFrustum);\r\n    addLine('n3', 'n1', colorFrustum);\r\n    // far\r\n    addLine('f1', 'f2', colorFrustum);\r\n    addLine('f2', 'f4', colorFrustum);\r\n    addLine('f4', 'f3', colorFrustum);\r\n    addLine('f3', 'f1', colorFrustum);\r\n    // sides\r\n    addLine('n1', 'f1', colorFrustum);\r\n    addLine('n2', 'f2', colorFrustum);\r\n    addLine('n3', 'f3', colorFrustum);\r\n    addLine('n4', 'f4', colorFrustum);\r\n    // cone\r\n    addLine('p', 'n1', colorCone);\r\n    addLine('p', 'n2', colorCone);\r\n    addLine('p', 'n3', colorCone);\r\n    addLine('p', 'n4', colorCone);\r\n    // up\r\n    addLine('u1', 'u2', colorUp);\r\n    addLine('u2', 'u3', colorUp);\r\n    addLine('u3', 'u1', colorUp);\r\n    // target\r\n    addLine('c', 't', colorTarget);\r\n    addLine('p', 'c', colorCross);\r\n    // cross\r\n    addLine('cn1', 'cn2', colorCross);\r\n    addLine('cn3', 'cn4', colorCross);\r\n    addLine('cf1', 'cf2', colorCross);\r\n    addLine('cf3', 'cf4', colorCross);\r\n    function addLine(a, b, color) {\r\n        addPoint(a, color);\r\n        addPoint(b, color);\r\n    }\r\n    function addPoint(id, color) {\r\n        vertices.push(0, 0, 0);\r\n        colors.push(color.r, color.g, color.b);\r\n        if (pointMap[id] === undefined) {\r\n            pointMap[id] = [];\r\n        }\r\n        pointMap[id].push((vertices.length / 3) - 1);\r\n    }\r\n    geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\r\n    LineSegments.call(this, geometry, material);\r\n    this.camera = camera;\r\n    if (this.camera.updateProjectionMatrix)\r\n        this.camera.updateProjectionMatrix();\r\n    this.matrix = camera.matrixWorld;\r\n    this.matrixAutoUpdate = false;\r\n    this.pointMap = pointMap;\r\n    this.update();\r\n}\r\nCameraHelper.prototype = Object.create(LineSegments.prototype);\r\nCameraHelper.prototype.constructor = CameraHelper;\r\nCameraHelper.prototype.update = function () {\r\n    var geometry, pointMap;\r\n    var vector = new Vector3();\r\n    var camera = new Camera();\r\n    function setPoint(point, x, y, z) {\r\n        vector.set(x, y, z).unproject(camera);\r\n        var points = pointMap[point];\r\n        if (points !== undefined) {\r\n            var position = geometry.getAttribute('position');\r\n            for (var i = 0, l = points.length; i < l; i++) {\r\n                position.setXYZ(points[i], vector.x, vector.y, vector.z);\r\n            }\r\n        }\r\n    }\r\n    return function update() {\r\n        geometry = this.geometry;\r\n        pointMap = this.pointMap;\r\n        var w = 1, h = 1;\r\n        // we need just camera projection matrix inverse\r\n        // world matrix must be identity\r\n        camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);\r\n        // center / target\r\n        setPoint('c', 0, 0, -1);\r\n        setPoint('t', 0, 0, 1);\r\n        // near\r\n        setPoint('n1', -w, -h, -1);\r\n        setPoint('n2', w, -h, -1);\r\n        setPoint('n3', -w, h, -1);\r\n        setPoint('n4', w, h, -1);\r\n        // far\r\n        setPoint('f1', -w, -h, 1);\r\n        setPoint('f2', w, -h, 1);\r\n        setPoint('f3', -w, h, 1);\r\n        setPoint('f4', w, h, 1);\r\n        // up\r\n        setPoint('u1', w * 0.7, h * 1.1, -1);\r\n        setPoint('u2', -w * 0.7, h * 1.1, -1);\r\n        setPoint('u3', 0, h * 2, -1);\r\n        // cross\r\n        setPoint('cf1', -w, 0, 1);\r\n        setPoint('cf2', w, 0, 1);\r\n        setPoint('cf3', 0, -h, 1);\r\n        setPoint('cf4', 0, h, 1);\r\n        setPoint('cn1', -w, 0, -1);\r\n        setPoint('cn2', w, 0, -1);\r\n        setPoint('cn3', 0, -h, -1);\r\n        setPoint('cn4', 0, h, -1);\r\n        geometry.getAttribute('position').needsUpdate = true;\r\n    };\r\n}();\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / http://github.com/Mugen87\r\n */\r\nfunction BoxHelper(object, color) {\r\n    this.object = object;\r\n    if (color === undefined)\r\n        color = 0xffff00;\r\n    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\r\n    var positions = new Float32Array(8 * 3);\r\n    var geometry = new BufferGeometry();\r\n    geometry.setIndex(new BufferAttribute(indices, 1));\r\n    geometry.addAttribute('position', new BufferAttribute(positions, 3));\r\n    LineSegments.call(this, geometry, new LineBasicMaterial({ color: color }));\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n}\r\nBoxHelper.prototype = Object.create(LineSegments.prototype);\r\nBoxHelper.prototype.constructor = BoxHelper;\r\nBoxHelper.prototype.update = (function () {\r\n    var box = new Box3();\r\n    return function update(object) {\r\n        if (object !== undefined) {\r\n            console.warn('THREE.BoxHelper: .update() has no longer arguments.');\r\n        }\r\n        if (this.object !== undefined) {\r\n            box.setFromObject(this.object);\r\n        }\r\n        if (box.isEmpty())\r\n            return;\r\n        var min = box.min;\r\n        var max = box.max;\r\n        /*\r\n          5____4\r\n        1/___0/|\r\n        | 6__|_7\r\n        2/___3/\r\n\r\n        0: max.x, max.y, max.z\r\n        1: min.x, max.y, max.z\r\n        2: min.x, min.y, max.z\r\n        3: max.x, min.y, max.z\r\n        4: max.x, max.y, min.z\r\n        5: min.x, max.y, min.z\r\n        6: min.x, min.y, min.z\r\n        7: max.x, min.y, min.z\r\n        */\r\n        var position = this.geometry.attributes.position;\r\n        var array = position.array;\r\n        array[0] = max.x;\r\n        array[1] = max.y;\r\n        array[2] = max.z;\r\n        array[3] = min.x;\r\n        array[4] = max.y;\r\n        array[5] = max.z;\r\n        array[6] = min.x;\r\n        array[7] = min.y;\r\n        array[8] = max.z;\r\n        array[9] = max.x;\r\n        array[10] = min.y;\r\n        array[11] = max.z;\r\n        array[12] = max.x;\r\n        array[13] = max.y;\r\n        array[14] = min.z;\r\n        array[15] = min.x;\r\n        array[16] = max.y;\r\n        array[17] = min.z;\r\n        array[18] = min.x;\r\n        array[19] = min.y;\r\n        array[20] = min.z;\r\n        array[21] = max.x;\r\n        array[22] = min.y;\r\n        array[23] = min.z;\r\n        position.needsUpdate = true;\r\n        this.geometry.computeBoundingSphere();\r\n    };\r\n})();\r\nBoxHelper.prototype.setFromObject = function (object) {\r\n    this.object = object;\r\n    this.update();\r\n    return this;\r\n};\r\nBoxHelper.prototype.copy = function (source) {\r\n    LineSegments.prototype.copy.call(this, source);\r\n    this.object = source.object;\r\n    return this;\r\n};\r\nBoxHelper.prototype.clone = function () {\r\n    return new this.constructor().copy(this);\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction Box3Helper(box, color) {\r\n    this.type = 'Box3Helper';\r\n    this.box = box;\r\n    color = color || 0xffff00;\r\n    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\r\n    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\r\n    var geometry = new BufferGeometry();\r\n    geometry.setIndex(new BufferAttribute(indices, 1));\r\n    geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));\r\n    LineSegments.call(this, geometry, new LineBasicMaterial({ color: color }));\r\n    this.geometry.computeBoundingSphere();\r\n}\r\nBox3Helper.prototype = Object.create(LineSegments.prototype);\r\nBox3Helper.prototype.constructor = Box3Helper;\r\nBox3Helper.prototype.updateMatrixWorld = function (force) {\r\n    var box = this.box;\r\n    if (box.isEmpty())\r\n        return;\r\n    box.getCenter(this.position);\r\n    box.getSize(this.scale);\r\n    this.scale.multiplyScalar(0.5);\r\n    Object3D.prototype.updateMatrixWorld.call(this, force);\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\nfunction PlaneHelper(plane, size, hex) {\r\n    this.type = 'PlaneHelper';\r\n    this.plane = plane;\r\n    this.size = (size === undefined) ? 1 : size;\r\n    var color = (hex !== undefined) ? hex : 0xffff00;\r\n    var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));\r\n    geometry.computeBoundingSphere();\r\n    Line.call(this, geometry, new LineBasicMaterial({ color: color }));\r\n    //\r\n    var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\r\n    var geometry2 = new BufferGeometry();\r\n    geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));\r\n    geometry2.computeBoundingSphere();\r\n    this.add(new Mesh(geometry2, new MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false })));\r\n}\r\nPlaneHelper.prototype = Object.create(Line.prototype);\r\nPlaneHelper.prototype.constructor = PlaneHelper;\r\nPlaneHelper.prototype.updateMatrixWorld = function (force) {\r\n    var scale = -this.plane.constant;\r\n    if (Math.abs(scale) < 1e-8)\r\n        scale = 1e-8; // sign does not matter\r\n    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);\r\n    this.children[0].material.side = (scale < 0) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\r\n    this.lookAt(this.plane.normal);\r\n    Object3D.prototype.updateMatrixWorld.call(this, force);\r\n};\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\nvar lineGeometry, coneGeometry;\r\nfunction ArrowHelper(dir, origin, length, color, headLength, headWidth) {\r\n    // dir is assumed to be normalized\r\n    Object3D.call(this);\r\n    if (dir === undefined)\r\n        dir = new Vector3(0, 0, 1);\r\n    if (origin === undefined)\r\n        origin = new Vector3(0, 0, 0);\r\n    if (length === undefined)\r\n        length = 1;\r\n    if (color === undefined)\r\n        color = 0xffff00;\r\n    if (headLength === undefined)\r\n        headLength = 0.2 * length;\r\n    if (headWidth === undefined)\r\n        headWidth = 0.2 * headLength;\r\n    if (lineGeometry === undefined) {\r\n        lineGeometry = new BufferGeometry();\r\n        lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\r\n        coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);\r\n        coneGeometry.translate(0, -0.5, 0);\r\n    }\r\n    this.position.copy(origin);\r\n    this.line = new Line(lineGeometry, new LineBasicMaterial({ color: color }));\r\n    this.line.matrixAutoUpdate = false;\r\n    this.add(this.line);\r\n    this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color: color }));\r\n    this.cone.matrixAutoUpdate = false;\r\n    this.add(this.cone);\r\n    this.setDirection(dir);\r\n    this.setLength(length, headLength, headWidth);\r\n}\r\nArrowHelper.prototype = Object.create(Object3D.prototype);\r\nArrowHelper.prototype.constructor = ArrowHelper;\r\nArrowHelper.prototype.setDirection = (function () {\r\n    var axis = new Vector3();\r\n    var radians;\r\n    return function setDirection(dir) {\r\n        // dir is assumed to be normalized\r\n        if (dir.y > 0.99999) {\r\n            this.quaternion.set(0, 0, 0, 1);\r\n        }\r\n        else if (dir.y < -0.99999) {\r\n            this.quaternion.set(1, 0, 0, 0);\r\n        }\r\n        else {\r\n            axis.set(dir.z, 0, -dir.x).normalize();\r\n            radians = Math.acos(dir.y);\r\n            this.quaternion.setFromAxisAngle(axis, radians);\r\n        }\r\n    };\r\n}());\r\nArrowHelper.prototype.setLength = function (length, headLength, headWidth) {\r\n    if (headLength === undefined)\r\n        headLength = 0.2 * length;\r\n    if (headWidth === undefined)\r\n        headWidth = 0.2 * headLength;\r\n    this.line.scale.set(1, Math.max(0, length - headLength), 1);\r\n    this.line.updateMatrix();\r\n    this.cone.scale.set(headWidth, headLength, headWidth);\r\n    this.cone.position.y = length;\r\n    this.cone.updateMatrix();\r\n};\r\nArrowHelper.prototype.setColor = function (color) {\r\n    this.line.material.color.set(color);\r\n    this.cone.material.color.set(color);\r\n};\r\nArrowHelper.prototype.copy = function (source) {\r\n    Object3D.prototype.copy.call(this, source, false);\r\n    this.line.copy(source.line);\r\n    this.cone.copy(source.cone);\r\n    return this;\r\n};\r\nArrowHelper.prototype.clone = function () {\r\n    return new this.constructor().copy(this);\r\n};\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction AxesHelper(size) {\r\n    size = size || 1;\r\n    var vertices = [\r\n        0, 0, 0, size, 0, 0,\r\n        0, 0, 0, 0, size, 0,\r\n        0, 0, 0, 0, 0, size\r\n    ];\r\n    var colors = [\r\n        1, 0, 0, 1, 0.6, 0,\r\n        0, 1, 0, 0.6, 1, 0,\r\n        0, 0, 1, 0, 0.6, 1\r\n    ];\r\n    var geometry = new BufferGeometry();\r\n    geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\r\n    var material = new LineBasicMaterial({ vertexColors: VertexColors });\r\n    LineSegments.call(this, geometry, material);\r\n}\r\nAxesHelper.prototype = Object.create(LineSegments.prototype);\r\nAxesHelper.prototype.constructor = AxesHelper;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\nfunction Face4(a, b, c, d, normal, color, materialIndex) {\r\n    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');\r\n    return new Face3(a, b, c, normal, color, materialIndex);\r\n}\r\nvar LineStrip = 0;\r\nvar LinePieces = 1;\r\nfunction MeshFaceMaterial(materials) {\r\n    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');\r\n    return materials;\r\n}\r\nfunction MultiMaterial(materials) {\r\n    if (materials === undefined)\r\n        materials = [];\r\n    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');\r\n    materials.isMultiMaterial = true;\r\n    materials.materials = materials;\r\n    materials.clone = function () {\r\n        return materials.slice();\r\n    };\r\n    return materials;\r\n}\r\nfunction PointCloud(geometry, material) {\r\n    console.warn('THREE.PointCloud has been renamed to THREE.Points.');\r\n    return new Points(geometry, material);\r\n}\r\nfunction Particle(material) {\r\n    console.warn('THREE.Particle has been renamed to THREE.Sprite.');\r\n    return new Sprite(material);\r\n}\r\nfunction ParticleSystem(geometry, material) {\r\n    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\r\n    return new Points(geometry, material);\r\n}\r\nfunction PointCloudMaterial(parameters) {\r\n    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\r\n    return new PointsMaterial(parameters);\r\n}\r\nfunction ParticleBasicMaterial(parameters) {\r\n    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\r\n    return new PointsMaterial(parameters);\r\n}\r\nfunction ParticleSystemMaterial(parameters) {\r\n    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\r\n    return new PointsMaterial(parameters);\r\n}\r\nfunction Vertex(x, y, z) {\r\n    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');\r\n    return new Vector3(x, y, z);\r\n}\r\n//\r\nfunction DynamicBufferAttribute(array, itemSize) {\r\n    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');\r\n    return new BufferAttribute(array, itemSize).setDynamic(true);\r\n}\r\nfunction Int8Attribute(array, itemSize) {\r\n    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');\r\n    return new Int8BufferAttribute(array, itemSize);\r\n}\r\nfunction Uint8Attribute(array, itemSize) {\r\n    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');\r\n    return new Uint8BufferAttribute(array, itemSize);\r\n}\r\nfunction Uint8ClampedAttribute(array, itemSize) {\r\n    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');\r\n    return new Uint8ClampedBufferAttribute(array, itemSize);\r\n}\r\nfunction Int16Attribute(array, itemSize) {\r\n    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');\r\n    return new Int16BufferAttribute(array, itemSize);\r\n}\r\nfunction Uint16Attribute(array, itemSize) {\r\n    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');\r\n    return new Uint16BufferAttribute(array, itemSize);\r\n}\r\nfunction Int32Attribute(array, itemSize) {\r\n    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');\r\n    return new Int32BufferAttribute(array, itemSize);\r\n}\r\nfunction Uint32Attribute(array, itemSize) {\r\n    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');\r\n    return new Uint32BufferAttribute(array, itemSize);\r\n}\r\nfunction Float32Attribute(array, itemSize) {\r\n    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');\r\n    return new Float32BufferAttribute(array, itemSize);\r\n}\r\nfunction Float64Attribute(array, itemSize) {\r\n    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');\r\n    return new Float64BufferAttribute(array, itemSize);\r\n}\r\n//\r\nCurve.create = function (construct, getPoint) {\r\n    console.log('THREE.Curve.create() has been deprecated');\r\n    construct.prototype = Object.create(Curve.prototype);\r\n    construct.prototype.constructor = construct;\r\n    construct.prototype.getPoint = getPoint;\r\n    return construct;\r\n};\r\n//\r\nObject.assign(CurvePath.prototype, {\r\n    createPointsGeometry: function (divisions) {\r\n        console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');\r\n        // generate geometry from path points (for Line or Points objects)\r\n        var pts = this.getPoints(divisions);\r\n        return this.createGeometry(pts);\r\n    },\r\n    createSpacedPointsGeometry: function (divisions) {\r\n        console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');\r\n        // generate geometry from equidistant sampling along the path\r\n        var pts = this.getSpacedPoints(divisions);\r\n        return this.createGeometry(pts);\r\n    },\r\n    createGeometry: function (points) {\r\n        console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');\r\n        var geometry = new Geometry();\r\n        for (var i = 0, l = points.length; i < l; i++) {\r\n            var point = points[i];\r\n            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));\r\n        }\r\n        return geometry;\r\n    }\r\n});\r\n//\r\nObject.assign(Path.prototype, {\r\n    fromPoints: function (points) {\r\n        console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');\r\n        this.setFromPoints(points);\r\n    }\r\n});\r\n//\r\nfunction ClosedSplineCurve3(points) {\r\n    console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');\r\n    CatmullRomCurve3.call(this, points);\r\n    this.type = 'catmullrom';\r\n    this.closed = true;\r\n}\r\nClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);\r\n//\r\nfunction SplineCurve3(points) {\r\n    console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');\r\n    CatmullRomCurve3.call(this, points);\r\n    this.type = 'catmullrom';\r\n}\r\nSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);\r\n//\r\nfunction Spline(points) {\r\n    console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');\r\n    CatmullRomCurve3.call(this, points);\r\n    this.type = 'catmullrom';\r\n}\r\nSpline.prototype = Object.create(CatmullRomCurve3.prototype);\r\nObject.assign(Spline.prototype, {\r\n    initFromArray: function ( /* a */) {\r\n        console.error('THREE.Spline: .initFromArray() has been removed.');\r\n    },\r\n    getControlPointsArray: function ( /* optionalTarget */) {\r\n        console.error('THREE.Spline: .getControlPointsArray() has been removed.');\r\n    },\r\n    reparametrizeByArcLength: function ( /* samplingCoef */) {\r\n        console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');\r\n    }\r\n});\r\n//\r\nfunction AxisHelper(size) {\r\n    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');\r\n    return new AxesHelper(size);\r\n}\r\nfunction BoundingBoxHelper(object, color) {\r\n    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');\r\n    return new BoxHelper(object, color);\r\n}\r\nfunction EdgesHelper(object, hex) {\r\n    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');\r\n    return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));\r\n}\r\nGridHelper.prototype.setColors = function () {\r\n    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\r\n};\r\nSkeletonHelper.prototype.update = function () {\r\n    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');\r\n};\r\nfunction WireframeHelper(object, hex) {\r\n    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');\r\n    return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));\r\n}\r\n//\r\nObject.assign(Loader.prototype, {\r\n    extractUrlBase: function (url) {\r\n        console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');\r\n        return LoaderUtils.extractUrlBase(url);\r\n    }\r\n});\r\nfunction XHRLoader(manager) {\r\n    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');\r\n    return new FileLoader(manager);\r\n}\r\nfunction BinaryTextureLoader(manager) {\r\n    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');\r\n    return new DataTextureLoader(manager);\r\n}\r\nObject.assign(ObjectLoader.prototype, {\r\n    setTexturePath: function (value) {\r\n        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');\r\n        return this.setResourcePath(value);\r\n    }\r\n});\r\n//\r\nObject.assign(Box2.prototype, {\r\n    center: function (optionalTarget) {\r\n        console.warn('THREE.Box2: .center() has been renamed to .getCenter().');\r\n        return this.getCenter(optionalTarget);\r\n    },\r\n    empty: function () {\r\n        console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');\r\n        return this.isEmpty();\r\n    },\r\n    isIntersectionBox: function (box) {\r\n        console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');\r\n        return this.intersectsBox(box);\r\n    },\r\n    size: function (optionalTarget) {\r\n        console.warn('THREE.Box2: .size() has been renamed to .getSize().');\r\n        return this.getSize(optionalTarget);\r\n    }\r\n});\r\nObject.assign(Box3.prototype, {\r\n    center: function (optionalTarget) {\r\n        console.warn('THREE.Box3: .center() has been renamed to .getCenter().');\r\n        return this.getCenter(optionalTarget);\r\n    },\r\n    empty: function () {\r\n        console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\r\n        return this.isEmpty();\r\n    },\r\n    isIntersectionBox: function (box) {\r\n        console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\r\n        return this.intersectsBox(box);\r\n    },\r\n    isIntersectionSphere: function (sphere) {\r\n        console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\r\n        return this.intersectsSphere(sphere);\r\n    },\r\n    size: function (optionalTarget) {\r\n        console.warn('THREE.Box3: .size() has been renamed to .getSize().');\r\n        return this.getSize(optionalTarget);\r\n    }\r\n});\r\nLine3.prototype.center = function (optionalTarget) {\r\n    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');\r\n    return this.getCenter(optionalTarget);\r\n};\r\nObject.assign(_Math, {\r\n    random16: function () {\r\n        console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');\r\n        return Math.random();\r\n    },\r\n    nearestPowerOfTwo: function (value) {\r\n        console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');\r\n        return _Math.floorPowerOfTwo(value);\r\n    },\r\n    nextPowerOfTwo: function (value) {\r\n        console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');\r\n        return _Math.ceilPowerOfTwo(value);\r\n    }\r\n});\r\nObject.assign(Matrix3.prototype, {\r\n    flattenToArrayOffset: function (array, offset) {\r\n        console.warn(\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\r\n        return this.toArray(array, offset);\r\n    },\r\n    multiplyVector3: function (vector) {\r\n        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\r\n        return vector.applyMatrix3(this);\r\n    },\r\n    multiplyVector3Array: function ( /* a */) {\r\n        console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\r\n    },\r\n    applyToBuffer: function (buffer /*, offset, length */) {\r\n        console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');\r\n        return this.applyToBufferAttribute(buffer);\r\n    },\r\n    applyToVector3Array: function ( /* array, offset, length */) {\r\n        console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\r\n    }\r\n});\r\nObject.assign(Matrix4.prototype, {\r\n    extractPosition: function (m) {\r\n        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\r\n        return this.copyPosition(m);\r\n    },\r\n    flattenToArrayOffset: function (array, offset) {\r\n        console.warn(\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\r\n        return this.toArray(array, offset);\r\n    },\r\n    getPosition: function () {\r\n        var v1;\r\n        return function getPosition() {\r\n            if (v1 === undefined)\r\n                v1 = new Vector3();\r\n            console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\r\n            return v1.setFromMatrixColumn(this, 3);\r\n        };\r\n    }(),\r\n    setRotationFromQuaternion: function (q) {\r\n        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\r\n        return this.makeRotationFromQuaternion(q);\r\n    },\r\n    multiplyToArray: function () {\r\n        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\r\n    },\r\n    multiplyVector3: function (vector) {\r\n        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\r\n        return vector.applyMatrix4(this);\r\n    },\r\n    multiplyVector4: function (vector) {\r\n        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\r\n        return vector.applyMatrix4(this);\r\n    },\r\n    multiplyVector3Array: function ( /* a */) {\r\n        console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\r\n    },\r\n    rotateAxis: function (v) {\r\n        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\r\n        v.transformDirection(this);\r\n    },\r\n    crossVector: function (vector) {\r\n        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\r\n        return vector.applyMatrix4(this);\r\n    },\r\n    translate: function () {\r\n        console.error('THREE.Matrix4: .translate() has been removed.');\r\n    },\r\n    rotateX: function () {\r\n        console.error('THREE.Matrix4: .rotateX() has been removed.');\r\n    },\r\n    rotateY: function () {\r\n        console.error('THREE.Matrix4: .rotateY() has been removed.');\r\n    },\r\n    rotateZ: function () {\r\n        console.error('THREE.Matrix4: .rotateZ() has been removed.');\r\n    },\r\n    rotateByAxis: function () {\r\n        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');\r\n    },\r\n    applyToBuffer: function (buffer /*, offset, length */) {\r\n        console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');\r\n        return this.applyToBufferAttribute(buffer);\r\n    },\r\n    applyToVector3Array: function ( /* array, offset, length */) {\r\n        console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\r\n    },\r\n    makeFrustum: function (left, right, bottom, top, near, far) {\r\n        console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\r\n        return this.makePerspective(left, right, top, bottom, near, far);\r\n    }\r\n});\r\nPlane.prototype.isIntersectionLine = function (line) {\r\n    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\r\n    return this.intersectsLine(line);\r\n};\r\nQuaternion.prototype.multiplyVector3 = function (vector) {\r\n    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\r\n    return vector.applyQuaternion(this);\r\n};\r\nObject.assign(Ray.prototype, {\r\n    isIntersectionBox: function (box) {\r\n        console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\r\n        return this.intersectsBox(box);\r\n    },\r\n    isIntersectionPlane: function (plane) {\r\n        console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\r\n        return this.intersectsPlane(plane);\r\n    },\r\n    isIntersectionSphere: function (sphere) {\r\n        console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\r\n        return this.intersectsSphere(sphere);\r\n    }\r\n});\r\nObject.assign(Triangle.prototype, {\r\n    area: function () {\r\n        console.warn('THREE.Triangle: .area() has been renamed to .getArea().');\r\n        return this.getArea();\r\n    },\r\n    barycoordFromPoint: function (point, target) {\r\n        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\r\n        return this.getBarycoord(point, target);\r\n    },\r\n    midpoint: function (target) {\r\n        console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');\r\n        return this.getMidpoint(target);\r\n    },\r\n    normal: function (target) {\r\n        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\r\n        return this.getNormal(target);\r\n    },\r\n    plane: function (target) {\r\n        console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\r\n        return this.getPlane(target);\r\n    }\r\n});\r\nObject.assign(Triangle, {\r\n    barycoordFromPoint: function (point, a, b, c, target) {\r\n        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\r\n        return Triangle.getBarycoord(point, a, b, c, target);\r\n    },\r\n    normal: function (a, b, c, target) {\r\n        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\r\n        return Triangle.getNormal(a, b, c, target);\r\n    }\r\n});\r\nObject.assign(Shape.prototype, {\r\n    extractAllPoints: function (divisions) {\r\n        console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');\r\n        return this.extractPoints(divisions);\r\n    },\r\n    extrude: function (options) {\r\n        console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\r\n        return new ExtrudeGeometry(this, options);\r\n    },\r\n    makeGeometry: function (options) {\r\n        console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\r\n        return new ShapeGeometry(this, options);\r\n    }\r\n});\r\nObject.assign(Vector2.prototype, {\r\n    fromAttribute: function (attribute, index, offset) {\r\n        console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\r\n        return this.fromBufferAttribute(attribute, index, offset);\r\n    },\r\n    distanceToManhattan: function (v) {\r\n        console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\r\n        return this.manhattanDistanceTo(v);\r\n    },\r\n    lengthManhattan: function () {\r\n        console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');\r\n        return this.manhattanLength();\r\n    }\r\n});\r\nObject.assign(Vector3.prototype, {\r\n    setEulerFromRotationMatrix: function () {\r\n        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\r\n    },\r\n    setEulerFromQuaternion: function () {\r\n        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\r\n    },\r\n    getPositionFromMatrix: function (m) {\r\n        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\r\n        return this.setFromMatrixPosition(m);\r\n    },\r\n    getScaleFromMatrix: function (m) {\r\n        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\r\n        return this.setFromMatrixScale(m);\r\n    },\r\n    getColumnFromMatrix: function (index, matrix) {\r\n        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\r\n        return this.setFromMatrixColumn(matrix, index);\r\n    },\r\n    applyProjection: function (m) {\r\n        console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\r\n        return this.applyMatrix4(m);\r\n    },\r\n    fromAttribute: function (attribute, index, offset) {\r\n        console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\r\n        return this.fromBufferAttribute(attribute, index, offset);\r\n    },\r\n    distanceToManhattan: function (v) {\r\n        console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\r\n        return this.manhattanDistanceTo(v);\r\n    },\r\n    lengthManhattan: function () {\r\n        console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');\r\n        return this.manhattanLength();\r\n    }\r\n});\r\nObject.assign(Vector4.prototype, {\r\n    fromAttribute: function (attribute, index, offset) {\r\n        console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\r\n        return this.fromBufferAttribute(attribute, index, offset);\r\n    },\r\n    lengthManhattan: function () {\r\n        console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');\r\n        return this.manhattanLength();\r\n    }\r\n});\r\n//\r\nObject.assign(Geometry.prototype, {\r\n    computeTangents: function () {\r\n        console.error('THREE.Geometry: .computeTangents() has been removed.');\r\n    },\r\n    computeLineDistances: function () {\r\n        console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\r\n    }\r\n});\r\nObject.assign(Object3D.prototype, {\r\n    getChildByName: function (name) {\r\n        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\r\n        return this.getObjectByName(name);\r\n    },\r\n    renderDepth: function () {\r\n        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\r\n    },\r\n    translate: function (distance, axis) {\r\n        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\r\n        return this.translateOnAxis(axis, distance);\r\n    },\r\n    getWorldRotation: function () {\r\n        console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');\r\n    }\r\n});\r\nObject.defineProperties(Object3D.prototype, {\r\n    eulerOrder: {\r\n        get: function () {\r\n            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\r\n            return this.rotation.order;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\r\n            this.rotation.order = value;\r\n        }\r\n    },\r\n    useQuaternion: {\r\n        get: function () {\r\n            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\r\n        }\r\n    }\r\n});\r\nObject.defineProperties(LOD.prototype, {\r\n    objects: {\r\n        get: function () {\r\n            console.warn('THREE.LOD: .objects has been renamed to .levels.');\r\n            return this.levels;\r\n        }\r\n    }\r\n});\r\nObject.defineProperty(Skeleton.prototype, 'useVertexTexture', {\r\n    get: function () {\r\n        console.warn('THREE.Skeleton: useVertexTexture has been removed.');\r\n    },\r\n    set: function () {\r\n        console.warn('THREE.Skeleton: useVertexTexture has been removed.');\r\n    }\r\n});\r\nSkinnedMesh.prototype.initBones = function () {\r\n    console.error('THREE.SkinnedMesh: initBones() has been removed.');\r\n};\r\nObject.defineProperty(Curve.prototype, '__arcLengthDivisions', {\r\n    get: function () {\r\n        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');\r\n        return this.arcLengthDivisions;\r\n    },\r\n    set: function (value) {\r\n        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');\r\n        this.arcLengthDivisions = value;\r\n    }\r\n});\r\n//\r\nPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\r\n    console.warn(\"THREE.PerspectiveCamera.setLens is deprecated. \" +\r\n        \"Use .setFocalLength and .filmGauge for a photographic setup.\");\r\n    if (filmGauge !== undefined)\r\n        this.filmGauge = filmGauge;\r\n    this.setFocalLength(focalLength);\r\n};\r\n//\r\nObject.defineProperties(Light.prototype, {\r\n    onlyShadow: {\r\n        set: function () {\r\n            console.warn('THREE.Light: .onlyShadow has been removed.');\r\n        }\r\n    },\r\n    shadowCameraFov: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\r\n            this.shadow.camera.fov = value;\r\n        }\r\n    },\r\n    shadowCameraLeft: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\r\n            this.shadow.camera.left = value;\r\n        }\r\n    },\r\n    shadowCameraRight: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\r\n            this.shadow.camera.right = value;\r\n        }\r\n    },\r\n    shadowCameraTop: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\r\n            this.shadow.camera.top = value;\r\n        }\r\n    },\r\n    shadowCameraBottom: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\r\n            this.shadow.camera.bottom = value;\r\n        }\r\n    },\r\n    shadowCameraNear: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\r\n            this.shadow.camera.near = value;\r\n        }\r\n    },\r\n    shadowCameraFar: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\r\n            this.shadow.camera.far = value;\r\n        }\r\n    },\r\n    shadowCameraVisible: {\r\n        set: function () {\r\n            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\r\n        }\r\n    },\r\n    shadowBias: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');\r\n            this.shadow.bias = value;\r\n        }\r\n    },\r\n    shadowDarkness: {\r\n        set: function () {\r\n            console.warn('THREE.Light: .shadowDarkness has been removed.');\r\n        }\r\n    },\r\n    shadowMapWidth: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\r\n            this.shadow.mapSize.width = value;\r\n        }\r\n    },\r\n    shadowMapHeight: {\r\n        set: function (value) {\r\n            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\r\n            this.shadow.mapSize.height = value;\r\n        }\r\n    }\r\n});\r\n//\r\nObject.defineProperties(BufferAttribute.prototype, {\r\n    length: {\r\n        get: function () {\r\n            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\r\n            return this.array.length;\r\n        }\r\n    },\r\n    copyIndicesArray: function ( /* indices */) {\r\n        console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\r\n    }\r\n});\r\nObject.assign(BufferGeometry.prototype, {\r\n    addIndex: function (index) {\r\n        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\r\n        this.setIndex(index);\r\n    },\r\n    addDrawCall: function (start, count, indexOffset) {\r\n        if (indexOffset !== undefined) {\r\n            console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\r\n        }\r\n        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\r\n        this.addGroup(start, count);\r\n    },\r\n    clearDrawCalls: function () {\r\n        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\r\n        this.clearGroups();\r\n    },\r\n    computeTangents: function () {\r\n        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');\r\n    },\r\n    computeOffsets: function () {\r\n        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\r\n    }\r\n});\r\nObject.defineProperties(BufferGeometry.prototype, {\r\n    drawcalls: {\r\n        get: function () {\r\n            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\r\n            return this.groups;\r\n        }\r\n    },\r\n    offsets: {\r\n        get: function () {\r\n            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\r\n            return this.groups;\r\n        }\r\n    }\r\n});\r\n//\r\nObject.assign(ExtrudeBufferGeometry.prototype, {\r\n    getArrays: function () {\r\n        console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');\r\n    },\r\n    addShapeList: function () {\r\n        console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');\r\n    },\r\n    addShape: function () {\r\n        console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');\r\n    }\r\n});\r\n//\r\nObject.defineProperties(Uniform.prototype, {\r\n    dynamic: {\r\n        set: function () {\r\n            console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');\r\n        }\r\n    },\r\n    onUpdate: {\r\n        value: function () {\r\n            console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');\r\n            return this;\r\n        }\r\n    }\r\n});\r\n//\r\nObject.defineProperties(Material$1.prototype, {\r\n    wrapAround: {\r\n        get: function () {\r\n            console.warn('THREE.Material: .wrapAround has been removed.');\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.Material: .wrapAround has been removed.');\r\n        }\r\n    },\r\n    overdraw: {\r\n        get: function () {\r\n            console.warn('THREE.Material: .overdraw has been removed.');\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.Material: .overdraw has been removed.');\r\n        }\r\n    },\r\n    wrapRGB: {\r\n        get: function () {\r\n            console.warn('THREE.Material: .wrapRGB has been removed.');\r\n            return new Color();\r\n        }\r\n    },\r\n    shading: {\r\n        get: function () {\r\n            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\r\n            this.flatShading = (value === FlatShading);\r\n        }\r\n    }\r\n});\r\nObject.defineProperties(MeshPhongMaterial.prototype, {\r\n    metal: {\r\n        get: function () {\r\n            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');\r\n            return false;\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');\r\n        }\r\n    }\r\n});\r\nObject.defineProperties(ShaderMaterial.prototype, {\r\n    derivatives: {\r\n        get: function () {\r\n            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\r\n            return this.extensions.derivatives;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\r\n            this.extensions.derivatives = value;\r\n        }\r\n    }\r\n});\r\n//\r\nObject.assign(WebGLRenderer.prototype, {\r\n    clearTarget: function (renderTarget, color, depth, stencil) {\r\n        console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');\r\n        this.setRenderTarget(renderTarget);\r\n        this.clear(color, depth, stencil);\r\n    },\r\n    animate: function (callback) {\r\n        console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\r\n        this.setAnimationLoop(callback);\r\n    },\r\n    getCurrentRenderTarget: function () {\r\n        console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');\r\n        return this.getRenderTarget();\r\n    },\r\n    getMaxAnisotropy: function () {\r\n        console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');\r\n        return this.capabilities.getMaxAnisotropy();\r\n    },\r\n    getPrecision: function () {\r\n        console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');\r\n        return this.capabilities.precision;\r\n    },\r\n    resetGLState: function () {\r\n        console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\r\n        return this.state.reset();\r\n    },\r\n    supportsFloatTextures: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\r\n        return this.extensions.get('OES_texture_float');\r\n    },\r\n    supportsHalfFloatTextures: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\r\n        return this.extensions.get('OES_texture_half_float');\r\n    },\r\n    supportsStandardDerivatives: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\r\n        return this.extensions.get('OES_standard_derivatives');\r\n    },\r\n    supportsCompressedTextureS3TC: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\r\n        return this.extensions.get('WEBGL_compressed_texture_s3tc');\r\n    },\r\n    supportsCompressedTexturePVRTC: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\r\n        return this.extensions.get('WEBGL_compressed_texture_pvrtc');\r\n    },\r\n    supportsBlendMinMax: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\r\n        return this.extensions.get('EXT_blend_minmax');\r\n    },\r\n    supportsVertexTextures: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\r\n        return this.capabilities.vertexTextures;\r\n    },\r\n    supportsInstancedArrays: function () {\r\n        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\r\n        return this.extensions.get('ANGLE_instanced_arrays');\r\n    },\r\n    enableScissorTest: function (boolean) {\r\n        console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\r\n        this.setScissorTest(boolean);\r\n    },\r\n    initMaterial: function () {\r\n        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\r\n    },\r\n    addPrePlugin: function () {\r\n        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\r\n    },\r\n    addPostPlugin: function () {\r\n        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\r\n    },\r\n    updateShadowMap: function () {\r\n        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\r\n    },\r\n    setFaceCulling: function () {\r\n        console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\r\n    },\r\n    allocTextureUnit: function () {\r\n        console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\r\n    },\r\n    setTexture: function () {\r\n        console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\r\n    },\r\n    setTexture2D: function () {\r\n        console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\r\n    },\r\n    setTextureCube: function () {\r\n        console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\r\n    },\r\n    getActiveMipMapLevel: function () {\r\n        console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');\r\n        return this.getActiveMipmapLevel();\r\n    }\r\n});\r\nObject.defineProperties(WebGLRenderer.prototype, {\r\n    shadowMapEnabled: {\r\n        get: function () {\r\n            return this.shadowMap.enabled;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\r\n            this.shadowMap.enabled = value;\r\n        }\r\n    },\r\n    shadowMapType: {\r\n        get: function () {\r\n            return this.shadowMap.type;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\r\n            this.shadowMap.type = value;\r\n        }\r\n    },\r\n    shadowMapCullFace: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\r\n            return undefined;\r\n        },\r\n        set: function ( /* value */) {\r\n            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\r\n        }\r\n    },\r\n    context: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');\r\n            return this.getContext();\r\n        }\r\n    }\r\n});\r\nObject.defineProperties(WebGLShadowMap.prototype, {\r\n    cullFace: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\r\n            return undefined;\r\n        },\r\n        set: function ( /* cullFace */) {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\r\n        }\r\n    },\r\n    renderReverseSided: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\r\n            return undefined;\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\r\n        }\r\n    },\r\n    renderSingleSided: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\r\n            return undefined;\r\n        },\r\n        set: function () {\r\n            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\r\n        }\r\n    }\r\n});\r\n//\r\nObject.defineProperties(WebGLRenderTargetCube.prototype, {\r\n    activeCubeFace: {\r\n        set: function ( /* value */) {\r\n            console.warn('THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().');\r\n        }\r\n    },\r\n    activeMipMapLevel: {\r\n        set: function ( /* value */) {\r\n            console.warn('THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().');\r\n        }\r\n    }\r\n});\r\n//\r\nObject.defineProperties(WebGLRenderTarget.prototype, {\r\n    wrapS: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\r\n            return this.texture.wrapS;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\r\n            this.texture.wrapS = value;\r\n        }\r\n    },\r\n    wrapT: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\r\n            return this.texture.wrapT;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\r\n            this.texture.wrapT = value;\r\n        }\r\n    },\r\n    magFilter: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\r\n            return this.texture.magFilter;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\r\n            this.texture.magFilter = value;\r\n        }\r\n    },\r\n    minFilter: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\r\n            return this.texture.minFilter;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\r\n            this.texture.minFilter = value;\r\n        }\r\n    },\r\n    anisotropy: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\r\n            return this.texture.anisotropy;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\r\n            this.texture.anisotropy = value;\r\n        }\r\n    },\r\n    offset: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\r\n            return this.texture.offset;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\r\n            this.texture.offset = value;\r\n        }\r\n    },\r\n    repeat: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\r\n            return this.texture.repeat;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\r\n            this.texture.repeat = value;\r\n        }\r\n    },\r\n    format: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\r\n            return this.texture.format;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\r\n            this.texture.format = value;\r\n        }\r\n    },\r\n    type: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\r\n            return this.texture.type;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\r\n            this.texture.type = value;\r\n        }\r\n    },\r\n    generateMipmaps: {\r\n        get: function () {\r\n            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\r\n            return this.texture.generateMipmaps;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\r\n            this.texture.generateMipmaps = value;\r\n        }\r\n    }\r\n});\r\n//\r\nObject.defineProperties(WebVRManager.prototype, {\r\n    standing: {\r\n        set: function ( /* value */) {\r\n            console.warn('THREE.WebVRManager: .standing has been removed.');\r\n        }\r\n    },\r\n    userHeight: {\r\n        set: function ( /* value */) {\r\n            console.warn('THREE.WebVRManager: .userHeight has been removed.');\r\n        }\r\n    }\r\n});\r\n//\r\nAudio.prototype.load = function (file) {\r\n    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\r\n    var scope = this;\r\n    var audioLoader = new AudioLoader();\r\n    audioLoader.load(file, function (buffer) {\r\n        scope.setBuffer(buffer);\r\n    });\r\n    return this;\r\n};\r\nAudioAnalyser.prototype.getData = function () {\r\n    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');\r\n    return this.getFrequencyData();\r\n};\r\n//\r\nCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\r\n    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\r\n    return this.update(renderer, scene);\r\n};\r\n//\r\nvar GeometryUtils = {\r\n    merge: function (geometry1, geometry2, materialIndexOffset) {\r\n        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');\r\n        var matrix;\r\n        if (geometry2.isMesh) {\r\n            geometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n            matrix = geometry2.matrix;\r\n            geometry2 = geometry2.geometry;\r\n        }\r\n        geometry1.merge(geometry2, matrix, materialIndexOffset);\r\n    },\r\n    center: function (geometry) {\r\n        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');\r\n        return geometry.center();\r\n    }\r\n};\r\nImageUtils.crossOrigin = undefined;\r\nImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\r\n    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\r\n    var loader = new TextureLoader();\r\n    loader.setCrossOrigin(this.crossOrigin);\r\n    var texture = loader.load(url, onLoad, undefined, onError);\r\n    if (mapping)\r\n        texture.mapping = mapping;\r\n    return texture;\r\n};\r\nImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\r\n    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\r\n    var loader = new CubeTextureLoader();\r\n    loader.setCrossOrigin(this.crossOrigin);\r\n    var texture = loader.load(urls, onLoad, undefined, onError);\r\n    if (mapping)\r\n        texture.mapping = mapping;\r\n    return texture;\r\n};\r\nImageUtils.loadCompressedTexture = function () {\r\n    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\r\n};\r\nImageUtils.loadCompressedTextureCube = function () {\r\n    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\r\n};\r\n//\r\nfunction CanvasRenderer() {\r\n    console.error('THREE.CanvasRenderer has been removed');\r\n}\r\n//\r\nfunction JSONLoader() {\r\n    console.error('THREE.JSONLoader has been removed.');\r\n}\r\n//\r\nvar SceneUtils = {\r\n    createMultiMaterialObject: function ( /* geometry, materials */) {\r\n        console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');\r\n    },\r\n    detach: function ( /* child, parent, scene */) {\r\n        console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');\r\n    },\r\n    attach: function ( /* child, scene, parent */) {\r\n        console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');\r\n    }\r\n};\r\n//\r\nfunction LensFlare() {\r\n    console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');\r\n}\r\nvar three_module = /*#__PURE__*/ Object.freeze({\r\n    ACESFilmicToneMapping: ACESFilmicToneMapping,\r\n    AddEquation: AddEquation,\r\n    AddOperation: AddOperation,\r\n    AdditiveBlending: AdditiveBlending,\r\n    AlphaFormat: AlphaFormat,\r\n    AlwaysDepth: AlwaysDepth,\r\n    AlwaysStencilFunc: AlwaysStencilFunc,\r\n    AmbientLight: AmbientLight,\r\n    AmbientLightProbe: AmbientLightProbe,\r\n    AnimationClip: AnimationClip,\r\n    AnimationLoader: AnimationLoader,\r\n    AnimationMixer: AnimationMixer,\r\n    AnimationObjectGroup: AnimationObjectGroup,\r\n    AnimationUtils: AnimationUtils,\r\n    ArcCurve: ArcCurve,\r\n    ArrayCamera: ArrayCamera,\r\n    ArrowHelper: ArrowHelper,\r\n    Audio: Audio,\r\n    AudioAnalyser: AudioAnalyser,\r\n    AudioContext: AudioContext,\r\n    AudioListener: AudioListener,\r\n    AudioLoader: AudioLoader,\r\n    AxesHelper: AxesHelper,\r\n    AxisHelper: AxisHelper,\r\n    BackSide: BackSide,\r\n    BasicDepthPacking: BasicDepthPacking,\r\n    BasicShadowMap: BasicShadowMap,\r\n    BinaryTextureLoader: BinaryTextureLoader,\r\n    Bone: Bone,\r\n    BooleanKeyframeTrack: BooleanKeyframeTrack,\r\n    BoundingBoxHelper: BoundingBoxHelper,\r\n    Box2: Box2,\r\n    Box3: Box3,\r\n    Box3Helper: Box3Helper,\r\n    BoxBufferGeometry: BoxBufferGeometry,\r\n    BoxGeometry: BoxGeometry,\r\n    BoxHelper: BoxHelper,\r\n    BufferAttribute: BufferAttribute,\r\n    BufferGeometry: BufferGeometry,\r\n    BufferGeometryLoader: BufferGeometryLoader,\r\n    ByteType: ByteType,\r\n    Cache: Cache,\r\n    Camera: Camera,\r\n    CameraHelper: CameraHelper,\r\n    CanvasRenderer: CanvasRenderer,\r\n    CanvasTexture: CanvasTexture,\r\n    CatmullRomCurve3: CatmullRomCurve3,\r\n    CineonToneMapping: CineonToneMapping,\r\n    CircleBufferGeometry: CircleBufferGeometry,\r\n    CircleGeometry: CircleGeometry,\r\n    ClampToEdgeWrapping: ClampToEdgeWrapping,\r\n    Clock: Clock,\r\n    ClosedSplineCurve3: ClosedSplineCurve3,\r\n    Color: Color,\r\n    ColorKeyframeTrack: ColorKeyframeTrack,\r\n    CompressedTexture: CompressedTexture,\r\n    CompressedTextureLoader: CompressedTextureLoader,\r\n    ConeBufferGeometry: ConeBufferGeometry,\r\n    ConeGeometry: ConeGeometry,\r\n    CubeCamera: CubeCamera,\r\n    CubeGeometry: BoxGeometry,\r\n    CubeReflectionMapping: CubeReflectionMapping,\r\n    CubeRefractionMapping: CubeRefractionMapping,\r\n    CubeTexture: CubeTexture,\r\n    CubeTextureLoader: CubeTextureLoader,\r\n    CubeUVReflectionMapping: CubeUVReflectionMapping,\r\n    CubeUVRefractionMapping: CubeUVRefractionMapping,\r\n    CubicBezierCurve: CubicBezierCurve,\r\n    CubicBezierCurve3: CubicBezierCurve3,\r\n    CubicInterpolant: CubicInterpolant,\r\n    CullFaceBack: CullFaceBack,\r\n    CullFaceFront: CullFaceFront,\r\n    CullFaceFrontBack: CullFaceFrontBack,\r\n    CullFaceNone: CullFaceNone,\r\n    Curve: Curve,\r\n    CurvePath: CurvePath,\r\n    CustomBlending: CustomBlending,\r\n    CylinderBufferGeometry: CylinderBufferGeometry,\r\n    CylinderGeometry: CylinderGeometry,\r\n    Cylindrical: Cylindrical,\r\n    DataTexture: DataTexture,\r\n    DataTexture2DArray: DataTexture2DArray,\r\n    DataTexture3D: DataTexture3D,\r\n    DataTextureLoader: DataTextureLoader,\r\n    DecrementStencilOp: DecrementStencilOp,\r\n    DecrementWrapStencilOp: DecrementWrapStencilOp,\r\n    DefaultLoadingManager: DefaultLoadingManager,\r\n    DepthFormat: DepthFormat,\r\n    DepthStencilFormat: DepthStencilFormat,\r\n    DepthTexture: DepthTexture,\r\n    DirectionalLight: DirectionalLight,\r\n    DirectionalLightHelper: DirectionalLightHelper,\r\n    DirectionalLightShadow: DirectionalLightShadow,\r\n    DiscreteInterpolant: DiscreteInterpolant,\r\n    DodecahedronBufferGeometry: DodecahedronBufferGeometry,\r\n    DodecahedronGeometry: DodecahedronGeometry,\r\n    DoubleSide: DoubleSide,\r\n    DstAlphaFactor: DstAlphaFactor,\r\n    DstColorFactor: DstColorFactor,\r\n    DynamicBufferAttribute: DynamicBufferAttribute,\r\n    EdgesGeometry: EdgesGeometry,\r\n    EdgesHelper: EdgesHelper,\r\n    EllipseCurve: EllipseCurve,\r\n    EqualDepth: EqualDepth,\r\n    EqualStencilFunc: EqualStencilFunc,\r\n    EquirectangularReflectionMapping: EquirectangularReflectionMapping,\r\n    EquirectangularRefractionMapping: EquirectangularRefractionMapping,\r\n    Euler: Euler,\r\n    EventDispatcher: EventDispatcher,\r\n    ExtrudeBufferGeometry: ExtrudeBufferGeometry,\r\n    ExtrudeGeometry: ExtrudeGeometry,\r\n    Face3: Face3,\r\n    Face4: Face4,\r\n    FaceColors: FaceColors,\r\n    FaceNormalsHelper: FaceNormalsHelper,\r\n    FileLoader: FileLoader,\r\n    FlatShading: FlatShading,\r\n    Float32Attribute: Float32Attribute,\r\n    Float32BufferAttribute: Float32BufferAttribute,\r\n    Float64Attribute: Float64Attribute,\r\n    Float64BufferAttribute: Float64BufferAttribute,\r\n    FloatType: FloatType,\r\n    Fog: Fog,\r\n    FogExp2: FogExp2,\r\n    Font: Font,\r\n    FontLoader: FontLoader,\r\n    FrontFaceDirectionCCW: FrontFaceDirectionCCW,\r\n    FrontFaceDirectionCW: FrontFaceDirectionCW,\r\n    FrontSide: FrontSide,\r\n    Frustum: Frustum,\r\n    GammaEncoding: GammaEncoding,\r\n    Geometry: Geometry,\r\n    GeometryUtils: GeometryUtils,\r\n    GreaterDepth: GreaterDepth,\r\n    GreaterEqualDepth: GreaterEqualDepth,\r\n    GreaterEqualStencilFunc: GreaterEqualStencilFunc,\r\n    GreaterStencilFunc: GreaterStencilFunc,\r\n    GridHelper: GridHelper,\r\n    Group: Group,\r\n    HalfFloatType: HalfFloatType,\r\n    HemisphereLight: HemisphereLight,\r\n    HemisphereLightHelper: HemisphereLightHelper,\r\n    HemisphereLightProbe: HemisphereLightProbe,\r\n    IcosahedronBufferGeometry: IcosahedronBufferGeometry,\r\n    IcosahedronGeometry: IcosahedronGeometry,\r\n    ImageBitmapLoader: ImageBitmapLoader,\r\n    ImageLoader: ImageLoader,\r\n    ImageUtils: ImageUtils,\r\n    ImmediateRenderObject: ImmediateRenderObject,\r\n    IncrementStencilOp: IncrementStencilOp,\r\n    IncrementWrapStencilOp: IncrementWrapStencilOp,\r\n    InstancedBufferAttribute: InstancedBufferAttribute,\r\n    InstancedBufferGeometry: InstancedBufferGeometry,\r\n    InstancedInterleavedBuffer: InstancedInterleavedBuffer,\r\n    Int16Attribute: Int16Attribute,\r\n    Int16BufferAttribute: Int16BufferAttribute,\r\n    Int32Attribute: Int32Attribute,\r\n    Int32BufferAttribute: Int32BufferAttribute,\r\n    Int8Attribute: Int8Attribute,\r\n    Int8BufferAttribute: Int8BufferAttribute,\r\n    IntType: IntType,\r\n    InterleavedBuffer: InterleavedBuffer,\r\n    InterleavedBufferAttribute: InterleavedBufferAttribute,\r\n    Interpolant: Interpolant,\r\n    InterpolateDiscrete: InterpolateDiscrete,\r\n    InterpolateLinear: InterpolateLinear,\r\n    InterpolateSmooth: InterpolateSmooth,\r\n    InvertStencilOp: InvertStencilOp,\r\n    JSONLoader: JSONLoader,\r\n    KeepStencilOp: KeepStencilOp,\r\n    KeyframeTrack: KeyframeTrack,\r\n    LOD: LOD,\r\n    LatheBufferGeometry: LatheBufferGeometry,\r\n    LatheGeometry: LatheGeometry,\r\n    Layers: Layers,\r\n    LensFlare: LensFlare,\r\n    LessDepth: LessDepth,\r\n    LessEqualDepth: LessEqualDepth,\r\n    LessEqualStencilFunc: LessEqualStencilFunc,\r\n    LessStencilFunc: LessStencilFunc,\r\n    Light: Light,\r\n    LightProbe: LightProbe,\r\n    LightProbeHelper: LightProbeHelper,\r\n    LightShadow: LightShadow,\r\n    Line: Line,\r\n    Line3: Line3,\r\n    LineBasicMaterial: LineBasicMaterial,\r\n    LineCurve: LineCurve,\r\n    LineCurve3: LineCurve3,\r\n    LineDashedMaterial: LineDashedMaterial,\r\n    LineLoop: LineLoop,\r\n    LinePieces: LinePieces,\r\n    LineSegments: LineSegments,\r\n    LineStrip: LineStrip,\r\n    LinearEncoding: LinearEncoding,\r\n    LinearFilter: LinearFilter,\r\n    LinearInterpolant: LinearInterpolant,\r\n    LinearMipMapLinearFilter: LinearMipMapLinearFilter,\r\n    LinearMipMapNearestFilter: LinearMipMapNearestFilter,\r\n    LinearMipmapLinearFilter: LinearMipmapLinearFilter,\r\n    LinearMipmapNearestFilter: LinearMipmapNearestFilter,\r\n    LinearToneMapping: LinearToneMapping,\r\n    Loader: Loader,\r\n    LoaderUtils: LoaderUtils,\r\n    LoadingManager: LoadingManager,\r\n    LogLuvEncoding: LogLuvEncoding,\r\n    LoopOnce: LoopOnce,\r\n    LoopPingPong: LoopPingPong,\r\n    LoopRepeat: LoopRepeat,\r\n    LuminanceAlphaFormat: LuminanceAlphaFormat,\r\n    LuminanceFormat: LuminanceFormat,\r\n    MOUSE: MOUSE,\r\n    Material: Material$1,\r\n    MaterialLoader: MaterialLoader,\r\n    Math: _Math,\r\n    Matrix3: Matrix3,\r\n    Matrix4: Matrix4,\r\n    MaxEquation: MaxEquation,\r\n    Mesh: Mesh,\r\n    MeshBasicMaterial: MeshBasicMaterial,\r\n    MeshDepthMaterial: MeshDepthMaterial,\r\n    MeshDistanceMaterial: MeshDistanceMaterial,\r\n    MeshFaceMaterial: MeshFaceMaterial,\r\n    MeshLambertMaterial: MeshLambertMaterial,\r\n    MeshMatcapMaterial: MeshMatcapMaterial,\r\n    MeshNormalMaterial: MeshNormalMaterial,\r\n    MeshPhongMaterial: MeshPhongMaterial,\r\n    MeshPhysicalMaterial: MeshPhysicalMaterial,\r\n    MeshStandardMaterial: MeshStandardMaterial,\r\n    MeshToonMaterial: MeshToonMaterial,\r\n    MinEquation: MinEquation,\r\n    MirroredRepeatWrapping: MirroredRepeatWrapping,\r\n    MixOperation: MixOperation,\r\n    MultiMaterial: MultiMaterial,\r\n    MultiplyBlending: MultiplyBlending,\r\n    MultiplyOperation: MultiplyOperation,\r\n    NearestFilter: NearestFilter,\r\n    NearestMipMapLinearFilter: NearestMipMapLinearFilter,\r\n    NearestMipMapNearestFilter: NearestMipMapNearestFilter,\r\n    NearestMipmapLinearFilter: NearestMipmapLinearFilter,\r\n    NearestMipmapNearestFilter: NearestMipmapNearestFilter,\r\n    NeverDepth: NeverDepth,\r\n    NeverStencilFunc: NeverStencilFunc,\r\n    NoBlending: NoBlending,\r\n    NoColors: NoColors,\r\n    NoToneMapping: NoToneMapping,\r\n    NormalBlending: NormalBlending,\r\n    NotEqualDepth: NotEqualDepth,\r\n    NotEqualStencilFunc: NotEqualStencilFunc,\r\n    NumberKeyframeTrack: NumberKeyframeTrack,\r\n    Object3D: Object3D,\r\n    ObjectLoader: ObjectLoader,\r\n    ObjectSpaceNormalMap: ObjectSpaceNormalMap,\r\n    OctahedronBufferGeometry: OctahedronBufferGeometry,\r\n    OctahedronGeometry: OctahedronGeometry,\r\n    OneFactor: OneFactor,\r\n    OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,\r\n    OneMinusDstColorFactor: OneMinusDstColorFactor,\r\n    OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,\r\n    OneMinusSrcColorFactor: OneMinusSrcColorFactor,\r\n    OrthographicCamera: OrthographicCamera,\r\n    PCFShadowMap: PCFShadowMap,\r\n    PCFSoftShadowMap: PCFSoftShadowMap,\r\n    ParametricBufferGeometry: ParametricBufferGeometry,\r\n    ParametricGeometry: ParametricGeometry,\r\n    Particle: Particle,\r\n    ParticleBasicMaterial: ParticleBasicMaterial,\r\n    ParticleSystem: ParticleSystem,\r\n    ParticleSystemMaterial: ParticleSystemMaterial,\r\n    Path: Path,\r\n    PerspectiveCamera: PerspectiveCamera,\r\n    Plane: Plane,\r\n    PlaneBufferGeometry: PlaneBufferGeometry,\r\n    PlaneGeometry: PlaneGeometry,\r\n    PlaneHelper: PlaneHelper,\r\n    PointCloud: PointCloud,\r\n    PointCloudMaterial: PointCloudMaterial,\r\n    PointLight: PointLight,\r\n    PointLightHelper: PointLightHelper,\r\n    Points: Points,\r\n    PointsMaterial: PointsMaterial,\r\n    PolarGridHelper: PolarGridHelper,\r\n    PolyhedronBufferGeometry: PolyhedronBufferGeometry,\r\n    PolyhedronGeometry: PolyhedronGeometry,\r\n    PositionalAudio: PositionalAudio,\r\n    PositionalAudioHelper: PositionalAudioHelper,\r\n    PropertyBinding: PropertyBinding,\r\n    PropertyMixer: PropertyMixer,\r\n    QuadraticBezierCurve: QuadraticBezierCurve,\r\n    QuadraticBezierCurve3: QuadraticBezierCurve3,\r\n    Quaternion: Quaternion,\r\n    QuaternionKeyframeTrack: QuaternionKeyframeTrack,\r\n    QuaternionLinearInterpolant: QuaternionLinearInterpolant,\r\n    REVISION: REVISION,\r\n    RGBADepthPacking: RGBADepthPacking,\r\n    RGBAFormat: RGBAFormat,\r\n    RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,\r\n    RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,\r\n    RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,\r\n    RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,\r\n    RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,\r\n    RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,\r\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\r\n    RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,\r\n    RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,\r\n    RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,\r\n    RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,\r\n    RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,\r\n    RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,\r\n    RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,\r\n    RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,\r\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\r\n    RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,\r\n    RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,\r\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\r\n    RGBDEncoding: RGBDEncoding,\r\n    RGBEEncoding: RGBEEncoding,\r\n    RGBEFormat: RGBEFormat,\r\n    RGBFormat: RGBFormat,\r\n    RGBM16Encoding: RGBM16Encoding,\r\n    RGBM7Encoding: RGBM7Encoding,\r\n    RGB_ETC1_Format: RGB_ETC1_Format,\r\n    RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,\r\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\r\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\r\n    RawShaderMaterial: RawShaderMaterial,\r\n    Ray: Ray,\r\n    Raycaster: Raycaster,\r\n    RectAreaLight: RectAreaLight,\r\n    RectAreaLightHelper: RectAreaLightHelper,\r\n    RedFormat: RedFormat,\r\n    ReinhardToneMapping: ReinhardToneMapping,\r\n    RepeatWrapping: RepeatWrapping,\r\n    ReplaceStencilOp: ReplaceStencilOp,\r\n    ReverseSubtractEquation: ReverseSubtractEquation,\r\n    RingBufferGeometry: RingBufferGeometry,\r\n    RingGeometry: RingGeometry,\r\n    Scene: Scene,\r\n    SceneUtils: SceneUtils,\r\n    ShaderChunk: ShaderChunk,\r\n    ShaderLib: ShaderLib,\r\n    ShaderMaterial: ShaderMaterial,\r\n    ShadowMaterial: ShadowMaterial,\r\n    Shape: Shape,\r\n    ShapeBufferGeometry: ShapeBufferGeometry,\r\n    ShapeGeometry: ShapeGeometry,\r\n    ShapePath: ShapePath,\r\n    ShapeUtils: ShapeUtils,\r\n    ShortType: ShortType,\r\n    Skeleton: Skeleton,\r\n    SkeletonHelper: SkeletonHelper,\r\n    SkinnedMesh: SkinnedMesh,\r\n    SmoothShading: SmoothShading,\r\n    Sphere: Sphere,\r\n    SphereBufferGeometry: SphereBufferGeometry,\r\n    SphereGeometry: SphereGeometry,\r\n    Spherical: Spherical,\r\n    SphericalHarmonics3: SphericalHarmonics3,\r\n    SphericalReflectionMapping: SphericalReflectionMapping,\r\n    Spline: Spline,\r\n    SplineCurve: SplineCurve,\r\n    SplineCurve3: SplineCurve3,\r\n    SpotLight: SpotLight,\r\n    SpotLightHelper: SpotLightHelper,\r\n    SpotLightShadow: SpotLightShadow,\r\n    Sprite: Sprite,\r\n    SpriteMaterial: SpriteMaterial,\r\n    SrcAlphaFactor: SrcAlphaFactor,\r\n    SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,\r\n    SrcColorFactor: SrcColorFactor,\r\n    StereoCamera: StereoCamera,\r\n    StringKeyframeTrack: StringKeyframeTrack,\r\n    SubtractEquation: SubtractEquation,\r\n    SubtractiveBlending: SubtractiveBlending,\r\n    TOUCH: TOUCH,\r\n    TangentSpaceNormalMap: TangentSpaceNormalMap,\r\n    TetrahedronBufferGeometry: TetrahedronBufferGeometry,\r\n    TetrahedronGeometry: TetrahedronGeometry,\r\n    TextBufferGeometry: TextBufferGeometry,\r\n    TextGeometry: TextGeometry,\r\n    Texture: Texture,\r\n    TextureLoader: TextureLoader,\r\n    TorusBufferGeometry: TorusBufferGeometry,\r\n    TorusGeometry: TorusGeometry,\r\n    TorusKnotBufferGeometry: TorusKnotBufferGeometry,\r\n    TorusKnotGeometry: TorusKnotGeometry,\r\n    Triangle: Triangle,\r\n    TriangleFanDrawMode: TriangleFanDrawMode,\r\n    TriangleStripDrawMode: TriangleStripDrawMode,\r\n    TrianglesDrawMode: TrianglesDrawMode,\r\n    TubeBufferGeometry: TubeBufferGeometry,\r\n    TubeGeometry: TubeGeometry,\r\n    UVMapping: UVMapping,\r\n    Uint16Attribute: Uint16Attribute,\r\n    Uint16BufferAttribute: Uint16BufferAttribute,\r\n    Uint32Attribute: Uint32Attribute,\r\n    Uint32BufferAttribute: Uint32BufferAttribute,\r\n    Uint8Attribute: Uint8Attribute,\r\n    Uint8BufferAttribute: Uint8BufferAttribute,\r\n    Uint8ClampedAttribute: Uint8ClampedAttribute,\r\n    Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,\r\n    Uncharted2ToneMapping: Uncharted2ToneMapping,\r\n    Uniform: Uniform,\r\n    UniformsLib: UniformsLib,\r\n    UniformsUtils: UniformsUtils,\r\n    UnsignedByteType: UnsignedByteType,\r\n    UnsignedInt248Type: UnsignedInt248Type,\r\n    UnsignedIntType: UnsignedIntType,\r\n    UnsignedShort4444Type: UnsignedShort4444Type,\r\n    UnsignedShort5551Type: UnsignedShort5551Type,\r\n    UnsignedShort565Type: UnsignedShort565Type,\r\n    UnsignedShortType: UnsignedShortType,\r\n    Vector2: Vector2,\r\n    Vector3: Vector3,\r\n    Vector4: Vector4,\r\n    VectorKeyframeTrack: VectorKeyframeTrack,\r\n    Vertex: Vertex,\r\n    VertexColors: VertexColors,\r\n    VertexNormalsHelper: VertexNormalsHelper,\r\n    VideoTexture: VideoTexture,\r\n    WebGLMultisampleRenderTarget: WebGLMultisampleRenderTarget,\r\n    WebGLRenderTarget: WebGLRenderTarget,\r\n    WebGLRenderTargetCube: WebGLRenderTargetCube,\r\n    WebGLRenderer: WebGLRenderer,\r\n    WebGLUtils: WebGLUtils,\r\n    WireframeGeometry: WireframeGeometry,\r\n    WireframeHelper: WireframeHelper,\r\n    WrapAroundEnding: WrapAroundEnding,\r\n    XHRLoader: XHRLoader,\r\n    ZeroCurvatureEnding: ZeroCurvatureEnding,\r\n    ZeroFactor: ZeroFactor,\r\n    ZeroSlopeEnding: ZeroSlopeEnding,\r\n    ZeroStencilOp: ZeroStencilOp,\r\n    sRGBEncoding: sRGBEncoding\r\n});\r\nvar haloFragmentS = \"#define GLSLIFY 1\\nvarying vec3 vNormal;\\nuniform float r;\\nuniform float g;\\nuniform float b;\\nuniform float a;\\nuniform float c;\\n\\nvoid main()\\n{\\n    float intensity = pow( abs(c) - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), 4.0 );\\n    gl_FragColor = vec4(r, g, b, a) * intensity;\\n}\"; // eslint-disable-line\r\nvar haloVertexS = \"#define GLSLIFY 1\\nvarying vec3 vNormal;\\n\\nvoid main()\\n{\\n    vNormal = normalize( normalMatrix * normal );\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\"; // eslint-disable-line\r\nvar ShaderUtils = /** @class */ (function () {\r\n    function ShaderUtils() {\r\n    }\r\n    ShaderUtils.getHaloMaterial = function (red, green, blue, alpha, chrominace) {\r\n        if (red === void 0) { red = 0.5; }\r\n        if (green === void 0) { green = 0.5; }\r\n        if (blue === void 0) { blue = 0.5; }\r\n        if (alpha === void 0) { alpha = 0.1; }\r\n        if (chrominace === void 0) { chrominace = 0.5; }\r\n        //return new THREE.MeshLambertMaterial( { color: 0x666666, emissive: 0xff0000 } )\r\n        return new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                r: { value: red },\r\n                g: { value: green },\r\n                b: { value: blue },\r\n                a: { value: alpha },\r\n                c: { value: chrominace }\r\n            },\r\n            vertexShader: haloVertexS,\r\n            fragmentShader: haloFragmentS,\r\n            side: THREE.BackSide,\r\n            blending: THREE.AdditiveBlending,\r\n            transparent: true,\r\n            depthTest: false\r\n        });\r\n    };\r\n    return ShaderUtils;\r\n}());\r\nAFRAME.registerComponent(\"al-angle\", {\r\n    schema: {\r\n        angle: { type: \"number\" },\r\n        edge0Pos: { type: \"vec3\" },\r\n        edge1Pos: { type: \"vec3\" },\r\n        length: { type: \"number\" },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        position: { type: \"vec3\" },\r\n        radius: { type: \"number\" },\r\n        scale: { type: \"number\" },\r\n        selected: { type: \"boolean\" }\r\n    },\r\n    init: function () {\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.state = {\r\n            selected: true,\r\n            hovered: false\r\n        };\r\n        this.createMesh();\r\n    },\r\n    bindMethods: function () {\r\n        this.createMesh = this.createMesh.bind(this);\r\n        this.getMatrix = this.getMatrix.bind(this);\r\n        this.objectToVector3 = this.objectToVector3.bind(this);\r\n        this.pointerDown = this.pointerDown.bind(this);\r\n        this.pointerOut = this.pointerOut.bind(this);\r\n        this.pointerOver = this.pointerOver.bind(this);\r\n    },\r\n    objectToVector3: function (vec) {\r\n        var res = new THREE.Vector3();\r\n        res.x = vec.x;\r\n        res.y = vec.y;\r\n        res.z = vec.z;\r\n        return res;\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.addEventListener(\"mousedown\", this.pointerDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected\", this.pointerOver, {\r\n            capture: true,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected-cleared\", this.pointerOut, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.removeEventListener(\"mousedown\", this.pointerDown);\r\n        this.el.removeEventListener(\"raycaster-intersected\", this.pointerOver);\r\n        this.el.removeEventListener(\"raycaster-intersected-cleared\", this.pointerOut);\r\n    },\r\n    pointerDown: function (_event) {\r\n        this.el.sceneEl.emit(AlGraphEvents.SELECTED, { type: AlGraphEntryType.ANGLE, id: this.el.id }, true);\r\n    },\r\n    pointerOver: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = true;\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OVER, { id: this.el.id }, true);\r\n    },\r\n    pointerOut: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = false;\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OUT, {}, true);\r\n    },\r\n    getMatrix: function () {\r\n        // Set up vector of cylinder to be direction from 1 to 2; so that scale works properly\r\n        var edgePos0 = this.objectToVector3(this.data.edge0Pos);\r\n        var edgePos1 = this.objectToVector3(this.data.edge1Pos);\r\n        var scale = new THREE.Matrix4();\r\n        scale.makeScale(this.data.scale, this.data.scale, 1);\r\n        var mult = new THREE.Matrix4();\r\n        mult.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n        var orientation = new THREE.Matrix4();\r\n        orientation.lookAt(edgePos0, edgePos1, new THREE.Object3D().up);\r\n        // 0 === x Scale, 5 === Y scale, 10 === Z scale\r\n        orientation.multiply(scale);\r\n        orientation.multiply(mult);\r\n        return orientation;\r\n    },\r\n    createMesh: function () {\r\n        var geometry = new THREE.CylinderGeometry(this.data.radius, this.data.radius, this.data.length, 6, 4);\r\n        var material = new THREE.MeshBasicMaterial();\r\n        var mesh = new THREE.Mesh(geometry, material);\r\n        mesh.applyMatrix(this.getMatrix());\r\n        mesh.position.copy(this.objectToVector3(this.data.position));\r\n        this.state.geometry = geometry;\r\n        this.state.material = material;\r\n        this.state.mesh = mesh;\r\n        var outlineGeometry = new THREE.CylinderGeometry(this.data.radius, this.data.radius, this.data.length, 6, 4);\r\n        var outlineMaterial = ShaderUtils.getHaloMaterial();\r\n        var outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);\r\n        this.state.outlineGeometry = outlineGeometry;\r\n        this.state.outlineMaterialt = outlineMaterial;\r\n        this.state.outlineMesh = outlineMesh;\r\n        mesh.add(outlineMesh);\r\n        this.el.setObject3D(\"mesh\", mesh);\r\n        this.el.object3D.renderOrder =\r\n            Constants.topLayerRenderOrder - 3;\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    update: function (oldData) {\r\n        var state = this.state;\r\n        state.selected = this.data.selected;\r\n        // If height or radius has changed, create a new mesh\r\n        if (oldData &&\r\n            (oldData.angle !== this.data.angle || oldData.scale !== this.data.scale)) {\r\n            this.createMesh();\r\n        }\r\n    },\r\n    tickFunction: function () {\r\n        var el = this.el;\r\n        var state = this.state;\r\n        if (state.hovered) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.hover);\r\n        }\r\n        else if (state.selected) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.active);\r\n        }\r\n        else {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.up);\r\n        }\r\n        var text = el.firstChild;\r\n        if (text) {\r\n            var obj3d = text.object3D;\r\n            // show/hide label\r\n            if (state.hovered) {\r\n                obj3d.visible = true;\r\n            }\r\n            else {\r\n                obj3d.visible = false;\r\n            }\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n        this.el.removeObject3D(\"mesh\");\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-background\", {\r\n    schema: {\r\n        boundingRadius: { type: \"number\", default: 1 },\r\n        frustrumDistance: { type: \"number\", default: 1 },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        scale: { type: \"number\", default: 8 },\r\n        text: { type: \"string\", default: \"\" }\r\n    },\r\n    init: function () {\r\n        this.state = {\r\n            hasUpdated: false\r\n        };\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n    },\r\n    // tslint:disable-next-line: no-empty\r\n    bindMethods: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    addEventListeners: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    removeEventListeners: function () { },\r\n    // tslint:disable-next-line: no-any\r\n    update: function (oldData) {\r\n        if (this.data.text !== oldData.text) {\r\n            this.state.hasUpdated = false;\r\n        }\r\n    },\r\n    // tslint:disable-next-line: no-empty\r\n    tickFunction: function () {\r\n        if (!this.state.hasUpdated) {\r\n            // const parentGeom = (this.el.parentEl.object3DMap.text as THREE.Mesh)\r\n            //   .geometry as THREE.BufferGeometry;\r\n            var parent = this.el.object3DMap.text;\r\n            var parentGeom = void 0;\r\n            if (parent) {\r\n                parentGeom = parent.geometry;\r\n                if (parentGeom.attributes.position) {\r\n                    parentGeom.computeBoundingBox();\r\n                    var size = new THREE.Vector3();\r\n                    parentGeom.boundingBox.getSize(size);\r\n                    var height = (size.y * 0.001 + Constants.textPadding.height) *\r\n                        this.data.boundingRadius;\r\n                    var planeGeom = new THREE.PlaneGeometry(1, 1, 1, 1);\r\n                    var planeMat = new THREE.MeshStandardMaterial();\r\n                    planeMat.color = new THREE.Color(Constants.colors.black);\r\n                    planeMat.transparent = true;\r\n                    planeMat.opacity = 0.9;\r\n                    planeMat.flatShading = true;\r\n                    planeMat.roughness = 1;\r\n                    planeMat.depthTest = false;\r\n                    var mesh = new THREE.Mesh(planeGeom, planeMat);\r\n                    mesh.scale.set((size.x * 0.001 + Constants.textPadding.width) *\r\n                        this.data.boundingRadius, height, 1);\r\n                    mesh.renderOrder = Constants.topLayerRenderOrder - 1;\r\n                    mesh.position.add(new THREE.Vector3(0, height * (this.data.frustrumDistance / 4), 0));\r\n                    this.el.object3D.add(mesh);\r\n                    this.state.hasUpdated = true;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-billboard\", {\r\n    schema: {\r\n        cameraPosition: { type: \"string\" },\r\n        cameraTarget: { type: \"string\", default: \"0 0 0\" },\r\n        controlsType: { type: \"string\", default: \"orbit\" },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        worldPosition: { type: \"string\" }\r\n    },\r\n    init: function () {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n    },\r\n    // tslint:disable-next-line: no-empty\r\n    bindMethods: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    addEventListeners: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    removeEventListeners: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    tickFunction: function () {\r\n        var camera = this.el.sceneEl.camera;\r\n        var object = this.el.object3D;\r\n        var worldPosition = ThreeUtils.stringToVector3(this.data.worldPosition);\r\n        var cameraPosition = ThreeUtils.stringToVector3(this.data.cameraPosition);\r\n        ThreeUtils.lookToFrustrumSpace(object, camera, worldPosition, cameraPosition);\r\n        object.up.copy(this.el.sceneEl.camera.up);\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\r\nfunction commonjsRequire() {\r\n    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\r\n}\r\nfunction createCommonjsModule(fn, module) {\r\n    return module = { exports: {} }, fn(module, module.exports), module.exports;\r\n}\r\nvar src$1 = createCommonjsModule(function (module, exports) {\r\n    (function () {\r\n        var root = this;\r\n        var has_require = typeof commonjsRequire !== 'undefined';\r\n        var THREE = root.THREE || (has_require && three_module);\r\n        if (!THREE)\r\n            throw new Error('MeshLine requires three.js');\r\n        function MeshLine() {\r\n            THREE.BufferGeometry.call(this);\r\n            this.type = 'MeshLine';\r\n            this.positions = [];\r\n            this.previous = [];\r\n            this.next = [];\r\n            this.side = [];\r\n            this.width = [];\r\n            this.indices_array = [];\r\n            this.uvs = [];\r\n            this.counters = [];\r\n            this._vertices = [];\r\n            this._bufferArray = [];\r\n            this.widthCallback = null;\r\n            // Used to raycast\r\n            this.matrixWorld = new THREE.Matrix4();\r\n            // to support previous api\r\n            Object.defineProperties(this, {\r\n                geometry: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this;\r\n                    },\r\n                    set: function (value) {\r\n                        this.setFromGeometry(value);\r\n                    },\r\n                },\r\n                vertices: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this._vertices;\r\n                    },\r\n                    set: function (value) {\r\n                        this.setVertices(value);\r\n                    },\r\n                },\r\n                bufferArray: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this._bufferArray;\r\n                    },\r\n                    set: function (value) {\r\n                        this.setBufferArray(value);\r\n                    },\r\n                },\r\n            });\r\n        }\r\n        MeshLine.prototype = Object.create(THREE.BufferGeometry.prototype);\r\n        MeshLine.prototype.constructor = MeshLine;\r\n        MeshLine.prototype.isMeshLine = true;\r\n        MeshLine.prototype.setMatrixWorld = function (matrixWorld) {\r\n            this.matrixWorld = matrixWorld;\r\n        };\r\n        MeshLine.prototype.setFromGeometry = function (g, c) {\r\n            if (g instanceof THREE.Geometry) {\r\n                this.setVertices(g.vertices, c);\r\n            }\r\n            if (g instanceof THREE.BufferGeometry) {\r\n                this.setBufferArray(g.getAttribute('position').array, c);\r\n            }\r\n            if (g instanceof Float32Array || g instanceof Array) {\r\n                // to support previous api\r\n                this.setBufferArray(g, c);\r\n            }\r\n        };\r\n        // to support previous api\r\n        MeshLine.prototype.setGeometry = function (g, c) {\r\n            this.setFromGeometry(g, c);\r\n        };\r\n        MeshLine.prototype.setVertices = function (vts, wcb) {\r\n            this._vertices = vts;\r\n            this.widthCallback = wcb || this.widthCallback;\r\n            this.positions = [];\r\n            this.counters = [];\r\n            for (var j = 0; j < vts.length; j++) {\r\n                var v = vts[j];\r\n                var c = j / vts.length;\r\n                this.positions.push(v.x, v.y, v.z);\r\n                this.positions.push(v.x, v.y, v.z);\r\n                this.counters.push(c);\r\n                this.counters.push(c);\r\n            }\r\n            this.process();\r\n        };\r\n        MeshLine.prototype.setBufferArray = function (ba, wcb) {\r\n            this._bufferArray = ba;\r\n            this.widthCallback = wcb || this.widthCallback;\r\n            this.positions = [];\r\n            this.counters = [];\r\n            for (var j = 0; j < ba.length; j += 3) {\r\n                var c = j / ba.length;\r\n                this.positions.push(ba[j], ba[j + 1], ba[j + 2]);\r\n                this.positions.push(ba[j], ba[j + 1], ba[j + 2]);\r\n                this.counters.push(c);\r\n                this.counters.push(c);\r\n            }\r\n            this.process();\r\n        };\r\n        function MeshLineRaycast(raycaster, intersects) {\r\n            var inverseMatrix = new THREE.Matrix4();\r\n            var ray = new THREE.Ray();\r\n            var sphere = new THREE.Sphere();\r\n            var interRay = new THREE.Vector3();\r\n            var geometry = this.geometry;\r\n            // Checking boundingSphere distance to ray\r\n            sphere.copy(geometry.boundingSphere);\r\n            sphere.applyMatrix4(this.matrixWorld);\r\n            if (raycaster.ray.intersectSphere(sphere, interRay) === false) {\r\n                return;\r\n            }\r\n            inverseMatrix.getInverse(this.matrixWorld);\r\n            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\r\n            var vStart = new THREE.Vector3();\r\n            var vEnd = new THREE.Vector3();\r\n            var interSegment = new THREE.Vector3();\r\n            var step = this instanceof THREE.LineSegments ? 2 : 1;\r\n            var index = geometry.index;\r\n            var attributes = geometry.attributes;\r\n            if (index !== null) {\r\n                var indices = index.array;\r\n                var positions = attributes.position.array;\r\n                var widths = attributes.width.array;\r\n                for (var i = 0, l = indices.length - 1; i < l; i += step) {\r\n                    var a = indices[i];\r\n                    var b = indices[i + 1];\r\n                    vStart.fromArray(positions, a * 3);\r\n                    vEnd.fromArray(positions, b * 3);\r\n                    var width = widths[Math.floor(i / 3)] != undefined ? widths[Math.floor(i / 3)] : 1;\r\n                    var precision = raycaster.params.Line.threshold + (this.material.lineWidth * width) / 2;\r\n                    var precisionSq = precision * precision;\r\n                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\r\n                    if (distSq > precisionSq)\r\n                        continue;\r\n                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\r\n                    var distance = raycaster.ray.origin.distanceTo(interRay);\r\n                    if (distance < raycaster.near || distance > raycaster.far)\r\n                        continue;\r\n                    intersects.push({\r\n                        distance: distance,\r\n                        // What do we want? intersection point on the ray or on the segment??\r\n                        // point: raycaster.ray.at( distance ),\r\n                        point: interSegment.clone().applyMatrix4(this.matrixWorld),\r\n                        index: i,\r\n                        face: null,\r\n                        faceIndex: null,\r\n                        object: this,\r\n                    });\r\n                    // make event only fire once\r\n                    i = l;\r\n                }\r\n            }\r\n        }\r\n        MeshLine.prototype.raycast = MeshLineRaycast;\r\n        MeshLine.prototype.compareV3 = function (a, b) {\r\n            var aa = a * 6;\r\n            var ab = b * 6;\r\n            return (this.positions[aa] === this.positions[ab] &&\r\n                this.positions[aa + 1] === this.positions[ab + 1] &&\r\n                this.positions[aa + 2] === this.positions[ab + 2]);\r\n        };\r\n        MeshLine.prototype.copyV3 = function (a) {\r\n            var aa = a * 6;\r\n            return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\r\n        };\r\n        MeshLine.prototype.process = function () {\r\n            var l = this.positions.length / 6;\r\n            this.previous = [];\r\n            this.next = [];\r\n            this.side = [];\r\n            this.width = [];\r\n            this.indices_array = [];\r\n            this.uvs = [];\r\n            var w;\r\n            var v;\r\n            // initial previous points\r\n            if (this.compareV3(0, l - 1)) {\r\n                v = this.copyV3(l - 2);\r\n            }\r\n            else {\r\n                v = this.copyV3(0);\r\n            }\r\n            this.previous.push(v[0], v[1], v[2]);\r\n            this.previous.push(v[0], v[1], v[2]);\r\n            for (var j = 0; j < l; j++) {\r\n                // sides\r\n                this.side.push(1);\r\n                this.side.push(-1);\r\n                // widths\r\n                if (this.widthCallback)\r\n                    w = this.widthCallback(j / (l - 1));\r\n                else\r\n                    w = 1;\r\n                this.width.push(w);\r\n                this.width.push(w);\r\n                // uvs\r\n                this.uvs.push(j / (l - 1), 0);\r\n                this.uvs.push(j / (l - 1), 1);\r\n                if (j < l - 1) {\r\n                    // points previous to poisitions\r\n                    v = this.copyV3(j);\r\n                    this.previous.push(v[0], v[1], v[2]);\r\n                    this.previous.push(v[0], v[1], v[2]);\r\n                    // indices\r\n                    var n = j * 2;\r\n                    this.indices_array.push(n, n + 1, n + 2);\r\n                    this.indices_array.push(n + 2, n + 1, n + 3);\r\n                }\r\n                if (j > 0) {\r\n                    // points after poisitions\r\n                    v = this.copyV3(j);\r\n                    this.next.push(v[0], v[1], v[2]);\r\n                    this.next.push(v[0], v[1], v[2]);\r\n                }\r\n            }\r\n            // last next point\r\n            if (this.compareV3(l - 1, 0)) {\r\n                v = this.copyV3(1);\r\n            }\r\n            else {\r\n                v = this.copyV3(l - 1);\r\n            }\r\n            this.next.push(v[0], v[1], v[2]);\r\n            this.next.push(v[0], v[1], v[2]);\r\n            // redefining the attribute seems to prevent range errors \r\n            // if the user sets a differing number of vertices\r\n            if (!this._attributes || this._attributes.position.count !== this.positions.length) {\r\n                this._attributes = {\r\n                    position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\r\n                    previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\r\n                    next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\r\n                    side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\r\n                    width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\r\n                    uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\r\n                    index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\r\n                    counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1),\r\n                };\r\n            }\r\n            else {\r\n                this._attributes.position.copyArray(new Float32Array(this.positions));\r\n                this._attributes.position.needsUpdate = true;\r\n                this._attributes.previous.copyArray(new Float32Array(this.previous));\r\n                this._attributes.previous.needsUpdate = true;\r\n                this._attributes.next.copyArray(new Float32Array(this.next));\r\n                this._attributes.next.needsUpdate = true;\r\n                this._attributes.side.copyArray(new Float32Array(this.side));\r\n                this._attributes.side.needsUpdate = true;\r\n                this._attributes.width.copyArray(new Float32Array(this.width));\r\n                this._attributes.width.needsUpdate = true;\r\n                this._attributes.uv.copyArray(new Float32Array(this.uvs));\r\n                this._attributes.uv.needsUpdate = true;\r\n                this._attributes.index.copyArray(new Uint16Array(this.indices_array));\r\n                this._attributes.index.needsUpdate = true;\r\n            }\r\n            this.setAttribute('position', this._attributes.position);\r\n            this.setAttribute('previous', this._attributes.previous);\r\n            this.setAttribute('next', this._attributes.next);\r\n            this.setAttribute('side', this._attributes.side);\r\n            this.setAttribute('width', this._attributes.width);\r\n            this.setAttribute('uv', this._attributes.uv);\r\n            this.setAttribute('counters', this._attributes.counters);\r\n            this.setIndex(this._attributes.index);\r\n            this.computeBoundingSphere();\r\n            this.computeBoundingBox();\r\n        };\r\n        function memcpy(src, srcOffset, dst, dstOffset, length) {\r\n            var i;\r\n            src = src.subarray || src.slice ? src : src.buffer;\r\n            dst = dst.subarray || dst.slice ? dst : dst.buffer;\r\n            src = srcOffset\r\n                ? src.subarray\r\n                    ? src.subarray(srcOffset, length && srcOffset + length)\r\n                    : src.slice(srcOffset, length && srcOffset + length)\r\n                : src;\r\n            if (dst.set) {\r\n                dst.set(src, dstOffset);\r\n            }\r\n            else {\r\n                for (i = 0; i < src.length; i++) {\r\n                    dst[i + dstOffset] = src[i];\r\n                }\r\n            }\r\n            return dst;\r\n        }\r\n        /**\r\n         * Fast method to advance the line by one position.  The oldest position is removed.\r\n         * @param position\r\n         */\r\n        MeshLine.prototype.advance = function (position) {\r\n            var positions = this._attributes.position.array;\r\n            var previous = this._attributes.previous.array;\r\n            var next = this._attributes.next.array;\r\n            var l = positions.length;\r\n            // PREVIOUS\r\n            memcpy(positions, 0, previous, 0, l);\r\n            // POSITIONS\r\n            memcpy(positions, 6, positions, 0, l - 6);\r\n            positions[l - 6] = position.x;\r\n            positions[l - 5] = position.y;\r\n            positions[l - 4] = position.z;\r\n            positions[l - 3] = position.x;\r\n            positions[l - 2] = position.y;\r\n            positions[l - 1] = position.z;\r\n            // NEXT\r\n            memcpy(positions, 6, next, 0, l - 6);\r\n            next[l - 6] = position.x;\r\n            next[l - 5] = position.y;\r\n            next[l - 4] = position.z;\r\n            next[l - 3] = position.x;\r\n            next[l - 2] = position.y;\r\n            next[l - 1] = position.z;\r\n            this._attributes.position.needsUpdate = true;\r\n            this._attributes.previous.needsUpdate = true;\r\n            this._attributes.next.needsUpdate = true;\r\n        };\r\n        THREE.ShaderChunk['meshline_vert'] = [\r\n            '',\r\n            THREE.ShaderChunk.logdepthbuf_pars_vertex,\r\n            THREE.ShaderChunk.fog_pars_vertex,\r\n            '',\r\n            'attribute vec3 previous;',\r\n            'attribute vec3 next;',\r\n            'attribute float side;',\r\n            'attribute float width;',\r\n            'attribute float counters;',\r\n            '',\r\n            'uniform vec2 resolution;',\r\n            'uniform float lineWidth;',\r\n            'uniform vec3 color;',\r\n            'uniform float opacity;',\r\n            'uniform float sizeAttenuation;',\r\n            '',\r\n            'varying vec2 vUV;',\r\n            'varying vec4 vColor;',\r\n            'varying float vCounters;',\r\n            '',\r\n            'vec2 fix( vec4 i, float aspect ) {',\r\n            '',\r\n            '    vec2 res = i.xy / i.w;',\r\n            '    res.x *= aspect;',\r\n            '\t vCounters = counters;',\r\n            '    return res;',\r\n            '',\r\n            '}',\r\n            '',\r\n            'void main() {',\r\n            '',\r\n            '    float aspect = resolution.x / resolution.y;',\r\n            '',\r\n            '    vColor = vec4( color, opacity );',\r\n            '    vUV = uv;',\r\n            '',\r\n            '    mat4 m = projectionMatrix * modelViewMatrix;',\r\n            '    vec4 finalPosition = m * vec4( position, 1.0 );',\r\n            '    vec4 prevPos = m * vec4( previous, 1.0 );',\r\n            '    vec4 nextPos = m * vec4( next, 1.0 );',\r\n            '',\r\n            '    vec2 currentP = fix( finalPosition, aspect );',\r\n            '    vec2 prevP = fix( prevPos, aspect );',\r\n            '    vec2 nextP = fix( nextPos, aspect );',\r\n            '',\r\n            '    float w = lineWidth * width;',\r\n            '',\r\n            '    vec2 dir;',\r\n            '    if( nextP == currentP ) dir = normalize( currentP - prevP );',\r\n            '    else if( prevP == currentP ) dir = normalize( nextP - currentP );',\r\n            '    else {',\r\n            '        vec2 dir1 = normalize( currentP - prevP );',\r\n            '        vec2 dir2 = normalize( nextP - currentP );',\r\n            '        dir = normalize( dir1 + dir2 );',\r\n            '',\r\n            '        vec2 perp = vec2( -dir1.y, dir1.x );',\r\n            '        vec2 miter = vec2( -dir.y, dir.x );',\r\n            '        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );',\r\n            '',\r\n            '    }',\r\n            '',\r\n            '    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;',\r\n            '    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );',\r\n            '    normal.xy *= .5 * w;',\r\n            '    normal *= projectionMatrix;',\r\n            '    if( sizeAttenuation == 0. ) {',\r\n            '        normal.xy *= finalPosition.w;',\r\n            '        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;',\r\n            '    }',\r\n            '',\r\n            '    finalPosition.xy += normal.xy * side;',\r\n            '',\r\n            '    gl_Position = finalPosition;',\r\n            '',\r\n            THREE.ShaderChunk.logdepthbuf_vertex,\r\n            THREE.ShaderChunk.fog_vertex && '    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n            THREE.ShaderChunk.fog_vertex,\r\n            '}',\r\n        ].join('\\n');\r\n        THREE.ShaderChunk['meshline_frag'] = [\r\n            '',\r\n            THREE.ShaderChunk.fog_pars_fragment,\r\n            THREE.ShaderChunk.logdepthbuf_pars_fragment,\r\n            '',\r\n            'uniform sampler2D map;',\r\n            'uniform sampler2D alphaMap;',\r\n            'uniform float useMap;',\r\n            'uniform float useAlphaMap;',\r\n            'uniform float useDash;',\r\n            'uniform float dashArray;',\r\n            'uniform float dashOffset;',\r\n            'uniform float dashRatio;',\r\n            'uniform float visibility;',\r\n            'uniform float alphaTest;',\r\n            'uniform vec2 repeat;',\r\n            '',\r\n            'varying vec2 vUV;',\r\n            'varying vec4 vColor;',\r\n            'varying float vCounters;',\r\n            '',\r\n            'void main() {',\r\n            '',\r\n            THREE.ShaderChunk.logdepthbuf_fragment,\r\n            '',\r\n            '    vec4 c = vColor;',\r\n            '    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );',\r\n            '    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;',\r\n            '    if( c.a < alphaTest ) discard;',\r\n            '    if( useDash == 1. ){',\r\n            '        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));',\r\n            '    }',\r\n            '    gl_FragColor = c;',\r\n            '    gl_FragColor.a *= step(vCounters, visibility);',\r\n            '',\r\n            THREE.ShaderChunk.fog_fragment,\r\n            '}',\r\n        ].join('\\n');\r\n        function MeshLineMaterial(parameters) {\r\n            THREE.ShaderMaterial.call(this, {\r\n                uniforms: Object.assign({}, THREE.UniformsLib.fog, {\r\n                    lineWidth: { value: 1 },\r\n                    map: { value: null },\r\n                    useMap: { value: 0 },\r\n                    alphaMap: { value: null },\r\n                    useAlphaMap: { value: 0 },\r\n                    color: { value: new THREE.Color(0xffffff) },\r\n                    opacity: { value: 1 },\r\n                    resolution: { value: new THREE.Vector2(1, 1) },\r\n                    sizeAttenuation: { value: 1 },\r\n                    dashArray: { value: 0 },\r\n                    dashOffset: { value: 0 },\r\n                    dashRatio: { value: 0.5 },\r\n                    useDash: { value: 0 },\r\n                    visibility: { value: 1 },\r\n                    alphaTest: { value: 0 },\r\n                    repeat: { value: new THREE.Vector2(1, 1) },\r\n                }),\r\n                vertexShader: THREE.ShaderChunk.meshline_vert,\r\n                fragmentShader: THREE.ShaderChunk.meshline_frag,\r\n            });\r\n            this.type = 'MeshLineMaterial';\r\n            Object.defineProperties(this, {\r\n                lineWidth: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.lineWidth.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.lineWidth.value = value;\r\n                    },\r\n                },\r\n                map: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.map.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.map.value = value;\r\n                    },\r\n                },\r\n                useMap: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.useMap.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.useMap.value = value;\r\n                    },\r\n                },\r\n                alphaMap: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.alphaMap.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.alphaMap.value = value;\r\n                    },\r\n                },\r\n                useAlphaMap: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.useAlphaMap.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.useAlphaMap.value = value;\r\n                    },\r\n                },\r\n                color: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.color.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.color.value = value;\r\n                    },\r\n                },\r\n                opacity: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.opacity.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.opacity.value = value;\r\n                    },\r\n                },\r\n                resolution: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.resolution.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.resolution.value.copy(value);\r\n                    },\r\n                },\r\n                sizeAttenuation: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.sizeAttenuation.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.sizeAttenuation.value = value;\r\n                    },\r\n                },\r\n                dashArray: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.dashArray.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.dashArray.value = value;\r\n                        this.useDash = value !== 0 ? 1 : 0;\r\n                    },\r\n                },\r\n                dashOffset: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.dashOffset.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.dashOffset.value = value;\r\n                    },\r\n                },\r\n                dashRatio: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.dashRatio.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.dashRatio.value = value;\r\n                    },\r\n                },\r\n                useDash: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.useDash.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.useDash.value = value;\r\n                    },\r\n                },\r\n                visibility: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.visibility.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.visibility.value = value;\r\n                    },\r\n                },\r\n                alphaTest: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.alphaTest.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.alphaTest.value = value;\r\n                    },\r\n                },\r\n                repeat: {\r\n                    enumerable: true,\r\n                    get: function () {\r\n                        return this.uniforms.repeat.value;\r\n                    },\r\n                    set: function (value) {\r\n                        this.uniforms.repeat.value.copy(value);\r\n                    },\r\n                },\r\n            });\r\n            this.setValues(parameters);\r\n        }\r\n        MeshLineMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);\r\n        MeshLineMaterial.prototype.constructor = MeshLineMaterial;\r\n        MeshLineMaterial.prototype.isMeshLineMaterial = true;\r\n        MeshLineMaterial.prototype.copy = function (source) {\r\n            THREE.ShaderMaterial.prototype.copy.call(this, source);\r\n            this.lineWidth = source.lineWidth;\r\n            this.map = source.map;\r\n            this.useMap = source.useMap;\r\n            this.alphaMap = source.alphaMap;\r\n            this.useAlphaMap = source.useAlphaMap;\r\n            this.color.copy(source.color);\r\n            this.opacity = source.opacity;\r\n            this.resolution.copy(source.resolution);\r\n            this.sizeAttenuation = source.sizeAttenuation;\r\n            this.dashArray.copy(source.dashArray);\r\n            this.dashOffset.copy(source.dashOffset);\r\n            this.dashRatio.copy(source.dashRatio);\r\n            this.useDash = source.useDash;\r\n            this.visibility = source.visibility;\r\n            this.alphaTest = source.alphaTest;\r\n            this.repeat.copy(source.repeat);\r\n            return this;\r\n        };\r\n        {\r\n            if (module.exports) {\r\n                exports = module.exports = {\r\n                    MeshLine: MeshLine,\r\n                    MeshLineMaterial: MeshLineMaterial,\r\n                    MeshLineRaycast: MeshLineRaycast,\r\n                };\r\n            }\r\n            exports.MeshLine = MeshLine;\r\n            exports.MeshLineMaterial = MeshLineMaterial;\r\n            exports.MeshLineRaycast = MeshLineRaycast;\r\n        }\r\n    }.call(commonjsGlobal));\r\n});\r\nvar src_1 = src$1.MeshLine;\r\nvar src_2 = src$1.MeshLineMaterial;\r\nAFRAME.registerComponent(\"al-bounding-box\", {\r\n    schema: {\r\n        boundingBoxWidth: { type: \"number\", default: 2 },\r\n        color: { type: \"string\", default: \"#fff\" },\r\n        scale: { type: \"string\" },\r\n        enabled: { type: \"boolean\", default: true },\r\n        topLayerRenderOrder: { type: \"number\", default: 999 }\r\n    },\r\n    init: function () {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.state = {\r\n            box: new THREE.Box3()\r\n        };\r\n    },\r\n    bindMethods: function () { },\r\n    addEventListeners: function () { },\r\n    removeEventListeners: function () { },\r\n    update: function () {\r\n        var _this_1 = this;\r\n        var el = this.el;\r\n        var state = this.state;\r\n        var scale = AFRAME.utils.coordinates.parse(this.data.scale);\r\n        state.box.setFromCenterAndSize(new THREE.Vector3(0, 0, 0), scale);\r\n        // Add a second mesh for raycasting against volumes\r\n        var geometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z);\r\n        var material = new THREE.MeshBasicMaterial({\r\n            color: this.data.color,\r\n            visible: false\r\n        });\r\n        var mesh = new THREE.Mesh(geometry, material);\r\n        el.setObject3D(\"mesh\", mesh);\r\n        // Parent of all MeshLines that form the bounding box\r\n        var BboxLineController = new THREE.Mesh();\r\n        BboxLineController.renderOrder = this.data.topLayerRenderOrder - 5;\r\n        var MeshLineMat = new src_2({\r\n            // - THREE.Color to paint the line width, or tint the texture with\r\n            color: new THREE.Color(this.data.color),\r\n            // - cutoff value from 0 to 1\r\n            alphaTest: 0,\r\n            // - THREE.Vector2 specifying the canvas size (REQUIRED)\r\n            resolution: new THREE.Vector2(this.el.sceneEl.canvas.clientWidth, this.el.sceneEl.canvas.clientHeight),\r\n            // - makes the line width constant regardless distance (1 unit is 1px on screen) (0 - attenuate, 1 - don't attenuate)\r\n            sizeAttenuation: 0,\r\n            // - float defining width (if sizeAttenuation is true, it's world units; else is screen pixels)\r\n            lineWidth: this.data.boundingBoxWidth\r\n        });\r\n        // MeshLineMat.transparent = this.data.opacity === 0;\r\n        // // - alpha value from 0 to 1 (requires transparent set to true)\r\n        // MeshLineMat.opacity = this.data.opactiy;\r\n        var TopLeftFront = new THREE.Vector3(scale.x, scale.y, scale.z).multiplyScalar(0.5);\r\n        var TopRightFront = new THREE.Vector3(-scale.x, scale.y, scale.z).multiplyScalar(0.5);\r\n        var TopLeftBack = new THREE.Vector3(scale.x, scale.y, -scale.z).multiplyScalar(0.5);\r\n        var TopRightBack = new THREE.Vector3(-scale.x, scale.y, -scale.z).multiplyScalar(0.5);\r\n        var BottomLeftFront = new THREE.Vector3(scale.x, -scale.y, scale.z).multiplyScalar(0.5);\r\n        var BottomRightFront = new THREE.Vector3(-scale.x, -scale.y, scale.z).multiplyScalar(0.5);\r\n        var BottomLeftBack = new THREE.Vector3(scale.x, -scale.y, -scale.z).multiplyScalar(0.5);\r\n        var BottomRightBack = new THREE.Vector3(-scale.x, -scale.y, -scale.z).multiplyScalar(0.5);\r\n        // Line 1\r\n        var TLF_TRF = new THREE.Geometry();\r\n        TLF_TRF.vertices.push(TopLeftFront);\r\n        TLF_TRF.vertices.push(TopRightFront);\r\n        var line1 = new src_1();\r\n        line1.setGeometry(TLF_TRF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh1 = new THREE.Mesh(line1.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh1);\r\n        // Line 2\r\n        var TLF_TLB = new THREE.Geometry();\r\n        TLF_TLB.vertices.push(TopLeftFront);\r\n        TLF_TLB.vertices.push(TopLeftBack);\r\n        var line2 = new src_1();\r\n        line2.setGeometry(TLF_TLB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh2 = new THREE.Mesh(line2.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh2);\r\n        // Line 3\r\n        var TLF_BLF = new THREE.Geometry();\r\n        TLF_BLF.vertices.push(TopLeftFront);\r\n        TLF_BLF.vertices.push(BottomLeftFront);\r\n        var line3 = new src_1();\r\n        line3.setGeometry(TLF_BLF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh3 = new THREE.Mesh(line3.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh3);\r\n        // Line 4\r\n        var TRB_TRF = new THREE.Geometry();\r\n        TRB_TRF.vertices.push(TopRightBack);\r\n        TRB_TRF.vertices.push(TopRightFront);\r\n        var line4 = new src_1();\r\n        line4.setGeometry(TRB_TRF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh4 = new THREE.Mesh(line4.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh4);\r\n        // Line 5\r\n        var TRB_TLB = new THREE.Geometry();\r\n        TRB_TLB.vertices.push(TopRightBack);\r\n        TRB_TLB.vertices.push(TopLeftBack);\r\n        var line5 = new src_1();\r\n        line5.setGeometry(TRB_TLB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh5 = new THREE.Mesh(line5.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh5);\r\n        // Line 6\r\n        var TRB_BRB = new THREE.Geometry();\r\n        TRB_BRB.vertices.push(TopRightBack);\r\n        TRB_BRB.vertices.push(BottomRightBack);\r\n        var line6 = new src_1();\r\n        line6.setGeometry(TRB_BRB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh6 = new THREE.Mesh(line6.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh6);\r\n        // Line 7\r\n        var BRB_BRF = new THREE.Geometry();\r\n        BRB_BRF.vertices.push(BottomRightBack);\r\n        BRB_BRF.vertices.push(BottomRightFront);\r\n        var line7 = new src_1();\r\n        line7.setGeometry(BRB_BRF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh7 = new THREE.Mesh(line7.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh7);\r\n        // Line 8\r\n        var BRB_BLB = new THREE.Geometry();\r\n        BRB_BLB.vertices.push(BottomRightBack);\r\n        BRB_BLB.vertices.push(BottomLeftBack);\r\n        var line8 = new src_1();\r\n        line8.setGeometry(BRB_BLB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh8 = new THREE.Mesh(line8.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh8);\r\n        // Line 9\r\n        var BLF_BLB = new THREE.Geometry();\r\n        BLF_BLB.vertices.push(BottomLeftFront);\r\n        BLF_BLB.vertices.push(BottomLeftBack);\r\n        var line9 = new src_1();\r\n        line9.setGeometry(BLF_BLB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh9 = new THREE.Mesh(line9.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh9);\r\n        // Line 10\r\n        var BLF_BRF = new THREE.Geometry();\r\n        BLF_BRF.vertices.push(BottomLeftFront);\r\n        BLF_BRF.vertices.push(BottomRightFront);\r\n        var line10 = new src_1();\r\n        line10.setGeometry(BLF_BRF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh10 = new THREE.Mesh(line10.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh10);\r\n        // Line 11\r\n        var TRF_BRF = new THREE.Geometry();\r\n        TRF_BRF.vertices.push(TopRightFront);\r\n        TRF_BRF.vertices.push(BottomRightFront);\r\n        var line11 = new src_1();\r\n        line11.setGeometry(TRF_BRF, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh11 = new THREE.Mesh(line11.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh11);\r\n        // Line 12\r\n        var TLB_BLB = new THREE.Geometry();\r\n        TLB_BLB.vertices.push(TopLeftBack);\r\n        TLB_BLB.vertices.push(BottomLeftBack);\r\n        var line12 = new src_1();\r\n        line12.setGeometry(TLB_BLB, function (_p) { return _this_1.data.boundingBoxWidth; });\r\n        var mesh12 = new THREE.Mesh(line12.geometry, MeshLineMat);\r\n        BboxLineController.add(mesh12);\r\n        state.mesh = BboxLineController;\r\n        state.material = MeshLineMat;\r\n        if (this.data.enabled) {\r\n            el.setObject3D(\"bbox\", BboxLineController);\r\n        }\r\n        else if (el.object3DMap.bbox) {\r\n            el.removeObject3D(\"bbox\");\r\n        }\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n        this.el.removeObject3D(\"mesh\");\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-child-hover-visible\", {\r\n    schema: {\r\n        minFrameMS: { type: \"number\", default: 15 }\r\n    },\r\n    init: function () {\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.hovered = false;\r\n    },\r\n    bindMethods: function () {\r\n        this.pointerOver = this.pointerOver.bind(this);\r\n        this.pointerOut = this.pointerOut.bind(this);\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.addEventListener(\"raycaster-intersected\", this.pointerOver, {\r\n            capture: true,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected-cleared\", this.pointerOut, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.removeEventListener(\"raycaster-intersected\", this.pointerOver);\r\n        this.el.removeEventListener(\"raycaster-intersected-cleared\", this.pointerOut);\r\n    },\r\n    pointerOver: function (_event) {\r\n        this.hovered = true;\r\n    },\r\n    pointerOut: function (_event) {\r\n        this.hovered = false;\r\n    },\r\n    tickFunction: function () {\r\n        var el = this.el;\r\n        var firstChild = el.firstChild.firstChild;\r\n        if (firstChild) {\r\n            var obj3d = firstChild.object3D;\r\n            // show/hide label\r\n            if (this.hovered) {\r\n                obj3d.visible = true;\r\n            }\r\n            else {\r\n                obj3d.visible = false;\r\n            }\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-control-lights\", {\r\n    schema: {\r\n        color: { type: \"string\", default: \"#fff\" },\r\n        controlsType: { type: \"string\", default: \"orbit\" },\r\n        lightIntensity: { type: \"number\", default: 0.8 },\r\n        minFrameMS: { type: \"number\", default: 15 }\r\n    },\r\n    init: function () {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        var parent = this.el.getObject3D(\"camera\");\r\n        var light1 = new THREE.DirectionalLight(new THREE.Color(this.data.color), this.data.lightIntensity);\r\n        light1.position.copy(new THREE.Vector3(1, 1, 1));\r\n        parent.add(light1);\r\n        var light2 = new THREE.DirectionalLight(new THREE.Color(this.data.color), this.data.lightIntensity);\r\n        light2.position.copy(new THREE.Vector3(-1, -1, -1));\r\n        parent.add(light2);\r\n    },\r\n    bindMethods: function () { },\r\n    addEventListeners: function () { },\r\n    removeEventListeners: function () { },\r\n    update: function (oldData) {\r\n        // Reset the up vector if we change camera mode\r\n        if (this.data.controlsType !== oldData.controlsType) {\r\n            this.el.object3D.up.copy(this.el.sceneEl.camera.up.clone());\r\n        }\r\n    },\r\n    tick: function () { },\r\n    remove: function () { }\r\n});\r\n// https://github.com/donmccurdy/aframe-extras/blob/master/src/misc/cube-env-map.js\r\n/**\r\n * @param  {Array<THREE.Material>|THREE.Material} material\r\n * @return {Array<THREE.Material>}\r\n */\r\nfunction ensureMaterialArray(material) {\r\n    if (!material) {\r\n        return [];\r\n    }\r\n    else if (Array.isArray(material)) {\r\n        return material;\r\n    }\r\n    else if (material.materials) {\r\n        return material.materials;\r\n    }\r\n    else {\r\n        return [material];\r\n    }\r\n}\r\n/**\r\n * @param  {THREE.Object3D} mesh\r\n * @param  {Array<string>} materialNames\r\n * @param  {THREE.Texture} envMap\r\n * @param  {number} reflectivity  [description]\r\n */\r\nfunction applyEnvMap(mesh, materialNames, envMap, reflectivity) {\r\n    if (!mesh) {\r\n        return;\r\n    }\r\n    materialNames = materialNames || [];\r\n    mesh.traverse(function (node) {\r\n        if (!node.isMesh) {\r\n            return;\r\n        }\r\n        var meshMaterials = ensureMaterialArray(node.material);\r\n        meshMaterials.forEach(function (material) {\r\n            if (material && !(\"envMap\" in material)) {\r\n                return;\r\n            }\r\n            if (materialNames.length && materialNames.indexOf(material.name) === -1) {\r\n                return;\r\n            }\r\n            material.envMap = envMap;\r\n            material.reflectivity = reflectivity;\r\n            material.needsUpdate = true;\r\n        });\r\n    });\r\n}\r\n/**\r\n * Specifies an envMap on an entity, without replacing any existing material\r\n * properties.\r\n */\r\nAFRAME.registerComponent(\"al-cube-env-map\", {\r\n    multiple: true,\r\n    schema: {\r\n        path: { default: \"\" },\r\n        extension: { default: \"jpg\", oneOf: [\"jpg\", \"png\"] },\r\n        format: { default: \"RGBFormat\", oneOf: [\"RGBFormat\", \"RGBAFormat\"] },\r\n        enableBackground: { default: false },\r\n        reflectivity: { default: 1, min: 0, max: 1 },\r\n        materials: { default: [] }\r\n    },\r\n    init: function () {\r\n        var _this_1 = this;\r\n        var data = this.data;\r\n        if (!data.path) {\r\n            return;\r\n        }\r\n        this.texture = new THREE.CubeTextureLoader().load([\r\n            data.path + \"posx.\" + data.extension,\r\n            data.path + \"negx.\" + data.extension,\r\n            data.path + \"posy.\" + data.extension,\r\n            data.path + \"negy.\" + data.extension,\r\n            data.path + \"posz.\" + data.extension,\r\n            data.path + \"negz.\" + data.extension\r\n        ]);\r\n        this.texture.format = THREE[data.format];\r\n        this.object3dsetHandler = function () {\r\n            var mesh = _this_1.el.getObject3D(\"mesh\");\r\n            var data = _this_1.data;\r\n            applyEnvMap(mesh, data.materials, _this_1.texture, data.reflectivity);\r\n        };\r\n        this.el.addEventListener(\"object3dset\", this.object3dsetHandler);\r\n    },\r\n    update: function (oldData) {\r\n        var data = this.data;\r\n        var mesh = this.el.getObject3D(\"mesh\");\r\n        var addedMaterialNames = [];\r\n        var removedMaterialNames = [];\r\n        if (data.materials.length) {\r\n            if (oldData.materials) {\r\n                addedMaterialNames = data.materials.filter(function (name) { return !oldData.materials.includes(name); });\r\n                removedMaterialNames = oldData.materials.filter(function (name) { return !data.materials.includes(name); });\r\n            }\r\n            else {\r\n                addedMaterialNames = data.materials;\r\n            }\r\n        }\r\n        if (addedMaterialNames.length) {\r\n            applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);\r\n        }\r\n        if (removedMaterialNames.length) {\r\n            applyEnvMap(mesh, removedMaterialNames, null, 1);\r\n        }\r\n        if (oldData.materials && data.reflectivity !== oldData.reflectivity) {\r\n            var maintainedMaterialNames = data.materials.filter(function (name) { return oldData.materials.includes(name); });\r\n            if (maintainedMaterialNames.length) {\r\n                applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);\r\n            }\r\n        }\r\n        if (this.data.enableBackground && !oldData.enableBackground) {\r\n            this.setBackground(this.texture);\r\n        }\r\n        else if (!this.data.enableBackground && oldData.enableBackground) {\r\n            this.setBackground(null);\r\n        }\r\n    },\r\n    remove: function () {\r\n        this.el.removeEventListener(\"object3dset\", this.object3dsetHandler);\r\n        var mesh = this.el.getObject3D(\"mesh\");\r\n        var data = this.data;\r\n        applyEnvMap(mesh, data.materials, null, 1);\r\n        if (data.enableBackground) {\r\n            this.setBackground(null);\r\n        }\r\n    },\r\n    setBackground: function (texture) {\r\n        this.el.sceneEl.object3D.background = texture;\r\n    }\r\n});\r\n// todo: use the A-Frame default cursor when updating to a new release. PR was merged with fixes: https://github.com/aframevr/aframe/pull/4249\r\nvar EVENTS = {\r\n    CLICK: \"click\",\r\n    FUSING: \"fusing\",\r\n    MOUSEENTER: \"mouseenter\",\r\n    MOUSEDOWN: \"mousedown\",\r\n    MOUSELEAVE: \"mouseleave\",\r\n    MOUSEUP: \"mouseup\"\r\n    // TOUCHSTART: 'touchstart',\r\n    // TOUCHEND: 'touchend'\r\n};\r\nvar STATES = {\r\n    FUSING: \"cursor-fusing\",\r\n    HOVERING: \"cursor-hovering\",\r\n    HOVERED: \"cursor-hovered\"\r\n};\r\nvar CANVAS_EVENTS = {\r\n    DOWN: [\"mousedown\", \"touchstart\"],\r\n    UP: [\"mouseup\", \"touchend\"]\r\n};\r\nvar CANVAS_HOVER_CLASS = \"a-mouse-cursor-hover\";\r\n/**\r\n * Cursor component. Applies the raycaster component specifically for starting the raycaster\r\n * from the camera and pointing from camera's facing direction, and then only returning the\r\n * closest intersection. Cursor can be fine-tuned by setting raycaster properties.\r\n *\r\n * @member {object} fuseTimeout - Timeout to trigger fuse-click.\r\n * @member {Element} cursorDownEl - Entity that was last mousedowned during current click.\r\n * @member {object} intersection - Attributes of the current intersection event, including\r\n *         3D- and 2D-space coordinates. See: http://threejs.org/docs/api/core/Raycaster.html\r\n * @member {Element} intersectedEl - Currently-intersected entity. Used to keep track to\r\n *         emit events when unintersecting.\r\n */\r\nAFRAME.registerComponent(\"al-cursor\", {\r\n    dependencies: [\"raycaster\"],\r\n    schema: {\r\n        downEvents: { default: [] },\r\n        fuse: { default: AFRAME.utils.device.isMobile() },\r\n        fuseTimeout: { default: 1500, min: 0 },\r\n        mouseCursorStylesEnabled: { default: true },\r\n        upEvents: { default: [] },\r\n        rayOrigin: { default: \"entity\", oneOf: [\"mouse\", \"entity\"] }\r\n    },\r\n    init: function () {\r\n        var self = this;\r\n        this.fuseTimeout = undefined;\r\n        this.cursorDownEl = null;\r\n        this.intersectedEl = null;\r\n        this.canvasBounds = document.body.getBoundingClientRect();\r\n        this.isCursorDown = false;\r\n        // Debounce.\r\n        this.updateCanvasBounds = AFRAME.utils.debounce(function updateCanvasBounds() {\r\n            self.canvasBounds = self.el.sceneEl.canvas.getBoundingClientRect();\r\n        }, 500);\r\n        this.eventDetail = {};\r\n        this.intersectedEventDetail = { cursorEl: this.el };\r\n        // Bind methods.\r\n        this.onCursorDown = AFRAME.utils.bind(this.onCursorDown, this);\r\n        this.onCursorUp = AFRAME.utils.bind(this.onCursorUp, this);\r\n        this.onIntersection = AFRAME.utils.bind(this.onIntersection, this);\r\n        this.onIntersectionCleared = AFRAME.utils.bind(this.onIntersectionCleared, this);\r\n        this.onMouseMove = AFRAME.utils.bind(this.onMouseMove, this);\r\n    },\r\n    update: function (oldData) {\r\n        if (this.data.rayOrigin === oldData.rayOrigin) {\r\n            return;\r\n        }\r\n        this.updateMouseEventListeners();\r\n    },\r\n    play: function () {\r\n        this.addEventListeners();\r\n    },\r\n    pause: function () {\r\n        this.removeEventListeners();\r\n    },\r\n    remove: function () {\r\n        var el = this.el;\r\n        el.removeState(STATES.HOVERING);\r\n        el.removeState(STATES.FUSING);\r\n        clearTimeout(this.fuseTimeout);\r\n        if (this.intersectedEl) {\r\n            this.intersectedEl.removeState(STATES.HOVERED);\r\n        }\r\n        this.removeEventListeners();\r\n    },\r\n    addEventListeners: function () {\r\n        var canvas;\r\n        var data = this.data;\r\n        var el = this.el;\r\n        var self = this;\r\n        function addCanvasListeners() {\r\n            canvas = el.sceneEl.canvas;\r\n            if (data.downEvents.length || data.upEvents.length) {\r\n                return;\r\n            }\r\n            CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\r\n                canvas.addEventListener(downEvent, self.onCursorDown);\r\n            });\r\n            CANVAS_EVENTS.UP.forEach(function (upEvent) {\r\n                canvas.addEventListener(upEvent, self.onCursorUp);\r\n            });\r\n        }\r\n        canvas = el.sceneEl.canvas;\r\n        if (canvas) {\r\n            addCanvasListeners();\r\n        }\r\n        else {\r\n            el.sceneEl.addEventListener(\"render-target-loaded\", addCanvasListeners);\r\n        }\r\n        data.downEvents.forEach(function (downEvent) {\r\n            el.addEventListener(downEvent, self.onCursorDown);\r\n        });\r\n        data.upEvents.forEach(function (upEvent) {\r\n            el.addEventListener(upEvent, self.onCursorUp);\r\n        });\r\n        el.addEventListener(\"raycaster-intersection\", this.onIntersection);\r\n        el.addEventListener(\"raycaster-intersection-cleared\", this.onIntersectionCleared);\r\n        el.sceneEl.addEventListener(\"rendererresize\", this.updateCanvasBounds);\r\n        window.addEventListener(\"resize\", this.updateCanvasBounds);\r\n        window.addEventListener(\"scroll\", this.updateCanvasBounds);\r\n        this.updateMouseEventListeners();\r\n    },\r\n    removeEventListeners: function () {\r\n        var canvas;\r\n        var data = this.data;\r\n        var el = this.el;\r\n        var self = this;\r\n        canvas = el.sceneEl.canvas;\r\n        if (canvas && !data.downEvents.length && !data.upEvents.length) {\r\n            CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\r\n                canvas.removeEventListener(downEvent, self.onCursorDown);\r\n            });\r\n            CANVAS_EVENTS.UP.forEach(function (upEvent) {\r\n                canvas.removeEventListener(upEvent, self.onCursorUp);\r\n            });\r\n        }\r\n        data.downEvents.forEach(function (downEvent) {\r\n            el.removeEventListener(downEvent, self.onCursorDown);\r\n        });\r\n        data.upEvents.forEach(function (upEvent) {\r\n            el.removeEventListener(upEvent, self.onCursorUp);\r\n        });\r\n        el.removeEventListener(\"raycaster-intersection\", this.onIntersection);\r\n        el.removeEventListener(\"raycaster-intersection-cleared\", this.onIntersectionCleared);\r\n        canvas.removeEventListener(\"mousemove\", this.onMouseMove);\r\n        canvas.removeEventListener(\"touchstart\", this.onMouseMove);\r\n        canvas.removeEventListener(\"touchmove\", this.onMouseMove);\r\n        el.sceneEl.removeEventListener(\"rendererresize\", this.updateCanvasBounds);\r\n        window.removeEventListener(\"resize\", this.updateCanvasBounds);\r\n        window.removeEventListener(\"scroll\", this.updateCanvasBounds);\r\n    },\r\n    updateMouseEventListeners: function () {\r\n        var canvas;\r\n        var el = this.el;\r\n        canvas = el.sceneEl.canvas;\r\n        canvas.removeEventListener(\"mousemove\", this.onMouseMove);\r\n        canvas.removeEventListener(\"touchmove\", this.onMouseMove);\r\n        el.setAttribute(\"raycaster\", \"useWorldCoordinates\", false);\r\n        el.setAttribute(\"raycaster\", \"far\", 1000);\r\n        if (this.data.rayOrigin !== \"mouse\") {\r\n            return;\r\n        }\r\n        canvas.addEventListener(\"mousemove\", this.onMouseMove, false);\r\n        canvas.addEventListener(\"touchmove\", this.onMouseMove, false);\r\n        el.setAttribute(\"raycaster\", \"useWorldCoordinates\", true);\r\n        el.setAttribute(\"raycaster\", \"far\", 100000);\r\n        this.updateCanvasBounds();\r\n    },\r\n    onMouseMove: (function () {\r\n        var direction = new THREE.Vector3();\r\n        var mouse = new THREE.Vector2();\r\n        var origin = new THREE.Vector3();\r\n        var rayCasterConfig = { origin: origin, direction: direction };\r\n        return function (evt) {\r\n            var bounds = this.canvasBounds;\r\n            var camera = this.el.sceneEl.camera;\r\n            var left;\r\n            var point;\r\n            var top;\r\n            camera.parent.updateMatrixWorld();\r\n            // Calculate mouse position based on the canvas element\r\n            if (evt.type === \"touchmove\" || evt.type === \"touchstart\") {\r\n                // Track the first touch for simplicity.\r\n                point = evt.touches.item(0);\r\n            }\r\n            else {\r\n                point = evt;\r\n            }\r\n            left = point.clientX - bounds.left;\r\n            top = point.clientY - bounds.top;\r\n            mouse.x = (left / bounds.width) * 2 - 1;\r\n            mouse.y = -(top / bounds.height) * 2 + 1;\r\n            origin.setFromMatrixPosition(camera.matrixWorld);\r\n            direction\r\n                .set(mouse.x, mouse.y, 0.5)\r\n                .unproject(camera)\r\n                .sub(origin)\r\n                .normalize();\r\n            this.el.setAttribute(\"raycaster\", rayCasterConfig);\r\n            if (evt.type === \"touchmove\") {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n    })(),\r\n    /**\r\n     * Trigger mousedown and keep track of the mousedowned entity.\r\n     */\r\n    onCursorDown: function (evt) {\r\n        this.isCursorDown = true;\r\n        // Raycast again for touch.\r\n        if (this.data.rayOrigin === \"mouse\" && evt.type === \"touchstart\") {\r\n            this.onMouseMove(evt);\r\n            this.el.components.raycaster.checkIntersections();\r\n            evt.preventDefault();\r\n        }\r\n        this.twoWayEmit(EVENTS.MOUSEDOWN);\r\n        this.cursorDownEl = this.intersectedEl;\r\n    },\r\n    /**\r\n     * Trigger mouseup if:\r\n     * - Not fusing (mobile has no mouse).\r\n     * - Currently intersecting an entity.\r\n     * - Currently-intersected entity is the same as the one when mousedown was triggered,\r\n     *   in case user mousedowned one entity, dragged to another, and mouseupped.\r\n     */\r\n    onCursorUp: function (evt) {\r\n        if (!this.isCursorDown) {\r\n            return;\r\n        }\r\n        this.isCursorDown = false;\r\n        var data = this.data;\r\n        this.twoWayEmit(EVENTS.MOUSEUP);\r\n        // If intersected entity has changed since the cursorDown, still emit mouseUp on the\r\n        // previously cursorUp entity.\r\n        if (this.cursorDownEl && this.cursorDownEl !== this.intersectedEl) {\r\n            this.intersectedEventDetail.intersection = null;\r\n            this.cursorDownEl.emit(EVENTS.MOUSEUP, this.intersectedEventDetail);\r\n        }\r\n        if ((!data.fuse || data.rayOrigin === \"mouse\") &&\r\n            this.intersectedEl &&\r\n            this.cursorDownEl === this.intersectedEl) {\r\n            this.twoWayEmit(EVENTS.CLICK);\r\n        }\r\n        this.cursorDownEl = null;\r\n        if (evt.type === \"touchend\") {\r\n            evt.preventDefault();\r\n        }\r\n    },\r\n    /**\r\n     * Handle intersection.\r\n     */\r\n    onIntersection: function (evt) {\r\n        var currentIntersection;\r\n        var cursorEl = this.el;\r\n        var index;\r\n        var intersectedEl;\r\n        var intersection;\r\n        // Select closest object, excluding the cursor.\r\n        index = evt.detail.els[0] === cursorEl ? 1 : 0;\r\n        intersection = evt.detail.intersections[index];\r\n        intersectedEl = evt.detail.els[index];\r\n        // If cursor is the only intersected object, ignore the event.\r\n        if (!intersectedEl) {\r\n            return;\r\n        }\r\n        // Already intersecting this entity.\r\n        if (this.intersectedEl === intersectedEl) {\r\n            return;\r\n        }\r\n        // Ignore events further away than active intersection.\r\n        if (this.intersectedEl) {\r\n            currentIntersection = this.el.components.raycaster.getIntersection(this.intersectedEl);\r\n            if (currentIntersection &&\r\n                currentIntersection.distance <= intersection.distance) {\r\n                return;\r\n            }\r\n        }\r\n        // Unset current intersection.\r\n        this.clearCurrentIntersection(true);\r\n        this.setIntersection(intersectedEl, intersection);\r\n    },\r\n    /**\r\n     * Handle intersection cleared.\r\n     */\r\n    onIntersectionCleared: function (evt) {\r\n        var clearedEls = evt.detail.clearedEls;\r\n        // Check if the current intersection has ended\r\n        if (clearedEls.indexOf(this.intersectedEl) === -1) {\r\n            return;\r\n        }\r\n        this.clearCurrentIntersection();\r\n    },\r\n    setIntersection: function (intersectedEl) {\r\n        var cursorEl = this.el;\r\n        var data = this.data;\r\n        var self = this;\r\n        // Already intersecting.\r\n        if (this.intersectedEl === intersectedEl) {\r\n            return;\r\n        }\r\n        // Set new intersection.\r\n        this.intersectedEl = intersectedEl;\r\n        // Hovering.\r\n        cursorEl.addState(STATES.HOVERING);\r\n        intersectedEl.addState(STATES.HOVERED);\r\n        this.twoWayEmit(EVENTS.MOUSEENTER);\r\n        if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === \"mouse\") {\r\n            this.el.sceneEl.canvas.classList.add(CANVAS_HOVER_CLASS);\r\n        }\r\n        // Begin fuse if necessary.\r\n        if (data.fuseTimeout === 0 || !data.fuse) {\r\n            return;\r\n        }\r\n        cursorEl.addState(STATES.FUSING);\r\n        this.twoWayEmit(EVENTS.FUSING);\r\n        this.fuseTimeout = setTimeout(function fuse() {\r\n            cursorEl.removeState(STATES.FUSING);\r\n            self.twoWayEmit(EVENTS.CLICK);\r\n        }, data.fuseTimeout);\r\n    },\r\n    clearCurrentIntersection: function (ignoreRemaining) {\r\n        var index;\r\n        var intersection;\r\n        var intersections;\r\n        var cursorEl = this.el;\r\n        // Nothing to be cleared.\r\n        if (!this.intersectedEl) {\r\n            return;\r\n        }\r\n        // No longer hovering (or fusing).\r\n        this.intersectedEl.removeState(STATES.HOVERED);\r\n        cursorEl.removeState(STATES.HOVERING);\r\n        cursorEl.removeState(STATES.FUSING);\r\n        this.twoWayEmit(EVENTS.MOUSELEAVE);\r\n        if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === \"mouse\") {\r\n            this.el.sceneEl.canvas.classList.remove(CANVAS_HOVER_CLASS);\r\n        }\r\n        // Unset intersected entity (after emitting the event).\r\n        this.intersectedEl = null;\r\n        // Clear fuseTimeout.\r\n        clearTimeout(this.fuseTimeout);\r\n        // Set intersection to another raycasted element if any.\r\n        if (ignoreRemaining === true) {\r\n            return;\r\n        }\r\n        intersections = this.el.components.raycaster.intersections;\r\n        if (intersections.length === 0) {\r\n            return;\r\n        }\r\n        // Exclude the cursor.\r\n        index = intersections[0].object.el === cursorEl ? 1 : 0;\r\n        intersection = intersections[index];\r\n        if (!intersection) {\r\n            return;\r\n        }\r\n        this.setIntersection(intersection.object.el, intersection);\r\n    },\r\n    /**\r\n     * Helper to emit on both the cursor and the intersected entity (if exists).\r\n     */\r\n    twoWayEmit: function (evtName) {\r\n        var el = this.el;\r\n        var intersectedEl = this.intersectedEl;\r\n        var intersection;\r\n        intersection = this.el.components.raycaster.getIntersection(intersectedEl);\r\n        this.eventDetail.intersectedEl = intersectedEl;\r\n        this.eventDetail.intersection = intersection;\r\n        el.emit(evtName, this.eventDetail);\r\n        if (!intersectedEl) {\r\n            return;\r\n        }\r\n        this.intersectedEventDetail.intersection = intersection;\r\n        intersectedEl.emit(evtName, this.intersectedEventDetail);\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-edge\", {\r\n    schema: {\r\n        length: { type: \"number\" },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        node1: { type: \"vec3\" },\r\n        node2: { type: \"vec3\" },\r\n        nodeScale: { type: \"number\" },\r\n        radius: { type: \"number\" },\r\n        scale: { type: \"number\" },\r\n        selected: { type: \"boolean\" }\r\n    },\r\n    init: function () {\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.state = {\r\n            selected: true,\r\n            hovered: false\r\n        };\r\n    },\r\n    bindMethods: function () {\r\n        this.pointerDown = this.pointerDown.bind(this);\r\n        this.pointerOver = this.pointerOver.bind(this);\r\n        this.pointerOut = this.pointerOut.bind(this);\r\n        this.createMesh = this.createMesh.bind(this);\r\n        this.getMatrix = this.getMatrix.bind(this);\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.sceneEl.addEventListener(\"mousedown\", this.pointerDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected\", this.pointerOver, {\r\n            capture: true,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected-cleared\", this.pointerOut, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.sceneEl.removeEventListener(\"mousedown\", this.pointerDown);\r\n        this.el.removeEventListener(\"raycaster-intersected\", this.pointerOver);\r\n        this.el.removeEventListener(\"raycaster-intersected-cleared\", this.pointerOut);\r\n    },\r\n    pointerDown: function (_event) {\r\n        var state = this.state;\r\n        if (state.hovered) {\r\n            this.el.sceneEl.emit(AlGraphEvents.SELECTED, { type: AlGraphEntryType.EDGE, id: this.el.id }, false);\r\n        }\r\n    },\r\n    pointerOver: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = true;\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OVER, { id: this.el.id }, false);\r\n    },\r\n    pointerOut: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = false;\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OUT, {}, false);\r\n    },\r\n    getMatrix: function () {\r\n        // Set up vector of cylinder to be direction from 1 to 2; so that scale works properly\r\n        var node1Pos = ThreeUtils.objectToVector3(this.data.node1);\r\n        var node2Pos = ThreeUtils.objectToVector3(this.data.node2);\r\n        var scale = new THREE.Matrix4();\r\n        scale.makeScale(this.data.scale, this.data.scale, 1);\r\n        var mult = new THREE.Matrix4();\r\n        mult.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n        var orientation = new THREE.Matrix4();\r\n        orientation.lookAt(node1Pos, node2Pos, new THREE.Object3D().up);\r\n        // 0 === x Scale, 5 === Y scale, 10 === Z scale\r\n        orientation.multiply(scale);\r\n        orientation.multiply(mult);\r\n        return orientation;\r\n    },\r\n    createMesh: function () {\r\n        var geometry = new THREE.CylinderGeometry(this.data.radius, this.data.radius, this.data.length, 6, 4);\r\n        var material = new THREE.MeshBasicMaterial();\r\n        var mesh = new THREE.Mesh(geometry, material);\r\n        mesh.applyMatrix(this.getMatrix());\r\n        this.state.geometry = geometry;\r\n        this.state.material = material;\r\n        this.state.mesh = mesh;\r\n        var outlineGeometry = new THREE.CylinderGeometry(this.data.radius, this.data.radius, this.data.length - this.data.nodeScale * 2, 6, 4);\r\n        var outlineMaterial = ShaderUtils.getHaloMaterial();\r\n        var outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);\r\n        this.state.outlineGeometry = outlineGeometry;\r\n        this.state.outlineMaterialt = outlineMaterial;\r\n        this.state.outlineMesh = outlineMesh;\r\n        mesh.add(outlineMesh);\r\n        this.el.setObject3D(\"mesh\", mesh);\r\n        this.el.object3D.renderOrder =\r\n            Constants.topLayerRenderOrder - 2;\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    update: function (oldData) {\r\n        var state = this.state;\r\n        state.selected = this.data.selected;\r\n        // If length or radius has changed, create a new mesh\r\n        if (oldData &&\r\n            (oldData.radius !== this.data.radius ||\r\n                oldData.length !== this.data.length ||\r\n                oldData.scale !== this.data.scale)) {\r\n            this.createMesh();\r\n        }\r\n    },\r\n    tickFunction: function () {\r\n        var el = this.el;\r\n        var state = this.state;\r\n        // update color\r\n        if (state.hovered) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.hover);\r\n        }\r\n        else if (state.selected) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.active);\r\n        }\r\n        else {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.up);\r\n        }\r\n        var text = el.firstChild;\r\n        if (text) {\r\n            var obj3d = text.object3D;\r\n            // show/hide label\r\n            if (state.hovered) {\r\n                obj3d.visible = true;\r\n            }\r\n            else {\r\n                obj3d.visible = false;\r\n            }\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n        this.el.removeObject3D(\"mesh\");\r\n    }\r\n});\r\nvar AlGltfModelEvents = {\r\n    LOADED: \"al-model-loaded\",\r\n    ERROR: \"al-model-error\"\r\n};\r\nAFRAME.registerComponent(\"al-gltf-model\", {\r\n    schema: {\r\n        src: { type: \"model\", default: \"\" },\r\n        dracoDecoderPath: { type: \"string\", default: \"\" }\r\n    },\r\n    init: function () {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.model = null;\r\n        this.loader = new THREE.GLTFLoader();\r\n        this.dracoLoader = new THREE.DRACOLoader();\r\n        this.dracoLoader.setDecoderPath(this.data.dracoDecoderPath);\r\n        this.loader.setDRACOLoader(this.dracoLoader);\r\n    },\r\n    bindMethods: function () { },\r\n    addEventListeners: function () { },\r\n    removeEventListeners: function () { },\r\n    update: function (oldData) {\r\n        var self = this;\r\n        var el = this.el;\r\n        var src = this.data.src;\r\n        if (oldData && oldData.src !== src) {\r\n            this.remove();\r\n            this.loader.load(src, function gltfLoaded(gltfModel) {\r\n                self.model = gltfModel.scene || gltfModel.scenes[0];\r\n                self.model.animations = gltfModel.animations;\r\n                // The \"mesh\" is actually a whole GLTF scene\r\n                el.setObject3D(\"mesh\", self.model);\r\n                el.sceneEl.emit(AlGltfModelEvents.LOADED, {\r\n                    format: \"gltf\",\r\n                    model: self.model\r\n                }, false);\r\n            }, undefined /* onProgress */, function gltfFailed(error) {\r\n                var message = error && error.message\r\n                    ? error.message\r\n                    : \"Failed to load glTF model\";\r\n                console.warn(message);\r\n                el.sceneEl.emit(AlGltfModelEvents.ERROR, {\r\n                    format: \"gltf\",\r\n                    src: src\r\n                }, false);\r\n            });\r\n        }\r\n    },\r\n    remove: function () {\r\n        if (!this.model) {\r\n            return;\r\n        }\r\n        this.removeEventListeners();\r\n        this.el.removeObject3D(\"mesh\");\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-node\", {\r\n    schema: {\r\n        graphEnabled: { type: \"boolean\" },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        scale: { type: \"number\", default: 1 },\r\n        selected: { type: \"boolean\" }\r\n    },\r\n    init: function () {\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        var data = this.data;\r\n        var el = this.el;\r\n        var camera = el.sceneEl.camera.el.object3DMap.camera;\r\n        if (data.scale < Constants.minNodeSize) {\r\n            data.scale = Constants.minNodeSize;\r\n        }\r\n        var geometry = new THREE.SphereGeometry(data.scale, 16, 16);\r\n        var material = new THREE.MeshBasicMaterial();\r\n        var mesh = new THREE.Mesh(geometry, material);\r\n        var outlineGeometry = new THREE.SphereGeometry(data.scale, 16, 16);\r\n        var outlineMaterial = ShaderUtils.getHaloMaterial();\r\n        var outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);\r\n        mesh.add(outlineMesh);\r\n        el.setObject3D(\"mesh\", mesh);\r\n        el.object3D.renderOrder =\r\n            Constants.topLayerRenderOrder - 1;\r\n        this.state = {\r\n            selected: true,\r\n            hovered: false,\r\n            geometry: geometry,\r\n            material: material,\r\n            mesh: mesh,\r\n            outlineGeometry: outlineGeometry,\r\n            outlineMaterial: outlineMaterial,\r\n            outlineMesh: outlineMesh,\r\n            camera: camera,\r\n            dragging: false\r\n        };\r\n    },\r\n    bindMethods: function () {\r\n        this.pointerDown = this.pointerDown.bind(this);\r\n        this.pointerUp = this.pointerUp.bind(this);\r\n        this.pointerOver = this.pointerOver.bind(this);\r\n        this.pointerOut = this.pointerOut.bind(this);\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.sceneEl.addEventListener(\"mousedown\", this.pointerDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"mouseup\", this.pointerUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.addEventListener(\"mouseup\", this.pointerUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected\", this.pointerOver, {\r\n            capture: true,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected-cleared\", this.pointerOut, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.sceneEl.removeEventListener(\"mousedown\", this.pointerDown);\r\n        this.el.sceneEl.removeEventListener(\"mouseup\", this.pointerUp);\r\n        this.el.removeEventListener(\"mouseup\", this.pointerUp);\r\n        this.el.removeEventListener(\"raycaster-intersected\", this.pointerOver);\r\n        this.el.removeEventListener(\"raycaster-intersected-cleared\", this.pointerOut);\r\n    },\r\n    pointerDown: function (_event) {\r\n        var state = this.state;\r\n        if (state.hovered) {\r\n            this.el.sceneEl.emit(AlGraphEvents.SELECTED, { type: AlGraphEntryType.NODE, id: this.el.id }, true);\r\n            if (this.data.graphEnabled) {\r\n                var stat = this.state;\r\n                stat.mouseDown = true;\r\n                this.el.sceneEl.emit(AlGraphEvents.POINTER_DOWN, {}, true);\r\n            }\r\n        }\r\n    },\r\n    pointerUp: function (_event) {\r\n        var state = this.state;\r\n        if (this.data.graphEnabled) {\r\n            state.dragging = false;\r\n            state.mouseDown = false;\r\n            this.el.sceneEl.emit(AlGraphEvents.POINTER_UP, {}, true);\r\n        }\r\n    },\r\n    pointerOver: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = true;\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OVER, { id: this.el.id }, true);\r\n    },\r\n    pointerOut: function (_event) {\r\n        var state = this.state;\r\n        state.hovered = false;\r\n        if (state.mouseDown && state.selected) {\r\n            state.dragging = true;\r\n        }\r\n        this.el.sceneEl.emit(AlGraphEvents.POINTER_OUT, {}, true);\r\n    },\r\n    update: function () {\r\n        var state = this.state;\r\n        state.selected = this.data.selected;\r\n    },\r\n    tickFunction: function () {\r\n        var el = this.el;\r\n        var state = this.state;\r\n        if (this.data.graphEnabled && state.dragging) {\r\n            this.el.sceneEl.emit(AlGraphEvents.DRAGGED, { id: this.el.id }, true);\r\n        }\r\n        // update color\r\n        if (state.hovered || state.dragging) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.hover);\r\n        }\r\n        else if (state.selected) {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.active);\r\n        }\r\n        else {\r\n            state.material.color = new THREE.Color(Constants.buttonColors.up);\r\n        }\r\n        var text = el.firstChild;\r\n        if (text) {\r\n            var obj3d = text.object3D;\r\n            // show/hide label\r\n            if (state.hovered || state.dragging) {\r\n                obj3d.visible = true;\r\n            }\r\n            else {\r\n                obj3d.visible = false;\r\n            }\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n        this.el.removeObject3D(\"mesh\");\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-node-spawner\", {\r\n    schema: {\r\n        graphEnabled: { type: \"boolean\" },\r\n        minFrameMS: { type: \"number\", default: 15 }\r\n    },\r\n    init: function () {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.state = {\r\n            left: false,\r\n            intersecting: false\r\n        };\r\n    },\r\n    bindMethods: function () {\r\n        this.canvasMouseDown = this.canvasMouseDown.bind(this);\r\n        this.pointerOver = this.pointerOver.bind(this);\r\n        this.pointerOut = this.pointerOut.bind(this);\r\n        this.elClick = this.elClick.bind(this);\r\n        this.canvasMouseUp = this.canvasMouseUp.bind(this);\r\n        this.pointerDown = this.pointerDown.bind(this);\r\n        this.pointerUp = this.pointerUp.bind(this);\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.sceneEl.canvas.addEventListener(\"mousedown\", this.canvasMouseDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.canvas.addEventListener(\"mouseup\", this.canvasMouseUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected\", this.pointerOver, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"raycaster-intersected-cleared\", this.pointerOut, false);\r\n        this.el.addEventListener(\"click\", this.elClick, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"mousedown\", this.pointerDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.addEventListener(\"mouseup\", this.pointerUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.sceneEl.canvas.removeEventListener(\"mousedown\", this.canvasMouseDown);\r\n        this.el.sceneEl.canvas.removeEventListener(\"mouseup\", this.canvasMouseUp);\r\n        this.el.removeEventListener(\"raycaster-intersected\", this.pointerOver);\r\n        this.el.removeEventListener(\"raycaster-intersected-cleared\", this.pointerOut);\r\n        this.el.removeEventListener(\"click\", this.elClick);\r\n        this.el.removeEventListener(\"mousedown\", this.pointerDown);\r\n        this.el.removeEventListener(\"mouseup\", this.pointerUp);\r\n    },\r\n    canvasMouseDown: function (event) {\r\n        this.state.left = event.button === 0;\r\n    },\r\n    canvasMouseUp: function (_event) {\r\n        var _this_1 = this;\r\n        setTimeout(function () {\r\n            _this_1.state.left = false;\r\n        }, this.data.minFrameMS);\r\n    },\r\n    pointerOver: function (_event) {\r\n        this.state.intersecting = true;\r\n        this.el.sceneEl.emit(\"al-valid-target\", { valid: true }, false);\r\n    },\r\n    pointerOut: function (_event) {\r\n        this.state.intersecting = false;\r\n        this.el.sceneEl.emit(\"al-valid-target\", { valid: false }, false);\r\n    },\r\n    pointerDown: function (_event) {\r\n        if (this.data.graphEnabled) {\r\n            this.el.sceneEl.emit(\"al-graph-pointer-down\", {}, false);\r\n        }\r\n    },\r\n    pointerUp: function (_event) {\r\n        if (this.data.graphEnabled) {\r\n            this.el.sceneEl.emit(\"al-graph-pointer-up\", {}, false);\r\n        }\r\n    },\r\n    elClick: function (event) {\r\n        if (this.state.left && this.data.graphEnabled) {\r\n            this.el.sceneEl.emit(\"al-add-node\", { aframeEvent: event }, false);\r\n        }\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nvar AlControlEvents = {\r\n    INTERACTION: \"al-control-interaction\",\r\n    INTERACTION_FINISHED: \"al-control-interaction-finished\",\r\n    ANIMATION_STARTED: \"al-controls-animation-started\",\r\n    ANIMATION_FINISHED: \"al-controls-animation-finished\"\r\n};\r\nAFRAME.registerComponent(\"al-orbit-control\", {\r\n    dependencies: [\"camera\"],\r\n    schema: {\r\n        animating: { type: \"boolean\", default: false },\r\n        autoRotate: { type: \"boolean\" },\r\n        autoRotateSpeed: { default: 2 },\r\n        controlPosition: { type: \"vec3\" },\r\n        controlTarget: { type: \"vec3\" },\r\n        dampingFactor: { default: 0.1 },\r\n        enabled: { default: true },\r\n        enableDamping: { default: true },\r\n        enableKeys: { default: true },\r\n        enablePan: { default: true },\r\n        enableRotate: { default: true },\r\n        enableZoom: { default: true },\r\n        keyPanSpeed: { default: 7 },\r\n        maxAzimuthAngle: { type: \"number\", default: Infinity },\r\n        maxDistance: { default: 8000 },\r\n        // maxPolarAngle: { default: AFRAME.utils.device.isMobile() ? 90 : 120 },\r\n        maxPolarAngle: { default: 88 },\r\n        minAzimuthAngle: { type: \"number\", default: -Infinity },\r\n        minDistance: { default: 1 },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        minPolarAngle: { default: 0 },\r\n        panSpeed: { default: 1 },\r\n        rotateSpeed: { default: 0.05 },\r\n        screenSpacePanning: { default: false },\r\n        zoomSpeed: { type: \"number\", default: 0.5 }\r\n    },\r\n    bindMethods: function () {\r\n        this.canvasWheel = this.canvasWheel.bind(this);\r\n        this.getCameraState = this.getCameraState.bind(this);\r\n        this.handleAnimationCache = this.handleAnimationCache.bind(this);\r\n        this.mouseDown = this.mouseDown.bind(this);\r\n        this.mouseMove = this.mouseMove.bind(this);\r\n        this.mouseUp = this.mouseUp.bind(this);\r\n        this.objectToVector3 = this.objectToVector3.bind(this);\r\n        this.onWheel = this.onWheel.bind(this);\r\n    },\r\n    objectToVector3: function (vec) {\r\n        var res = new THREE.Vector3();\r\n        res.x = vec.x;\r\n        res.y = vec.y;\r\n        res.z = vec.z;\r\n        return res;\r\n    },\r\n    addListeners: function () {\r\n        window.addEventListener(\"mouseup\", this.mouseUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"mousemove\", this.mouseMove, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.canvas.addEventListener(\"mousedown\", this.mouseDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.canvas.addEventListener(\"wheel\", this.canvasWheel, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.addEventListener(AlControlEvents.ANIMATION_STARTED, this.handleAnimationCache, false);\r\n    },\r\n    removeListeners: function () {\r\n        window.removeEventListener(\"mouseup\", this.mouseUp);\r\n        window.removeEventListener(\"mousemove\", this.mouseMove),\r\n            this.el.sceneEl.canvas.removeEventListener(\"mousedown\", this.mouseDown);\r\n        this.el.sceneEl.canvas.removeEventListener(\"wheel\", this.canvasWheel);\r\n        this.el.sceneEl.removeEventListener(AlControlEvents.ANIMATION_STARTED, this.handleAnimationCache, false);\r\n    },\r\n    handleAnimationCache: function (event) {\r\n        this.state.animationCache = event.detail.slerpPath;\r\n    },\r\n    mouseUp: function (_event) {\r\n        document.body.style.cursor = \"grab\";\r\n        var controls = this.state.controls;\r\n        if (controls.enabled) {\r\n            this.el.sceneEl.emit(AlControlEvents.INTERACTION_FINISHED, {\r\n                cameraState: this.getCameraState(),\r\n                needsRender: this.state.mouseDown\r\n            }, false);\r\n        }\r\n        this.state.mouseDown = false;\r\n    },\r\n    mouseDown: function (_event) {\r\n        this.state.mouseDown = true;\r\n        document.body.style.cursor = \"grabbing\";\r\n    },\r\n    mouseMove: function (_event) {\r\n        if (this.state.mouseDown) {\r\n            this.el.sceneEl.emit(AlControlEvents.INTERACTION, {\r\n                cameraState: this.getCameraState(),\r\n                needsRender: this.state.mouseDown\r\n            }, false);\r\n        }\r\n    },\r\n    onWheel: function () {\r\n        var _this_1 = this;\r\n        var state = this.state;\r\n        state.wheelMarker = false;\r\n        state.wheelCounter2 = state.wheelCounter1;\r\n        setTimeout(function () {\r\n            if (state.wheelCounter2 === state.wheelCounter1) {\r\n                state.wheelMarker = true;\r\n                state.wheelCounter1 = 0;\r\n                state.wheelCounter2 = 0;\r\n                _this_1.el.sceneEl.emit(AlControlEvents.INTERACTION_FINISHED, {\r\n                    cameraState: _this_1.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n            else {\r\n                _this_1.onWheel();\r\n            }\r\n        }, state.wheelInterval);\r\n    },\r\n    canvasWheel: function (_event) {\r\n        var state = this.state;\r\n        state.wheelCounter1 += 1;\r\n        if (state.wheelMarker) {\r\n            this.onWheel();\r\n        }\r\n        this.el.sceneEl.emit(AlControlEvents.INTERACTION, {\r\n            cameraState: this.getCameraState(),\r\n            needsRender: true\r\n        }, false);\r\n    },\r\n    init: function () {\r\n        var _this_1 = this;\r\n        var el = this.el;\r\n        var data = this.data;\r\n        document.body.style.cursor = \"grab\";\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        var controls = new THREE.OrbitControls(el.getObject3D(\"camera\"), el.sceneEl.renderer.domElement);\r\n        // Convert the controlPosition & controlTarget Objects into THREE.Vector3\r\n        var controlPosition = this.objectToVector3(data.controlPosition);\r\n        var controlTarget = this.objectToVector3(data.controlTarget);\r\n        controls.object.position.copy(controlPosition);\r\n        el.getObject3D(\"camera\").position.copy(controlPosition);\r\n        controls.target.copy(controlTarget);\r\n        var animationCache = [];\r\n        this.state = {\r\n            animationCache: animationCache,\r\n            controls: controls,\r\n            mouseDown: false,\r\n            wheelCounter1: 0,\r\n            wheelCounter2: undefined,\r\n            wheelInterval: 50,\r\n            wheelMarker: true\r\n        };\r\n        this.bindMethods();\r\n        this.addListeners();\r\n        // wait a frame before emitting initialised event\r\n        setTimeout(function () {\r\n            _this_1.el.sceneEl.emit(AlControlEvents.INTERACTION, {\r\n                cameraState: _this_1.getCameraState(),\r\n                needsRender: false\r\n            }, false);\r\n        }, this.data.minFrameMS);\r\n    },\r\n    getCameraState: function () {\r\n        return {\r\n            position: this.state.controls.object.position,\r\n            target: this.state.controls.target\r\n        };\r\n    },\r\n    update: function (_oldData) {\r\n        var controls = this.state.controls;\r\n        var data = this.data;\r\n        controls.target = this.objectToVector3(data.controlTarget);\r\n        controls.autoRotate = data.autoRotate;\r\n        controls.autoRotateSpeed = data.autoRotateSpeed;\r\n        controls.dampingFactor = data.dampingFactor;\r\n        controls.enabled = data.enabled;\r\n        controls.enableDamping = data.enableDamping;\r\n        controls.enableKeys = data.enableKeys;\r\n        controls.enablePan = data.enablePan;\r\n        controls.enableRotate = data.enableRotate;\r\n        controls.enableZoom = data.enableZoom;\r\n        controls.keyPanSpeed = data.keyPanSpeed;\r\n        controls.maxPolarAngle = THREE.Math.degToRad(data.maxPolarAngle);\r\n        controls.maxAzimuthAngle = THREE.Math.degToRad(data.maxAzimuthAngle);\r\n        controls.maxDistance = data.maxDistance;\r\n        controls.minDistance = data.minDistance;\r\n        controls.minPolarAngle = THREE.Math.degToRad(data.minPolarAngle);\r\n        controls.minAzimuthAngle = THREE.Math.degToRad(data.minAzimuthAngle);\r\n        controls.panSpeed = data.panSpeed;\r\n        controls.rotateSpeed = data.rotateSpeed;\r\n        controls.screenSpacePanning = data.screenSpacePanning;\r\n        controls.zoomSpeed = data.zoomSpeed;\r\n        this.el\r\n            .getObject3D(\"camera\")\r\n            .position.copy(this.objectToVector3(data.controlPosition));\r\n    },\r\n    tickFunction: function () {\r\n        var controls = this.state.controls;\r\n        if (!controls.enabled) {\r\n            return;\r\n        }\r\n        if (this.data.animating) {\r\n            var nextFrame = this.state.animationCache.shift();\r\n            if (nextFrame && nextFrame.position && nextFrame.target) {\r\n                controls.object.position.copy(nextFrame.position);\r\n                this.el.getObject3D(\"camera\").position.copy(nextFrame.position);\r\n                controls.target.copy(nextFrame.target);\r\n                this.el.sceneEl.emit(AlControlEvents.INTERACTION, {\r\n                    cameraState: this.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n            if (this.state.animationCache.length === 0) {\r\n                this.el.sceneEl.emit(AlControlEvents.ANIMATION_FINISHED, {}, false);\r\n                this.el.sceneEl.emit(AlControlEvents.INTERACTION_FINISHED, {\r\n                    cameraState: this.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n        }\r\n        if (controls.enabled && (controls.enableDamping || controls.autoRotate)) {\r\n            controls.update();\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.state.controls.reset();\r\n        this.removeListeners();\r\n        var state = this.state;\r\n        state.controls.dispose();\r\n        state = null;\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-render-order\", {\r\n    schema: {\r\n        renderOrder: { type: \"number\", default: 999 }\r\n    },\r\n    init: function () {\r\n        var _this_1 = this;\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        Object.keys(this.el.object3DMap).forEach(function (key) {\r\n            _this_1.el.object3DMap[key].renderOrder = _this_1.data.renderOrder;\r\n        });\r\n    },\r\n    // tslint:disable-next-line: no-empty\r\n    bindMethods: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    addEventListeners: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    removeEventListeners: function () { },\r\n    update: function () {\r\n        var _this_1 = this;\r\n        Object.keys(this.el.object3DMap).forEach(function (key) {\r\n            _this_1.el.object3DMap[key].renderOrder = _this_1.data.renderOrder;\r\n        });\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nAFRAME.registerComponent(\"al-render-overlaid\", {\r\n    schema: {\r\n        renderOrder: { type: \"number\", default: 999 }\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    init: function (_data) {\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.setDepth(this.el.object3DMap.mesh);\r\n        this.setDepth(this.el.object3DMap.text);\r\n    },\r\n    // tslint:disable-next-line: no-empty\r\n    bindMethods: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    addEventListeners: function () { },\r\n    // tslint:disable-next-line: no-empty\r\n    removeEventListeners: function () { },\r\n    setDepth: function (mesh) {\r\n        if (mesh) {\r\n            mesh.renderOrder = this.data.renderOrder;\r\n            if (mesh.material) {\r\n                mesh.material.depthTest = false;\r\n            }\r\n        }\r\n    },\r\n    remove: function () {\r\n        this.removeEventListeners();\r\n    }\r\n});\r\nvar AlControlEvents$1 = /** @class */ (function () {\r\n    function AlControlEvents$1() {\r\n    }\r\n    return AlControlEvents$1;\r\n}());\r\nAlControlEvents$1.INTERACTION = \"al-control-interaction\";\r\nAlControlEvents$1.INTERACTION_FINISHED = \"al-control-interaction-finished\";\r\nAlControlEvents$1.ANIMATION_STARTED = \"al-controls-animation-started\";\r\nAlControlEvents$1.ANIMATION_FINISHED = \"al-controls-animation-finished\";\r\n/**\r\n * @author Eberhard Graether / http://egraether.com/\r\n * @author Mark Lundin \t/ http://mark-lundin.com\r\n * @author Simone Manini / http://daron1337.github.io\r\n * @author Luca Antiga \t/ http://lantiga.github.io\r\n */\r\n// Possible states for control component\r\nvar AlTrackballState = {\r\n    NONE: -1,\r\n    ROTATE: 0,\r\n    ZOOM: 1,\r\n    PAN: 2,\r\n    TOUCH_ROTATE: 3,\r\n    TOUCH_ZOOM_PAN: 4\r\n};\r\n// Mouse button binds to actions\r\nvar AlMouseButtons = {\r\n    ROTATE: THREE.MOUSE.LEFT,\r\n    ZOOM: THREE.MOUSE.MIDDLE,\r\n    PAN: THREE.MOUSE.RIGHT\r\n};\r\nvar AlTrackballControls = /** @class */ (function (_super) {\r\n    __extends(AlTrackballControls, _super);\r\n    // tslint:disable-next-line: no-any\r\n    function AlTrackballControls(object, domElement) {\r\n        var _this_1 = _super.call(this) || this;\r\n        _this_1.screen = {\r\n            left: 0,\r\n            top: 0,\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        // events\r\n        _this_1._changeEvent = { type: \"change\" };\r\n        _this_1._startEvent = { type: \"start\" };\r\n        _this_1._endEvent = { type: \"end\" };\r\n        _this_1.object = object;\r\n        _this_1.domElement = domElement !== undefined ? domElement : document;\r\n        // ======== API ========\r\n        _this_1.enabled = true;\r\n        _this_1.screen = { left: 0, top: 0, width: 0, height: 0 };\r\n        _this_1.rotateSpeed = 1.0;\r\n        _this_1.zoomSpeed = 1.2;\r\n        _this_1.panSpeed = 0.3;\r\n        _this_1.noRotate = false;\r\n        _this_1.noZoom = false;\r\n        _this_1.noPan = false;\r\n        _this_1.staticMoving = false;\r\n        _this_1.dynamicDampingFactor = 0.2;\r\n        _this_1.minDistance = 0;\r\n        _this_1.maxDistance = Infinity;\r\n        // =====================\r\n        // ===== internals =====\r\n        // for reset\r\n        _this_1.target = new THREE.Vector3();\r\n        _this_1.EPS = 0.000001;\r\n        _this_1._lastPosition = new THREE.Vector3();\r\n        _this_1._state = AlTrackballState.NONE;\r\n        _this_1._eye = new THREE.Vector3();\r\n        _this_1._movePrev = new THREE.Vector2();\r\n        _this_1._moveCurr = new THREE.Vector2();\r\n        _this_1._lastAxis = new THREE.Vector3();\r\n        _this_1._lastAngle = 0;\r\n        _this_1._zoomStart = new THREE.Vector2();\r\n        _this_1._zoomEnd = new THREE.Vector2();\r\n        _this_1._touchZoomDistanceStart = 0;\r\n        _this_1._touchZoomDistanceEnd = 0;\r\n        _this_1._panStart = new THREE.Vector2();\r\n        _this_1._panEnd = new THREE.Vector2();\r\n        _this_1._target0 = _this_1.target.clone();\r\n        _this_1._position0 = _this_1.object.position.clone();\r\n        _this_1._up0 = _this_1.object.up.clone();\r\n        _this_1._bindMethods();\r\n        _this_1._addListeners();\r\n        _this_1.update();\r\n        return _this_1;\r\n    }\r\n    Object.defineProperty(AlTrackballControls.prototype, \"up0\", {\r\n        get: function () {\r\n            return this._up0.clone();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AlTrackballControls.prototype._bindMethods = function () {\r\n        this._mouseDown = this._mouseDown.bind(this);\r\n        this._mouseMove = this._mouseMove.bind(this);\r\n        this._mouseUp = this._mouseUp.bind(this);\r\n        this._mouseWheel = this._mouseWheel.bind(this);\r\n        this._touchStart = this._touchStart.bind(this);\r\n        this._touchEnd = this._touchEnd.bind(this);\r\n        this._touchMove = this._touchMove.bind(this);\r\n        this._resize = this._resize.bind(this);\r\n    };\r\n    AlTrackballControls.prototype._addListeners = function () {\r\n        this.domElement.addEventListener(\"mousedown\", this._mouseDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"mousemove\", this._mouseMove, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"mouseup\", this._mouseUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.domElement.addEventListener(\"wheel\", this._mouseWheel, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.domElement.addEventListener(\"touchstart\", this._touchStart, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"touchend\", this._touchEnd, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"touchmove\", this._touchMove, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n    };\r\n    AlTrackballControls.prototype._mouseDown = function (event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        if (this._state === AlTrackballState.NONE) {\r\n            switch (event.button) {\r\n                case AlMouseButtons.ROTATE:\r\n                    this._state = AlTrackballState.ROTATE;\r\n                    if (!this.noRotate) {\r\n                        this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\r\n                        this._movePrev.copy(this._moveCurr);\r\n                    }\r\n                    break;\r\n                case AlMouseButtons.ZOOM:\r\n                    this._state = AlTrackballState.ZOOM;\r\n                    if (!this.noZoom) {\r\n                        this._zoomStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));\r\n                        this._zoomEnd.copy(this._zoomStart);\r\n                    }\r\n                    break;\r\n                case AlMouseButtons.PAN:\r\n                    this._state = AlTrackballState.PAN;\r\n                    if (!this.noPan) {\r\n                        this._panStart.copy(this._getMouseOnScreen(event.pageX, event.pageY));\r\n                        this._panEnd.copy(this._panStart);\r\n                    }\r\n                    break;\r\n                default:\r\n                    this._state = AlTrackballState.NONE;\r\n            }\r\n        }\r\n        this.dispatchEvent(this._startEvent);\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._mouseMove = function (event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        if (this._state === AlTrackballState.ROTATE && !this.noRotate) {\r\n            this._movePrev.copy(this._moveCurr);\r\n            this._moveCurr.copy(this._getMouseOnCircle(event.pageX, event.pageY));\r\n        }\r\n        else if (this._state === AlTrackballState.ZOOM && !this.noZoom) {\r\n            this._zoomEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\r\n        }\r\n        else if (this._state === AlTrackballState.PAN && !this.noPan) {\r\n            this._panEnd.copy(this._getMouseOnScreen(event.pageX, event.pageY));\r\n        }\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._mouseUp = function (_event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        this._state = AlTrackballState.NONE;\r\n        this.dispatchEvent(this._endEvent);\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._mouseWheel = function (event) {\r\n        if (this.enabled === false || this.noZoom === true) {\r\n            return;\r\n        }\r\n        switch (event.deltaMode) {\r\n            case 2:\r\n                // Zoom in pages\r\n                this._zoomStart.y -= event.deltaY * 0.025;\r\n                break;\r\n            case 1:\r\n                // Zoom in lines\r\n                this._zoomStart.y -= event.deltaY * 0.01;\r\n                break;\r\n            default:\r\n                // undefined, 0, assume pixels\r\n                this._zoomStart.y -= event.deltaY * 0.00025;\r\n                break;\r\n        }\r\n        this.dispatchEvent(this._startEvent);\r\n        this.dispatchEvent(this._endEvent);\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._touchStart = function (event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        switch (event.touches.length) {\r\n            case 1:\r\n                this._state = AlTrackballState.TOUCH_ROTATE;\r\n                this._moveCurr.copy(this._getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\r\n                this._movePrev.copy(this._moveCurr);\r\n                break;\r\n            default:\r\n                // 2 or more\r\n                this._state = AlTrackballState.TOUCH_ZOOM_PAN;\r\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n                this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\r\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\r\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\r\n                this._panStart.copy(this._getMouseOnScreen(x, y));\r\n                this._panEnd.copy(this._panStart);\r\n                break;\r\n        }\r\n        this.dispatchEvent(this._startEvent);\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._touchEnd = function (event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        switch (event.touches.length) {\r\n            case 0:\r\n                this._state = AlTrackballState.NONE;\r\n                break;\r\n            case 1:\r\n                this._state = AlTrackballState.TOUCH_ROTATE;\r\n                this._moveCurr.copy(this._getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\r\n                this._movePrev.copy(this._moveCurr);\r\n                break;\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n        this.dispatchEvent(this._endEvent);\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._touchMove = function (event) {\r\n        if (this.enabled === false) {\r\n            return;\r\n        }\r\n        switch (event.touches.length) {\r\n            case 1:\r\n                this._movePrev.copy(this._moveCurr);\r\n                this._moveCurr.copy(this._getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\r\n                break;\r\n            default:\r\n                // 2 or more\r\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n                this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\r\n                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\r\n                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\r\n                this._panEnd.copy(this._getMouseOnScreen(x, y));\r\n                break;\r\n        }\r\n        this.update();\r\n    };\r\n    AlTrackballControls.prototype._resize = function () {\r\n        if (this.domElement === document) {\r\n            this.screen.left = 0;\r\n            this.screen.top = 0;\r\n            this.screen.width = window.innerWidth;\r\n            this.screen.height = window.innerHeight;\r\n        }\r\n        else {\r\n            var box = this.domElement.getBoundingClientRect();\r\n            // adjustments come from similar code in the jquery offset() function\r\n            var d = this.domElement.ownerDocument.documentElement;\r\n            this.screen.left = box.left + window.pageXOffset - d.clientLeft;\r\n            this.screen.top = box.top + window.pageYOffset - d.clientTop;\r\n            this.screen.width = box.width;\r\n            this.screen.height = box.height;\r\n        }\r\n    };\r\n    AlTrackballControls.prototype._getMouseOnScreen = function (pageX, pageY) {\r\n        var vector = new THREE.Vector2();\r\n        vector.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);\r\n        return vector;\r\n    };\r\n    AlTrackballControls.prototype._getMouseOnCircle = function (pageX, pageY) {\r\n        var vector = new THREE.Vector2();\r\n        vector.set((pageX - this.screen.width * 0.5 - this.screen.left) /\r\n            (this.screen.width * 0.5), (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width // screen.width intentional\r\n        );\r\n        return vector;\r\n    };\r\n    AlTrackballControls.prototype._rotateCamera = function () {\r\n        var axis = new THREE.Vector3();\r\n        var quaternion = new THREE.Quaternion();\r\n        var eyeDirection = new THREE.Vector3();\r\n        var objectUpDirection = new THREE.Vector3();\r\n        var objectSidewaysDirection = new THREE.Vector3();\r\n        var moveDirection = new THREE.Vector3();\r\n        var angle;\r\n        moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\r\n        angle = moveDirection.length();\r\n        if (angle) {\r\n            this._eye.copy(this.object.position).sub(this.target);\r\n            eyeDirection.copy(this._eye).normalize();\r\n            objectUpDirection.copy(this.object.up).normalize();\r\n            objectSidewaysDirection\r\n                .crossVectors(objectUpDirection, eyeDirection)\r\n                .normalize();\r\n            objectUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\r\n            objectSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\r\n            moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\r\n            axis.crossVectors(moveDirection, this._eye).normalize();\r\n            angle *= this.rotateSpeed;\r\n            quaternion.setFromAxisAngle(axis, angle);\r\n            this._eye.applyQuaternion(quaternion);\r\n            this.object.up.applyQuaternion(quaternion);\r\n            this._lastAxis.copy(axis);\r\n            this._lastAngle = angle;\r\n        }\r\n        else if (!this.staticMoving && this._lastAngle) {\r\n            this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);\r\n            this._eye.copy(this.object.position).sub(this.target);\r\n            quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\r\n            this._eye.applyQuaternion(quaternion);\r\n            this.object.up.applyQuaternion(quaternion);\r\n        }\r\n        this._movePrev.copy(this._moveCurr);\r\n    };\r\n    AlTrackballControls.prototype._zoomCamera = function () {\r\n        var factor;\r\n        if (this._state === AlTrackballState.TOUCH_ZOOM_PAN) {\r\n            factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\r\n            this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\r\n            this._eye.multiplyScalar(factor);\r\n        }\r\n        else {\r\n            factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;\r\n            if (factor !== 1.0 && factor > 0.0) {\r\n                this._eye.multiplyScalar(factor);\r\n            }\r\n            if (this.staticMoving) {\r\n                this._zoomStart.copy(this._zoomEnd);\r\n            }\r\n            else {\r\n                this._zoomStart.y +=\r\n                    (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;\r\n            }\r\n        }\r\n    };\r\n    AlTrackballControls.prototype._panCamera = function () {\r\n        var mouseChange = new THREE.Vector2();\r\n        var objectUp = new THREE.Vector3();\r\n        var pan = new THREE.Vector3();\r\n        mouseChange.copy(this._panEnd).sub(this._panStart);\r\n        if (mouseChange.lengthSq()) {\r\n            mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);\r\n            pan\r\n                .copy(this._eye)\r\n                .cross(this.object.up)\r\n                .setLength(mouseChange.x);\r\n            pan.add(objectUp.copy(this.object.up).setLength(mouseChange.y));\r\n            this.object.position.add(pan);\r\n            this.target.add(pan);\r\n            if (this.staticMoving) {\r\n                this._panStart.copy(this._panEnd);\r\n            }\r\n            else {\r\n                this._panStart.add(mouseChange\r\n                    .subVectors(this._panEnd, this._panStart)\r\n                    .multiplyScalar(this.dynamicDampingFactor));\r\n            }\r\n        }\r\n    };\r\n    AlTrackballControls.prototype._checkDistances = function () {\r\n        if (!this.noZoom || !this.noPan) {\r\n            if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {\r\n                this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance));\r\n                this._zoomStart.copy(this._zoomEnd);\r\n            }\r\n            if (this._eye.lengthSq() < this.minDistance * this.minDistance) {\r\n                this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance));\r\n                this._zoomStart.copy(this._zoomEnd);\r\n            }\r\n        }\r\n    };\r\n    AlTrackballControls.prototype.update = function () {\r\n        this._eye.subVectors(this.object.position, this.target);\r\n        if (!this.noRotate) {\r\n            this._rotateCamera();\r\n        }\r\n        if (!this.noZoom) {\r\n            this._zoomCamera();\r\n        }\r\n        if (!this.noPan) {\r\n            this._panCamera();\r\n        }\r\n        this.object.position.addVectors(this.target, this._eye);\r\n        this._checkDistances();\r\n        this.object.lookAt(this.target);\r\n        if (this._lastPosition.distanceToSquared(this.object.position) > this.EPS) {\r\n            this.dispatchEvent(this._changeEvent);\r\n            this._lastPosition.copy(this.object.position);\r\n        }\r\n    };\r\n    AlTrackballControls.prototype.reset = function () {\r\n        this._state = AlTrackballState.NONE;\r\n        this.target.copy(this._target0);\r\n        this.object.position.copy(this._position0);\r\n        this.object.up.copy(this._up0);\r\n        this._eye.subVectors(this.object.position, this.target);\r\n        this.object.lookAt(this.target);\r\n        this.dispatchEvent(this._changeEvent);\r\n        this._lastPosition.copy(this.object.position);\r\n    };\r\n    AlTrackballControls.prototype.dispose = function () {\r\n        this._removeListeners();\r\n    };\r\n    AlTrackballControls.prototype._removeListeners = function () {\r\n        this.domElement.removeEventListener(\"mousedown\", this._mouseDown, false);\r\n        window.removeEventListener(\"mousemove\", this._mouseMove, false);\r\n        window.removeEventListener(\"mouseup\", this._mouseUp, false);\r\n        this.domElement.removeEventListener(\"wheel\", this._mouseWheel, false);\r\n        this.domElement.removeEventListener(\"touchstart\", this._touchStart, false);\r\n        window.removeEventListener(\"touchend\", this._touchEnd, false);\r\n        window.removeEventListener(\"touchmove\", this._touchMove, false);\r\n    };\r\n    return AlTrackballControls;\r\n}(THREE.EventDispatcher));\r\nAFRAME.registerComponent(\"al-trackball-control\", {\r\n    dependencies: [\"camera\"],\r\n    schema: {\r\n        animating: { type: \"boolean\", default: false },\r\n        controlPosition: { type: \"vec3\" },\r\n        controlTarget: { type: \"vec3\" },\r\n        dynamicDampingFactor: { default: 0.1 },\r\n        enabled: { type: \"boolean\", default: true },\r\n        maxDistance: { type: \"number\", default: 8000 },\r\n        minDistance: { type: \"number\", default: 0 },\r\n        noPan: { type: \"boolean\", default: false },\r\n        noRotate: { type: \"boolean\", default: false },\r\n        noZoom: { type: \"boolean\", default: false },\r\n        panSpeed: { type: \"number\", default: 0.3 },\r\n        rotateSpeed: { type: \"number\", default: 1.0 },\r\n        screenHeight: { type: \"number\", default: 0 },\r\n        screenLeft: { type: \"number\", default: 0 },\r\n        screenTop: { type: \"number\", default: 0 },\r\n        screenWidth: { type: \"number\", default: 0 },\r\n        staticMoving: { type: \"boolean\", default: true },\r\n        zoomSpeed: { type: \"number\", default: 0.5 }\r\n    },\r\n    bindMethods: function () {\r\n        this.canvasWheel = this.canvasWheel.bind(this);\r\n        this.getCameraState = this.getCameraState.bind(this);\r\n        this.handleAnimationCache = this.handleAnimationCache.bind(this);\r\n        this.mouseDown = this.mouseDown.bind(this);\r\n        this.mouseMove = this.mouseMove.bind(this);\r\n        this.mouseUp = this.mouseUp.bind(this);\r\n        this.onWheel = this.onWheel.bind(this);\r\n    },\r\n    addListeners: function () {\r\n        window.addEventListener(\"mouseup\", this.mouseUp, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        window.addEventListener(\"mousemove\", this.mouseMove, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.canvas.addEventListener(\"mousedown\", this.mouseDown, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.canvas.addEventListener(\"wheel\", this.canvasWheel, {\r\n            capture: false,\r\n            once: false,\r\n            passive: true\r\n        });\r\n        this.el.sceneEl.oncontextmenu = function (e) {\r\n            e.preventDefault();\r\n        };\r\n        this.el.sceneEl.addEventListener(AlControlEvents$1.ANIMATION_STARTED, this.handleAnimationCache, false);\r\n    },\r\n    removeListeners: function () {\r\n        window.removeEventListener(\"mouseup\", this.mouseUp);\r\n        window.removeEventListener(\"mousemove\", this.mouseMove),\r\n            this.el.sceneEl.canvas.removeEventListener(\"mousedown\", this.mouseDown);\r\n        this.el.sceneEl.canvas.removeEventListener(\"wheel\", this.canvasWheel);\r\n        this.el.sceneEl.removeEventListener(AlControlEvents$1.ANIMATION_STARTED, this.handleAnimationCache, false);\r\n    },\r\n    handleAnimationCache: function (event) {\r\n        this.state.animationCache = event.detail.slerpPath;\r\n        var camera = this.el.getObject3D(\"camera\");\r\n        this.state.cameraAnimationCache = ThreeUtils.getSlerp3Path(camera.up.clone(), this.state.controls.up0);\r\n    },\r\n    mouseUp: function (_event) {\r\n        document.body.style.cursor = \"grab\";\r\n        var controls = this.state.controls;\r\n        if (controls.enabled) {\r\n            this.el.sceneEl.emit(AlControlEvents$1.INTERACTION_FINISHED, {\r\n                cameraState: this.getCameraState(),\r\n                needsRender: this.state.mouseDown\r\n            }, false);\r\n        }\r\n        this.state.mouseDown = false;\r\n    },\r\n    mouseDown: function (_event) {\r\n        this.state.mouseDown = true;\r\n        document.body.style.cursor = \"grabbing\";\r\n    },\r\n    mouseMove: function (_event) {\r\n        if (this.state.mouseDown) {\r\n            this.el.sceneEl.emit(AlControlEvents$1.INTERACTION, {\r\n                cameraState: this.getCameraState(),\r\n                needsRender: this.state.mouseDown\r\n            }, false);\r\n        }\r\n    },\r\n    onWheel: function () {\r\n        var _this_1 = this;\r\n        var state = this.state;\r\n        state.wheelMarker = false;\r\n        state.wheelCounter2 = state.wheelCounter1;\r\n        setTimeout(function () {\r\n            if (state.wheelCounter2 === state.wheelCounter1) {\r\n                state.wheelMarker = true;\r\n                state.wheelCounter1 = 0;\r\n                state.wheelCounter2 = 0;\r\n                _this_1.el.sceneEl.emit(AlControlEvents$1.INTERACTION_FINISHED, {\r\n                    cameraState: _this_1.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n            else {\r\n                _this_1.onWheel();\r\n            }\r\n        }, state.wheelInterval);\r\n    },\r\n    canvasWheel: function (_event) {\r\n        var state = this.state;\r\n        state.wheelCounter1 += 1;\r\n        if (state.wheelMarker) {\r\n            this.onWheel();\r\n        }\r\n        this.el.sceneEl.emit(AlControlEvents$1.INTERACTION, {\r\n            cameraState: this.getCameraState(),\r\n            needsRender: true\r\n        }, false);\r\n    },\r\n    init: function () {\r\n        var _this_1 = this;\r\n        var el = this.el;\r\n        var data = this.data;\r\n        document.body.style.cursor = \"grab\";\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, Constants.minFrameMS, this);\r\n        // tslint:disable-next-line: no-any\r\n        var controls = new AlTrackballControls(el.getObject3D(\"camera\"), el.sceneEl.renderer.domElement);\r\n        // Convert the controlPosition & controlTarget Objects into THREE.Vector3\r\n        var controlPosition = ThreeUtils.objectToVector3(data.controlPosition);\r\n        var controlTarget = ThreeUtils.objectToVector3(data.controlTarget);\r\n        controls.object.position.copy(controlPosition);\r\n        el.getObject3D(\"camera\").position.copy(controlPosition);\r\n        controls.target.copy(controlTarget);\r\n        var animationCache = [];\r\n        this.state = {\r\n            animationCache: animationCache,\r\n            cameraAnimationCache: null,\r\n            controls: controls,\r\n            mouseDown: false,\r\n            wheelCounter1: 0,\r\n            wheelCounter2: undefined,\r\n            wheelInterval: 50,\r\n            wheelMarker: true\r\n        };\r\n        this.bindMethods();\r\n        this.addListeners();\r\n        // wait a frame before emitting initialised event\r\n        ThreeUtils.waitOneFrame(function () {\r\n            _this_1.el.sceneEl.emit(AlControlEvents$1.INTERACTION, {\r\n                cameraState: _this_1.getCameraState(),\r\n                needsRender: false\r\n            }, false);\r\n        });\r\n    },\r\n    getCameraState: function () {\r\n        return {\r\n            position: this.state.controls.object.position,\r\n            target: this.state.controls.target\r\n        };\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    update: function (_oldData) {\r\n        var controls = this.state.controls;\r\n        var data = this.data;\r\n        controls.target = ThreeUtils.objectToVector3(data.controlTarget);\r\n        controls.dynamicDampingFactor = data.dynamicDampingFactor;\r\n        controls.enabled = data.enabled;\r\n        controls.maxDistance = data.maxDistance;\r\n        controls.minDistance = data.minDistance;\r\n        controls.noPan = data.noPan;\r\n        controls.noRotate = data.noRotate;\r\n        controls.noZoom = data.noZoom;\r\n        controls.panSpeed = data.panSpeed;\r\n        controls.rotateSpeed = data.rotateSpeed;\r\n        controls.screen.height = data.screenHeight;\r\n        controls.screen.left = data.screenLeft;\r\n        controls.screen.top = data.screenTop;\r\n        controls.screen.width = data.screenWidth;\r\n        controls.staticMoving = data.screenHeight;\r\n        controls.zoomSpeed = data.zoomSpeed;\r\n        this.el\r\n            .getObject3D(\"camera\")\r\n            .position.copy(ThreeUtils.objectToVector3(data.controlPosition));\r\n    },\r\n    tickFunction: function () {\r\n        var controls = this.state.controls;\r\n        if (!controls.enabled) {\r\n            return;\r\n        }\r\n        if (this.data.animating && this.state.cameraAnimationCache) {\r\n            var nextFrame = this.state.animationCache.shift();\r\n            var nextCamera = this.state.cameraAnimationCache.shift();\r\n            if (nextFrame && nextFrame.position && nextFrame.target) {\r\n                var camera = this.el.getObject3D(\"camera\");\r\n                controls.object.position.copy(nextFrame.position);\r\n                camera.position.copy(nextFrame.position);\r\n                // Need to align Up vector as well to re-orient correctly\r\n                // inside the Quaternion space that trackball uses\r\n                if (nextCamera) {\r\n                    camera.up.copy(nextCamera);\r\n                }\r\n                controls.target.copy(nextFrame.target);\r\n                this.el.sceneEl.emit(AlControlEvents$1.INTERACTION, {\r\n                    cameraState: this.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n            if (this.state.animationCache.length === 0) {\r\n                this.el.sceneEl.emit(AlControlEvents$1.ANIMATION_FINISHED, {}, false);\r\n                this.el.sceneEl.emit(AlControlEvents$1.INTERACTION_FINISHED, {\r\n                    cameraState: this.getCameraState(),\r\n                    needsRender: true\r\n                }, false);\r\n            }\r\n        }\r\n        if (controls.enabled) {\r\n            controls.update();\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        this.state.controls.reset();\r\n        this.removeListeners();\r\n        var state = this.state;\r\n        state.controls.dispose();\r\n        state = null;\r\n    }\r\n});\r\nvar VolumetricLoader = /** @class */ (function () {\r\n    function VolumetricLoader() {\r\n    }\r\n    // tslint:disable-next-line: no-any\r\n    VolumetricLoader.prototype.load = function (src, container) {\r\n        var _this_1 = this;\r\n        // tslint:disable-next-line: no-any\r\n        return new Promise(function (resolve, reject) {\r\n            var xhr = new XMLHttpRequest();\r\n            var fileExtension = Utils.getFileExtension(src);\r\n            var fileEnd = Utils.getFileEndCharacters(src, 3);\r\n            if (Object.values(VolumeFileType).includes(fileExtension) ||\r\n                Object.values(VolumeFileType).includes(fileEnd)) {\r\n                var data = [src];\r\n                _this_1._loadVolume(data, resolve, reject, container);\r\n            }\r\n            else {\r\n                xhr.open(\"GET\", src, true);\r\n                xhr.onload = function () {\r\n                    var data = JSON.parse(xhr.responseText);\r\n                    data = _this_1._mapfiles(data.baseurl, data.series);\r\n                    _this_1._loadVolume(data, resolve, reject, container);\r\n                };\r\n                xhr.onerror = function (error) {\r\n                    reject(error);\r\n                };\r\n                xhr.send();\r\n            }\r\n        });\r\n    };\r\n    VolumetricLoader.prototype._loadVolume = function (data, resolve, reject, container) {\r\n        var loader = new AMI.VolumeLoader(container);\r\n        loader\r\n            .load(data)\r\n            .then(function () {\r\n            var sr = loader.data[0].mergeSeries(loader.data);\r\n            var stack = sr[0].stack[0];\r\n            loader.free();\r\n            resolve(stack);\r\n        })\r\n            .catch(function (error) {\r\n            // tslint:disable-next-line: no-console\r\n            console.error(\"Volume load error\");\r\n            reject(error);\r\n        });\r\n    };\r\n    VolumetricLoader.prototype._mapfiles = function (baseurl, files) {\r\n        return files.map(function (filename) {\r\n            if (!baseurl.endsWith(\"/\")) {\r\n                baseurl += \"/\";\r\n            }\r\n            return \"\" + baseurl + filename;\r\n        });\r\n    };\r\n    return VolumetricLoader;\r\n}());\r\nvar AlVolumeEvents = /** @class */ (function () {\r\n    function AlVolumeEvents() {\r\n    }\r\n    return AlVolumeEvents;\r\n}());\r\nAlVolumeEvents.DEFAULT_RENDER_STEPS = \"al-default-render-steps\";\r\nAlVolumeEvents.ERROR = \"al-volume-error\";\r\nAlVolumeEvents.LOADED = \"al-volume-loaded\";\r\nAlVolumeEvents.SLICES_MAX_INDEX = \"al-volume-slices-max-index\";\r\nAlVolumeEvents.VOLUME_RAY_REQUEST = \"al-volume-ray-requested\";\r\nAlVolumeEvents.VOLUME_RAY_CAST = \"al-volume-ray-cast\";\r\n// tslint:disable-next-line: max-classes-per-file\r\nvar AlVolumeCastType = /** @class */ (function () {\r\n    function AlVolumeCastType() {\r\n    }\r\n    return AlVolumeCastType;\r\n}());\r\nAlVolumeCastType.CREATE = \"create\";\r\nAlVolumeCastType.DRAG = \"drag\";\r\nAFRAME.registerComponent(\"al-volume\", {\r\n    schema: {\r\n        controlsType: { type: \"string\" },\r\n        displayMode: { type: \"string\" },\r\n        minFrameMS: { type: \"number\", default: 15 },\r\n        slicesIndex: { type: \"number\" },\r\n        slicesOrientation: { type: \"string\" },\r\n        src: { type: \"string\" },\r\n        srcLoaded: { type: \"boolean\" },\r\n        volumeSteps: { type: \"number\" },\r\n        volumeWindowCenter: { type: \"number\" },\r\n        volumeWindowWidth: { type: \"number\" }\r\n    },\r\n    init: function () {\r\n        this.tickFunction = AFRAME.utils.throttle(this.tickFunction, this.data.minFrameMS, this);\r\n        this.loader = new VolumetricLoader();\r\n        this.state = {\r\n            bufferScene: new THREE.Scene(),\r\n            bufferSceneTextureHeight: this.el.sceneEl.canvas.clientHeight,\r\n            bufferSceneTextureWidth: this.el.sceneEl.canvas.clientWidth,\r\n            debounce: false,\r\n            frameTime: window.performance.now(),\r\n            loaded: false,\r\n            lastRenderTime: 0,\r\n            volumeSteps: 0\r\n        };\r\n        this.bindMethods();\r\n        this.addEventListeners();\r\n        this.createBufferTexture();\r\n        this.debouncedRenderBufferScene = EventUtils.debounce(this.renderBufferScene, this.data.minFrameMS).bind(this);\r\n    },\r\n    bindMethods: function () {\r\n        this.addEventListeners = this.addEventListeners.bind(this);\r\n        this.denormaliseVolumeSteps = this.denormaliseVolumeSteps.bind(this);\r\n        this.castVolumeRay = this.castVolumeRay.bind(this);\r\n        this.createBufferTexture = this.createBufferTexture.bind(this);\r\n        this.getDefaultVolumeSteps = this.getDefaultVolumeSteps.bind(this);\r\n        this.handleStack = this.handleStack.bind(this);\r\n        this.onInteraction = this.onInteraction.bind(this);\r\n        this.onInteractionFinished = this.onInteractionFinished.bind(this);\r\n        this.removeEventListeners = this.removeEventListeners.bind(this);\r\n        this.renderBufferScene = this.renderBufferScene.bind(this);\r\n        this.rendererResize = this.rendererResize.bind(this);\r\n        this.updateSlicesStack = this.updateSlicesStack.bind(this);\r\n        this.updateVolumeStack = this.updateVolumeStack.bind(this);\r\n    },\r\n    addEventListeners: function () {\r\n        this.el.sceneEl.addEventListener(\"rendererresize\", this.rendererResize, false);\r\n        this.el.sceneEl.addEventListener(AlControlEvents$1.INTERACTION, this.onInteraction, false);\r\n        this.el.sceneEl.addEventListener(AlControlEvents$1.INTERACTION_FINISHED, this.onInteractionFinished, false);\r\n        this.el.sceneEl.addEventListener(AlVolumeEvents.VOLUME_RAY_REQUEST, this.castVolumeRay, false);\r\n    },\r\n    removeEventListeners: function () {\r\n        this.el.sceneEl.removeEventListener(\"rendererresize\", this.rendererResize);\r\n        this.el.sceneEl.removeEventListener(AlControlEvents$1.INTERACTION, this.onInteraction);\r\n        this.el.sceneEl.removeEventListener(AlControlEvents$1.INTERACTION_FINISHED, this.onInteractionFinished);\r\n        this.el.sceneEl.addEventListener(AlVolumeEvents.VOLUME_RAY_REQUEST, this.castVolumeRay);\r\n    },\r\n    castVolumeRay: function (event) {\r\n        var camPos = event.detail.cameraPosition;\r\n        var camDir = event.detail.cameraDirection;\r\n        var intersection = event.detail.intersection;\r\n        var hitPosition = new THREE.Vector3();\r\n        var hitNormal = new THREE.Vector3();\r\n        var rayResult = AMIUtils.volumeRay(this.state.stackhelper, camPos, camDir, Constants.camera.far, hitPosition, hitNormal);\r\n        this.el.sceneEl.emit(AlVolumeEvents.VOLUME_RAY_CAST, {\r\n            hitPosition: hitPosition,\r\n            intersection: intersection,\r\n            rayResult: rayResult,\r\n            hitNormal: hitNormal,\r\n            type: event.detail.type\r\n        });\r\n    },\r\n    createBufferTexture: function () {\r\n        this.state.bufferSceneTexture = new THREE.WebGLRenderTarget(this.state.bufferSceneTextureWidth, this.state.bufferSceneTextureHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter });\r\n        this.el.sceneEl\r\n            .object3D.background = this.state.bufferSceneTexture.texture;\r\n    },\r\n    onInteraction: function (event) {\r\n        if (this.state.stackhelper && event.detail.needsRender) {\r\n            this.state.volumeSteps = 2;\r\n        }\r\n    },\r\n    onInteractionFinished: function (event) {\r\n        if (this.state.stackhelper && event.detail.needsRender) {\r\n            this.state.volumeSteps = this.denormaliseVolumeSteps(this.data.volumeSteps);\r\n        }\r\n        this.state.debounce = false;\r\n    },\r\n    getDefaultVolumeSteps: function () {\r\n        // default to 128 steps for desktop (2 ^ 7), 32 steps for mobile (2 ^ 5)\r\n        var power;\r\n        if (AFRAME.utils.device.isMobile()) {\r\n            power = 5;\r\n        }\r\n        else {\r\n            power = 7;\r\n        }\r\n        var steps = Math.pow(2, power);\r\n        return steps;\r\n    },\r\n    denormaliseVolumeSteps: function (normalisedValue) {\r\n        var steps = Math.pow(2, normalisedValue * 10);\r\n        return steps;\r\n    },\r\n    rendererResize: function () {\r\n        var state = this.state;\r\n        var needsResize = state.bufferSceneTextureWidth !== this.el.sceneEl.canvas.clientWidth ||\r\n            state.bufferSceneTextureHeight !== this.el.sceneEl.canvas.clientHeight;\r\n        if (needsResize && this.data.displayMode === DisplayMode.VOLUME) {\r\n            state.bufferSceneTextureWidth = this.el.sceneEl.canvas.clientWidth;\r\n            state.bufferSceneTextureHeight = this.el.sceneEl.canvas.clientHeight;\r\n            this.state.volumeSteps = this.data.volumeSteps;\r\n        }\r\n    },\r\n    renderBufferScene: function () {\r\n        if (this.data.displayMode === DisplayMode.VOLUME) {\r\n            this.createBufferTexture();\r\n            this.state.stackhelper.steps = this.state.volumeSteps;\r\n            var prev = window.performance.now();\r\n            this.el.sceneEl.renderer.setRenderTarget(this.state.bufferSceneTexture);\r\n            this.el.sceneEl.renderer.render(this.state.bufferScene, this.el.sceneEl.camera);\r\n            this.el.sceneEl.renderer.setRenderTarget(null);\r\n            var post = window.performance.now();\r\n            var renderTime = post - prev;\r\n            this.state.lastRenderTime = renderTime;\r\n            this.state.volumeSteps = 0;\r\n        }\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    handleStack: function (stack) {\r\n        var state = this.state;\r\n        var el = this.el;\r\n        state.stack = stack;\r\n        switch (this.data.displayMode) {\r\n            case DisplayMode.SLICES: {\r\n                state.stackhelper = new AMI.StackHelper(state.stack);\r\n                state.stackhelper.bbox.visible = false;\r\n                state.stackhelper.border.color = Constants.colors.blue;\r\n                break;\r\n            }\r\n            case DisplayMode.VOLUME: {\r\n                // Get LUT Canvas\r\n                var lutCanvases = el.sceneEl.parentEl.querySelector(\"#lut-canvases\");\r\n                // Create the LUT Helper\r\n                state.lutHelper = new AMI.LutHelper(lutCanvases);\r\n                state.lutHelper.luts = AMI.LutHelper.presetLuts();\r\n                state.lutHelper.lutsO = AMI.LutHelper.presetLutsO();\r\n                state.stackhelper = new AMI.VolumeRenderHelper(state.stack);\r\n                state.stackhelper.textureLUT = state.lutHelper.texture;\r\n                state.stackhelper.steps = this.getDefaultVolumeSteps();\r\n                break;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n        // If a hot reload of the display, reset the mesh\r\n        if (el.object3DMap.mesh) {\r\n            el.removeObject3D(\"mesh\");\r\n        }\r\n        // If slices mode, set stackhelper as the mesh\r\n        if (this.data.displayMode === DisplayMode.SLICES) {\r\n            el.setObject3D(\"mesh\", this.state.stackhelper);\r\n        }\r\n        else {\r\n            // Else place it in the buffer scene\r\n            if (this.state.bufferScene.children.length) {\r\n                this.state.bufferScene.remove(this.state.bufferScene.children[0]);\r\n            }\r\n            this.state.bufferScene.add(this.state.stackhelper);\r\n        }\r\n        if (!this.state.loaded) {\r\n            el.sceneEl.emit(AlVolumeEvents.LOADED, state.stackhelper, false);\r\n            this.state.loaded = true;\r\n        }\r\n    },\r\n    updateSlicesStack: function () {\r\n        if (!this.state.stackhelper ||\r\n            (this.state.stackhelper &&\r\n                !this.state.stackhelper.slice)) {\r\n            return;\r\n        }\r\n        var orientationIndex = Object.keys(Orientation).indexOf(this.data.slicesOrientation.toUpperCase());\r\n        // based off zCosine, x:1 = saggital, y:1 = coronal, z:1 = axial\r\n        var zCosine = this.state.stackhelper.stack.zCosine;\r\n        var orientationOffset;\r\n        // If DICOM's up axis is X, offset the viewer's orientation by 1\r\n        if (Math.round(zCosine.x) === 1) {\r\n            orientationOffset = 1;\r\n        }\r\n        // If the DICOM's up is Y, offset the viewer's orientation by 2\r\n        else if (Math.round(zCosine.y) === 1) {\r\n            orientationOffset = 2;\r\n        }\r\n        // Else Orientation matches viewer orientation, no offset\r\n        else {\r\n            orientationOffset = 0;\r\n        }\r\n        // Wrap the orientationIndex so that it may never exceed 2\r\n        var displayOrientationIndex = Math.round((orientationIndex + orientationOffset) % 3);\r\n        var stackOrientationIndex = Math.round((orientationIndex + orientationOffset + 2) % 3);\r\n        var slicesIndexMax = this.state.stackhelper.stack.dimensionsIJK[Object.keys(this.state.stackhelper.stack.dimensionsIJK)[stackOrientationIndex]] - 1;\r\n        var index;\r\n        if (stackOrientationIndex !== this._lastStackOrientationIndex ||\r\n            this.data.slicesIndex === undefined) {\r\n            // set default\r\n            index = Math.floor(slicesIndexMax * 0.5);\r\n            this.el.sceneEl.emit(AlVolumeEvents.SLICES_MAX_INDEX, slicesIndexMax, false);\r\n        }\r\n        else {\r\n            index = slicesIndexMax * this.data.slicesIndex;\r\n        }\r\n        this._lastStackOrientationIndex = stackOrientationIndex;\r\n        // brightness\r\n        var windowCenterMax = this.state.stackhelper.stack.minMax[1];\r\n        var windowCenter = Math.floor(Utils.reverseNumber(windowCenterMax * this.data.volumeWindowCenter, 0, windowCenterMax));\r\n        // contrast\r\n        var windowWidthMax = this.state.stackhelper.stack.minMax[1] -\r\n            this.state.stackhelper.stack.minMax[0];\r\n        var windowWidth = Math.floor(windowWidthMax * this.data.volumeWindowWidth);\r\n        // update the stackhelper\r\n        this.state\r\n            .stackhelper.orientation = displayOrientationIndex;\r\n        this.state.stackhelper.index = index;\r\n        this.state\r\n            .stackhelper.slice.windowCenter = windowCenter;\r\n        this.state.stackhelper.slice.windowWidth = windowWidth;\r\n    },\r\n    updateVolumeStack: function () {\r\n        if (!this.state.stackhelper) {\r\n            return;\r\n        }\r\n        // brightness\r\n        var windowCenterMax = this.state.stackhelper.stack.minMax[1];\r\n        var windowCenter = Math.floor(Utils.reverseNumber(windowCenterMax * this.data.volumeWindowCenter, 0, windowCenterMax));\r\n        // contrast\r\n        var windowWidthMax = this.state.stackhelper.stack.minMax[1] -\r\n            this.state.stackhelper.stack.minMax[0];\r\n        var windowWidth = Math.floor(windowWidthMax * this.data.volumeWindowWidth);\r\n        // update the stackhelper\r\n        this.state\r\n            .stackhelper.windowCenter = windowCenter;\r\n        this.state\r\n            .stackhelper.windowWidth = windowWidth;\r\n    },\r\n    // tslint:disable-next-line: no-any\r\n    update: function (oldData) {\r\n        var _this_1 = this;\r\n        var state = this.state;\r\n        var el = this.el;\r\n        if (!this.data.src) {\r\n            return;\r\n        }\r\n        if (oldData && oldData.src !== this.data.src) {\r\n            // loading\r\n            this.loader.load(this.data.src, el).then(function (stack) {\r\n                _this_1.handleStack(stack);\r\n            });\r\n        }\r\n        else if (oldData &&\r\n            oldData.displayMode !== this.data.displayMode &&\r\n            state.stack) {\r\n            // switching display mode\r\n            this.removeEventListeners();\r\n            this.handleStack(state.stack);\r\n            this.addEventListeners();\r\n            // if in volume mode, create a buffer texture\r\n            if (this.data.displayMode === DisplayMode.VOLUME) {\r\n                this.createBufferTexture();\r\n                // allow some time for the stackhelper to update\r\n                setTimeout(function () {\r\n                    var defaultVolumeSteps = _this_1.getDefaultVolumeSteps();\r\n                    var normalised = Math.log2(defaultVolumeSteps) / 10;\r\n                    _this_1.el.sceneEl.emit(AlVolumeEvents.DEFAULT_RENDER_STEPS, normalised, false);\r\n                    _this_1.state.volumeSteps = defaultVolumeSteps;\r\n                }, Constants.volumeStepsDelay);\r\n            }\r\n            else {\r\n                this.el.sceneEl.object3D.background = null;\r\n            }\r\n        }\r\n        switch (this.data.displayMode) {\r\n            case DisplayMode.SLICES: {\r\n                this.updateSlicesStack();\r\n                break;\r\n            }\r\n            case DisplayMode.VOLUME: {\r\n                this.updateVolumeStack();\r\n                if (oldData && oldData.volumeSteps !== this.data.volumeSteps) {\r\n                    this.state.volumeSteps = this.denormaliseVolumeSteps(this.data.volumeSteps);\r\n                }\r\n                // if the controls type has changed, re-render the buffer scene\r\n                if (oldData &&\r\n                    oldData.controlsType &&\r\n                    oldData.controlsType !== this.data.controlsType) {\r\n                    setTimeout(function () {\r\n                        _this_1.state.volumeSteps = _this_1.denormaliseVolumeSteps(_this_1.data.volumeSteps);\r\n                    }, Constants.volumeStepsDelay);\r\n                }\r\n                // if the volumeSteps changed\r\n                if (oldData &&\r\n                    oldData.volumeWindowCenter &&\r\n                    oldData.volumeWindowCenter !== this.data.volumeWindowCenter) {\r\n                    this.state.debounce = true;\r\n                    this.state.stackhelper.stack.windowCenter = this.data.volumeWindowCenter;\r\n                    this.state.volumeSteps = this.denormaliseVolumeSteps(this.data.volumeSteps);\r\n                }\r\n                // if the volumeWindowWidth changed\r\n                if (oldData &&\r\n                    oldData.volumeWindowWidth &&\r\n                    oldData.volumeWindowWidth !== this.data.volumeWindowWidth) {\r\n                    this.state.debounce = true;\r\n                    this.state.stackhelper.stack.windowWidth = this.data.volumeWindowWidth;\r\n                    this.state.volumeSteps = this.denormaliseVolumeSteps(this.data.volumeSteps);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n    },\r\n    tickFunction: function () {\r\n        if (!this.state.stackhelper) {\r\n            return;\r\n        }\r\n        if (this.data.displayMode === DisplayMode.SLICES) {\r\n            this.el.setObject3D(\"mesh\", this.state.stackhelper);\r\n        }\r\n        if (this.state.volumeSteps > 0 && !this.state.debounce) {\r\n            this.renderBufferScene();\r\n        }\r\n    },\r\n    tick: function () {\r\n        this.tickFunction();\r\n    },\r\n    remove: function () {\r\n        if (this.data.displayMode === DisplayMode.SLICES) {\r\n            this.el.removeObject3D(\"mesh\");\r\n        }\r\n        this.removeEventListeners();\r\n        this.el.sceneEl.object3D.background = null;\r\n    }\r\n});\r\nAFRAME.registerPrimitive(\"al-a-camera\", {\r\n    defaultComponents: {\r\n        camera: {},\r\n        \"look-controls\": {},\r\n        \"wasd-controls\": {},\r\n        position: { x: 0, y: 1.6, z: 0 }\r\n    },\r\n    mappings: {\r\n        active: \"camera.active\",\r\n        aspect: \"camera.aspect\",\r\n        far: \"camera.far\",\r\n        fov: \"camera.fov\",\r\n        \"look-controls-enabled\": \"look-controls.enabled\",\r\n        near: \"camera.near\",\r\n        \"pointer-lock-enabled\": \"look-controls.pointerLockEnabled\",\r\n        \"wasd-controls-enabled\": \"wasd-controls.enabled\",\r\n        \"reverse-mouse-drag\": \"look-controls.reverseMouseDrag\",\r\n        zoom: \"camera.zoom\"\r\n    }\r\n});\r\nvar AlGltfModelEvents$1 = {\r\n    LOADED: \"al-model-loaded\",\r\n    ERROR: \"al-model-error\"\r\n};\r\nvar AlNodeSpawnerEvents = {\r\n    VALID_TARGET: \"al-valid-target\",\r\n    ADD_NODE: \"al-add-node\"\r\n};\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n// three@0.102.1 (have to bundle from assets to avoid THREE and AFRAME type clashes)\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one-finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\r\nTHREE.OrbitControls = function (object, domElement) {\r\n    this.object = object;\r\n    this.domElement = (domElement !== undefined) ? domElement : document;\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n    // \"target\" sets the location of focus, where the object orbits around\r\n    this.target = new THREE.Vector3();\r\n    // How far you can dolly in and out ( PerspectiveCamera only )\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n    // How far you can zoom in and out ( OrthographicCamera only )\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity;\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n    // How far you can orbit horizontally, upper and lower limits.\r\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n    this.minAzimuthAngle = -Infinity; // radians\r\n    this.maxAzimuthAngle = Infinity; // radians\r\n    // Set to true to enable damping (inertia)\r\n    // If damping is enabled, you must call controls.update() in your animation loop\r\n    this.enableDamping = false;\r\n    this.dampingFactor = 0.25;\r\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n    // Set to false to disable zooming\r\n    this.enableZoom = true;\r\n    this.zoomSpeed = 1.0;\r\n    // Set to false to disable rotating\r\n    this.enableRotate = true;\r\n    this.rotateSpeed = 1.0;\r\n    // Set to false to disable panning\r\n    this.enablePan = true;\r\n    this.panSpeed = 1.0;\r\n    this.screenSpacePanning = false; // if true, pan in screen-space\r\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\r\n    // Set to true to automatically rotate around the target\r\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n    // Set to false to disable use of the keys\r\n    this.enableKeys = true;\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n    // Mouse buttons\r\n    this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };\r\n    // for reset\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.object.position.clone();\r\n    this.zoom0 = this.object.zoom;\r\n    //\r\n    // public methods\r\n    //\r\n    this.getPolarAngle = function () {\r\n        return spherical.phi;\r\n    };\r\n    this.getAzimuthalAngle = function () {\r\n        return spherical.theta;\r\n    };\r\n    this.saveState = function () {\r\n        scope.target0.copy(scope.target);\r\n        scope.position0.copy(scope.object.position);\r\n        scope.zoom0 = scope.object.zoom;\r\n    };\r\n    this.reset = function () {\r\n        scope.target.copy(scope.target0);\r\n        scope.object.position.copy(scope.position0);\r\n        scope.object.zoom = scope.zoom0;\r\n        scope.object.updateProjectionMatrix();\r\n        scope.dispatchEvent(changeEvent);\r\n        scope.update();\r\n        state = STATE.NONE;\r\n    };\r\n    // this method is exposed, but perhaps it would be better if we can make it private...\r\n    this.update = function () {\r\n        var offset = new THREE.Vector3();\r\n        // so camera.up is the orbit axis\r\n        var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\r\n        var quatInverse = quat.clone().inverse();\r\n        var lastPosition = new THREE.Vector3();\r\n        var lastQuaternion = new THREE.Quaternion();\r\n        return function update() {\r\n            var position = scope.object.position;\r\n            offset.copy(position).sub(scope.target);\r\n            // rotate offset to \"y-axis-is-up\" space\r\n            offset.applyQuaternion(quat);\r\n            // angle from z-axis around y-axis\r\n            spherical.setFromVector3(offset);\r\n            if (scope.autoRotate && state === STATE.NONE) {\r\n                rotateLeft(getAutoRotationAngle());\r\n            }\r\n            spherical.theta += sphericalDelta.theta;\r\n            spherical.phi += sphericalDelta.phi;\r\n            // restrict theta to be between desired limits\r\n            spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\r\n            // restrict phi to be between desired limits\r\n            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\r\n            spherical.makeSafe();\r\n            spherical.radius *= scale;\r\n            // restrict radius to be between desired limits\r\n            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\r\n            // move target to panned location\r\n            scope.target.add(panOffset);\r\n            offset.setFromSpherical(spherical);\r\n            // rotate offset back to \"camera-up-vector-is-up\" space\r\n            offset.applyQuaternion(quatInverse);\r\n            position.copy(scope.target).add(offset);\r\n            scope.object.lookAt(scope.target);\r\n            if (scope.enableDamping === true) {\r\n                sphericalDelta.theta *= (1 - scope.dampingFactor);\r\n                sphericalDelta.phi *= (1 - scope.dampingFactor);\r\n                panOffset.multiplyScalar(1 - scope.dampingFactor);\r\n            }\r\n            else {\r\n                sphericalDelta.set(0, 0, 0);\r\n                panOffset.set(0, 0, 0);\r\n            }\r\n            scale = 1;\r\n            // update condition is:\r\n            // min(camera displacement, camera rotation in radians)^2 > EPS\r\n            // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n            if (zoomChanged ||\r\n                lastPosition.distanceToSquared(scope.object.position) > EPS ||\r\n                8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\r\n                scope.dispatchEvent(changeEvent);\r\n                lastPosition.copy(scope.object.position);\r\n                lastQuaternion.copy(scope.object.quaternion);\r\n                zoomChanged = false;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n    }();\r\n    this.dispose = function () {\r\n        scope.domElement.removeEventListener('contextmenu', onContextMenu, false);\r\n        scope.domElement.removeEventListener('mousedown', onMouseDown, false);\r\n        scope.domElement.removeEventListener('wheel', onMouseWheel, false);\r\n        scope.domElement.removeEventListener('touchstart', onTouchStart, false);\r\n        scope.domElement.removeEventListener('touchend', onTouchEnd, false);\r\n        scope.domElement.removeEventListener('touchmove', onTouchMove, false);\r\n        document.removeEventListener('mousemove', onMouseMove, false);\r\n        document.removeEventListener('mouseup', onMouseUp, false);\r\n        window.removeEventListener('keydown', onKeyDown, false);\r\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n    };\r\n    //\r\n    // internals\r\n    //\r\n    var scope = this;\r\n    var changeEvent = { type: 'change' };\r\n    var startEvent = { type: 'start' };\r\n    var endEvent = { type: 'end' };\r\n    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\r\n    var state = STATE.NONE;\r\n    var EPS = 0.000001;\r\n    // current position in spherical coordinates\r\n    var spherical = new THREE.Spherical();\r\n    var sphericalDelta = new THREE.Spherical();\r\n    var scale = 1;\r\n    var panOffset = new THREE.Vector3();\r\n    var zoomChanged = false;\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n    function getAutoRotationAngle() {\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n    }\r\n    function getZoomScale() {\r\n        return Math.pow(0.95, scope.zoomSpeed);\r\n    }\r\n    function rotateLeft(angle) {\r\n        sphericalDelta.theta -= angle;\r\n    }\r\n    function rotateUp(angle) {\r\n        sphericalDelta.phi -= angle;\r\n    }\r\n    var panLeft = function () {\r\n        var v = new THREE.Vector3();\r\n        return function panLeft(distance, objectMatrix) {\r\n            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\r\n            v.multiplyScalar(-distance);\r\n            panOffset.add(v);\r\n        };\r\n    }();\r\n    var panUp = function () {\r\n        var v = new THREE.Vector3();\r\n        return function panUp(distance, objectMatrix) {\r\n            if (scope.screenSpacePanning === true) {\r\n                v.setFromMatrixColumn(objectMatrix, 1);\r\n            }\r\n            else {\r\n                v.setFromMatrixColumn(objectMatrix, 0);\r\n                v.crossVectors(scope.object.up, v);\r\n            }\r\n            v.multiplyScalar(distance);\r\n            panOffset.add(v);\r\n        };\r\n    }();\r\n    // deltaX and deltaY are in pixels; right and down are positive\r\n    var pan = function () {\r\n        var offset = new THREE.Vector3();\r\n        return function pan(deltaX, deltaY) {\r\n            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n            if (scope.object.isPerspectiveCamera) {\r\n                // perspective\r\n                var position = scope.object.position;\r\n                offset.copy(position).sub(scope.target);\r\n                var targetDistance = offset.length();\r\n                // half of the fov is center to top of screen\r\n                targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\r\n                // we use only clientHeight here so aspect ratio does not distort speed\r\n                panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\r\n                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\r\n            }\r\n            else if (scope.object.isOrthographicCamera) {\r\n                // orthographic\r\n                panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\r\n                panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\r\n            }\r\n            else {\r\n                // camera neither orthographic nor perspective\r\n                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\r\n                scope.enablePan = false;\r\n            }\r\n        };\r\n    }();\r\n    function dollyIn(dollyScale) {\r\n        if (scope.object.isPerspectiveCamera) {\r\n            scale /= dollyScale;\r\n        }\r\n        else if (scope.object.isOrthographicCamera) {\r\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n        }\r\n        else {\r\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n            scope.enableZoom = false;\r\n        }\r\n    }\r\n    function dollyOut(dollyScale) {\r\n        if (scope.object.isPerspectiveCamera) {\r\n            scale *= dollyScale;\r\n        }\r\n        else if (scope.object.isOrthographicCamera) {\r\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n        }\r\n        else {\r\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n            scope.enableZoom = false;\r\n        }\r\n    }\r\n    //\r\n    // event callbacks - update the object state\r\n    //\r\n    function handleMouseDownRotate(event) {\r\n        //console.log( 'handleMouseDownRotate' );\r\n        rotateStart.set(event.clientX, event.clientY);\r\n    }\r\n    function handleMouseDownDolly(event) {\r\n        //console.log( 'handleMouseDownDolly' );\r\n        dollyStart.set(event.clientX, event.clientY);\r\n    }\r\n    function handleMouseDownPan(event) {\r\n        //console.log( 'handleMouseDownPan' );\r\n        panStart.set(event.clientX, event.clientY);\r\n    }\r\n    function handleMouseMoveRotate(event) {\r\n        //console.log( 'handleMouseMoveRotate' );\r\n        rotateEnd.set(event.clientX, event.clientY);\r\n        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\r\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\r\n        rotateStart.copy(rotateEnd);\r\n        scope.update();\r\n    }\r\n    function handleMouseMoveDolly(event) {\r\n        //console.log( 'handleMouseMoveDolly' );\r\n        dollyEnd.set(event.clientX, event.clientY);\r\n        dollyDelta.subVectors(dollyEnd, dollyStart);\r\n        if (dollyDelta.y > 0) {\r\n            dollyIn(getZoomScale());\r\n        }\r\n        else if (dollyDelta.y < 0) {\r\n            dollyOut(getZoomScale());\r\n        }\r\n        dollyStart.copy(dollyEnd);\r\n        scope.update();\r\n    }\r\n    function handleMouseMovePan(event) {\r\n        //console.log( 'handleMouseMovePan' );\r\n        panEnd.set(event.clientX, event.clientY);\r\n        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\r\n        pan(panDelta.x, panDelta.y);\r\n        panStart.copy(panEnd);\r\n        scope.update();\r\n    }\r\n    function handleMouseWheel(event) {\r\n        // console.log( 'handleMouseWheel' );\r\n        if (event.deltaY < 0) {\r\n            dollyOut(getZoomScale());\r\n        }\r\n        else if (event.deltaY > 0) {\r\n            dollyIn(getZoomScale());\r\n        }\r\n        scope.update();\r\n    }\r\n    function handleKeyDown(event) {\r\n        // console.log( 'handleKeyDown' );\r\n        var needsUpdate = false;\r\n        switch (event.keyCode) {\r\n            case scope.keys.UP:\r\n                pan(0, scope.keyPanSpeed);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.BOTTOM:\r\n                pan(0, -scope.keyPanSpeed);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.LEFT:\r\n                pan(scope.keyPanSpeed, 0);\r\n                needsUpdate = true;\r\n                break;\r\n            case scope.keys.RIGHT:\r\n                pan(-scope.keyPanSpeed, 0);\r\n                needsUpdate = true;\r\n                break;\r\n        }\r\n        if (needsUpdate) {\r\n            // prevent the browser from scrolling on cursor keys\r\n            event.preventDefault();\r\n            scope.update();\r\n        }\r\n    }\r\n    function handleTouchStartRotate(event) {\r\n        //console.log( 'handleTouchStartRotate' );\r\n        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\r\n    }\r\n    function handleTouchStartDollyPan(event) {\r\n        //console.log( 'handleTouchStartDollyPan' );\r\n        if (scope.enableZoom) {\r\n            var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n            var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n            var distance = Math.sqrt(dx * dx + dy * dy);\r\n            dollyStart.set(0, distance);\r\n        }\r\n        if (scope.enablePan) {\r\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n            panStart.set(x, y);\r\n        }\r\n    }\r\n    function handleTouchMoveRotate(event) {\r\n        //console.log( 'handleTouchMoveRotate' );\r\n        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\r\n        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\r\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\r\n        rotateStart.copy(rotateEnd);\r\n        scope.update();\r\n    }\r\n    function handleTouchMoveDollyPan(event) {\r\n        //console.log( 'handleTouchMoveDollyPan' );\r\n        if (scope.enableZoom) {\r\n            var dx = event.touches[0].pageX - event.touches[1].pageX;\r\n            var dy = event.touches[0].pageY - event.touches[1].pageY;\r\n            var distance = Math.sqrt(dx * dx + dy * dy);\r\n            dollyEnd.set(0, distance);\r\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\r\n            dollyIn(dollyDelta.y);\r\n            dollyStart.copy(dollyEnd);\r\n        }\r\n        if (scope.enablePan) {\r\n            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n            panEnd.set(x, y);\r\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\r\n            pan(panDelta.x, panDelta.y);\r\n            panStart.copy(panEnd);\r\n        }\r\n        scope.update();\r\n    }\r\n    //\r\n    // event handlers - FSM: listen for events and reset state\r\n    //\r\n    function onMouseDown(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        // Prevent the browser from scrolling.\r\n        event.preventDefault();\r\n        // Manually set the focus since calling preventDefault above\r\n        // prevents the browser from setting it automatically.\r\n        scope.domElement.focus ? scope.domElement.focus() : window.focus();\r\n        switch (event.button) {\r\n            case scope.mouseButtons.LEFT:\r\n                if (event.ctrlKey || event.metaKey || event.shiftKey) {\r\n                    if (scope.enablePan === false)\r\n                        return;\r\n                    handleMouseDownPan(event);\r\n                    state = STATE.PAN;\r\n                }\r\n                else {\r\n                    if (scope.enableRotate === false)\r\n                        return;\r\n                    handleMouseDownRotate(event);\r\n                    state = STATE.ROTATE;\r\n                }\r\n                break;\r\n            case scope.mouseButtons.MIDDLE:\r\n                if (scope.enableZoom === false)\r\n                    return;\r\n                handleMouseDownDolly(event);\r\n                state = STATE.DOLLY;\r\n                break;\r\n            case scope.mouseButtons.RIGHT:\r\n                if (scope.enablePan === false)\r\n                    return;\r\n                handleMouseDownPan(event);\r\n                state = STATE.PAN;\r\n                break;\r\n        }\r\n        if (state !== STATE.NONE) {\r\n            document.addEventListener('mousemove', onMouseMove, false);\r\n            document.addEventListener('mouseup', onMouseUp, false);\r\n            scope.dispatchEvent(startEvent);\r\n        }\r\n    }\r\n    function onMouseMove(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        event.preventDefault();\r\n        switch (state) {\r\n            case STATE.ROTATE:\r\n                if (scope.enableRotate === false)\r\n                    return;\r\n                handleMouseMoveRotate(event);\r\n                break;\r\n            case STATE.DOLLY:\r\n                if (scope.enableZoom === false)\r\n                    return;\r\n                handleMouseMoveDolly(event);\r\n                break;\r\n            case STATE.PAN:\r\n                if (scope.enablePan === false)\r\n                    return;\r\n                handleMouseMovePan(event);\r\n                break;\r\n        }\r\n    }\r\n    function onMouseUp(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        document.removeEventListener('mousemove', onMouseMove, false);\r\n        document.removeEventListener('mouseup', onMouseUp, false);\r\n        scope.dispatchEvent(endEvent);\r\n        state = STATE.NONE;\r\n    }\r\n    function onMouseWheel(event) {\r\n        if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE))\r\n            return;\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        scope.dispatchEvent(startEvent);\r\n        handleMouseWheel(event);\r\n        scope.dispatchEvent(endEvent);\r\n    }\r\n    function onKeyDown(event) {\r\n        if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false)\r\n            return;\r\n        handleKeyDown(event);\r\n    }\r\n    function onTouchStart(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        event.preventDefault();\r\n        switch (event.touches.length) {\r\n            case 1: // one-fingered touch: rotate\r\n                if (scope.enableRotate === false)\r\n                    return;\r\n                handleTouchStartRotate(event);\r\n                state = STATE.TOUCH_ROTATE;\r\n                break;\r\n            case 2: // two-fingered touch: dolly-pan\r\n                if (scope.enableZoom === false && scope.enablePan === false)\r\n                    return;\r\n                handleTouchStartDollyPan(event);\r\n                state = STATE.TOUCH_DOLLY_PAN;\r\n                break;\r\n            default:\r\n                state = STATE.NONE;\r\n        }\r\n        if (state !== STATE.NONE) {\r\n            scope.dispatchEvent(startEvent);\r\n        }\r\n    }\r\n    function onTouchMove(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        switch (event.touches.length) {\r\n            case 1: // one-fingered touch: rotate\r\n                if (scope.enableRotate === false)\r\n                    return;\r\n                if (state !== STATE.TOUCH_ROTATE)\r\n                    return; // is this needed?\r\n                handleTouchMoveRotate(event);\r\n                break;\r\n            case 2: // two-fingered touch: dolly-pan\r\n                if (scope.enableZoom === false && scope.enablePan === false)\r\n                    return;\r\n                if (state !== STATE.TOUCH_DOLLY_PAN)\r\n                    return; // is this needed?\r\n                handleTouchMoveDollyPan(event);\r\n                break;\r\n            default:\r\n                state = STATE.NONE;\r\n        }\r\n    }\r\n    function onTouchEnd(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        scope.dispatchEvent(endEvent);\r\n        state = STATE.NONE;\r\n    }\r\n    function onContextMenu(event) {\r\n        if (scope.enabled === false)\r\n            return;\r\n        event.preventDefault();\r\n    }\r\n    //\r\n    scope.domElement.addEventListener('contextmenu', onContextMenu, false);\r\n    scope.domElement.addEventListener('mousedown', onMouseDown, false);\r\n    scope.domElement.addEventListener('wheel', onMouseWheel, false);\r\n    scope.domElement.addEventListener('touchstart', onTouchStart, false);\r\n    scope.domElement.addEventListener('touchend', onTouchEnd, false);\r\n    scope.domElement.addEventListener('touchmove', onTouchMove, false);\r\n    window.addEventListener('keydown', onKeyDown, false);\r\n    // force an update at start\r\n    this.update();\r\n};\r\nTHREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\r\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\r\nObject.defineProperties(THREE.OrbitControls.prototype, {\r\n    center: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .center has been renamed to .target');\r\n            return this.target;\r\n        }\r\n    },\r\n    // backward compatibility\r\n    noZoom: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\r\n            return !this.enableZoom;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\r\n            this.enableZoom = !value;\r\n        }\r\n    },\r\n    noRotate: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\r\n            return !this.enableRotate;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\r\n            this.enableRotate = !value;\r\n        }\r\n    },\r\n    noPan: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\r\n            return !this.enablePan;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\r\n            this.enablePan = !value;\r\n        }\r\n    },\r\n    noKeys: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\r\n            return !this.enableKeys;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\r\n            this.enableKeys = !value;\r\n        }\r\n    },\r\n    staticMoving: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\r\n            return !this.enableDamping;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\r\n            this.enableDamping = !value;\r\n        }\r\n    },\r\n    dynamicDampingFactor: {\r\n        get: function () {\r\n            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\r\n            return this.dampingFactor;\r\n        },\r\n        set: function (value) {\r\n            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\r\n            this.dampingFactor = value;\r\n        }\r\n    }\r\n});\r\nvar Angles = function (_b, _children) {\r\n    var angles = _b.angles, boundingSphereRadius = _b.boundingSphereRadius, camera = _b.camera, cameraPosition = _b.cameraPosition, controlsType = _b.controlsType, edges = _b.edges, edgeSize = _b.edgeSize, fontSize = _b.fontSize, nodes = _b.nodes, selected = _b.selected;\r\n    return (function () {\r\n        return Array.from(angles).map(function (n) {\r\n            var angleId = n[0], angle = n[1];\r\n            var edge1 = edges.get(angle.edge1Id);\r\n            var edge2 = edges.get(angle.edge2Id);\r\n            if (edge1 && edge2) {\r\n                var centralNode = void 0;\r\n                var node1 = void 0;\r\n                var node2 = void 0;\r\n                // IF E1N1 === E2N1\r\n                if (edge1.node1Id === edge2.node1Id) {\r\n                    centralNode = nodes.get(edge2.node1Id);\r\n                    node1 = nodes.get(edge1.node2Id);\r\n                    node2 = nodes.get(edge2.node2Id);\r\n                }\r\n                // IF E1N1 === E2N2\r\n                else if (edge1.node1Id === edge2.node2Id) {\r\n                    centralNode = nodes.get(edge2.node2Id);\r\n                    node1 = nodes.get(edge1.node2Id);\r\n                    node2 = nodes.get(edge2.node1Id);\r\n                }\r\n                // IF E1N2 === E2N1\r\n                else if (edge1.node2Id === edge2.node1Id) {\r\n                    centralNode = nodes.get(edge2.node1Id);\r\n                    node1 = nodes.get(edge1.node1Id);\r\n                    node2 = nodes.get(edge2.node2Id);\r\n                }\r\n                // IF E1N2 === E2N2\r\n                else if (edge1.node2Id === edge2.node2Id) {\r\n                    centralNode = nodes.get(edge2.node2Id);\r\n                    node1 = nodes.get(edge1.node1Id);\r\n                    node2 = nodes.get(edge2.node1Id);\r\n                }\r\n                var radius = boundingSphereRadius * edgeSize;\r\n                var node1Pos = ThreeUtils.stringToVector3(node1.position);\r\n                var node2Pos = ThreeUtils.stringToVector3(node2.position);\r\n                var centralPos = ThreeUtils.stringToVector3(centralNode.position);\r\n                var dir1 = node1Pos\r\n                    .clone()\r\n                    .sub(centralPos)\r\n                    .normalize();\r\n                var dir2 = node2Pos\r\n                    .clone()\r\n                    .sub(centralPos)\r\n                    .normalize();\r\n                var angl = dir2.angleTo(dir1);\r\n                // get the edge with the smallest length\r\n                // set the distance from the connecting node to be 20% of the smallest length, unless it exceeds a max\r\n                var smallestLength = Math.min(centralPos.distanceTo(node1Pos), centralPos.distanceTo(node2Pos));\r\n                var distanceFromCentralNode = Math.min(smallestLength * 0.25, radius * 25);\r\n                distanceFromCentralNode = Math.max(distanceFromCentralNode, radius * 10);\r\n                var edge1Pos = dir1\r\n                    .clone()\r\n                    .multiplyScalar(distanceFromCentralNode);\r\n                var edge2Pos = dir2\r\n                    .clone()\r\n                    .multiplyScalar(distanceFromCentralNode);\r\n                var length = edge1Pos.clone().distanceTo(edge2Pos.clone());\r\n                var position = edge1Pos\r\n                    .clone()\r\n                    .add(edge2Pos.clone())\r\n                    .divideScalar(2);\r\n                var textOffset = new THREE.Vector3(0, 2.5, 0);\r\n                var scale = (node1.scale + node2.scale + centralNode.scale) / 3;\r\n                textOffset.multiplyScalar(scale);\r\n                var textV = THREE.Math.radToDeg(angl).toFixed(Constants.unitsDecimalPlaces) +\r\n                    \" deg\"; // todo: use i18n\r\n                var frustrumDistance = ThreeUtils.getFrustrumSpaceDistance(camera, centralPos.clone(), cameraPosition);\r\n                var entityScale = (frustrumDistance / boundingSphereRadius) *\r\n                    Constants.frustrumScaleFactor;\r\n                return (h(\"a-entity\", { \"al-child-hover-visible\": true, id: angleId + \"-parent\" }, h(\"a-entity\", { position: ThreeUtils.vector3ToString(centralPos), id: angleId + \"-title-anchor\", \"al-billboard\": \"\\n              controlsType: \" + controlsType + \";\\n              cameraPosition: \" + ThreeUtils.vector3ToString(camera.position) + \";\\n              worldPosition: \" + ThreeUtils.vector3ToString(centralPos.clone().add(textOffset.clone())) + \";\\n            \" }, h(\"a-entity\", { id: angleId + \"-title\", text: \"\\n                  value: \" + textV + \";\\n                  side: double;\\n                  align: center;\\n                  baseline: bottom;\\n                  anchor: center;\\n                  width: \" + fontSize * boundingSphereRadius + \"\\n                \", position: ThreeUtils.vector3ToString(textOffset), visible: \"\" + (selected === angleId), scale: \" \" + entityScale + \" \" + entityScale + \" \" + entityScale + \";\", \"al-background\": \"\\n                    text: \" + textV + \";\\n                    boundingRadius: \" + fontSize * boundingSphereRadius + \";\\n                \", \"al-render-overlaid\": true })), h(\"a-entity\", { \"data-raycastable\": true, id: angleId, position: centralNode.position, \"al-angle\": \"\\n                selected: \" + (selected === angleId) + \";\\n                edge0Pos: \" + ThreeUtils.vector3ToString(edge1Pos) + \";\\n                edge1Pos: \" + ThreeUtils.vector3ToString(edge2Pos) + \";\\n                position: \" + ThreeUtils.vector3ToString(position) + \";\\n                length: \" + length + \";\\n                radius: \" + radius + \";\\n                angle: \" + angle + \";\\n                scale: \" + entityScale + \";\\n              \" })));\r\n            }\r\n        });\r\n    })();\r\n};\r\nvar BoundingBox = function (_b, _children) {\r\n    var boundingBox = _b.boundingBox, boundingBoxEnabled = _b.boundingBoxEnabled, cb = _b.cb, color = _b.color, displayMode = _b.displayMode, graphEnabled = _b.graphEnabled, mesh = _b.mesh, srcLoaded = _b.srcLoaded, targetEntity = _b.targetEntity;\r\n    return (function () {\r\n        if (!srcLoaded) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (!mesh) {\r\n                return null;\r\n            }\r\n            var size = new THREE.Vector3();\r\n            boundingBox.getSize(size);\r\n            var meshGeom = mesh.geometry;\r\n            var position = void 0;\r\n            if (displayMode === DisplayMode.VOLUME) {\r\n                position = targetEntity.object3D.position\r\n                    .clone()\r\n                    .add(Utils.getGeometryCenter(meshGeom));\r\n                return (h(\"a-entity\", { \"data-raycastable\": true, position: ThreeUtils.vector3ToString(position), \"al-bounding-box\": \"\\n              scale: \" + ThreeUtils.vector3ToString(size) + \";\\n              color: \" + color + \";\\n              enabled: \" + boundingBoxEnabled + \";\\n            \", \"al-node-spawner\": \"\\n              graphEnabled: \" + graphEnabled + \";\\n            \", ref: function (ref) { return cb(ref); } }));\r\n            }\r\n            else if (displayMode === DisplayMode.SLICES) {\r\n                position = targetEntity.object3D.position\r\n                    .clone()\r\n                    .add(Utils.getGeometryCenter(meshGeom));\r\n                return (h(\"a-entity\", { position: ThreeUtils.vector3ToString(position), \"al-bounding-box\": \"\\n              scale: \" + ThreeUtils.vector3ToString(size) + \";\\n              color: \" + color + \";\\n              enabled: \" + boundingBoxEnabled + \";\\n            \", ref: function (ref) { return cb(ref); } }));\r\n            }\r\n            else {\r\n                var center = boundingBox.getCenter(new THREE.Vector3());\r\n                position = new THREE.Vector3();\r\n                position.x -= targetEntity.object3D.position.x - center.x;\r\n                position.y -= targetEntity.object3D.position.y - center.y;\r\n                position.z -= targetEntity.object3D.position.z - center.z;\r\n                return (h(\"a-entity\", { position: ThreeUtils.vector3ToString(position), \"al-bounding-box\": \"\\n              scale: \" + ThreeUtils.vector3ToString(size) + \";\\n              color: \" + color + \";\\n              enabled: \" + boundingBoxEnabled + \";\\n            \", ref: function (ref) { return cb(ref); } }));\r\n            }\r\n        }\r\n    })();\r\n};\r\nvar convertUnits = function (dist, displayMode, units) {\r\n    if (displayMode === DisplayMode.MESH) {\r\n        // if in mesh mode, units are always meters by default\r\n        switch (units) {\r\n            case Units.METERS: {\r\n                return dist.toFixed(Constants.unitsDecimalPlaces) + units;\r\n            }\r\n            case Units.MILLIMETERS: {\r\n                // convert m to mm\r\n                return (dist / 0.001).toFixed(Constants.unitsDecimalPlaces) + units;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // if in volume mode, units are always millimeters by default\r\n        switch (units) {\r\n            case Units.METERS: {\r\n                // convert mm to m\r\n                return (dist / 1000.0).toFixed(Constants.unitsDecimalPlaces) + units;\r\n            }\r\n            case Units.MILLIMETERS: {\r\n                return dist.toFixed(Constants.unitsDecimalPlaces) + units;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nvar Edges = function (_b, _children) {\r\n    var boundingSphereRadius = _b.boundingSphereRadius, camera = _b.camera, cameraPosition = _b.cameraPosition, controlsType = _b.controlsType, displayMode = _b.displayMode, edges = _b.edges, edgeSize = _b.edgeSize, fontSize = _b.fontSize, nodes = _b.nodes, selected = _b.selected, units = _b.units;\r\n    return (function () {\r\n        return Array.from(edges).map(function (n) {\r\n            var edgeId = n[0], edge = n[1];\r\n            var node1 = nodes.get(edge.node1Id);\r\n            var node2 = nodes.get(edge.node2Id);\r\n            if (node1 && node2) {\r\n                var sv = ThreeUtils.stringToVector3(node1.position);\r\n                var ev = ThreeUtils.stringToVector3(node2.position);\r\n                var dir = ev.clone().sub(sv);\r\n                var dist = dir.length();\r\n                dir = dir.normalize().multiplyScalar(dist * 0.5);\r\n                var centoid = sv.clone().add(dir);\r\n                var textOffset = new THREE.Vector3(0, 2.5, 0);\r\n                var scale = (node1.scale + node2.scale) / 2;\r\n                var radius = boundingSphereRadius * edgeSize;\r\n                textOffset.multiplyScalar(scale);\r\n                var textV = convertUnits(dist, displayMode, units);\r\n                var frustrumDistance = ThreeUtils.getFrustrumSpaceDistance(camera, centoid.clone(), cameraPosition);\r\n                var entityScale = (frustrumDistance / boundingSphereRadius) *\r\n                    Constants.frustrumScaleFactor;\r\n                return (h(\"a-entity\", { \"al-child-hover-visible\": true, id: edgeId + \"-parent\" }, h(\"a-entity\", { position: ThreeUtils.vector3ToString(centoid), id: edgeId + \"-title-anchor\", \"al-billboard\": \"\\n              controlsType: \" + controlsType + \";\\n              cameraPosition: \" + ThreeUtils.vector3ToString(camera.position) + \";\\n              worldPosition: \" + ThreeUtils.vector3ToString(centoid.clone().add(textOffset.clone())) + \";\\n            \" }, h(\"a-entity\", { id: edgeId + \"-title\", text: \"\\n                  value: \" + textV + \";\\n                  side: double;\\n                  align: center;\\n                  baseline: bottom;\\n                  anchor: center;\\n                  width: \" + fontSize * boundingSphereRadius + \"\\n                \", position: ThreeUtils.vector3ToString(textOffset), visible: \"\" + (selected === edgeId), scale: \" \" + entityScale + \" \" + entityScale + \" \" + entityScale + \";\", \"al-background\": \"\\n                  text: \" + textV + \";\\n                  boundingRadius: \" + fontSize * boundingSphereRadius + \";\\n                \", \"al-render-overlaid\": true })), h(\"a-entity\", { \"data-raycastable\": true, id: edgeId, position: ThreeUtils.vector3ToString(centoid), \"al-edge\": \"\\n                length: \" + dist + \";\\n                node1: \" + node1.position + \";\\n                node2: \" + node2.position + \";\\n                selected: \" + (selected === edgeId) + \";\\n                radius: \" + radius + \";\\n                nodeScale: \" + scale + \";\\n                scale: \" + entityScale + \";\\n              \" })));\r\n            }\r\n        });\r\n    })();\r\n};\r\nvar Lights = function (_b, _children) {\r\n    var ambientLightColor = _b.ambientLightColor, ambientLightIntensity = _b.ambientLightIntensity;\r\n    return (h(\"a-entity\", { id: \"ambient-light\", light: \"type: ambient; color: \" + ambientLightColor + \"; intensity: \" + ambientLightIntensity }));\r\n};\r\nvar Nodes = function (_b, _children) {\r\n    var boundingSphereRadius = _b.boundingSphereRadius, camera = _b.camera, cameraPosition = _b.cameraPosition, controlsType = _b.controlsType, fontSize = _b.fontSize, graphEnabled = _b.graphEnabled, nodes = _b.nodes, selected = _b.selected;\r\n    return (function () {\r\n        return Array.from(nodes).map(function (n) {\r\n            var nodeId = n[0], node = n[1];\r\n            var frustrumDistance = ThreeUtils.getFrustrumSpaceDistance(camera, ThreeUtils.stringToVector3(node.position), cameraPosition);\r\n            var entityScale = (frustrumDistance / boundingSphereRadius) *\r\n                Constants.frustrumScaleFactor;\r\n            var textOffset = new THREE.Vector3(0, 3 * entityScale, 0);\r\n            textOffset.multiplyScalar(node.scale);\r\n            return (h(\"a-entity\", { \"al-child-hover-visible\": true, id: nodeId + \"-parent\" }, h(\"a-entity\", { position: node.position, id: nodeId + \"-title-anchor\", \"al-billboard\": \"\\n              controlsType: \" + controlsType + \";\\n              cameraPosition: \" + ThreeUtils.vector3ToString(camera.position) + \";\\n              worldPosition: \" + ThreeUtils.vector3ToString(ThreeUtils.stringToVector3(node.position).add(textOffset.clone())) + \";\\n            \" }, h(\"a-entity\", { text: \"\\n                value: \" + node.title + \";\\n                side: double;\\n                align: center;\\n                baseline: bottom;\\n                anchor: center;\\n                width: \" + fontSize * boundingSphereRadius + \";\\n                zOffset: \" + 0.0000001 + \";\\n              \", position: ThreeUtils.vector3ToString(textOffset), \"al-render-overlaid\": true, visible: \"\" + (selected === nodeId), id: nodeId + \"-label\", \"al-background\": \"\\n                  text: \" + node.title + \";\\n                  boundingRadius: \" + fontSize * boundingSphereRadius + \";\\n              \", scale: \" \" + entityScale + \" \" + entityScale + \" \" + entityScale + \";\" })), h(\"a-entity\", { \"data-raycastable\": true, id: nodeId, position: node.position, \"al-node\": \"\\n              scale: \" + node.scale + \";\\n              selected: \" + (selected === nodeId) + \";\\n              graphEnabled: \" + graphEnabled + \";\\n            \", scale: \" \" + entityScale + \" \" + entityScale + \" \" + entityScale + \";\" })));\r\n        });\r\n    })();\r\n};\r\nvar OrbitCamera = function (_b, _children) {\r\n    var animating = _b.animating, aspect = _b.aspect, cb = _b.cb, controlPosition = _b.controlPosition, controlTarget = _b.controlTarget, dampingFactor = _b.dampingFactor, enabled = _b.enabled, far = _b.far, fov = _b.fov, graphEnabled = _b.graphEnabled, maxDistance = _b.maxDistance, maxPolarAngle = _b.maxPolarAngle, minDistance = _b.minDistance, minPolarAngle = _b.minPolarAngle, near = _b.near, panSpeed = _b.panSpeed, rotateSpeed = _b.rotateSpeed, zoomSpeed = _b.zoomSpeed;\r\n    return (function () {\r\n        if (graphEnabled) {\r\n            return (h(\"al-a-camera\", { fov: fov, near: near, aspect: aspect, \"look-controls\": \"enabled: false\", far: far, id: \"mainCamera\", raycaster: \"objects: [data-raycastable]\", \"al-cursor\": \"rayOrigin: mouse\", \"al-orbit-control\": \"\\n            minDistance: \" + minDistance + \";\\n            minPolarAngle: \" + minPolarAngle + \";\\n            maxDistance: \" + maxDistance + \";\\n            maxPolarAngle: \" + maxPolarAngle + \";\\n            screenSpacePanning: true;\\n            rotateSpeed: \" + rotateSpeed + \";\\n            zoomSpeed: \" + zoomSpeed + \";\\n            enableDamping: true;\\n            dampingFactor: \" + dampingFactor + \";\\n            controlTarget: \" + controlTarget + \";\\n            controlPosition: \" + controlPosition + \";\\n            enabled: \" + enabled + \";\\n            animating: \" + animating + \";\\n            panSpeed: \" + panSpeed + \"\\n          \", \"al-control-lights\": true, ref: function (ref) { return cb(ref); } }));\r\n        }\r\n        else {\r\n            return (h(\"al-a-camera\", { fov: fov, near: near, aspect: aspect, \"look-controls\": \"enabled: false\", far: far, id: \"mainCamera\", \"al-orbit-control\": \"\\n            minDistance: \" + minDistance + \";\\n            minPolarAngle: \" + minPolarAngle + \";\\n            maxDistance: \" + maxDistance + \";\\n            maxPolarAngle: \" + maxPolarAngle + \";\\n            screenSpacePanning: true;\\n            rotateSpeed: \" + rotateSpeed + \";\\n            zoomSpeed: \" + zoomSpeed + \";\\n            enableDamping: true;\\n            dampingFactor: \" + dampingFactor + \";\\n            controlTarget: \" + controlTarget + \";\\n            controlPosition: \" + controlPosition + \";\\n            enabled: \" + enabled + \";\\n            animating: \" + animating + \";\\n            panSpeed: \" + panSpeed + \"\\n          \", \"al-control-lights\": true, ref: function (ref) { return cb(ref); } }));\r\n        }\r\n    })();\r\n};\r\nvar Scene$1 = function (_b, children) {\r\n    var cb = _b.cb, isWebGl2 = _b.isWebGl2;\r\n    return (h(\"a-scene\", { embedded: true, renderer: \"\\n      colorManagement: true;\\n      sortObjects: true;\\n      webgl2: \" + isWebGl2 + \";\\n      antialias: true;\\n    \", \"vr-mode-ui\": \"enabled: false\", ref: function (ref) { return cb(ref); } }, children));\r\n};\r\nvar Src = function (_b, _children) {\r\n    var cb = _b.cb, controlsType = _b.controlsType, displayMode = _b.displayMode, dracoDecoderPath = _b.dracoDecoderPath, envMapPath = _b.envMapPath, graphEnabled = _b.graphEnabled, orientation = _b.orientation, slicesIndex = _b.slicesIndex, src = _b.src, srcLoaded = _b.srcLoaded, volumeSteps = _b.volumeSteps, volumeWindowCenter = _b.volumeWindowCenter, volumeWindowWidth = _b.volumeWindowWidth;\r\n    return (function () {\r\n        if (!src) {\r\n            return null;\r\n        }\r\n        else {\r\n            switch (displayMode) {\r\n                case DisplayMode.MESH: {\r\n                    return (h(\"a-entity\", { \"data-raycastable\": true, \"al-node-spawner\": \"\\n                graphEnabled: \" + graphEnabled + \";\\n              \", \"al-gltf-model\": \"\\n                src: url(\" + src + \");\\n                dracoDecoderPath: \" + dracoDecoderPath + \";\\n              \", \"al-cube-env-map\": \"\\n                path: \" + (envMapPath ? envMapPath : \"\") + \";\\n              \", position: \"0 0 0\", scale: \"1 1 1\", ref: function (ref) { return cb(ref); } }));\r\n                }\r\n                case DisplayMode.SLICES: {\r\n                    return (h(\"a-entity\", { id: \"target-entity\", \"data-raycastable\": true, \"al-node-spawner\": \"\\n                graphEnabled: \" + graphEnabled + \";\\n              \", \"al-volume\": \"\\n                controlsType: \" + controlsType + \";\\n                displayMode: \" + displayMode + \";\\n                slicesIndex: \" + slicesIndex + \";\\n                slicesOrientation: \" + orientation + \";\\n                src: \" + src + \";\\n                srcLoaded: \" + srcLoaded + \";\\n                volumeSteps: \" + volumeSteps + \";\\n                volumeWindowCenter: \" + volumeWindowCenter + \";\\n                volumeWindowWidth: \" + volumeWindowWidth + \";\\n              \", position: \"0 0 0\", ref: function (ref) { return cb(ref); } }));\r\n                }\r\n                // This is seperate from the slice entity as it will store the volume render,\r\n                // preventing long load times when switching mode\r\n                // Node spawner is on the bounding box in\r\n                // volume mode; as the \"volume\" is in a different scene\r\n                case DisplayMode.VOLUME: {\r\n                    return (h(\"a-entity\", { id: \"target-entity\", \"al-volume\": \"\\n                controlsType: \" + controlsType + \";\\n                displayMode: \" + displayMode + \";\\n                slicesIndex: \" + slicesIndex + \";\\n                slicesOrientation: \" + orientation + \";\\n                src: \" + src + \";\\n                srcLoaded: \" + srcLoaded + \";\\n                volumeSteps: \" + volumeSteps + \";\\n                volumeWindowCenter: \" + volumeWindowCenter + \";\\n                volumeWindowWidth: \" + volumeWindowWidth + \";\\n              \", position: \"0 0 0\", ref: function (ref) { return cb(ref); } }));\r\n                }\r\n                default: {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    })();\r\n};\r\nvar TrackballCamera = function (_b, _children) {\r\n    var animating = _b.animating, aspect = _b.aspect, cb = _b.cb, controlPosition = _b.controlPosition, controlTarget = _b.controlTarget, dampingFactor = _b.dampingFactor, enabled = _b.enabled, far = _b.far, fov = _b.fov, graphEnabled = _b.graphEnabled, maxDistance = _b.maxDistance, near = _b.near, panSpeed = _b.panSpeed, rotateSpeed = _b.rotateSpeed, screenHeight = _b.screenHeight, screenWidth = _b.screenWidth, zoomSpeed = _b.zoomSpeed;\r\n    return (function () {\r\n        if (graphEnabled) {\r\n            return (h(\"al-a-camera\", { fov: fov, near: near, aspect: aspect, \"look-controls\": \"enabled: false\", far: far, id: \"mainCamera\", raycaster: \"objects: [data-raycastable]\", \"al-cursor\": \"rayOrigin: mouse\", \"al-trackball-control\": \"\\n            screenLeft: \" + 0 + \";\\n            screenTop: \" + 0 + \";\\n            screenWidth: \" + screenWidth + \";\\n            screenHeight: \" + screenHeight + \";\\n            rotateSpeed: \" + rotateSpeed + \";\\n            zoomSpeed: \" + zoomSpeed + \";\\n            panSpeed: \" + panSpeed + \";\\n            maxDistance: \" + maxDistance + \";\\n            dynamicDampingFactor: \" + dampingFactor + \";\\n            controlTarget: \" + controlTarget + \";\\n            controlPosition: \" + controlPosition + \";\\n            enabled: \" + enabled + \";\\n            animating: \" + animating + \"\\n          \", \"al-control-lights\": true, ref: function (ref) { return cb(ref); } }));\r\n        }\r\n        else {\r\n            return (h(\"al-a-camera\", { fov: fov, near: near, aspect: aspect, \"look-controls\": \"enabled: false\", far: far, id: \"mainCamera\", \"al-trackball-control\": \"\\n            screenLeft: \" + 0 + \";\\n            screenTop: \" + 0 + \";\\n            screenWidth: \" + screenWidth + \";\\n            screenHeight: \" + screenHeight + \";\\n            rotateSpeed: \" + rotateSpeed + \";\\n            zoomSpeed: \" + zoomSpeed + \";\\n            panSpeed: \" + panSpeed + \";\\n            maxDistance: \" + maxDistance + \";\\n            dynamicDampingFactor: \" + dampingFactor + \";\\n            controlTarget: \" + controlTarget + \";\\n            controlPosition: \" + controlPosition + \";\\n            enabled: \" + enabled + \";\\n            animating: \" + animating + \"\\n          \", \"al-control-lights\": true, ref: function (ref) { return cb(ref); } }));\r\n        }\r\n    })();\r\n};\r\nvar TypeKeys;\r\n(function (TypeKeys) {\r\n    TypeKeys[\"NULL\"] = \"NULL\";\r\n    TypeKeys[\"ERROR\"] = \"ERROR\";\r\n    TypeKeys[\"APP_CLEAR_ANGLES\"] = \"APP_LOAD_ANGLES\";\r\n    TypeKeys[\"APP_CLEAR_EDGES\"] = \"APP_LOAD_EDGES\";\r\n    TypeKeys[\"APP_CLEAR_NODES\"] = \"APP_LOAD_NODES\";\r\n    TypeKeys[\"APP_DELETE_ANGLE\"] = \"APP_DELETE_ANGLE\";\r\n    TypeKeys[\"APP_DELETE_EDGE\"] = \"APP_DELETE_EDGE\";\r\n    TypeKeys[\"APP_DELETE_NODE\"] = \"APP_DELETE_NODE\";\r\n    TypeKeys[\"APP_SELECT_ANGLE\"] = \"APP_SELECT_ANGLE\";\r\n    TypeKeys[\"APP_SELECT_EDGE\"] = \"APP_SELECT_EDGE\";\r\n    TypeKeys[\"APP_SELECT_NODE\"] = \"APP_SELECT_NODE\";\r\n    TypeKeys[\"APP_SET_ANGLE\"] = \"APP_SET_ANGLE\";\r\n    TypeKeys[\"APP_SET_BOUNDINGBOX_ENABLED\"] = \"APP_SET_BOUNDINGBOX_ENABLED\";\r\n    TypeKeys[\"APP_SET_CAMERA\"] = \"APP_SET_CAMERA\";\r\n    TypeKeys[\"APP_SET_CONTROLS_ENABLED\"] = \"APP_SET_CONTROLS_ENABLED\";\r\n    TypeKeys[\"APP_SET_CONTROLS_TYPE\"] = \"APP_SET_CONTROLS_TYPE\";\r\n    TypeKeys[\"APP_SET_DISPLAY_MODE\"] = \"APP_SET_DISPLAY_MODE\";\r\n    TypeKeys[\"APP_SET_EDGE\"] = \"APP_SET_EDGE\";\r\n    TypeKeys[\"APP_SET_MATERIAL\"] = \"APP_SET_MATERIAL\";\r\n    TypeKeys[\"APP_SET_NODE\"] = \"APP_SET_NODE\";\r\n    TypeKeys[\"APP_SET_NODES_ENABLED\"] = \"APP_SET_NODES_ENABLED\";\r\n    TypeKeys[\"APP_SET_ORIENTATION\"] = \"APP_SET_ORIENTATION\";\r\n    TypeKeys[\"APP_SET_SCENE_DISTANCE\"] = \"APP_SET_SCENE_DISTANCE\";\r\n    TypeKeys[\"APP_SET_SLICES_INDEX\"] = \"APP_SET_SLICES_INDEX\";\r\n    TypeKeys[\"APP_SET_SLICES_MAX_INDEX\"] = \"APP_SET_SLICES_MAX_INDEX\";\r\n    TypeKeys[\"APP_SET_SLICES_WINDOW_CENTER\"] = \"APP_SET_SLICES_WINDOW_CENTER\";\r\n    TypeKeys[\"APP_SET_SLICES_WINDOW_WIDTH\"] = \"APP_SET_SLICES_WINDOW_WIDTH\";\r\n    TypeKeys[\"APP_SET_SRC\"] = \"APP_SET_SRC\";\r\n    TypeKeys[\"APP_SET_SRC_LOADED\"] = \"APP_SET_SRC_LOADED\";\r\n    TypeKeys[\"APP_SET_UNITS\"] = \"APP_SET_UNITS\";\r\n    TypeKeys[\"APP_SET_VOLUME_STEPS\"] = \"APP_SET_VOLUME_STEPS\";\r\n    TypeKeys[\"APP_SET_VOLUME_WINDOW_CENTER\"] = \"APP_SET_VOLUME_WINDOW_CENTER\";\r\n    TypeKeys[\"APP_SET_VOLUME_WINDOW_WIDTH\"] = \"APP_SET_VOLUME_WINDOW_WIDTH\";\r\n})(TypeKeys || (TypeKeys = {}));\r\nvar appSetSrc = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_SRC,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetSrcLoaded = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_SRC_LOADED,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetNode = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_NODE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appDeleteNode = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_DELETE_NODE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSelectNode = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SELECT_NODE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appClearNodes = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_CLEAR_NODES,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetEdge = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_EDGE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appDeleteEdge = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_DELETE_EDGE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSelectEdge = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SELECT_EDGE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appClearEdges = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_CLEAR_EDGES,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetAngle = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_ANGLE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appDeleteAngle = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_DELETE_ANGLE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSelectAngle = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SELECT_ANGLE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appClearAngles = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_CLEAR_ANGLES,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetBoundingBoxEnabled = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_BOUNDINGBOX_ENABLED,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetDisplayMode = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_DISPLAY_MODE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetGraphEnabled = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_NODES_ENABLED,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetMaterial = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_MATERIAL,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetUnits = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_UNITS,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetOrientation = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_ORIENTATION,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetSceneDistance = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_SCENE_DISTANCE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetSlicesIndex = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_SLICES_INDEX,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetSlicesMaxIndex = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_SLICES_MAX_INDEX,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetVolumeSteps = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_VOLUME_STEPS,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetVolumeWindowWidth = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_VOLUME_WINDOW_WIDTH,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetVolumeWindowCenter = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_VOLUME_WINDOW_CENTER,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetCamera = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_CAMERA,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetControlsEnabled = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_CONTROLS_ENABLED,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\nvar appSetControlsType = function (payload) { return function (dispatch, _getState) { return __awaiter(_this_1, void 0, void 0, function () {\r\n    return __generator(this, function (_b) {\r\n        return [2 /*return*/, dispatch({\r\n                type: TypeKeys.APP_SET_CONTROLS_TYPE,\r\n                payload: payload\r\n            })];\r\n    });\r\n}); }; };\r\n//#endregion\r\nfunction symbolObservablePonyfill(root) {\r\n    var result;\r\n    var Symbol = root.Symbol;\r\n    if (typeof Symbol === 'function') {\r\n        if (Symbol.observable) {\r\n            result = Symbol.observable;\r\n        }\r\n        else {\r\n            result = Symbol('observable');\r\n            Symbol.observable = result;\r\n        }\r\n    }\r\n    else {\r\n        result = '@@observable';\r\n    }\r\n    return result;\r\n}\r\n/* global window */\r\nvar root;\r\nif (typeof self !== 'undefined') {\r\n    root = self;\r\n}\r\nelse if (typeof window !== 'undefined') {\r\n    root = window;\r\n}\r\nelse if (typeof global !== 'undefined') {\r\n    root = global;\r\n}\r\nelse if (typeof module !== 'undefined') {\r\n    root = module;\r\n}\r\nelse {\r\n    root = Function('return this')();\r\n}\r\nvar result = symbolObservablePonyfill(root);\r\n/**\r\n * These are private action types reserved by Redux.\r\n * For any unknown actions, you must return the current state.\r\n * If the current state is undefined, you must return the initial state.\r\n * Do not reference these action types directly in your code.\r\n */\r\nvar randomString = function randomString() {\r\n    return Math.random().toString(36).substring(7).split('').join('.');\r\n};\r\nvar ActionTypes = {\r\n    INIT: \"@@redux/INIT\" + randomString(),\r\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\r\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\r\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\r\n    }\r\n};\r\n/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\r\nfunction isPlainObject(obj) {\r\n    if (typeof obj !== 'object' || obj === null)\r\n        return false;\r\n    var proto = obj;\r\n    while (Object.getPrototypeOf(proto) !== null) {\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return Object.getPrototypeOf(obj) === proto;\r\n}\r\n/**\r\n * Creates a Redux store that holds the state tree.\r\n * The only way to change the data in the store is to call `dispatch()` on it.\r\n *\r\n * There should only be a single store in your app. To specify how different\r\n * parts of the state tree respond to actions, you may combine several reducers\r\n * into a single reducer function by using `combineReducers`.\r\n *\r\n * @param {Function} reducer A function that returns the next state tree, given\r\n * the current state tree and the action to handle.\r\n *\r\n * @param {any} [preloadedState] The initial state. You may optionally specify it\r\n * to hydrate the state from the server in universal apps, or to restore a\r\n * previously serialized user session.\r\n * If you use `combineReducers` to produce the root reducer function, this must be\r\n * an object with the same shape as `combineReducers` keys.\r\n *\r\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\r\n * to enhance the store with third-party capabilities such as middleware,\r\n * time travel, persistence, etc. The only store enhancer that ships with Redux\r\n * is `applyMiddleware()`.\r\n *\r\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\r\n * and subscribe to changes.\r\n */\r\nfunction createStore(reducer, preloadedState, enhancer) {\r\n    var _ref2;\r\n    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\r\n        throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\r\n    }\r\n    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n        enhancer = preloadedState;\r\n        preloadedState = undefined;\r\n    }\r\n    if (typeof enhancer !== 'undefined') {\r\n        if (typeof enhancer !== 'function') {\r\n            throw new Error('Expected the enhancer to be a function.');\r\n        }\r\n        return enhancer(createStore)(reducer, preloadedState);\r\n    }\r\n    if (typeof reducer !== 'function') {\r\n        throw new Error('Expected the reducer to be a function.');\r\n    }\r\n    var currentReducer = reducer;\r\n    var currentState = preloadedState;\r\n    var currentListeners = [];\r\n    var nextListeners = currentListeners;\r\n    var isDispatching = false;\r\n    function ensureCanMutateNextListeners() {\r\n        if (nextListeners === currentListeners) {\r\n            nextListeners = currentListeners.slice();\r\n        }\r\n    }\r\n    /**\r\n     * Reads the state tree managed by the store.\r\n     *\r\n     * @returns {any} The current state tree of your application.\r\n     */\r\n    function getState() {\r\n        if (isDispatching) {\r\n            throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\r\n        }\r\n        return currentState;\r\n    }\r\n    /**\r\n     * Adds a change listener. It will be called any time an action is dispatched,\r\n     * and some part of the state tree may potentially have changed. You may then\r\n     * call `getState()` to read the current state tree inside the callback.\r\n     *\r\n     * You may call `dispatch()` from a change listener, with the following\r\n     * caveats:\r\n     *\r\n     * 1. The subscriptions are snapshotted just before every `dispatch()` call.\r\n     * If you subscribe or unsubscribe while the listeners are being invoked, this\r\n     * will not have any effect on the `dispatch()` that is currently in progress.\r\n     * However, the next `dispatch()` call, whether nested or not, will use a more\r\n     * recent snapshot of the subscription list.\r\n     *\r\n     * 2. The listener should not expect to see all state changes, as the state\r\n     * might have been updated multiple times during a nested `dispatch()` before\r\n     * the listener is called. It is, however, guaranteed that all subscribers\r\n     * registered before the `dispatch()` started will be called with the latest\r\n     * state by the time it exits.\r\n     *\r\n     * @param {Function} listener A callback to be invoked on every dispatch.\r\n     * @returns {Function} A function to remove this change listener.\r\n     */\r\n    function subscribe(listener) {\r\n        if (typeof listener !== 'function') {\r\n            throw new Error('Expected the listener to be a function.');\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\r\n        }\r\n        var isSubscribed = true;\r\n        ensureCanMutateNextListeners();\r\n        nextListeners.push(listener);\r\n        return function unsubscribe() {\r\n            if (!isSubscribed) {\r\n                return;\r\n            }\r\n            if (isDispatching) {\r\n                throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\r\n            }\r\n            isSubscribed = false;\r\n            ensureCanMutateNextListeners();\r\n            var index = nextListeners.indexOf(listener);\r\n            nextListeners.splice(index, 1);\r\n        };\r\n    }\r\n    /**\r\n     * Dispatches an action. It is the only way to trigger a state change.\r\n     *\r\n     * The `reducer` function, used to create the store, will be called with the\r\n     * current state tree and the given `action`. Its return value will\r\n     * be considered the **next** state of the tree, and the change listeners\r\n     * will be notified.\r\n     *\r\n     * The base implementation only supports plain object actions. If you want to\r\n     * dispatch a Promise, an Observable, a thunk, or something else, you need to\r\n     * wrap your store creating function into the corresponding middleware. For\r\n     * example, see the documentation for the `redux-thunk` package. Even the\r\n     * middleware will eventually dispatch plain object actions using this method.\r\n     *\r\n     * @param {Object} action A plain object representing “what changed”. It is\r\n     * a good idea to keep actions serializable so you can record and replay user\r\n     * sessions, or use the time travelling `redux-devtools`. An action must have\r\n     * a `type` property which may not be `undefined`. It is a good idea to use\r\n     * string constants for action types.\r\n     *\r\n     * @returns {Object} For convenience, the same action object you dispatched.\r\n     *\r\n     * Note that, if you use a custom middleware, it may wrap `dispatch()` to\r\n     * return something else (for example, a Promise you can await).\r\n     */\r\n    function dispatch(action) {\r\n        if (!isPlainObject(action)) {\r\n            throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\r\n        }\r\n        if (typeof action.type === 'undefined') {\r\n            throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error('Reducers may not dispatch actions.');\r\n        }\r\n        try {\r\n            isDispatching = true;\r\n            currentState = currentReducer(currentState, action);\r\n        }\r\n        finally {\r\n            isDispatching = false;\r\n        }\r\n        var listeners = currentListeners = nextListeners;\r\n        for (var i = 0; i < listeners.length; i++) {\r\n            var listener = listeners[i];\r\n            listener();\r\n        }\r\n        return action;\r\n    }\r\n    /**\r\n     * Replaces the reducer currently used by the store to calculate the state.\r\n     *\r\n     * You might need this if your app implements code splitting and you want to\r\n     * load some of the reducers dynamically. You might also need this if you\r\n     * implement a hot reloading mechanism for Redux.\r\n     *\r\n     * @param {Function} nextReducer The reducer for the store to use instead.\r\n     * @returns {void}\r\n     */\r\n    function replaceReducer(nextReducer) {\r\n        if (typeof nextReducer !== 'function') {\r\n            throw new Error('Expected the nextReducer to be a function.');\r\n        }\r\n        currentReducer = nextReducer;\r\n        dispatch({\r\n            type: ActionTypes.REPLACE\r\n        });\r\n    }\r\n    /**\r\n     * Interoperability point for observable/reactive libraries.\r\n     * @returns {observable} A minimal observable of state changes.\r\n     * For more information, see the observable proposal:\r\n     * https://github.com/tc39/proposal-observable\r\n     */\r\n    function observable() {\r\n        var _ref;\r\n        var outerSubscribe = subscribe;\r\n        return _ref = {\r\n            /**\r\n             * The minimal observable subscription method.\r\n             * @param {Object} observer Any object that can be used as an observer.\r\n             * The observer object should have a `next` method.\r\n             * @returns {subscription} An object with an `unsubscribe` method that can\r\n             * be used to unsubscribe the observable from the store, and prevent further\r\n             * emission of values from the observable.\r\n             */\r\n            subscribe: function subscribe(observer) {\r\n                if (typeof observer !== 'object' || observer === null) {\r\n                    throw new TypeError('Expected the observer to be an object.');\r\n                }\r\n                function observeState() {\r\n                    if (observer.next) {\r\n                        observer.next(getState());\r\n                    }\r\n                }\r\n                observeState();\r\n                var unsubscribe = outerSubscribe(observeState);\r\n                return {\r\n                    unsubscribe: unsubscribe\r\n                };\r\n            }\r\n        }, _ref[result] = function () {\r\n            return this;\r\n        }, _ref;\r\n    } // When a store is created, an \"INIT\" action is dispatched so that every\r\n    // reducer returns their initial state. This effectively populates\r\n    // the initial state tree.\r\n    dispatch({\r\n        type: ActionTypes.INIT\r\n    });\r\n    return _ref2 = {\r\n        dispatch: dispatch,\r\n        subscribe: subscribe,\r\n        getState: getState,\r\n        replaceReducer: replaceReducer\r\n    }, _ref2[result] = observable, _ref2;\r\n}\r\nfunction getUndefinedStateErrorMessage(key, action) {\r\n    var actionType = action && action.type;\r\n    var actionDescription = actionType && \"action \\\"\" + String(actionType) + \"\\\"\" || 'an action';\r\n    return \"Given \" + actionDescription + \", reducer \\\"\" + key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\";\r\n}\r\nfunction assertReducerShape(reducers) {\r\n    Object.keys(reducers).forEach(function (key) {\r\n        var reducer = reducers[key];\r\n        var initialState = reducer(undefined, {\r\n            type: ActionTypes.INIT\r\n        });\r\n        if (typeof initialState === 'undefined') {\r\n            throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\r\n        }\r\n        if (typeof reducer(undefined, {\r\n            type: ActionTypes.PROBE_UNKNOWN_ACTION()\r\n        }) === 'undefined') {\r\n            throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle \" + ActionTypes.INIT + \" or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\r\n        }\r\n    });\r\n}\r\n/**\r\n * Turns an object whose values are different reducer functions, into a single\r\n * reducer function. It will call every child reducer, and gather their results\r\n * into a single state object, whose keys correspond to the keys of the passed\r\n * reducer functions.\r\n *\r\n * @param {Object} reducers An object whose values correspond to different\r\n * reducer functions that need to be combined into one. One handy way to obtain\r\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\r\n * undefined for any action. Instead, they should return their initial state\r\n * if the state passed to them was undefined, and the current state for any\r\n * unrecognized action.\r\n *\r\n * @returns {Function} A reducer function that invokes every reducer inside the\r\n * passed object, and builds a state object with the same shape.\r\n */\r\nfunction combineReducers(reducers) {\r\n    var reducerKeys = Object.keys(reducers);\r\n    var finalReducers = {};\r\n    for (var i = 0; i < reducerKeys.length; i++) {\r\n        var key = reducerKeys[i];\r\n        if (typeof reducers[key] === 'function') {\r\n            finalReducers[key] = reducers[key];\r\n        }\r\n    }\r\n    var finalReducerKeys = Object.keys(finalReducers);\r\n    var shapeAssertionError;\r\n    try {\r\n        assertReducerShape(finalReducers);\r\n    }\r\n    catch (e) {\r\n        shapeAssertionError = e;\r\n    }\r\n    return function combination(state, action) {\r\n        if (state === void 0) {\r\n            state = {};\r\n        }\r\n        if (shapeAssertionError) {\r\n            throw shapeAssertionError;\r\n        }\r\n        var hasChanged = false;\r\n        var nextState = {};\r\n        for (var _i = 0; _i < finalReducerKeys.length; _i++) {\r\n            var _key = finalReducerKeys[_i];\r\n            var reducer = finalReducers[_key];\r\n            var previousStateForKey = state[_key];\r\n            var nextStateForKey = reducer(previousStateForKey, action);\r\n            if (typeof nextStateForKey === 'undefined') {\r\n                var errorMessage = getUndefinedStateErrorMessage(_key, action);\r\n                throw new Error(errorMessage);\r\n            }\r\n            nextState[_key] = nextStateForKey;\r\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\r\n        }\r\n        return hasChanged ? nextState : state;\r\n    };\r\n}\r\nfunction _defineProperty(obj, key, value) {\r\n    if (key in obj) {\r\n        Object.defineProperty(obj, key, {\r\n            value: value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        });\r\n    }\r\n    else {\r\n        obj[key] = value;\r\n    }\r\n    return obj;\r\n}\r\nfunction _objectSpread(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n        var source = arguments[i] != null ? arguments[i] : {};\r\n        var ownKeys = Object.keys(source);\r\n        if (typeof Object.getOwnPropertySymbols === 'function') {\r\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\r\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\r\n            }));\r\n        }\r\n        ownKeys.forEach(function (key) {\r\n            _defineProperty(target, key, source[key]);\r\n        });\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * Composes single-argument functions from right to left. The rightmost\r\n * function can take multiple arguments as it provides the signature for\r\n * the resulting composite function.\r\n *\r\n * @param {...Function} funcs The functions to compose.\r\n * @returns {Function} A function obtained by composing the argument functions\r\n * from right to left. For example, compose(f, g, h) is identical to doing\r\n * (...args) => f(g(h(...args))).\r\n */\r\nfunction compose() {\r\n    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        funcs[_key] = arguments[_key];\r\n    }\r\n    if (funcs.length === 0) {\r\n        return function (arg) {\r\n            return arg;\r\n        };\r\n    }\r\n    if (funcs.length === 1) {\r\n        return funcs[0];\r\n    }\r\n    return funcs.reduce(function (a, b) {\r\n        return function () {\r\n            return a(b.apply(void 0, arguments));\r\n        };\r\n    });\r\n}\r\n/**\r\n * Creates a store enhancer that applies middleware to the dispatch method\r\n * of the Redux store. This is handy for a variety of tasks, such as expressing\r\n * asynchronous actions in a concise manner, or logging every action payload.\r\n *\r\n * See `redux-thunk` package as an example of the Redux middleware.\r\n *\r\n * Because middleware is potentially asynchronous, this should be the first\r\n * store enhancer in the composition chain.\r\n *\r\n * Note that each middleware will be given the `dispatch` and `getState` functions\r\n * as named arguments.\r\n *\r\n * @param {...Function} middlewares The middleware chain to be applied.\r\n * @returns {Function} A store enhancer applying the middleware.\r\n */\r\nfunction applyMiddleware() {\r\n    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        middlewares[_key] = arguments[_key];\r\n    }\r\n    return function (createStore) {\r\n        return function () {\r\n            var store = createStore.apply(void 0, arguments);\r\n            var _dispatch = function dispatch() {\r\n                throw new Error(\"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\");\r\n            };\r\n            var middlewareAPI = {\r\n                getState: store.getState,\r\n                dispatch: function dispatch() {\r\n                    return _dispatch.apply(void 0, arguments);\r\n                }\r\n            };\r\n            var chain = middlewares.map(function (middleware) {\r\n                return middleware(middlewareAPI);\r\n            });\r\n            _dispatch = compose.apply(void 0, chain)(store.dispatch);\r\n            return _objectSpread({}, store, {\r\n                dispatch: _dispatch\r\n            });\r\n        };\r\n    };\r\n}\r\nfunction createThunkMiddleware(extraArgument) {\r\n    return function (_ref) {\r\n        var dispatch = _ref.dispatch, getState = _ref.getState;\r\n        return function (next) {\r\n            return function (action) {\r\n                if (typeof action === 'function') {\r\n                    return action(dispatch, getState, extraArgument);\r\n                }\r\n                return next(action);\r\n            };\r\n        };\r\n    };\r\n}\r\nvar thunk = createThunkMiddleware();\r\nthunk.withExtraArgument = createThunkMiddleware;\r\nvar getInitialState = function () {\r\n    return {\r\n        angles: new Map(),\r\n        boundingBoxEnabled: false,\r\n        camera: null,\r\n        controlsEnabled: true,\r\n        controlsType: ControlsType.TRACKBALL,\r\n        displayMode: DisplayMode.MESH,\r\n        edges: new Map(),\r\n        material: Material.DEFAULT,\r\n        nodes: new Map(),\r\n        graphEnabled: false,\r\n        orientation: Orientation.CORONAL,\r\n        selected: null,\r\n        slicesIndex: 0.5,\r\n        slicesMaxIndex: undefined,\r\n        src: null,\r\n        srcLoaded: false,\r\n        units: Units.METERS,\r\n        volumeSteps: 0.5,\r\n        volumeStepsHighEnabled: false,\r\n        volumeWindowCenter: 0.5,\r\n        volumeWindowWidth: 1.0\r\n    };\r\n};\r\nvar app = function (state, action) {\r\n    if (state === void 0) { state = getInitialState(); }\r\n    switch (action.type) {\r\n        //#region src\r\n        case TypeKeys.APP_SET_SRC: {\r\n            var _b = action.payload, src_3 = _b[0], plDisplayMode = _b[1];\r\n            var displayMode_1;\r\n            if (plDisplayMode) {\r\n                displayMode_1 = plDisplayMode;\r\n            }\r\n            else if (src_3) {\r\n                var fileExtension = Utils.getFileExtension(src_3);\r\n                var fileEnd = Utils.getFileEndCharacters(src_3, 3);\r\n                if (Object.values(MeshFileType).includes(fileExtension) ||\r\n                    Object.values(MeshFileType).includes(fileEnd)) {\r\n                    displayMode_1 = DisplayMode.MESH;\r\n                }\r\n                else {\r\n                    displayMode_1 = DisplayMode.SLICES; // if not a mesh, default to slices\r\n                }\r\n            }\r\n            else {\r\n                displayMode_1 = DisplayMode.MESH;\r\n            }\r\n            return Object.assign({}, getInitialState(), { displayMode: displayMode_1,\r\n                src: src_3 });\r\n        }\r\n        case TypeKeys.APP_SET_SRC_LOADED: {\r\n            return Object.assign({}, state, { controlsEnabled: action.payload, srcLoaded: action.payload, boundingBoxEnabled: state.displayMode !== DisplayMode.MESH\r\n                    ? true\r\n                    : state.boundingBoxEnabled, controlsType: state.displayMode === DisplayMode.MESH\r\n                    ? ControlsType.ORBIT\r\n                    : ControlsType.TRACKBALL, units: state.displayMode !== DisplayMode.MESH\r\n                    ? Units.MILLIMETERS\r\n                    : Units.METERS });\r\n        }\r\n        //#endregion\r\n        //#region nodes\r\n        case TypeKeys.APP_SET_NODE: {\r\n            // updates a map key if it already exists, otherwise adds it.\r\n            var _c = action.payload, key = _c[0], value = _c[1];\r\n            // sanitise\r\n            var sanitisedValue = JSON.parse(JSON.stringify(value));\r\n            // merge with the current value (if any)\r\n            var currentValue = state.nodes.get(key);\r\n            var nextValue = Object.assign({}, currentValue, sanitisedValue);\r\n            // if the key already exists, keep the current selected\r\n            // otherwise select the new key.\r\n            return Object.assign({}, state, { selected: currentValue ? state.selected : key, nodes: new Map(state.nodes).set(key, nextValue) });\r\n        }\r\n        case TypeKeys.APP_DELETE_NODE: {\r\n            return Object.assign({}, state, { selected: state.selected === action.payload ? null : state.selected, nodes: new Map(Array.from(state.nodes).filter(function (_b) {\r\n                    var key = _b[0];\r\n                    return key !== action.payload;\r\n                })), edges: new Map(Array.from(state.edges).filter(function (_b) {\r\n                    var _key = _b[0], edge = _b[1];\r\n                    return action.payload !== edge.node1Id && action.payload !== edge.node2Id;\r\n                })) });\r\n        }\r\n        case TypeKeys.APP_SELECT_NODE: {\r\n            return Object.assign({}, state, { selected: action.payload });\r\n        }\r\n        case TypeKeys.APP_CLEAR_NODES: {\r\n            return Object.assign({}, state, { nodes: new Map() });\r\n        }\r\n        //#endregion\r\n        //#region edges\r\n        case TypeKeys.APP_SET_EDGE: {\r\n            // updates a map key if it already exists, otherwise adds it.\r\n            var _d = action.payload, key = _d[0], value = _d[1];\r\n            // sanitise\r\n            var sanitisedValue = JSON.parse(JSON.stringify(value));\r\n            // merge with the current value (if any)\r\n            var currentValue = state.edges.get(key);\r\n            var nextValue = Object.assign({}, currentValue, sanitisedValue);\r\n            // if the key already exists, keep the current selected\r\n            // otherwise select the new key.\r\n            return Object.assign({}, state, { selected: currentValue ? state.selected : key, edges: new Map(state.edges).set(key, nextValue) });\r\n        }\r\n        case TypeKeys.APP_DELETE_EDGE: {\r\n            return Object.assign({}, state, { selected: state.selected === action.payload ? null : state.selected, edges: new Map(Array.from(state.edges).filter(function (_b) {\r\n                    var key = _b[0];\r\n                    return key !== action.payload;\r\n                })), angles: new Map(Array.from(state.angles).filter(function (_b) {\r\n                    var _key = _b[0], angle = _b[1];\r\n                    return action.payload !== angle.edge1Id &&\r\n                        action.payload !== angle.edge2Id;\r\n                })) });\r\n        }\r\n        case TypeKeys.APP_SELECT_EDGE: {\r\n            return Object.assign({}, state, { selected: action.payload });\r\n        }\r\n        case TypeKeys.APP_CLEAR_EDGES: {\r\n            return Object.assign({}, state, { edges: new Map() });\r\n        }\r\n        //#endregion\r\n        //#region angles\r\n        case TypeKeys.APP_SET_ANGLE: {\r\n            // updates a map key if it already exists, otherwise adds it.\r\n            var _e = action.payload, key = _e[0], value = _e[1];\r\n            // sanitise\r\n            var sanitisedValue = JSON.parse(JSON.stringify(value));\r\n            // merge with the current value (if any)\r\n            var currentValue = state.angles.get(key);\r\n            var nextValue = Object.assign({}, currentValue, sanitisedValue);\r\n            // if the key already exists, keep the current selected\r\n            // otherwise select the new key.\r\n            return Object.assign({}, state, { selected: currentValue ? state.selected : key, angles: new Map(state.angles).set(key, nextValue) });\r\n        }\r\n        case TypeKeys.APP_DELETE_ANGLE: {\r\n            return Object.assign({}, state, { selected: state.selected === action.payload ? null : state.selected, angles: new Map(Array.from(state.angles).filter(function (_b) {\r\n                    var key = _b[0];\r\n                    return key !== action.payload;\r\n                })) });\r\n        }\r\n        case TypeKeys.APP_SELECT_ANGLE: {\r\n            return Object.assign({}, state, { selected: action.payload });\r\n        }\r\n        case TypeKeys.APP_CLEAR_ANGLES: {\r\n            return Object.assign({}, state, { angles: new Map() });\r\n        }\r\n        //#endregion\r\n        //#region control panel\r\n        case TypeKeys.APP_SET_DISPLAY_MODE: {\r\n            return Object.assign({}, state, { displayMode: action.payload, boundingBoxEnabled: action.payload === DisplayMode.SLICES ? true : false });\r\n        }\r\n        case TypeKeys.APP_SET_ORIENTATION: {\r\n            return Object.assign({}, state, { slicesIndex: 0.5, orientation: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_MATERIAL: {\r\n            return Object.assign({}, state, { material: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_NODES_ENABLED: {\r\n            return Object.assign({}, state, { graphEnabled: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_BOUNDINGBOX_ENABLED: {\r\n            return Object.assign({}, state, { boundingBoxEnabled: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_SCENE_DISTANCE: {\r\n            return Object.assign({}, state, { sceneDistance: action.payload });\r\n        }\r\n        //#endregion\r\n        //#region volumes\r\n        case TypeKeys.APP_SET_SLICES_INDEX: {\r\n            return Object.assign({}, state, { slicesIndex: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_SLICES_MAX_INDEX: {\r\n            return Object.assign({}, state, { slicesMaxIndex: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_UNITS: {\r\n            return Object.assign({}, state, { units: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_VOLUME_STEPS: {\r\n            return Object.assign({}, state, { volumeSteps: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_VOLUME_WINDOW_WIDTH: {\r\n            return Object.assign({}, state, { volumeWindowWidth: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_VOLUME_WINDOW_CENTER: {\r\n            return Object.assign({}, state, { volumeWindowCenter: action.payload });\r\n        }\r\n        //#endregion\r\n        //#region camera\r\n        case TypeKeys.APP_SET_CAMERA: {\r\n            return Object.assign({}, state, { camera: Object.assign({}, state.camera, action.payload) });\r\n        }\r\n        case TypeKeys.APP_SET_CONTROLS_ENABLED: {\r\n            return Object.assign({}, state, { controlsEnabled: action.payload });\r\n        }\r\n        case TypeKeys.APP_SET_CONTROLS_TYPE: {\r\n            return Object.assign({}, state, { controlsType: action.payload });\r\n        }\r\n        default: {\r\n            return Object.assign({}, state);\r\n        }\r\n        //#endregion\r\n    }\r\n};\r\n// tslint:disable-next-line: no-any\r\nvar rootReducer = combineReducers({\r\n    app: app\r\n});\r\n// import logger from 'redux-logger';\r\n// tslint:disable-next-line: no-any\r\nvar configureStore = function (preloadedState) { return createStore(rootReducer, preloadedState, applyMiddleware(/*logger,*/ thunk)); };\r\nvar ModelContainer = function (_props, children) { return (h(\"a-entity\", { id: \"model-container\" }, children)); };\r\nvar Aleph = /** @class */ (function () {\r\n    function class_13(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this._hovered = null;\r\n        this._isShiftDown = false;\r\n        this._isWebGl2 = true;\r\n        this.width = \"640\";\r\n        this.height = \"480\";\r\n        this.change = createEvent(this, \"change\", 7);\r\n        this.loaded = createEvent(this, \"loaded\", 7);\r\n        this.store = getContext(this, \"store\");\r\n    }\r\n    //#endregion\r\n    //#region general methods\r\n    class_13.prototype.load = function (src, displayMode) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this_1 = this;\r\n            return __generator(this, function (_b) {\r\n                // validate\r\n                if (this.src) {\r\n                    this._setSrc(null); // shows loading spinner and resets gltf-model\r\n                    setTimeout(function () {\r\n                        _this_1._setSrc(src, displayMode);\r\n                    }, Constants.minLoadingMS);\r\n                }\r\n                else {\r\n                    this._setSrc(src, displayMode);\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.resize = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._resize();\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    //#endregion\r\n    //#region node methods\r\n    class_13.prototype.setNode = function (node) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setNode(node);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setGraph = function (graph) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setGraph(graph);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.deleteNode = function (nodeId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._deleteNode(nodeId);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.clearGraph = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._clearGraph();\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.selectNode = function (nodeId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._selectNode(nodeId, true);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.deleteEdge = function (edgeId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._deleteEdge(edgeId);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.deleteAngle = function (angleId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._deleteAngle(angleId);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    //#endregion\r\n    //#region Edge Methods\r\n    /** Creates or updates an edge in the graph */\r\n    class_13.prototype.setEdge = function (edge) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setEdge(edge);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    //#endregion\r\n    //#region control panel methods\r\n    class_13.prototype.recenter = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._recenter();\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setBoundingBoxEnabled = function (visible) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setBoundingBoxEnabled(visible);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setDisplayMode = function (displayMode) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setDisplayMode(displayMode);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setControlsEnabled = function (enabled) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setControlsEnabled(enabled);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setControlsType = function (type) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setControlsType(type);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setGraphEnabled = function (enabled) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setGraphEnabled(enabled);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setMaterial = function (material) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setMaterial(material);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setOrientation = function (orientation) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setOrientation(orientation);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setSceneDistance = function (distance) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setSceneDistance(distance);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setSlicesIndex = function (index) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setSlicesIndex(index);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setUnits = function (units) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setUnits(units);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setVolumeSteps = function (steps) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setVolumeSteps(steps);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setVolumeBrightness = function (brightness) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setVolumeWindowCenter(brightness);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype.setVolumeContrast = function (contrast) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._setVolumeWindowWidth(contrast);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    //#endregion\r\n    class_13.prototype.componentWillLoad = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                this._isWebGl2 = ThreeUtils.isWebGL2Available();\r\n                // redux\r\n                this.store.setStore(configureStore({}));\r\n                this.store.mapStateToProps(this, function (state) {\r\n                    var _b = state.app, angles = _b.angles, boundingBoxEnabled = _b.boundingBoxEnabled, camera = _b.camera, controlsEnabled = _b.controlsEnabled, controlsType = _b.controlsType, displayMode = _b.displayMode, edges = _b.edges, graphEnabled = _b.graphEnabled, material = _b.material, nodes = _b.nodes, orientation = _b.orientation, selected = _b.selected, sceneDistance = _b.sceneDistance, slicesIndex = _b.slicesIndex, slicesMaxIndex = _b.slicesMaxIndex, src = _b.src, srcLoaded = _b.srcLoaded, units = _b.units, volumeSteps = _b.volumeSteps, volumeWindowCenter = _b.volumeWindowCenter, volumeWindowWidth = _b.volumeWindowWidth;\r\n                    return {\r\n                        angles: angles,\r\n                        boundingBoxEnabled: boundingBoxEnabled,\r\n                        camera: camera,\r\n                        controlsEnabled: controlsEnabled,\r\n                        controlsType: controlsType,\r\n                        displayMode: displayMode,\r\n                        edges: edges,\r\n                        graphEnabled: graphEnabled,\r\n                        material: material,\r\n                        nodes: nodes,\r\n                        orientation: orientation,\r\n                        selected: selected,\r\n                        sceneDistance: sceneDistance,\r\n                        slicesIndex: slicesIndex,\r\n                        slicesMaxIndex: slicesMaxIndex,\r\n                        src: src,\r\n                        srcLoaded: srcLoaded,\r\n                        units: units,\r\n                        volumeSteps: volumeSteps,\r\n                        volumeWindowCenter: volumeWindowCenter,\r\n                        volumeWindowWidth: volumeWindowWidth\r\n                    };\r\n                });\r\n                this.store.mapDispatchToProps(this, {\r\n                    appClearAngles: appClearAngles,\r\n                    appClearEdges: appClearEdges,\r\n                    appClearNodes: appClearNodes,\r\n                    appDeleteAngle: appDeleteAngle,\r\n                    appDeleteEdge: appDeleteEdge,\r\n                    appDeleteNode: appDeleteNode,\r\n                    appSelectAngle: appSelectAngle,\r\n                    appSelectEdge: appSelectEdge,\r\n                    appSelectNode: appSelectNode,\r\n                    appSetAngle: appSetAngle,\r\n                    appSetBoundingBoxEnabled: appSetBoundingBoxEnabled,\r\n                    appSetCamera: appSetCamera,\r\n                    appSetControlsEnabled: appSetControlsEnabled,\r\n                    appSetControlsType: appSetControlsType,\r\n                    appSetDisplayMode: appSetDisplayMode,\r\n                    appSetEdge: appSetEdge,\r\n                    appSetGraphEnabled: appSetGraphEnabled,\r\n                    appSetMaterial: appSetMaterial,\r\n                    appSetNode: appSetNode,\r\n                    appSetOrientation: appSetOrientation,\r\n                    appSetSceneDistance: appSetSceneDistance,\r\n                    appSetSlicesIndex: appSetSlicesIndex,\r\n                    appSetSlicesMaxIndex: appSetSlicesMaxIndex,\r\n                    appSetSrc: appSetSrc,\r\n                    appSetSrcLoaded: appSetSrcLoaded,\r\n                    appSetUnits: appSetUnits,\r\n                    appSetVolumeSteps: appSetVolumeSteps,\r\n                    appSetVolumeWindowCenter: appSetVolumeWindowCenter,\r\n                    appSetVolumeWindowWidth: appSetVolumeWindowWidth\r\n                });\r\n                // set up event handlers\r\n                this._controlsAnimationFinishedHandler = this._controlsAnimationFinishedHandler.bind(this);\r\n                this._controlsInteractionHandler = this._controlsInteractionHandler.bind(this);\r\n                this._graphEntryDraggedHandler = this._graphEntryDraggedHandler.bind(this);\r\n                this._graphEntryPointerDownHandler = this._graphEntryPointerDownHandler.bind(this);\r\n                this._graphEntryPointerOutHandler = this._graphEntryPointerOutHandler.bind(this);\r\n                this._graphEntryPointerOverHandler = this._graphEntryPointerOverHandler.bind(this);\r\n                this._graphEntryPointerUpHandler = this._graphEntryPointerUpHandler.bind(this);\r\n                this._graphEntrySelectedHandler = this._graphEntrySelectedHandler.bind(this);\r\n                this._graphEntryValidTargetHandler = this._graphEntryValidTargetHandler.bind(this);\r\n                this._keyDownHandler = this._keyDownHandler.bind(this);\r\n                this._keyUpHandler = this._keyUpHandler.bind(this);\r\n                this._controlsInteractionFinishedHandler = this._controlsInteractionFinishedHandler.bind(this);\r\n                this._slicesMaxIndexHandler = this._slicesMaxIndexHandler.bind(this);\r\n                this._spawnNodeHandler = this._spawnNodeHandler.bind(this);\r\n                this._srcLoadedHandler = this._srcLoadedHandler.bind(this);\r\n                this._volumeDefaultRenderStepsHandler = this._volumeDefaultRenderStepsHandler.bind(this);\r\n                this._volumeRaycastHandler = this._volumeRaycastHandler.bind(this);\r\n                // debounced event handlers\r\n                this._debouncedAppSetCamera = EventUtils.debounce(this.appSetCamera, Constants.minFrameMS).bind(this);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_13.prototype._renderScene = function () {\r\n        var _this_1 = this;\r\n        return (h(Scene$1, { cb: function (ref) {\r\n                _this_1._scene = ref;\r\n                _this_1._scene.addEventListener(\"loaded\", function () {\r\n                    _this_1._scene.sceneEl.renderer.toneMapping = THREE.ACESFilmicToneMapping;\r\n                });\r\n            }, isWebGl2: this._isWebGl2 }, h(ModelContainer, null, h(Src, { cb: function (ref) {\r\n                _this_1._targetEntity = ref;\r\n            }, controlsType: this.controlsType, displayMode: this.displayMode, dracoDecoderPath: this.dracoDecoderPath, envMapPath: this.envMapPath, graphEnabled: this.graphEnabled, orientation: this.orientation, slicesIndex: this.slicesIndex, src: this.src, srcLoaded: this.srcLoaded, volumeSteps: this.volumeSteps, volumeWindowCenter: this.volumeWindowCenter, volumeWindowWidth: this.volumeWindowWidth }), h(BoundingBox, { cb: function (ref) {\r\n                _this_1._boundingEntity = ref;\r\n            }, boundingBox: this._boundingBox, boundingBoxEnabled: this.boundingBoxEnabled, color: Constants.colors.white, displayMode: this.displayMode, graphEnabled: this.graphEnabled, mesh: this._getMesh(), srcLoaded: this.srcLoaded, targetEntity: this._targetEntity })), h(Nodes, { boundingSphereRadius: this._boundingSphereRadius, camera: this._scene ? this._scene.camera : null, cameraPosition: this.camera ? this.camera.position : null, controlsType: this.controlsType, fontSize: Constants.fontSizeMedium, graphEnabled: this.graphEnabled, nodes: this.nodes, selected: this.selected }), h(Edges, { boundingSphereRadius: this._boundingSphereRadius, camera: this._scene ? this._scene.camera : null, cameraPosition: this.camera ? this.camera.position : null, controlsType: this.controlsType, displayMode: this.displayMode, edges: this.edges, edgeSize: Constants.edgeSize, fontSize: Constants.fontSizeSmall, nodes: this.nodes, selected: this.selected, units: this.units }), h(Angles, { angles: this.angles, boundingSphereRadius: this._boundingSphereRadius, camera: this._scene ? this._scene.camera : null, cameraPosition: this.camera ? this.camera.position : null, controlsType: this.controlsType, edges: this.edges, edgeSize: Constants.edgeSize, fontSize: Constants.fontSizeSmall, nodes: this.nodes, selected: this.selected }), (function () {\r\n            switch (_this_1.controlsType) {\r\n                case ControlsType.TRACKBALL: {\r\n                    return (h(TrackballCamera, { cb: function (ref) {\r\n                            _this_1._camera = ref;\r\n                        }, animating: _this_1.camera && _this_1.camera.animating\r\n                            ? _this_1.camera.animating\r\n                            : false, aspect: _this_1._scene\r\n                            ? _this_1._scene.offsetWidth / _this_1._scene.offsetHeight\r\n                            : null, controlPosition: ThreeUtils.vector3ToString(_this_1.camera\r\n                            ? _this_1.camera.position\r\n                            : new THREE.Vector3(0, 0, 0)), controlTarget: ThreeUtils.vector3ToString(_this_1.camera\r\n                            ? _this_1.camera.target\r\n                            : new THREE.Vector3(0, 0, 0)), dampingFactor: Constants.camera.dampingFactor, enabled: _this_1.controlsEnabled, far: _this_1.sceneDistance\r\n                            ? Utils.getFarFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.far, fov: Constants.camera.fov, graphEnabled: _this_1.graphEnabled, maxDistance: _this_1.sceneDistance\r\n                            ? Utils.getFarFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.maxDistance, near: _this_1.sceneDistance\r\n                            ? Utils.getNearFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.near, panSpeed: Constants.camera.panSpeed, rotateSpeed: Constants.camera.trackballRotateSpeed, screenHeight: _this_1._scene ? _this_1._scene.canvas.height : 0, screenWidth: _this_1._scene ? _this_1._scene.canvas.width : 0, zoomSpeed: Constants.camera.trackballZoomSpeed }));\r\n                }\r\n                case ControlsType.ORBIT: {\r\n                    return (h(OrbitCamera, { cb: function (ref) {\r\n                            _this_1._camera = ref;\r\n                        }, animating: _this_1.camera && _this_1.camera.animating\r\n                            ? _this_1.camera.animating\r\n                            : false, aspect: _this_1._scene\r\n                            ? _this_1._scene.offsetWidth / _this_1._scene.offsetHeight\r\n                            : null, controlPosition: ThreeUtils.vector3ToString(_this_1.camera\r\n                            ? _this_1.camera.position\r\n                            : new THREE.Vector3(0, 0, 0)), controlTarget: ThreeUtils.vector3ToString(_this_1.camera\r\n                            ? _this_1.camera.target\r\n                            : new THREE.Vector3(0, 0, 0)), dampingFactor: Constants.camera.dampingFactor, enabled: _this_1.controlsEnabled, far: _this_1.sceneDistance\r\n                            ? Utils.getFarFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.far, fov: Constants.camera.fov, graphEnabled: _this_1.graphEnabled, maxDistance: _this_1.sceneDistance\r\n                            ? Utils.getFarFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.maxDistance, maxPolarAngle: Constants.camera.maxPolarAngle, minDistance: Constants.camera.minDistance, minPolarAngle: Constants.camera.minPolarAngle, panSpeed: Constants.camera.orbitPanSpeed, near: _this_1.sceneDistance\r\n                            ? Utils.getNearFromSceneDistance(_this_1.sceneDistance)\r\n                            : Constants.camera.near, rotateSpeed: Constants.camera.orbitRotateSpeed, zoomSpeed: Constants.camera.orbitZoomSpeed }));\r\n                }\r\n                default: {\r\n                    return null;\r\n                }\r\n            }\r\n        })(), h(Lights, { ambientLightColor: Constants.lights.ambientLightColor, ambientLightIntensity: Constants.lights.ambientLightIntensity })));\r\n    };\r\n    class_13.prototype.render = function () {\r\n        return (h(\"div\", { id: \"al-container\", class: this.displayMode, style: {\r\n                width: Utils.addCssUnits(this.width),\r\n                height: Utils.addCssUnits(this.height)\r\n            } }, h(\"div\", { id: \"lut-container\" }, h(\"div\", { id: \"lut-min\" }, \"0.0\"), h(\"div\", { id: \"lut-canvases\" }), h(\"div\", { id: \"lut-max\" }, \"1.0\")), this._renderScene(), this.src && !this.srcLoaded && (h(\"div\", { id: \"spinner\" }, h(\"div\", { class: \"square\" })))));\r\n    };\r\n    //#endregion\r\n    //#region Private Methods\r\n    class_13.prototype._resize = function () {\r\n        if (this._scene) {\r\n            // tslint:disable-next-line: no-any\r\n            this._scene.resize();\r\n        }\r\n    };\r\n    class_13.prototype._createEdge = function (node1Id, node2Id) {\r\n        // check if there is already an edge connecting these two nodes\r\n        var match = Array.from(this.edges).find(function (_b) {\r\n            var _id = _b[0], edge = _b[1];\r\n            return ((edge.node1Id === node1Id && edge.node2Id === node2Id) ||\r\n                (edge.node1Id === node2Id && edge.node2Id === node1Id));\r\n        });\r\n        if (!match) {\r\n            var newEdge = {\r\n                node1Id: node1Id,\r\n                node2Id: node2Id\r\n            };\r\n            var edgeId = GraphUtils.getNextId(AlGraphEntryType.EDGE, this.edges);\r\n            this._setEdge([edgeId, newEdge]);\r\n        }\r\n    };\r\n    class_13.prototype._createAngle = function (edge1Id, edge2Id) {\r\n        // check if there is already an angle connecting these two edges\r\n        var match = Array.from(this.angles).find(function (_b) {\r\n            var _id = _b[0], angle = _b[1];\r\n            return ((angle.edge1Id === edge1Id && angle.edge2Id === edge2Id) ||\r\n                (angle.edge1Id === edge2Id && angle.edge2Id === edge1Id));\r\n        });\r\n        if (!match) {\r\n            var edge1 = this.edges.get(edge1Id);\r\n            var edge2 = this.edges.get(edge2Id);\r\n            if (edge1.node1Id === edge2.node1Id ||\r\n                edge1.node1Id === edge2.node2Id ||\r\n                edge1.node2Id === edge2.node1Id ||\r\n                edge1.node2Id === edge2.node2Id) {\r\n                var newAngle = {\r\n                    edge1Id: edge1Id,\r\n                    edge2Id: edge2Id\r\n                };\r\n                var angleId = GraphUtils.getNextId(AlGraphEntryType.ANGLE, this.angles);\r\n                this._setAngle([angleId, newAngle]);\r\n            }\r\n            else {\r\n                console.warn(\"cannot create angle: edges not connected\");\r\n            }\r\n        }\r\n        else {\r\n            console.warn(\"cannot create angle: angle already exists\");\r\n        }\r\n    };\r\n    class_13.prototype._stateChanged = function () {\r\n        this.change.emit(this.store.getState().app);\r\n    };\r\n    class_13.prototype._setGraph = function (graph) {\r\n        var _this_1 = this;\r\n        if (graph.nodes) {\r\n            var nodes = new Map(graph.nodes);\r\n            nodes.forEach(function (value, key) {\r\n                _this_1.appSetNode([key, value]);\r\n            });\r\n        }\r\n        if (graph.edges) {\r\n            var edges = new Map(graph.edges);\r\n            edges.forEach(function (value, key) {\r\n                _this_1.appSetEdge([key, value]);\r\n            });\r\n        }\r\n        if (graph.angles) {\r\n            var angles = new Map(graph.angles);\r\n            angles.forEach(function (value, key) {\r\n                _this_1.appSetAngle([key, value]);\r\n            });\r\n        }\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._clearGraph = function () {\r\n        // todo: can this be a single appClearGraph action?\r\n        this.appClearNodes();\r\n        this.appClearEdges();\r\n        this.appClearAngles();\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._deleteNode = function (nodeId) {\r\n        this.appDeleteNode(nodeId);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setNode = function (node) {\r\n        this.appSetNode(node);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._animateBetween = function (animationStart, animationEndVec3) {\r\n        var defaultCamera = Utils.getCameraStateFromMesh(this._getMesh(), this.sceneDistance);\r\n        var animationEnd = {\r\n            position: animationEndVec3,\r\n            target: defaultCamera.target.clone()\r\n        };\r\n        if (animationEndVec3) {\r\n            var diffPos = animationEnd.position.distanceTo(this.camera.position);\r\n            var diffTarg = animationEnd.target.distanceTo(this.camera.target);\r\n            var needsPos = diffPos / Constants.maxAnimationSteps > Number.EPSILON;\r\n            var needsTarg = diffTarg / Constants.maxAnimationSteps > Number.EPSILON;\r\n            if (needsPos || needsTarg) {\r\n                animationEnd.position.copy(animationEndVec3.clone());\r\n                var slerpPath = ThreeUtils.getSlerpCameraPath(animationStart, animationEnd, needsPos, needsTarg);\r\n                this._scene.emit(AlControlEvents$1.ANIMATION_STARTED, { slerpPath: slerpPath }, false);\r\n                this.appSetCamera({\r\n                    animating: true\r\n                });\r\n                this._stateChanged();\r\n            }\r\n        }\r\n    };\r\n    class_13.prototype._selectNode = function (nodeId, animate) {\r\n        if (animate === void 0) { animate = false; }\r\n        if (animate && nodeId !== this.selected) {\r\n            var animationStart = {\r\n                position: this.camera.position.clone(),\r\n                target: this.camera.target.clone()\r\n            };\r\n            var animationEndVec3 = Utils.getCameraPositionFromNode(this.nodes.get(nodeId), this._boundingSphereRadius, this.camera.target);\r\n            this.appSelectNode(nodeId);\r\n            this._animateBetween(animationStart, animationEndVec3);\r\n        }\r\n        else {\r\n            this.appSelectNode(nodeId);\r\n            this._stateChanged();\r\n        }\r\n    };\r\n    class_13.prototype._setEdge = function (edge) {\r\n        this.appSetEdge(edge);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._deleteEdge = function (edgeId) {\r\n        this.appDeleteEdge(edgeId);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._recenter = function () {\r\n        var cameraState = Utils.getCameraStateFromMesh(this._getMesh(), this.sceneDistance);\r\n        var animationStart = {\r\n            position: this.camera.position.clone(),\r\n            target: this.camera.target.clone()\r\n        };\r\n        // deselect current node\r\n        this._selectNode(null);\r\n        // todo: this also applies to edges and angles because it's setting state.selected to null.\r\n        // think about whether this should be generic\r\n        this._animateBetween(animationStart, cameraState.position);\r\n    };\r\n    class_13.prototype._selectEdge = function (edgeId) {\r\n        this.appSelectEdge(edgeId);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setAngle = function (angle) {\r\n        this.appSetAngle(angle);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._selectAngle = function (angleId) {\r\n        this.appSelectAngle(angleId);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._deleteAngle = function (angleId) {\r\n        this.appDeleteAngle(angleId);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setBoundingBoxEnabled = function (visible) {\r\n        this.appSetBoundingBoxEnabled(visible);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setControlsEnabled = function (enabled) {\r\n        this.appSetControlsEnabled(enabled);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setControlsType = function (type) {\r\n        this.appSetControlsType(type);\r\n        this._scene.camera.up.copy(this._targetEntity.object3D.up);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setGraphEnabled = function (enabled) {\r\n        this.appSetGraphEnabled(enabled);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setMaterial = function (material) {\r\n        this.appSetMaterial(material);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setOrientation = function (orientation) {\r\n        this.appSetOrientation(orientation);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setSceneDistance = function (distance) {\r\n        this.appSetSceneDistance(distance);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setSlicesIndex = function (index) {\r\n        this.appSetSlicesIndex(index);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setUnits = function (units) {\r\n        this.appSetUnits(units);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setVolumeSteps = function (steps) {\r\n        this.appSetVolumeSteps(steps);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setVolumeWindowCenter = function (center) {\r\n        this.appSetVolumeWindowCenter(center);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setVolumeWindowWidth = function (width) {\r\n        this.appSetVolumeWindowWidth(width);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setDisplayMode = function (displayMode) {\r\n        this.appSetDisplayMode(displayMode);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._setSrc = function (src, displayMode) {\r\n        this.appSetSrc([src, displayMode]);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._getMesh = function () {\r\n        var mesh = null;\r\n        if (this._targetEntity && this.displayMode === DisplayMode.MESH) {\r\n            var model = this._targetEntity.object3DMap.mesh;\r\n            if (model instanceof THREE.Mesh) {\r\n                mesh = model;\r\n            }\r\n            else if (model) {\r\n                model.traverse(function (child) {\r\n                    if (child instanceof THREE.Mesh && mesh === null) {\r\n                        mesh = child;\r\n                        return mesh;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        else if (this._loadedObject && this._loadedObject._bBox) {\r\n            mesh = this._loadedObject._bBox._mesh;\r\n        }\r\n        else if (this._loadedObject) {\r\n            mesh = this._loadedObject._mesh;\r\n        }\r\n        return mesh;\r\n    };\r\n    // tslint:disable-next-line: no-any\r\n    class_13.prototype._srcLoadedHandler = function (ev) {\r\n        this._loadedObject = ev.detail;\r\n        var cameraState;\r\n        var sceneDistance;\r\n        // if it's a gltf scene, there will be a _loadedObject.model\r\n        // use this to get the bounding box.\r\n        // otherwise use _getMesh()\r\n        if (this._loadedObject.model) {\r\n            this._boundingBox = Utils.getBoundingBox(this._loadedObject.model);\r\n            var sphere = new Sphere();\r\n            this._boundingSphereRadius = this._boundingBox.getBoundingSphere(sphere).radius;\r\n            sceneDistance = Utils.getSceneDistanceFromModel(this._loadedObject.model, Constants.zoomFactor, Constants.fov);\r\n            cameraState = Utils.getCameraStateFromModel(this._loadedObject.model, sceneDistance);\r\n        }\r\n        else {\r\n            // there's no model, use the mesh\r\n            var mesh = this._getMesh();\r\n            // Compute the bounding sphere of the mesh\r\n            mesh.geometry.computeBoundingSphere();\r\n            mesh.geometry.computeBoundingBox();\r\n            this._boundingBox = Utils.getBoundingBox(mesh);\r\n            this._boundingSphereRadius = mesh.geometry.boundingSphere.radius;\r\n            sceneDistance = Utils.getSceneDistanceFromMesh(mesh, Constants.zoomFactor, Constants.fov);\r\n            cameraState = Utils.getCameraStateFromMesh(mesh, sceneDistance);\r\n        }\r\n        if (sceneDistance) {\r\n            this.appSetSceneDistance(sceneDistance);\r\n        }\r\n        if (cameraState) {\r\n            this.appSetCamera(cameraState);\r\n        }\r\n        this.appSetSrcLoaded(true);\r\n        this._stateChanged();\r\n        this.loaded.emit(ev.detail);\r\n    };\r\n    //#endregion\r\n    //#region Event Handlers\r\n    class_13.prototype._keyDownHandler = function (event) {\r\n        this._isShiftDown = event.shiftKey;\r\n        if (event.keyCode === KeyDown.Delete) {\r\n            if (this.selected) {\r\n                if (this.nodes.has(this.selected)) {\r\n                    this._deleteNode(this.selected);\r\n                }\r\n                else if (this.edges.has(this.selected)) {\r\n                    this._deleteEdge(this.selected);\r\n                }\r\n                else if (this.angles.has(this.selected)) {\r\n                    this._deleteAngle(this.selected);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    class_13.prototype._keyUpHandler = function (_event) {\r\n        this._isShiftDown = false;\r\n    };\r\n    class_13.prototype._graphEntryPointerUpHandler = function (_event) {\r\n        this.appSetControlsEnabled(true);\r\n        ThreeUtils.enableControls(this._camera, true, this.controlsType);\r\n    };\r\n    class_13.prototype._graphEntryPointerDownHandler = function (_event) {\r\n        this.appSetControlsEnabled(false);\r\n        ThreeUtils.enableControls(this._camera, false, this.controlsType);\r\n    };\r\n    class_13.prototype._graphEntryPointerOutHandler = function (_event) {\r\n        this._hovered = null;\r\n    };\r\n    class_13.prototype._graphEntryPointerOverHandler = function (event) {\r\n        this._hovered = event.detail.id;\r\n    };\r\n    class_13.prototype._controlsInteractionHandler = function (event) {\r\n        // This means that graph elements will rescale while animating\r\n        // However this causes Redux to update every frame that we animate,\r\n        // which causes the VDOM to update every frame\r\n        var cameraState = event.detail.cameraState;\r\n        this.appSetCamera(cameraState);\r\n    };\r\n    class_13.prototype._controlsInteractionFinishedHandler = function (event) {\r\n        var cameraState = event.detail.cameraState;\r\n        this._debouncedAppSetCamera(cameraState);\r\n    };\r\n    class_13.prototype._spawnNodeHandler = function (event) {\r\n        // IF creating a new node and NOT intersecting an existing node\r\n        if (this.graphEnabled && // Nodes are enabled\r\n            this._validTarget && // Target is valid\r\n            this._hovered === null // Not intersecting a Node already\r\n        ) {\r\n            var newNode = void 0;\r\n            var nodeId = GraphUtils.getNextId(AlGraphEntryType.NODE, this.nodes);\r\n            var intersection = event.detail.aframeEvent.detail.intersection;\r\n            if (this.displayMode === DisplayMode.VOLUME && intersection) {\r\n                this._scene.emit(AlVolumeEvents.VOLUME_RAY_REQUEST, {\r\n                    cameraPosition: this._camera.object3D.children[0].position.clone(),\r\n                    cameraDirection: this._camera.getAttribute(\"raycaster\").direction,\r\n                    intersection: intersection,\r\n                    type: AlVolumeCastType.CREATE\r\n                });\r\n            }\r\n            else if (intersection) {\r\n                newNode = {\r\n                    targetId: this.src,\r\n                    position: ThreeUtils.vector3ToString(intersection.point),\r\n                    scale: this._boundingSphereRadius / Constants.nodeSizeRatio,\r\n                    normal: ThreeUtils.vector3ToString(intersection.face.normal),\r\n                    title: nodeId\r\n                };\r\n            }\r\n            if (newNode) {\r\n                var previousSelected = this.selected;\r\n                this._setNode([nodeId, newNode]);\r\n                if (this._isShiftDown && // Shift is down\r\n                    this.nodes.has(previousSelected) // A Node is already selected\r\n                ) {\r\n                    this._createEdge(previousSelected, nodeId);\r\n                    this._selectNode(nodeId);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    class_13.prototype._volumeRaycastHandler = function (event) {\r\n        var hitPosition = event.detail.hitPosition;\r\n        var rayResult = event.detail.rayResult;\r\n        switch (event.detail.type) {\r\n            case AlVolumeCastType.CREATE: {\r\n                var newNode = void 0;\r\n                var nodeId = GraphUtils.getNextId(AlGraphEntryType.NODE, this.nodes);\r\n                if (rayResult) {\r\n                    newNode = {\r\n                        targetId: this.src,\r\n                        position: ThreeUtils.vector3ToString(hitPosition),\r\n                        scale: this._boundingSphereRadius / Constants.nodeSizeRatio,\r\n                        title: nodeId\r\n                    };\r\n                }\r\n                if (newNode) {\r\n                    var previousSelected = this.selected;\r\n                    this._setNode([nodeId, newNode]);\r\n                    if (this._isShiftDown && // Shift is down\r\n                        this.nodes.has(previousSelected) // A Node is already selected\r\n                    ) {\r\n                        this._createEdge(previousSelected, nodeId);\r\n                        this._selectNode(nodeId);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case AlVolumeCastType.DRAG: {\r\n                var nodeId = this.selected;\r\n                if (!rayResult) {\r\n                    var distance = this._camera.object3D.children[0].position.distanceTo(this._targetEntity.getAttribute(\"position\"));\r\n                    hitPosition.copy(this._camera.object3D.children[0].position);\r\n                    hitPosition.add(this._camera\r\n                        .getAttribute(\"raycaster\")\r\n                        .direction.clone()\r\n                        .multiplyScalar(distance * 1.5));\r\n                }\r\n                this._setNode([\r\n                    nodeId,\r\n                    {\r\n                        position: ThreeUtils.vector3ToString(hitPosition)\r\n                    }\r\n                ]);\r\n                var eventName = nodeId + Constants.movedEventName;\r\n                this._scene.emit(eventName, {}, true);\r\n                break;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    class_13.prototype._graphEntryValidTargetHandler = function (event) {\r\n        this._validTarget = event.detail.valid;\r\n    };\r\n    class_13.prototype._controlsAnimationFinishedHandler = function (_event) {\r\n        this.appSetCamera({\r\n            animating: false\r\n        });\r\n    };\r\n    class_13.prototype._graphEntrySelectedHandler = function (event) {\r\n        if (!this.graphEnabled) {\r\n            return;\r\n        }\r\n        var type = event.detail.type;\r\n        var id = event.detail.id;\r\n        switch (type) {\r\n            case AlGraphEntryType.NODE: {\r\n                if (this._hovered !== null &&\r\n                    this.nodes.has(this._hovered) && // We're intersecting a node\r\n                    (this.selected !== null && this.nodes.has(this.selected)) && // We have a node already selected\r\n                    this.selected !== this._hovered && // The selected & intersecting elements are not the same\r\n                    this._isShiftDown // The shift key is down\r\n                ) {\r\n                    this._createEdge(this.selected, this._hovered);\r\n                }\r\n                this._selectNode(id);\r\n                break;\r\n            }\r\n            case AlGraphEntryType.EDGE: {\r\n                if (this._hovered !== null &&\r\n                    this.edges.has(this._hovered) && // We're intersecting an edge\r\n                    (this.selected !== null && this.edges.has(this.selected)) && // We have an edge already selected\r\n                    this.selected !== this._hovered && // The selected & intersecting elements are not the same\r\n                    this._isShiftDown // The shift key is down\r\n                ) {\r\n                    // We're intersecting an edge\r\n                    this._createAngle(this.selected, this._hovered);\r\n                }\r\n                this._selectEdge(id);\r\n                break;\r\n            }\r\n            case AlGraphEntryType.ANGLE: {\r\n                this._selectAngle(id);\r\n                break;\r\n            }\r\n            default: {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    class_13.prototype._graphEntryDraggedHandler = function (event) {\r\n        var nodeId = event.detail.id;\r\n        // tslint:disable-next-line: no-any\r\n        var raycaster = this._camera.components.raycaster;\r\n        var raycasterAttribute = this._camera.getAttribute(\"raycaster\");\r\n        var hitPosition = new THREE.Vector3();\r\n        var validLocation = false;\r\n        if (this.displayMode === DisplayMode.VOLUME) {\r\n            var intersection = raycaster.getIntersection(this._boundingEntity);\r\n            if (intersection) {\r\n                this._scene.emit(AlVolumeEvents.VOLUME_RAY_REQUEST, {\r\n                    cameraPosition: this._camera.object3D.children[0].position.clone(),\r\n                    cameraDirection: this._camera.getAttribute(\"raycaster\").direction,\r\n                    intersection: intersection,\r\n                    type: AlVolumeCastType.DRAG\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            var intersection = raycaster.getIntersection(this._targetEntity);\r\n            if (intersection) {\r\n                hitPosition.copy(intersection.point);\r\n                validLocation = true;\r\n            }\r\n            // IF not a valid location, dangle in space\r\n            if (!validLocation) {\r\n                var distance = this._camera.object3D.children[0].position.distanceTo(this._targetEntity.getAttribute(\"position\"));\r\n                hitPosition.copy(this._camera.object3D.children[0].position);\r\n                hitPosition.add(raycasterAttribute.direction.clone().multiplyScalar(distance * 1.5));\r\n            }\r\n            else {\r\n                hitPosition.copy(intersection.point);\r\n            }\r\n            this._setNode([\r\n                nodeId,\r\n                {\r\n                    position: ThreeUtils.vector3ToString(hitPosition)\r\n                }\r\n            ]);\r\n            var eventName = nodeId + Constants.movedEventName;\r\n            this._scene.emit(eventName, {}, true);\r\n        }\r\n    };\r\n    class_13.prototype._volumeDefaultRenderStepsHandler = function (event) {\r\n        this.appSetVolumeSteps(event.detail);\r\n        this._stateChanged();\r\n    };\r\n    class_13.prototype._slicesMaxIndexHandler = function (event) {\r\n        this.appSetSlicesMaxIndex(event.detail);\r\n    };\r\n    class_13.prototype._addEventListeners = function () {\r\n        window.addEventListener(\"keydown\", this._keyDownHandler, false);\r\n        window.addEventListener(\"keyup\", this._keyUpHandler, false);\r\n        this._scene.addEventListener(AlVolumeEvents.VOLUME_RAY_CAST, this._volumeRaycastHandler, false);\r\n        this._scene.addEventListener(AlControlEvents$1.ANIMATION_FINISHED, this._controlsAnimationFinishedHandler, false);\r\n        this._scene.addEventListener(AlControlEvents$1.INTERACTION, this._controlsInteractionHandler, false);\r\n        this._scene.addEventListener(AlControlEvents$1.INTERACTION_FINISHED, this._controlsInteractionFinishedHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.POINTER_UP, this._graphEntryPointerUpHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.POINTER_DOWN, this._graphEntryPointerDownHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.DRAGGED, this._graphEntryDraggedHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.SELECTED, this._graphEntrySelectedHandler, false);\r\n        this._scene.addEventListener(AlNodeSpawnerEvents.ADD_NODE, this._spawnNodeHandler, false);\r\n        this._scene.addEventListener(AlNodeSpawnerEvents.VALID_TARGET, this._graphEntryValidTargetHandler, false);\r\n        this._scene.addEventListener(AlGltfModelEvents$1.LOADED, this._srcLoadedHandler, false);\r\n        this._scene.addEventListener(AlVolumeEvents.DEFAULT_RENDER_STEPS, this._volumeDefaultRenderStepsHandler, false);\r\n        this._scene.addEventListener(AlVolumeEvents.LOADED, this._srcLoadedHandler, false);\r\n        this._scene.addEventListener(AlVolumeEvents.SLICES_MAX_INDEX, this._slicesMaxIndexHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.POINTER_OVER, this._graphEntryPointerOverHandler, false);\r\n        this._scene.addEventListener(AlGraphEvents.POINTER_OUT, this._graphEntryPointerOutHandler, false);\r\n    };\r\n    //#endregion\r\n    class_13.prototype.componentDidUpdate = function () {\r\n        if (this._scene) {\r\n            this._addEventListeners();\r\n        }\r\n    };\r\n    Object.defineProperty(class_13, \"style\", {\r\n        get: function () { return \"#al-container{position:relative;font-family:sans-serif}#al-container a-scene{display:block;width:100%;height:100%}#al-container.mesh a-scene{background-color:var(--al-mesh-viewport-background-color)}#al-container.slices a-scene{background-color:var(--al-slices-viewport-background-color)}#al-container.volume a-scene{background-color:var(--al-volume-viewport-background-color)}#al-container #lut-container{display:none}#al-container .progress.container{position:absolute;top:auto!important;bottom:0!important}#al-container .progress.container .load.progress,#al-container .progress.container .parse.progress{border:none!important;height:4px!important;background-color:var(--load-progress-color,#fff)!important}#al-container #spinner{position:absolute;left:50%;top:calc(50% - 15px)}#al-container #spinner .square{margin:0 0 0 -15px;width:30px;height:30px;-webkit-animation:sk-rotateplane 1.2s ease-in-out infinite;-moz-animation:sk-rotateplane 1.2s infinite ease-in-out;animation:sk-rotateplane 1.2s ease-in-out infinite}#al-container.mesh #spinner .square,#al-container.slices #spinner .square,#al-container.volume #spinner .square{background-color:var(--spinner-color,#fff)}\\@-webkit-keyframes sk-rotateplane{0%{-webkit-transform:perspective(120px)}50%{-webkit-transform:perspective(120px) rotateY(180deg)}to{-webkit-transform:perspective(120px) rotateY(180deg) rotateX(180deg)}}\\@keyframes sk-rotateplane{0%{transform:perspective(120px) rotateX(0deg) rotateY(0deg);-webkit-transform:perspective(120px) rotateX(0deg) rotateY(0deg)}50%{transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg);-webkit-transform:perspective(120px) rotateX(-180.1deg) rotateY(0deg)}to{transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg);-webkit-transform:perspective(120px) rotateX(-180deg) rotateY(-179.9deg)}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_13;\r\n}());\r\nvar App = /** @class */ (function () {\r\n    function class_14(hostRef) {\r\n        registerInstance(this, hostRef);\r\n    }\r\n    class_14.prototype.componentDidLoad = function () {\r\n        {\r\n            rIC(function () {\r\n                var isHybrid = isPlatform(window, 'hybrid');\r\n                if (!config.getBoolean('_testing')) {\r\n                    import('./tap-click-31591259.js').then(function (module) { return module.startTapClick(config); });\r\n                }\r\n                if (config.getBoolean('statusTap', isHybrid)) {\r\n                    import('./status-tap-7e7b1839.js').then(function (module) { return module.startStatusTap(); });\r\n                }\r\n                if (config.getBoolean('inputShims', needInputShims())) {\r\n                    import('./input-shims-c71a172f.js').then(function (module) { return module.startInputShims(config); });\r\n                }\r\n                if (config.getBoolean('hardwareBackButton', isHybrid)) {\r\n                    import('./hardware-back-button-fcf38822.js').then(function (module) { return module.startHardwareBackButton(); });\r\n                }\r\n                import('./focus-visible-30ddc1ea.js').then(function (module) { return module.startFocusVisible(); });\r\n            });\r\n        }\r\n    };\r\n    class_14.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { class: (_b = {},\r\n                _b[mode] = true,\r\n                _b['ion-page'] = true,\r\n                _b['force-statusbar-padding'] = config.getBoolean('_forceStatusbarPadding'),\r\n                _b) }));\r\n    };\r\n    Object.defineProperty(class_14.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_14, \"style\", {\r\n        get: function () { return \"html.plt-mobile ion-app{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_14;\r\n}());\r\nvar needInputShims = function () {\r\n    return isPlatform(window, 'ios') && isPlatform(window, 'mobile');\r\n};\r\nvar rIC = function (callback) {\r\n    if ('requestIdleCallback' in window) {\r\n        window.requestIdleCallback(callback);\r\n    }\r\n    else {\r\n        setTimeout(callback, 32);\r\n    }\r\n};\r\nvar Button = /** @class */ (function () {\r\n    function class_15(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.inToolbar = false;\r\n        this.inItem = false;\r\n        /**\r\n         * The type of button.\r\n         */\r\n        this.buttonType = 'button';\r\n        /**\r\n         * If `true`, the user cannot interact with the button.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * When using a router, it specifies the transition direction when navigating to\r\n         * another page using `href`.\r\n         */\r\n        this.routerDirection = 'forward';\r\n        /**\r\n         * If `true`, activates a button with a heavier font weight.\r\n         */\r\n        this.strong = false;\r\n        /**\r\n         * The type of the button.\r\n         */\r\n        this.type = 'button';\r\n        this.handleClick = function (ev) {\r\n            if (_this_1.type === 'button') {\r\n                openURL(_this_1.href, ev, _this_1.routerDirection);\r\n            }\r\n            else if (hasShadowDom(_this_1.el)) {\r\n                // this button wants to specifically submit a form\r\n                // climb up the dom to see if we're in a <form>\r\n                // and if so, then use JS to submit it\r\n                var form = _this_1.el.closest('form');\r\n                if (form) {\r\n                    ev.preventDefault();\r\n                    var fakeButton = document.createElement('button');\r\n                    fakeButton.type = _this_1.type;\r\n                    fakeButton.style.display = 'none';\r\n                    form.appendChild(fakeButton);\r\n                    fakeButton.click();\r\n                    fakeButton.remove();\r\n                }\r\n            }\r\n        };\r\n        this.onFocus = function () {\r\n            _this_1.ionFocus.emit();\r\n        };\r\n        this.onBlur = function () {\r\n            _this_1.ionBlur.emit();\r\n        };\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n    }\r\n    class_15.prototype.componentWillLoad = function () {\r\n        this.inToolbar = !!this.el.closest('ion-buttons');\r\n        this.inItem = !!this.el.closest('ion-item') || !!this.el.closest('ion-item-divider');\r\n    };\r\n    Object.defineProperty(class_15.prototype, \"hasIconOnly\", {\r\n        get: function () {\r\n            return !!this.el.querySelector('ion-icon[slot=\"icon-only\"]');\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_15.prototype, \"rippleType\", {\r\n        get: function () {\r\n            var hasClearFill = this.fill === undefined || this.fill === 'clear';\r\n            // If the button is in a toolbar, has a clear fill (which is the default)\r\n            // and only has an icon we use the unbounded \"circular\" ripple effect\r\n            if (hasClearFill && this.hasIconOnly && this.inToolbar) {\r\n                return 'unbounded';\r\n            }\r\n            return 'bounded';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_15.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        var _c = this, buttonType = _c.buttonType, type = _c.type, disabled = _c.disabled, rel = _c.rel, target = _c.target, size = _c.size, href = _c.href, color = _c.color, expand = _c.expand, hasIconOnly = _c.hasIconOnly, shape = _c.shape, strong = _c.strong;\r\n        var finalSize = size === undefined && this.inItem ? 'small' : size;\r\n        var TagType = href === undefined ? 'button' : 'a';\r\n        var attrs = (TagType === 'button')\r\n            ? { type: type }\r\n            : {\r\n                download: this.download,\r\n                href: href,\r\n                rel: rel,\r\n                target: target\r\n            };\r\n        var fill = this.fill;\r\n        if (fill === undefined) {\r\n            fill = this.inToolbar ? 'clear' : 'solid';\r\n        }\r\n        return (h(Host, { onClick: this.handleClick, \"aria-disabled\": disabled ? 'true' : null, class: Object.assign(Object.assign({}, createColorClasses$1(color)), (_b = {}, _b[mode] = true, _b[buttonType] = true, _b[buttonType + \"-\" + expand] = expand !== undefined, _b[buttonType + \"-\" + finalSize] = finalSize !== undefined, _b[buttonType + \"-\" + shape] = shape !== undefined, _b[buttonType + \"-\" + fill] = true, _b[buttonType + \"-strong\"] = strong, _b['button-has-icon-only'] = hasIconOnly, _b['button-disabled'] = disabled, _b['ion-activatable'] = true, _b['ion-focusable'] = true, _b)) }, h(TagType, Object.assign({}, attrs, { class: \"button-native\", disabled: disabled, onFocus: this.onFocus, onBlur: this.onBlur }), h(\"span\", { class: \"button-inner\" }, h(\"slot\", { name: \"icon-only\" }), h(\"slot\", { name: \"start\" }), h(\"slot\", null), h(\"slot\", { name: \"end\" })), mode === 'md' && h(\"ion-ripple-effect\", { type: this.rippleType }))));\r\n    };\r\n    Object.defineProperty(class_15.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_15, \"style\", {\r\n        get: function () { return \":host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-hover:initial;--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family,inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;pointer-events:auto;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){--opacity:.5;pointer-events:none}:host(.button-disabled) .button-native{cursor:default;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary,#3880ff);--background-focused:var(--ion-color-primary-shade,#3171e0);--background-hover:var(--ion-color-primary-tint,#4c8dff);--color:var(--ion-color-primary-contrast,#fff);--color-activated:var(--ion-color-primary-contrast,#fff);--color-focused:var(--ion-color-primary-contrast,#fff)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-solid.ion-color.ion-focused) .button-native{background:var(--ion-color-shade)}:host(.button-outline){--border-color:var(--ion-color-primary,#3880ff);--background:transparent;--color:var(--ion-color-primary,#3880ff);--color-focused:var(--ion-color-primary,#3880ff)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native{background:rgba(var(--ion-color-base-rgb),.1);color:var(--ion-color-base)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary,#3880ff)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-focused.ion-color) .button-native{background:rgba(var(--ion-color-base-rgb),.1);color:var(--ion-color-base)}:host(.button-clear.activated.ion-color) .button-native{background:transparent}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native:after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){margin-left:-.3em;margin-right:.3em;margin-top:0;margin-bottom:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-icon[slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:-.3em;margin-inline-start:-.3em;-webkit-margin-end:.3em;margin-inline-end:.3em}}::slotted(ion-icon[slot=end]){margin-left:.3em;margin-right:-.2em;margin-top:0;margin-bottom:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-icon[slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:.3em;margin-inline-start:.3em;-webkit-margin-end:-.2em;margin-inline-end:-.2em}}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}:host(.ion-focused) .button-native{background:var(--background-focused);color:var(--color-focused)}:host(.activated) .button-native{background:var(--background-activated);color:var(--color-activated)}\\@media (any-hover:hover){:host(:hover) .button-native{background:var(--background-hover);color:var(--color-hover)}}:host{--border-radius:10px;--padding-top:0;--padding-bottom:0;--padding-start:1em;--padding-end:1em;--transition:background-color,opacity 100ms linear;margin-left:2px;margin-right:2px;margin-top:4px;margin-bottom:4px;height:2.8em;font-size:16px;font-weight:500;letter-spacing:-.03em}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}:host(.button-solid){--background-activated:var(--ion-color-primary-shade,#3171e0)}:host(.button-solid.activated){--opacity:1}:host(.button-solid.activated.ion-color) .button-native{background:var(--ion-color-shade)}:host(.button-outline){--border-radius:10px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary,#3880ff);--background-focused:rgba(var(--ion-color-primary-rgb,56,128,255),0.1);--color-activated:var(--ion-color-primary-contrast,#fff)}:host(.button-outline.activated.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-clear.activated){--opacity:0.4}:host(.button-clear){--background-activated:transparent;--background-focused:rgba(var(--ion-color-primary-rgb,56,128,255),0.1);--color-activated:var(--ion-color-primary,#3880ff);--color-focused:var(--ion-color-primary,#3880ff)}:host(.button-large){--border-radius:12px;--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}:host(.button-small){--border-radius:6px;--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}\\@media (any-hover:hover){:host(.button-solid:hover){--opacity:0.8}:host(.button-clear:hover),:host(.button-outline:hover){--opacity:0.6}:host(.ion-focused:hover){--background-hover:var(--background-focused);--color-hover:var(--color-focused)}:host(.activated:hover){--background-hover:var(--background-activated);--color-hover:var(--color-activated)}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_15;\r\n}());\r\nvar CACHED_MAP;\r\nvar getIconMap = function () {\r\n    if (!CACHED_MAP) {\r\n        var win = window;\r\n        win.Ionicons = win.Ionicons || {};\r\n        CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\r\n    }\r\n    return CACHED_MAP;\r\n};\r\nvar getUrl = function (i) {\r\n    var url = getSrc(i.src);\r\n    if (url) {\r\n        return url;\r\n    }\r\n    url = getName(i.name, i.icon, i.mode, i.ios, i.md);\r\n    if (url) {\r\n        return getNamedUrl(url);\r\n    }\r\n    if (i.icon) {\r\n        url = getSrc(i.icon);\r\n        if (url) {\r\n            return url;\r\n        }\r\n        url = getSrc(i.icon[i.mode]);\r\n        if (url) {\r\n            return url;\r\n        }\r\n    }\r\n    return null;\r\n};\r\nvar getNamedUrl = function (name) {\r\n    var url = getIconMap().get(name);\r\n    if (url) {\r\n        return url;\r\n    }\r\n    return getAssetPath(\"svg/\" + name + \".svg\");\r\n};\r\nvar getName = function (name, icon, mode, ios, md) {\r\n    // default to \"md\" if somehow the mode wasn't set\r\n    mode = (mode && mode.toLowerCase()) === 'ios' ? 'ios' : 'md';\r\n    // if an icon was passed in using the ios or md attributes\r\n    // set the iconName to whatever was passed in\r\n    if (ios && mode === 'ios') {\r\n        name = ios.toLowerCase();\r\n    }\r\n    else if (md && mode === 'md') {\r\n        name = md.toLowerCase();\r\n    }\r\n    else {\r\n        if (!name && icon && !isSrc(icon)) {\r\n            name = icon;\r\n        }\r\n        if (isStr(name)) {\r\n            name = name.toLowerCase();\r\n            if (!/^md-|^ios-|^logo-/.test(name)) {\r\n                // this does not have one of the defaults\r\n                // so lets auto add in the mode prefix for them\r\n                name = mode + '-' + name;\r\n            }\r\n        }\r\n    }\r\n    if (!isStr(name) || name.trim() === '') {\r\n        return null;\r\n    }\r\n    // only allow alpha characters and dash\r\n    var invalidChars = name.replace(/[a-z]|-|\\d/gi, '');\r\n    if (invalidChars !== '') {\r\n        return null;\r\n    }\r\n    return name;\r\n};\r\nvar getSrc = function (src) {\r\n    if (isStr(src)) {\r\n        src = src.trim();\r\n        if (isSrc(src)) {\r\n            return src;\r\n        }\r\n    }\r\n    return null;\r\n};\r\nvar isSrc = function (str) {\r\n    return str.length > 0 && /(\\/|\\.)/.test(str);\r\n};\r\nvar isStr = function (val) { return typeof val === 'string'; };\r\nvar validateContent = function (svgContent) {\r\n    if (svgContent) {\r\n        var div = document.createElement('div');\r\n        div.innerHTML = svgContent;\r\n        // setup this way to ensure it works on our buddy IE\r\n        for (var i = div.childNodes.length - 1; i >= 0; i--) {\r\n            if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\r\n                div.removeChild(div.childNodes[i]);\r\n            }\r\n        }\r\n        // must only have 1 root element\r\n        var svgElm = div.firstElementChild;\r\n        if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\r\n            svgElm.setAttribute('class', 's-ion-icon');\r\n            // root element must be an svg\r\n            // lets double check we've got valid elements\r\n            // do not allow scripts\r\n            if (isValid(svgElm)) {\r\n                return div.innerHTML;\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n};\r\nvar isValid = function (elm) {\r\n    if (elm.nodeType === 1) {\r\n        if (elm.nodeName.toLowerCase() === 'script') {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < elm.attributes.length; i++) {\r\n            var val = elm.attributes[i].value;\r\n            if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\r\n                return false;\r\n            }\r\n        }\r\n        for (var i = 0; i < elm.childNodes.length; i++) {\r\n            if (!isValid(elm.childNodes[i])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\nvar requests = new Map();\r\nvar getSvgContent = function (url) {\r\n    // see if we already have a request for this url\r\n    var req = requests.get(url);\r\n    if (!req) {\r\n        // we don't already have a request\r\n        req = fetch(url).then(function (rsp) {\r\n            if (rsp.status <= 299) {\r\n                return rsp.text();\r\n            }\r\n            return Promise.resolve(null);\r\n        }).then(function (svgContent) { return validateContent(svgContent); });\r\n        // cache for the same requests\r\n        requests.set(url, req);\r\n    }\r\n    return req;\r\n};\r\nvar Icon = /** @class */ (function () {\r\n    function class_16(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.mode = getIonMode(this);\r\n        this.isVisible = false;\r\n        /**\r\n         * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\r\n         * Default, `false`.\r\n         */\r\n        this.lazy = false;\r\n    }\r\n    class_16.prototype.connectedCallback = function () {\r\n        var _this_1 = this;\r\n        // purposely do not return the promise here because loading\r\n        // the svg file should not hold up loading the app\r\n        // only load the svg if it's visible\r\n        this.waitUntilVisible(this.el, '50px', function () {\r\n            _this_1.isVisible = true;\r\n            _this_1.loadIcon();\r\n        });\r\n    };\r\n    class_16.prototype.disconnectedCallback = function () {\r\n        if (this.io) {\r\n            this.io.disconnect();\r\n            this.io = undefined;\r\n        }\r\n    };\r\n    class_16.prototype.waitUntilVisible = function (el, rootMargin, cb) {\r\n        var _this_1 = this;\r\n        if (this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {\r\n            var io_1 = this.io = new window.IntersectionObserver(function (data) {\r\n                if (data[0].isIntersecting) {\r\n                    io_1.disconnect();\r\n                    _this_1.io = undefined;\r\n                    cb();\r\n                }\r\n            }, { rootMargin: rootMargin });\r\n            io_1.observe(el);\r\n        }\r\n        else {\r\n            // browser doesn't support IntersectionObserver\r\n            // so just fallback to always show it\r\n            cb();\r\n        }\r\n    };\r\n    class_16.prototype.loadIcon = function () {\r\n        var _this_1 = this;\r\n        if (this.isVisible) {\r\n            var url = getUrl(this);\r\n            if (url) {\r\n                getSvgContent(url)\r\n                    .then(function (svgContent) { return _this_1.svgContent = svgContent; });\r\n            }\r\n        }\r\n        if (!this.ariaLabel) {\r\n            var label = getName(this.name, this.icon, this.mode, this.ios, this.md);\r\n            // user did not provide a label\r\n            // come up with the label based on the icon name\r\n            if (label) {\r\n                this.ariaLabel = label\r\n                    .replace('ios-', '')\r\n                    .replace('md-', '')\r\n                    .replace(/\\-/g, ' ');\r\n            }\r\n        }\r\n    };\r\n    class_16.prototype.render = function () {\r\n        var _b, _c;\r\n        var mode = this.mode || 'md';\r\n        var flipRtl = this.flipRtl || (this.ariaLabel && this.ariaLabel.indexOf('arrow') > -1 && this.flipRtl !== false);\r\n        return (h(Host, { role: \"img\", class: Object.assign((_b = {}, _b[mode] = true, _b), createColorClasses(this.color), (_c = {}, _c[\"icon-\" + this.size] = !!this.size, _c['flip-rtl'] = !!flipRtl && this.el.ownerDocument.dir === 'rtl', _c)) }, ((this.svgContent)\r\n            ? h(\"div\", { class: \"icon-inner\", innerHTML: this.svgContent })\r\n            : h(\"div\", { class: \"icon-inner\" }))));\r\n    };\r\n    Object.defineProperty(class_16, \"assetsDirs\", {\r\n        get: function () { return [\"svg\"]; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_16.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_16, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"name\": [\"loadIcon\"],\r\n                \"src\": [\"loadIcon\"],\r\n                \"icon\": [\"loadIcon\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_16, \"style\", {\r\n        get: function () { return \":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box!important;box-sizing:content-box!important}.icon-inner,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px!important}:host(.icon-large){font-size:32px!important}:host(.ion-color){color:var(--ion-color-base)!important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary,#3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary,#0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary,#f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success,#10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning,#ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger,#f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light,#f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium,#989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark,#222428)}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_16;\r\n}());\r\nvar getIonMode = function (ref) {\r\n    return getMode(ref) || document.documentElement.getAttribute('mode') || 'md';\r\n};\r\nvar createColorClasses = function (color) {\r\n    var _b;\r\n    return (color) ? (_b = {\r\n            'ion-color': true\r\n        },\r\n        _b[\"ion-color-\" + color] = true,\r\n        _b) : null;\r\n};\r\nvar Input = /** @class */ (function () {\r\n    function class_17(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.inputId = \"ion-input-\" + inputIds++;\r\n        this.didBlurAfterEdit = false;\r\n        this.hasFocus = false;\r\n        /**\r\n         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.\r\n         */\r\n        this.autocapitalize = 'off';\r\n        /**\r\n         * Indicates whether the value of the control can be automatically completed by the browser.\r\n         */\r\n        this.autocomplete = 'off';\r\n        /**\r\n         * Whether auto correction should be enabled when the user is entering/editing the text value.\r\n         */\r\n        this.autocorrect = 'off';\r\n        /**\r\n         * This Boolean attribute lets you specify that a form control should have input focus when the page loads.\r\n         */\r\n        this.autofocus = false;\r\n        /**\r\n         * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.\r\n         */\r\n        this.clearInput = false;\r\n        /**\r\n         * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke.\r\n         */\r\n        this.debounce = 0;\r\n        /**\r\n         * If `true`, the user cannot interact with the input.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The name of the control, which is submitted with the form data.\r\n         */\r\n        this.name = this.inputId;\r\n        /**\r\n         * If `true`, the user cannot modify the value.\r\n         */\r\n        this.readonly = false;\r\n        /**\r\n         * If `true`, the user must fill in a value before submitting a form.\r\n         */\r\n        this.required = false;\r\n        /**\r\n         * If `true`, the element will have its spelling and grammar checked.\r\n         */\r\n        this.spellcheck = false;\r\n        /**\r\n         * The type of control to display. The default type is text.\r\n         */\r\n        this.type = 'text';\r\n        /**\r\n         * The value of the input.\r\n         */\r\n        this.value = '';\r\n        this.onInput = function (ev) {\r\n            var input = ev.target;\r\n            if (input) {\r\n                _this_1.value = input.value || '';\r\n            }\r\n            _this_1.ionInput.emit(ev);\r\n        };\r\n        this.onBlur = function () {\r\n            _this_1.hasFocus = false;\r\n            _this_1.focusChanged();\r\n            _this_1.emitStyle();\r\n            _this_1.ionBlur.emit();\r\n        };\r\n        this.onFocus = function () {\r\n            _this_1.hasFocus = true;\r\n            _this_1.focusChanged();\r\n            _this_1.emitStyle();\r\n            _this_1.ionFocus.emit();\r\n        };\r\n        this.onKeydown = function () {\r\n            if (_this_1.shouldClearOnEdit()) {\r\n                // Did the input value change after it was blurred and edited?\r\n                if (_this_1.didBlurAfterEdit && _this_1.hasValue()) {\r\n                    // Clear the input\r\n                    _this_1.clearTextInput();\r\n                }\r\n                // Reset the flag\r\n                _this_1.didBlurAfterEdit = false;\r\n            }\r\n        };\r\n        this.clearTextInput = function (ev) {\r\n            if (_this_1.clearInput && !_this_1.readonly && !_this_1.disabled && ev) {\r\n                ev.preventDefault();\r\n                ev.stopPropagation();\r\n            }\r\n            _this_1.value = '';\r\n            /**\r\n             * This is needed for clearOnEdit\r\n             * Otherwise the value will not be cleared\r\n             * if user is inside the input\r\n             */\r\n            if (_this_1.nativeInput) {\r\n                _this_1.nativeInput.value = '';\r\n            }\r\n        };\r\n        this.ionInput = createEvent(this, \"ionInput\", 7);\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.ionInputDidLoad = createEvent(this, \"ionInputDidLoad\", 7);\r\n        this.ionInputDidUnload = createEvent(this, \"ionInputDidUnload\", 7);\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n    }\r\n    class_17.prototype.debounceChanged = function () {\r\n        this.ionChange = debounceEvent(this.ionChange, this.debounce);\r\n    };\r\n    class_17.prototype.disabledChanged = function () {\r\n        this.emitStyle();\r\n    };\r\n    /**\r\n     * Update the native input element when the value changes\r\n     */\r\n    class_17.prototype.valueChanged = function () {\r\n        this.emitStyle();\r\n        this.ionChange.emit({ value: this.value });\r\n    };\r\n    class_17.prototype.connectedCallback = function () {\r\n        this.emitStyle();\r\n        this.debounceChanged();\r\n        {\r\n            this.el.dispatchEvent(new CustomEvent('ionInputDidLoad', {\r\n                detail: this.el\r\n            }));\r\n        }\r\n    };\r\n    class_17.prototype.disconnectedCallback = function () {\r\n        {\r\n            document.dispatchEvent(new CustomEvent('ionInputDidUnload', {\r\n                detail: this.el\r\n            }));\r\n        }\r\n    };\r\n    /**\r\n     * Sets focus on the specified `ion-input`. Use this method instead of the global\r\n     * `input.focus()`.\r\n     */\r\n    class_17.prototype.setFocus = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                if (this.nativeInput) {\r\n                    this.nativeInput.focus();\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Returns the native `<input>` element used under the hood.\r\n     */\r\n    class_17.prototype.getInputElement = function () {\r\n        return Promise.resolve(this.nativeInput);\r\n    };\r\n    class_17.prototype.shouldClearOnEdit = function () {\r\n        var _b = this, type = _b.type, clearOnEdit = _b.clearOnEdit;\r\n        return (clearOnEdit === undefined)\r\n            ? type === 'password'\r\n            : clearOnEdit;\r\n    };\r\n    class_17.prototype.getValue = function () {\r\n        return this.value || '';\r\n    };\r\n    class_17.prototype.emitStyle = function () {\r\n        this.ionStyle.emit({\r\n            'interactive': true,\r\n            'input': true,\r\n            'has-placeholder': this.placeholder != null,\r\n            'has-value': this.hasValue(),\r\n            'has-focus': this.hasFocus,\r\n            'interactive-disabled': this.disabled,\r\n        });\r\n    };\r\n    class_17.prototype.focusChanged = function () {\r\n        // If clearOnEdit is enabled and the input blurred but has a value, set a flag\r\n        if (!this.hasFocus && this.shouldClearOnEdit() && this.hasValue()) {\r\n            this.didBlurAfterEdit = true;\r\n        }\r\n    };\r\n    class_17.prototype.hasValue = function () {\r\n        return this.getValue().length > 0;\r\n    };\r\n    class_17.prototype.render = function () {\r\n        var _b;\r\n        var _this_1 = this;\r\n        var mode = getIonMode$1(this);\r\n        var value = this.getValue();\r\n        var labelId = this.inputId + '-lbl';\r\n        var label = findItemLabel(this.el);\r\n        if (label) {\r\n            label.id = labelId;\r\n        }\r\n        return (h(Host, { \"aria-disabled\": this.disabled ? 'true' : null, class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_b = {}, _b[mode] = true, _b['has-value'] = this.hasValue(), _b['has-focus'] = this.hasFocus, _b)) }, h(\"input\", { class: \"native-input\", ref: function (input) { return _this_1.nativeInput = input; }, \"aria-labelledby\": labelId, disabled: this.disabled, accept: this.accept, autoCapitalize: this.autocapitalize, autoComplete: this.autocomplete, autoCorrect: this.autocorrect, autoFocus: this.autofocus, inputMode: this.inputmode, min: this.min, max: this.max, minLength: this.minlength, maxLength: this.maxlength, multiple: this.multiple, name: this.name, pattern: this.pattern, placeholder: this.placeholder || '', readOnly: this.readonly, required: this.required, spellCheck: this.spellcheck, step: this.step, size: this.size, type: this.type, value: value, onInput: this.onInput, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeydown }), (this.clearInput && !this.readonly && !this.disabled) && h(\"button\", { type: \"button\", class: \"input-clear-icon\", tabindex: \"-1\", onTouchStart: this.clearTextInput, onMouseDown: this.clearTextInput })));\r\n    };\r\n    Object.defineProperty(class_17.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_17, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"debounce\": [\"debounceChanged\"],\r\n                \"disabled\": [\"disabledChanged\"],\r\n                \"value\": [\"valueChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_17, \"style\", {\r\n        get: function () { return \".sc-ion-input-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--background:transparent;--color:initial;display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;width:100%;padding:0!important;background:var(--background);color:var(--color);font-family:var(--ion-font-family,inherit);z-index:2}ion-item.sc-ion-input-ios-h:not(.item-label), ion-item:not(.item-label) .sc-ion-input-ios-h{--padding-start:0}.ion-color.sc-ion-input-ios-h{color:var(--ion-color-base)}.native-input.sc-ion-input-ios{border-radius:var(--border-radius);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.native-input.sc-ion-input-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-input.sc-ion-input-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-ios:invalid{-webkit-box-shadow:none;box-shadow:none}.native-input.sc-ion-input-ios::-ms-clear{display:none}.native-input[disabled].sc-ion-input-ios{opacity:.4}.cloned-input.sc-ion-input-ios{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-input-ios-h .cloned-input.sc-ion-input-ios, [dir=rtl] .sc-ion-input-ios-h .cloned-input.sc-ion-input-ios, [dir=rtl].sc-ion-input-ios .cloned-input.sc-ion-input-ios{left:unset;right:unset;right:0}.input-clear-icon.sc-ion-input-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:50%;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;visibility:hidden;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.has-value.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{visibility:visible}.has-focus.sc-ion-input-ios-h{pointer-events:none}.has-focus.sc-ion-input-ios-h a.sc-ion-input-ios, .has-focus.sc-ion-input-ios-h button.sc-ion-input-ios, .has-focus.sc-ion-input-ios-h input.sc-ion-input-ios{pointer-events:auto}.sc-ion-input-ios-h{--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:0;font-size:inherit}.item-label-floating.sc-ion-input-ios-h, .item-label-floating .sc-ion-input-ios-h, .item-label-stacked.sc-ion-input-ios-h, .item-label-stacked .sc-ion-input-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}.input-clear-icon.sc-ion-input-ios{background-image:url(\\\"data:image/svg+xml;charset=utf-8,<svg%20xmlns=\\'http://www.w3.org/2000/svg\\'%20viewBox=\\'0%200%20512%20512\\'><path%20fill=\\'var(--ion-color-step-600,%20%23666666)\\'%20d=\\'M403.1,108.9c-81.2-81.2-212.9-81.2-294.2,0s-81.2,212.9,0,294.2c81.2,81.2,212.9,81.2,294.2,0S484.3,190.1,403.1,108.9z%20M352,340.2L340.2,352l-84.4-84.2l-84,83.8L160,339.8l84-83.8l-84-83.8l11.8-11.8l84,83.8l84.4-84.2l11.8,11.8L267.6,256L352,340.2z\\'/></svg>\\\");width:30px;height:30px;background-size:18px}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_17;\r\n}());\r\nvar inputIds = 0;\r\nvar Item = /** @class */ (function () {\r\n    function class_18(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.itemStyles = new Map();\r\n        this.multipleInputs = false;\r\n        /**\r\n         * If `true`, a button tag will be rendered and the item will be tappable.\r\n         */\r\n        this.button = false;\r\n        /**\r\n         * The icon to use when `detail` is set to `true`.\r\n         */\r\n        this.detailIcon = 'ios-arrow-forward';\r\n        /**\r\n         * If `true`, the user cannot interact with the item.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * When using a router, it specifies the transition direction when navigating to\r\n         * another page using `href`.\r\n         */\r\n        this.routerDirection = 'forward';\r\n        /**\r\n         * The type of the button. Only used when an `onclick` or `button` property is present.\r\n         */\r\n        this.type = 'button';\r\n    }\r\n    class_18.prototype.itemStyle = function (ev) {\r\n        ev.stopPropagation();\r\n        var tagName = ev.target.tagName;\r\n        var updatedStyles = ev.detail;\r\n        var newStyles = {};\r\n        var childStyles = this.itemStyles.get(tagName) || {};\r\n        var hasStyleChange = false;\r\n        Object.keys(updatedStyles).forEach(function (key) {\r\n            if (updatedStyles[key]) {\r\n                var itemKey = \"item-\" + key;\r\n                if (!childStyles[itemKey]) {\r\n                    hasStyleChange = true;\r\n                }\r\n                newStyles[itemKey] = true;\r\n            }\r\n        });\r\n        if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {\r\n            hasStyleChange = true;\r\n        }\r\n        if (hasStyleChange) {\r\n            this.itemStyles.set(tagName, newStyles);\r\n            this.el.forceUpdate();\r\n        }\r\n    };\r\n    class_18.prototype.componentDidLoad = function () {\r\n        // The following elements have a clickable cover that is relative to the entire item\r\n        var covers = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');\r\n        // The following elements can accept focus alongside the previous elements\r\n        // therefore if these elements are also a child of item, we don't want the\r\n        // input cover on top of those interfering with their clicks\r\n        var inputs = this.el.querySelectorAll('ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle');\r\n        // Check for multiple inputs to change the position of the input cover to relative\r\n        // for all of the covered inputs above\r\n        this.multipleInputs = covers.length + inputs.length > 1;\r\n    };\r\n    // If the item contains an input including a checkbox, datetime, select, or radio\r\n    // then the item will have a clickable input cover that covers the item\r\n    // that should get the hover, focused and activated states UNLESS it has multiple\r\n    // inputs, then those need to individually get each click\r\n    class_18.prototype.hasCover = function () {\r\n        var inputs = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');\r\n        return inputs.length === 1 && !this.multipleInputs;\r\n    };\r\n    // If the item has an href or button property it will render a native\r\n    // anchor or button that is clickable\r\n    class_18.prototype.isClickable = function () {\r\n        return (this.href !== undefined || this.button);\r\n    };\r\n    class_18.prototype.canActivate = function () {\r\n        return (this.isClickable() || this.hasCover());\r\n    };\r\n    class_18.prototype.render = function () {\r\n        var _b;\r\n        var _c = this, detail = _c.detail, detailIcon = _c.detailIcon, download = _c.download, lines = _c.lines, disabled = _c.disabled, href = _c.href, rel = _c.rel, target = _c.target, routerDirection = _c.routerDirection;\r\n        var childStyles = {};\r\n        var mode = getIonMode$1(this);\r\n        var clickable = this.isClickable();\r\n        var canActivate = this.canActivate();\r\n        var TagType = clickable ? (href === undefined ? 'button' : 'a') : 'div';\r\n        var attrs = (TagType === 'button')\r\n            ? { type: this.type }\r\n            : {\r\n                download: download,\r\n                href: href,\r\n                rel: rel,\r\n                target: target\r\n            };\r\n        var showDetail = detail !== undefined ? detail : mode === 'ios' && clickable;\r\n        this.itemStyles.forEach(function (value) {\r\n            Object.assign(childStyles, value);\r\n        });\r\n        return (h(Host, { \"aria-disabled\": disabled ? 'true' : null, class: Object.assign(Object.assign(Object.assign({}, childStyles), createColorClasses$1(this.color)), (_b = { 'item': true }, _b[mode] = true, _b[\"item-lines-\" + lines] = lines !== undefined, _b['item-disabled'] = disabled, _b['in-list'] = hostContext('ion-list', this.el), _b['item-multiple-inputs'] = this.multipleInputs, _b['ion-activatable'] = canActivate, _b['ion-focusable'] = true, _b)) }, h(TagType, Object.assign({}, attrs, { class: \"item-native\", disabled: disabled, onClick: function (ev) { return openURL(href, ev, routerDirection); } }), h(\"slot\", { name: \"start\" }), h(\"div\", { class: \"item-inner\" }, h(\"div\", { class: \"input-wrapper\" }, h(\"slot\", null)), h(\"slot\", { name: \"end\" }), showDetail && h(\"ion-icon\", { icon: detailIcon, lazy: false, class: \"item-detail-icon\" }), h(\"div\", { class: \"item-inner-highlight\" })), canActivate && mode === 'md' && h(\"ion-ripple-effect\", null)), h(\"div\", { class: \"item-highlight\" })));\r\n    };\r\n    Object.defineProperty(class_18.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_18, \"style\", {\r\n        get: function () { return \":host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--box-shadow:none;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:var(--ion-item-background-activated,currentColor);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;outline:none;color:var(--color);font-family:var(--ion-font-family,inherit);text-align:initial;text-decoration:none;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden}:host(.ion-color) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color) .item-inner,:host(.ion-color) .item-native{border-color:var(--ion-color-shade)}:host(.ion-focused) .item-native{background:var(--background-focused);color:var(--color-focused)}:host(.ion-color.ion-focused) .item-native{background:var(--ion-color-shade);color:var(--ion-color-contrast)}\\@media (any-hover:hover){:host(.ion-activatable:hover) .item-native{background:var(--background-hover);color:var(--color-hover)}:host(.ion-color.ion-activatable:hover) .item-native{background:var(--ion-color-tint);color:var(--ion-color-contrast)}}:host(.activated) .item-native{background:var(--background-activated);color:var(--color-activated)}:host(.item-disabled),:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){opacity:.3}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.item-native{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}a,button{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.item-inner{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}.item-detail-icon{color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label){-ms-flex:1;flex:1}:host(.item-input),:host([vertical-align-top]){-ms-flex-align:start;align-items:flex-start}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-floating) .item-native,:host(.item-label-stacked) .item-native{-ms-flex-align:start;align-items:start}:host(.item-label-floating) .input-wrapper,:host(.item-label-stacked) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;bottom:0;position:absolute;background:var(--highlight-background)}.item-highlight{height:var(--full-highlight-height)}.item-inner-highlight{height:var(--inset-highlight-height)}:host(.item-interactive.ion-touched.ion-invalid),:host(.item-interactive.item-has-focus){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-label-floating) ::slotted(ion-select),:host(.item-label-stacked) ::slotted(ion-select){--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(.item-label-floating) ::slotted(ion-datetime),:host(.item-label-stacked) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host{--min-height:44px;--transition:background-color 200ms linear;--padding-start:16px;--inner-padding-end:8px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background,var(--ion-background-color,#fff));--background-activated:var(--ion-item-background-activated,var(--ion-color-step-150,#d9d9d9));--background-focused:var(--ion-item-background-focused,var(--ion-color-step-100,#e1e1e1));--background-hover:var(--ion-item-background-hover,rgba(var(--ion-text-color-rgb,0,0,0),0.04));--border-color:var(--ion-item-border-color,var(--ion-border-color,var(--ion-color-step-250,#c8c7cc)));--color:var(--ion-item-color,var(--ion-text-color,#000));--highlight-height:0;--highlight-color-focused:var(--ion-color-primary,#3880ff);--highlight-color-valid:var(--ion-color-success,#10dc60);--highlight-color-invalid:var(--ion-color-danger,#f04141);font-size:17px}:host(.activated){--transition:none}:host(.ion-color.activated) .item-native{background:var(--ion-color-shade);color:var(--ion-color-contrast)}\\@media (any-hover:hover){:host(.activated.ion-activatable:hover) .item-native{background:var(--background-activated);color:var(--color-activated)}:host(.activated.ion-color.ion-activatable:hover) .item-native{background:var(--ion-color-shade);color:var(--ion-color-contrast)}}:host(.item-interactive){--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-full){--border-width:0px 0px 0.55px 0px;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0px 0px 0.55px 0px;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0px;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0px;--show-inset-highlight:0}::slotted([slot=start]){margin-left:0;margin-right:16px;margin-top:2px;margin-bottom:2px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted([slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}}::slotted([slot=end]){margin-left:8px;margin-right:8px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted([slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px}}::slotted(ion-icon[slot=end]),::slotted(ion-icon[slot=start]){margin-left:0;margin-top:7px;margin-bottom:7px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-icon[slot=end]),::slotted(ion-icon[slot=start]){margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}::slotted(ion-toggle[slot=end]),::slotted(ion-toggle[slot=start]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.item-label-floating) ::slotted([slot=end]),:host(.item-label-stacked) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}::slotted(.button-small){--padding-top:0px;--padding-bottom:0px;--padding-start:.5em;--padding-end:.5em;height:24px;font-size:13px}::slotted(ion-avatar){width:36px;height:36px}::slotted(ion-thumbnail){width:56px;height:56px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:8px;margin-right:8px;margin-top:8px;margin-bottom:8px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px}}:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){margin-left:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}::slotted(ion-label){margin-left:0;margin-right:8px;margin-top:10px;margin-bottom:10px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-label){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}:host(.item-label-floating),:host(.item-label-stacked){--min-height:68px}:host(.item-label-floating) ::slotted(ion-select),:host(.item-label-stacked) ::slotted(ion-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0px}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_18;\r\n}());\r\nvar ItemDivider = /** @class */ (function () {\r\n    function class_19(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        /**\r\n         * When it's set to `true`, the item-divider will stay visible when it reaches the top\r\n         * of the viewport until the next `ion-item-divider` replaces it.\r\n         *\r\n         * This feature relies in `position:sticky`:\r\n         * https://caniuse.com/#feat=css-sticky\r\n         */\r\n        this.sticky = false;\r\n    }\r\n    class_19.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_b = {}, _b[mode] = true, _b['item-divider-sticky'] = this.sticky, _b['item'] = true, _b)) }, h(\"slot\", { name: \"start\" }), h(\"div\", { class: \"item-divider-inner\" }, h(\"div\", { class: \"item-divider-wrapper\" }, h(\"slot\", null)), h(\"slot\", { name: \"end\" }))));\r\n    };\r\n    Object.defineProperty(class_19.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_19, \"style\", {\r\n        get: function () { return \":host{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--inner-padding-top:0px;--inner-padding-end:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:30px;background:var(--background);color:var(--color);font-family:var(--ion-font-family,inherit);overflow:hidden;z-index:100;-webkit-box-sizing:border-box;box-sizing:border-box}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.item-divider-sticky){position:-webkit-sticky;position:sticky;top:0}.item-divider-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border:0;overflow:hidden}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.item-divider-inner{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}.item-divider-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:hidden}:host{--background:var(--ion-color-step-50,#f2f2f2);--color:var(--ion-color-step-850,#262626);--padding-start:16px;--inner-padding-end:8px;border-radius:0;position:relative;font-size:17px}:host([slot=start]){margin-left:0;margin-right:16px;margin-top:2px;margin-bottom:2px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host([slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}}:host([slot=end]){margin-left:8px;margin-right:8px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host([slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px}}::slotted(ion-icon[slot=end]),::slotted(ion-icon[slot=start]){margin-left:0;margin-top:7px;margin-bottom:7px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-icon[slot=end]),::slotted(ion-icon[slot=start]){margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}::slotted(ion-label){margin-left:0;margin-right:8px;margin-top:10px;margin-bottom:10px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-label){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}::slotted(h1){font-size:24px}::slotted(h1),::slotted(h2){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-weight:400}::slotted(h2){font-size:17px}::slotted(h3),::slotted(h4),::slotted(h5),::slotted(h6){margin-bottom:3px;font-weight:400}::slotted(h3),::slotted(h4),::slotted(h5),::slotted(h6),::slotted(p){margin-left:0;margin-right:0;margin-top:0;font-size:14px;line-height:normal}::slotted(p){margin-bottom:2px;color:rgba(var(--ion-text-color-rgb,0,0,0),.4);text-overflow:inherit;overflow:inherit}::slotted(h2:last-child) ::slotted(h3:last-child),::slotted(h4:last-child),::slotted(h5:last-child),::slotted(h6:last-child),::slotted(p:last-child){margin-bottom:0}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_19;\r\n}());\r\nvar Label = /** @class */ (function () {\r\n    function class_20(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.noAnimate = false;\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n    }\r\n    class_20.prototype.componentWillLoad = function () {\r\n        this.noAnimate = (this.position === 'floating');\r\n        this.emitStyle();\r\n    };\r\n    class_20.prototype.componentDidLoad = function () {\r\n        var _this_1 = this;\r\n        if (this.noAnimate) {\r\n            setTimeout(function () {\r\n                _this_1.noAnimate = false;\r\n            }, 1000);\r\n        }\r\n    };\r\n    class_20.prototype.positionChanged = function () {\r\n        this.emitStyle();\r\n    };\r\n    class_20.prototype.emitStyle = function () {\r\n        var _b;\r\n        var position = this.position;\r\n        this.ionStyle.emit((_b = {\r\n                'label': true\r\n            },\r\n            _b[\"label-\" + position] = position !== undefined,\r\n            _b));\r\n    };\r\n    class_20.prototype.render = function () {\r\n        var _b;\r\n        var position = this.position;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_b = {}, _b[mode] = true, _b[\"label-\" + position] = position !== undefined, _b[\"label-no-animate\"] = (this.noAnimate), _b)) }));\r\n    };\r\n    Object.defineProperty(class_20.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_20, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"position\": [\"positionChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_20, \"style\", {\r\n        get: function () { return \".item.sc-ion-label-ios-h, .item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family,inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-ios-h, [text-wrap].sc-ion-label-ios-h{white-space:normal}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs), .item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:.3;pointer-events:none}.item-input.sc-ion-label-ios-h, .item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h, .item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-floating.sc-ion-label-ios-h, .label-stacked.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.ion-text-wrap.sc-ion-label-ios-h, [text-wrap].sc-ion-label-ios-h{font-size:14px;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:13.6px}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate3d(0,27px,0);transform:translate3d(0,27px,0);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform .15s ease-in-out;transition:-webkit-transform .15s ease-in-out;transition:transform .15s ease-in-out;transition:transform .15s ease-in-out,-webkit-transform .15s ease-in-out}[dir=rtl].label-floating.sc-ion-label-ios-h, [dir=rtl] .label-floating.sc-ion-label-ios-h, [dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h, [dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}.item-has-focus.label-floating.sc-ion-label-ios-h, .item-has-focus .label-floating.sc-ion-label-ios-h, .item-has-placeholder.label-floating.sc-ion-label-ios-h, .item-has-placeholder .label-floating.sc-ion-label-ios-h, .item-has-value.label-floating.sc-ion-label-ios-h, .item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:translateZ(0) scale(.8);transform:translateZ(0) scale(.8)}.sc-ion-label-ios-s  h1 {font-size:24px}.sc-ion-label-ios-s  h1 , .sc-ion-label-ios-s  h2 {margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-weight:400}.sc-ion-label-ios-s  h2 {font-size:17px}.sc-ion-label-ios-s  h3 , .sc-ion-label-ios-s  h4 , .sc-ion-label-ios-s  h5 , .sc-ion-label-ios-s  h6 {margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:400;line-height:normal}.sc-ion-label-ios-s  p {margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s > p{color:rgba(var(--ion-text-color-rgb,0,0,0),.4)}.sc-ion-label-ios-h.ion-color.sc-ion-label-ios-s > p, .ion-color .sc-ion-label-ios-h.sc-ion-label-ios-s > p{color:inherit}.sc-ion-label-ios-s  h2:last-child , .sc-ion-label-ios-s  h3:last-child , .sc-ion-label-ios-s  h4:last-child , .sc-ion-label-ios-s  h5:last-child , .sc-ion-label-ios-s  h6:last-child , .sc-ion-label-ios-s  p:last-child {margin-bottom:0}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_20;\r\n}());\r\nvar List = /** @class */ (function () {\r\n    function class_21(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        /**\r\n         * If `true`, the list will have margin around it and rounded corners.\r\n         */\r\n        this.inset = false;\r\n    }\r\n    /**\r\n     * If `ion-item-sliding` are used inside the list, this method closes\r\n     * any open sliding item.\r\n     *\r\n     * Returns `true` if an actual `ion-item-sliding` is closed.\r\n     */\r\n    class_21.prototype.closeSlidingItems = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var item;\r\n            return __generator(this, function (_b) {\r\n                item = this.el.querySelector('ion-item-sliding');\r\n                if (item && item.closeOpened) {\r\n                    return [2 /*return*/, item.closeOpened()];\r\n                }\r\n                return [2 /*return*/, false];\r\n            });\r\n        });\r\n    };\r\n    class_21.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        var _c = this, lines = _c.lines, inset = _c.inset;\r\n        return (h(Host, { class: (_b = {},\r\n                _b[mode] = true,\r\n                // Used internally for styling\r\n                _b[\"list-\" + mode] = true,\r\n                _b['list-inset'] = inset,\r\n                _b[\"list-lines-\" + lines] = lines !== undefined,\r\n                _b[\"list-\" + mode + \"-lines-\" + lines] = lines !== undefined,\r\n                _b) }));\r\n    };\r\n    Object.defineProperty(class_21.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_21, \"style\", {\r\n        get: function () { return \"ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-ios{margin-left:0;margin-right:0;margin-top:-1px;margin-bottom:32px;background:var(--ion-item-background,var(--ion-background-color,#fff))}.list-ios.list-inset{margin-left:16px;margin-right:16px;margin-top:16px;margin-bottom:16px;border-radius:4px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.list-ios.list-inset{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}.list-ios.list-inset ion-item{--border-width:0 0 1px 0;--inner-border-width:0}.list-ios.list-inset ion-item:last-child{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item{--border-width:0;--inner-border-width:0}.list-ios-lines-full .item,.list-ios .item-lines-full{--border-width:0 0 0.55px 0}.list-ios-lines-full .item{--inner-border-width:0}.list-ios-lines-inset .item,.list-ios .item-lines-inset{--inner-border-width:0 0 0.55px 0}.list-ios .item-lines-inset{--border-width:0}.list-ios .item-lines-full{--inner-border-width:0}.list-ios .item-lines-none{--border-width:0;--inner-border-width:0}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_21;\r\n}());\r\nvar ListHeader = /** @class */ (function () {\r\n    function class_22(hostRef) {\r\n        registerInstance(this, hostRef);\r\n    }\r\n    class_22.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_b = {}, _b[mode] = true, _b)) }, h(\"slot\", null)));\r\n    };\r\n    Object.defineProperty(class_22, \"style\", {\r\n        get: function () { return \":host{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:40px;background:var(--background);color:var(--color);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host{--background:transparent;--color:var(--ion-color-step-850,#262626);padding-left:calc(var(--ion-safe-area-left, 0px) + 16px);position:relative;font-size:12px;font-weight:500;letter-spacing:1px;text-transform:uppercase}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{padding-left:unset;-webkit-padding-start:calc(var(--ion-safe-area-left, 0px) + 16px);padding-inline-start:calc(var(--ion-safe-area-left, 0px) + 16px)}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_22;\r\n}());\r\nvar Range = /** @class */ (function () {\r\n    function class_23(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.noUpdate = false;\r\n        this.hasFocus = false;\r\n        this.ratioA = 0;\r\n        this.ratioB = 0;\r\n        /**\r\n         * How long, in milliseconds, to wait to trigger the\r\n         * `ionChange` event after each change in the range value.\r\n         */\r\n        this.debounce = 0;\r\n        /**\r\n         * The name of the control, which is submitted with the form data.\r\n         */\r\n        this.name = '';\r\n        /**\r\n         * Show two knobs.\r\n         */\r\n        this.dualKnobs = false;\r\n        /**\r\n         * Minimum integer value of the range.\r\n         */\r\n        this.min = 0;\r\n        /**\r\n         * Maximum integer value of the range.\r\n         */\r\n        this.max = 100;\r\n        /**\r\n         * If `true`, a pin with integer value is shown when the knob\r\n         * is pressed.\r\n         */\r\n        this.pin = false;\r\n        /**\r\n         * If `true`, the knob snaps to tick marks evenly spaced based\r\n         * on the step property value.\r\n         */\r\n        this.snaps = false;\r\n        /**\r\n         * Specifies the value granularity.\r\n         */\r\n        this.step = 1;\r\n        /**\r\n         * If `true`, tick marks are displayed based on the step value.\r\n         * Only applies when `snaps` is `true`.\r\n         */\r\n        this.ticks = true;\r\n        /**\r\n         * If `true`, the user cannot interact with the range.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * the value of the range.\r\n         */\r\n        this.value = 0;\r\n        this.clampBounds = function (value) {\r\n            return clamp(_this_1.min, value, _this_1.max);\r\n        };\r\n        this.ensureValueInBounds = function (value) {\r\n            if (_this_1.dualKnobs) {\r\n                return {\r\n                    lower: _this_1.clampBounds(value.lower),\r\n                    upper: _this_1.clampBounds(value.upper)\r\n                };\r\n            }\r\n            else {\r\n                return _this_1.clampBounds(value);\r\n            }\r\n        };\r\n        this.handleKeyboard = function (knob, isIncrease) {\r\n            var step = _this_1.step;\r\n            step = step > 0 ? step : 1;\r\n            step = step / (_this_1.max - _this_1.min);\r\n            if (!isIncrease) {\r\n                step *= -1;\r\n            }\r\n            if (knob === 'A') {\r\n                _this_1.ratioA = clamp(0, _this_1.ratioA + step, 1);\r\n            }\r\n            else {\r\n                _this_1.ratioB = clamp(0, _this_1.ratioB + step, 1);\r\n            }\r\n            _this_1.updateValue();\r\n        };\r\n        this.onBlur = function () {\r\n            if (_this_1.hasFocus) {\r\n                _this_1.hasFocus = false;\r\n                _this_1.ionBlur.emit();\r\n                _this_1.emitStyle();\r\n            }\r\n        };\r\n        this.onFocus = function () {\r\n            if (!_this_1.hasFocus) {\r\n                _this_1.hasFocus = true;\r\n                _this_1.ionFocus.emit();\r\n                _this_1.emitStyle();\r\n            }\r\n        };\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n    }\r\n    class_23.prototype.debounceChanged = function () {\r\n        this.ionChange = debounceEvent(this.ionChange, this.debounce);\r\n    };\r\n    class_23.prototype.minChanged = function () {\r\n        if (!this.noUpdate) {\r\n            this.updateRatio();\r\n        }\r\n    };\r\n    class_23.prototype.maxChanged = function () {\r\n        if (!this.noUpdate) {\r\n            this.updateRatio();\r\n        }\r\n    };\r\n    class_23.prototype.disabledChanged = function () {\r\n        if (this.gesture) {\r\n            this.gesture.setDisabled(this.disabled);\r\n        }\r\n        this.emitStyle();\r\n    };\r\n    class_23.prototype.valueChanged = function (value) {\r\n        if (!this.noUpdate) {\r\n            this.updateRatio();\r\n        }\r\n        value = this.ensureValueInBounds(value);\r\n        this.ionChange.emit({ value: value });\r\n    };\r\n    class_23.prototype.connectedCallback = function () {\r\n        this.updateRatio();\r\n        this.debounceChanged();\r\n        this.disabledChanged();\r\n    };\r\n    class_23.prototype.disconnectedCallback = function () {\r\n        if (this.gesture) {\r\n            this.gesture.destroy();\r\n            this.gesture = undefined;\r\n        }\r\n    };\r\n    class_23.prototype.componentDidLoad = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var rangeSlider, _b;\r\n            var _this_1 = this;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        rangeSlider = this.rangeSlider;\r\n                        if (!rangeSlider) return [3 /*break*/, 2];\r\n                        _b = this;\r\n                        return [4 /*yield*/, import('./index-14bae62d.js')];\r\n                    case 1:\r\n                        _b.gesture = (_c.sent()).createGesture({\r\n                            el: rangeSlider,\r\n                            gestureName: 'range',\r\n                            gesturePriority: 100,\r\n                            threshold: 0,\r\n                            onStart: function (ev) { return _this_1.onStart(ev); },\r\n                            onMove: function (ev) { return _this_1.onMove(ev); },\r\n                            onEnd: function (ev) { return _this_1.onEnd(ev); },\r\n                        });\r\n                        this.gesture.setDisabled(this.disabled);\r\n                        _c.label = 2;\r\n                    case 2: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    class_23.prototype.getValue = function () {\r\n        var value = this.value || 0;\r\n        if (this.dualKnobs) {\r\n            if (typeof value === 'object') {\r\n                return value;\r\n            }\r\n            return {\r\n                lower: 0,\r\n                upper: value\r\n            };\r\n        }\r\n        else {\r\n            if (typeof value === 'object') {\r\n                return value.upper;\r\n            }\r\n            return value;\r\n        }\r\n    };\r\n    class_23.prototype.emitStyle = function () {\r\n        this.ionStyle.emit({\r\n            'interactive': true,\r\n            'interactive-disabled': this.disabled\r\n        });\r\n    };\r\n    class_23.prototype.onStart = function (detail) {\r\n        var rect = this.rect = this.rangeSlider.getBoundingClientRect();\r\n        var currentX = detail.currentX;\r\n        // figure out which knob they started closer to\r\n        var ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\r\n        if (document.dir === 'rtl') {\r\n            ratio = 1 - ratio;\r\n        }\r\n        this.pressedKnob =\r\n            !this.dualKnobs ||\r\n                Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio)\r\n                ? 'A'\r\n                : 'B';\r\n        this.setFocus(this.pressedKnob);\r\n        // update the active knob's position\r\n        this.update(currentX);\r\n    };\r\n    class_23.prototype.onMove = function (detail) {\r\n        this.update(detail.currentX);\r\n    };\r\n    class_23.prototype.onEnd = function (detail) {\r\n        this.update(detail.currentX);\r\n        this.pressedKnob = undefined;\r\n    };\r\n    class_23.prototype.update = function (currentX) {\r\n        // figure out where the pointer is currently at\r\n        // update the knob being interacted with\r\n        var rect = this.rect;\r\n        var ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\r\n        if (document.dir === 'rtl') {\r\n            ratio = 1 - ratio;\r\n        }\r\n        if (this.snaps) {\r\n            // snaps the ratio to the current value\r\n            ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\r\n        }\r\n        // update which knob is pressed\r\n        if (this.pressedKnob === 'A') {\r\n            this.ratioA = ratio;\r\n        }\r\n        else {\r\n            this.ratioB = ratio;\r\n        }\r\n        // Update input value\r\n        this.updateValue();\r\n    };\r\n    Object.defineProperty(class_23.prototype, \"valA\", {\r\n        get: function () {\r\n            return ratioToValue(this.ratioA, this.min, this.max, this.step);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_23.prototype, \"valB\", {\r\n        get: function () {\r\n            return ratioToValue(this.ratioB, this.min, this.max, this.step);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_23.prototype, \"ratioLower\", {\r\n        get: function () {\r\n            if (this.dualKnobs) {\r\n                return Math.min(this.ratioA, this.ratioB);\r\n            }\r\n            return 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_23.prototype, \"ratioUpper\", {\r\n        get: function () {\r\n            if (this.dualKnobs) {\r\n                return Math.max(this.ratioA, this.ratioB);\r\n            }\r\n            return this.ratioA;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_23.prototype.updateRatio = function () {\r\n        var value = this.getValue();\r\n        var _b = this, min = _b.min, max = _b.max;\r\n        if (this.dualKnobs) {\r\n            this.ratioA = valueToRatio(value.lower, min, max);\r\n            this.ratioB = valueToRatio(value.upper, min, max);\r\n        }\r\n        else {\r\n            this.ratioA = valueToRatio(value, min, max);\r\n        }\r\n    };\r\n    class_23.prototype.updateValue = function () {\r\n        this.noUpdate = true;\r\n        var _b = this, valA = _b.valA, valB = _b.valB;\r\n        this.value = !this.dualKnobs\r\n            ? valA\r\n            : {\r\n                lower: Math.min(valA, valB),\r\n                upper: Math.max(valA, valB)\r\n            };\r\n        this.noUpdate = false;\r\n    };\r\n    class_23.prototype.setFocus = function (knob) {\r\n        if (this.el.shadowRoot) {\r\n            var knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\r\n            if (knobEl) {\r\n                knobEl.focus();\r\n            }\r\n        }\r\n    };\r\n    class_23.prototype.render = function () {\r\n        var _b, _c;\r\n        var _this_1 = this;\r\n        var _d = this, min = _d.min, max = _d.max, step = _d.step, el = _d.el, handleKeyboard = _d.handleKeyboard, pressedKnob = _d.pressedKnob, disabled = _d.disabled, pin = _d.pin, ratioLower = _d.ratioLower, ratioUpper = _d.ratioUpper;\r\n        var mode = getIonMode$1(this);\r\n        var barStart = ratioLower * 100 + \"%\";\r\n        var barEnd = 100 - ratioUpper * 100 + \"%\";\r\n        var doc = document;\r\n        var isRTL = doc.dir === 'rtl';\r\n        var start = isRTL ? 'right' : 'left';\r\n        var end = isRTL ? 'left' : 'right';\r\n        var tickStyle = function (tick) {\r\n            var _b;\r\n            return _b = {},\r\n                _b[start] = tick[start],\r\n                _b;\r\n        };\r\n        var barStyle = (_b = {},\r\n            _b[start] = barStart,\r\n            _b[end] = barEnd,\r\n            _b);\r\n        var ticks = [];\r\n        if (this.snaps && this.ticks) {\r\n            for (var value = min; value <= max; value += step) {\r\n                var ratio = valueToRatio(value, min, max);\r\n                var tick = {\r\n                    ratio: ratio,\r\n                    active: ratio >= ratioLower && ratio <= ratioUpper,\r\n                };\r\n                tick[start] = ratio * 100 + \"%\";\r\n                ticks.push(tick);\r\n            }\r\n        }\r\n        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\r\n        return (h(Host, { onFocusin: this.onFocus, onFocusout: this.onBlur, class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_c = {}, _c[mode] = true, _c['in-item'] = hostContext('ion-item', el), _c['range-disabled'] = disabled, _c['range-pressed'] = pressedKnob !== undefined, _c['range-has-pin'] = pin, _c)) }, h(\"slot\", { name: \"start\" }), h(\"div\", { class: \"range-slider\", ref: function (rangeEl) { return _this_1.rangeSlider = rangeEl; } }, ticks.map(function (tick) { return (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\r\n                'range-tick': true,\r\n                'range-tick-active': tick.active\r\n            } })); }), h(\"div\", { class: \"range-bar\", role: \"presentation\" }), h(\"div\", { class: \"range-bar range-bar-active\", role: \"presentation\", style: barStyle }), renderKnob(isRTL, {\r\n            knob: 'A',\r\n            pressed: pressedKnob === 'A',\r\n            value: this.valA,\r\n            ratio: this.ratioA,\r\n            pin: pin,\r\n            disabled: disabled,\r\n            handleKeyboard: handleKeyboard,\r\n            min: min,\r\n            max: max\r\n        }), this.dualKnobs && renderKnob(isRTL, {\r\n            knob: 'B',\r\n            pressed: pressedKnob === 'B',\r\n            value: this.valB,\r\n            ratio: this.ratioB,\r\n            pin: pin,\r\n            disabled: disabled,\r\n            handleKeyboard: handleKeyboard,\r\n            min: min,\r\n            max: max\r\n        })), h(\"slot\", { name: \"end\" })));\r\n    };\r\n    Object.defineProperty(class_23.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_23, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"debounce\": [\"debounceChanged\"],\r\n                \"min\": [\"minChanged\"],\r\n                \"max\": [\"maxChanged\"],\r\n                \"disabled\": [\"disabledChanged\"],\r\n                \"value\": [\"valueChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_23, \"style\", {\r\n        get: function () { return \":host{--knob-handle-size:calc(var(--knob-size) * 2);display:-ms-flexbox;display:flex;position:relative;-ms-flex:3;flex:3;-ms-flex-align:center;align-items:center;font-family:var(--ion-font-family,inherit);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.range-disabled){pointer-events:none}::slotted(ion-label){-ms-flex:initial;flex:initial}::slotted(ion-icon[slot]){font-size:24px}.range-slider{position:relative;-ms-flex:1;flex:1;width:100%;height:var(--height);contain:size layout style;cursor:-webkit-grab;cursor:grab;-ms-touch-action:pan-y;touch-action:pan-y}:host(.range-pressed) .range-slider{cursor:-webkit-grabbing;cursor:grabbing}.range-pin{position:absolute;background:var(--ion-color-base);color:var(--ion-color-contrast);-webkit-box-sizing:border-box;box-sizing:border-box}.range-knob-handle{left:0;top:calc((var(--height) - var(--knob-handle-size)) / 2);margin-left:calc(0px - var(--knob-handle-size) / 2);position:absolute;width:var(--knob-handle-size);height:var(--knob-handle-size);text-align:center}:host-context([dir=rtl]) .range-knob-handle,[dir=rtl] .range-knob-handle{right:unset;right:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.range-knob-handle{margin-left:unset;-webkit-margin-start:calc(0px - var(--knob-handle-size) / 2);margin-inline-start:calc(0px - var(--knob-handle-size) / 2)}}:host-context([dir=rtl]) .range-knob-handle,[dir=rtl] .range-knob-handle{left:unset}.range-knob-handle:active,.range-knob-handle:focus{outline:none}.range-bar{border-radius:var(--bar-border-radius);left:0;top:calc((var(--height) - var(--bar-height)) / 2);position:absolute;width:100%;height:var(--bar-height);background:var(--bar-background);pointer-events:none}:host-context([dir=rtl]) .range-bar,[dir=rtl] .range-bar{right:unset;right:0;left:unset}.range-knob{border-radius:var(--knob-border-radius);left:calc(50% - var(--knob-size) / 2);top:calc(50% - var(--knob-size) / 2);position:absolute;width:var(--knob-size);height:var(--knob-size);background:var(--knob-background);-webkit-box-shadow:var(--knob-box-shadow);box-shadow:var(--knob-box-shadow);z-index:2;pointer-events:none}:host-context([dir=rtl]) .range-knob,[dir=rtl] .range-knob{right:unset;right:calc(50% - var(--knob-size) / 2);left:unset}:host(.range-pressed) .range-bar-active{will-change:left,right}:host(.in-item){width:100%}:host(.in-item) ::slotted(ion-label){-ms-flex-item-align:center;align-self:center}:host{--knob-border-radius:50%;--knob-background:#fff;--knob-box-shadow:0 3px 1px rgba(0,0,0,0.1),0 4px 8px rgba(0,0,0,0.13),0 0 0 1px rgba(0,0,0,0.02);--knob-size:28px;--bar-height:2px;--bar-background:rgba(var(--ion-text-color-rgb,0,0,0),0.1);--bar-background-active:var(--ion-color-primary,#3880ff);--bar-border-radius:0;--height:42px;padding-left:16px;padding-right:16px;padding-top:8px;padding-bottom:8px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host(.ion-color) .range-bar-active,:host(.ion-color) .range-tick-active{background:var(--ion-color-base)}::slotted([slot=start]){margin-left:0;margin-right:16px;margin-top:0;margin-bottom:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted([slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}}::slotted([slot=end]){margin-left:16px;margin-right:0;margin-top:0;margin-bottom:0}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted([slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}}:host(.range-has-pin){padding-top:20px}.range-bar-active{bottom:0;width:auto;background:var(--bar-background-active)}.range-tick{margin-left:-1px;border-radius:0;position:absolute;top:18px;width:2px;height:8px;background:rgba(var(--ion-text-color-rgb,0,0,0),.1);pointer-events:none}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.range-tick{margin-left:unset;-webkit-margin-start:-1px;margin-inline-start:-1px}}.range-tick-active{background:var(--bar-background-active)}.range-pin{-webkit-transform:translate3d(0,28px,0) scale(.01);transform:translate3d(0,28px,0) scale(.01);padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;display:inline-block;position:relative;top:-20px;min-width:28px;-webkit-transition:-webkit-transform .12s ease;transition:-webkit-transform .12s ease;transition:transform .12s ease;transition:transform .12s ease,-webkit-transform .12s ease;background:transparent;color:var(--ion-text-color,#000);font-size:12px;text-align:center}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.range-pin{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.range-knob-pressed .range-pin{-webkit-transform:translateZ(0) scale(1);transform:translateZ(0) scale(1)}:host(.range-disabled){opacity:.5}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_23;\r\n}());\r\nvar renderKnob = function (isRTL, _b) {\r\n    var knob = _b.knob, value = _b.value, ratio = _b.ratio, min = _b.min, max = _b.max, disabled = _b.disabled, pressed = _b.pressed, pin = _b.pin, handleKeyboard = _b.handleKeyboard;\r\n    var start = isRTL ? 'right' : 'left';\r\n    var knobStyle = function () {\r\n        var style = {};\r\n        style[start] = ratio * 100 + \"%\";\r\n        return style;\r\n    };\r\n    return (h(\"div\", { onKeyDown: function (ev) {\r\n            var key = ev.key;\r\n            if (key === 'ArrowLeft' || key === 'ArrowDown') {\r\n                handleKeyboard(knob, false);\r\n                ev.preventDefault();\r\n                ev.stopPropagation();\r\n            }\r\n            else if (key === 'ArrowRight' || key === 'ArrowUp') {\r\n                handleKeyboard(knob, true);\r\n                ev.preventDefault();\r\n                ev.stopPropagation();\r\n            }\r\n        }, class: {\r\n            'range-knob-handle': true,\r\n            'range-knob-a': knob === 'A',\r\n            'range-knob-b': knob === 'B',\r\n            'range-knob-pressed': pressed,\r\n            'range-knob-min': value === min,\r\n            'range-knob-max': value === max\r\n        }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && h(\"div\", { class: \"range-pin\", role: \"presentation\" }, Math.round(value)), h(\"div\", { class: \"range-knob\", role: \"presentation\" })));\r\n};\r\nvar ratioToValue = function (ratio, min, max, step) {\r\n    var value = (max - min) * ratio;\r\n    if (step > 0) {\r\n        value = Math.round(value / step) * step + min;\r\n    }\r\n    return clamp(min, value, max);\r\n};\r\nvar valueToRatio = function (value, min, max) {\r\n    return clamp(0, (value - min) / (max - min), 1);\r\n};\r\nvar RippleEffect = /** @class */ (function () {\r\n    function class_24(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        /**\r\n         * Sets the type of ripple-effect:\r\n         *\r\n         * - `bounded`: the ripple effect expands from the user's click position\r\n         * - `unbounded`: the ripple effect expands from the center of the button and overflows the container.\r\n         *\r\n         * NOTE: Surfaces for bounded ripples should have the overflow property set to hidden,\r\n         * while surfaces for unbounded ripples should have it set to visible.\r\n         */\r\n        this.type = 'bounded';\r\n    }\r\n    /**\r\n     * Adds the ripple effect to the parent element.\r\n     *\r\n     * @param x The horizontal coordinate of where the ripple should start.\r\n     * @param y The vertical coordinate of where the ripple should start.\r\n     */\r\n    class_24.prototype.addRipple = function (x, y) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this_1 = this;\r\n            return __generator(this, function (_b) {\r\n                return [2 /*return*/, new Promise(function (resolve) {\r\n                        readTask(function () {\r\n                            var rect = _this_1.el.getBoundingClientRect();\r\n                            var width = rect.width;\r\n                            var height = rect.height;\r\n                            var hypotenuse = Math.sqrt(width * width + height * height);\r\n                            var maxDim = Math.max(height, width);\r\n                            var maxRadius = _this_1.unbounded ? maxDim : hypotenuse + PADDING;\r\n                            var initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\r\n                            var finalScale = maxRadius / initialSize;\r\n                            var posX = x - rect.left;\r\n                            var posY = y - rect.top;\r\n                            if (_this_1.unbounded) {\r\n                                posX = width * 0.5;\r\n                                posY = height * 0.5;\r\n                            }\r\n                            var styleX = posX - initialSize * 0.5;\r\n                            var styleY = posY - initialSize * 0.5;\r\n                            var moveX = width * 0.5 - posX;\r\n                            var moveY = height * 0.5 - posY;\r\n                            writeTask(function () {\r\n                                var div = document.createElement('div');\r\n                                div.classList.add('ripple-effect');\r\n                                var style = div.style;\r\n                                style.top = styleY + 'px';\r\n                                style.left = styleX + 'px';\r\n                                style.width = style.height = initialSize + 'px';\r\n                                style.setProperty('--final-scale', \"\" + finalScale);\r\n                                style.setProperty('--translate-end', moveX + \"px, \" + moveY + \"px\");\r\n                                var container = _this_1.el.shadowRoot || _this_1.el;\r\n                                container.appendChild(div);\r\n                                setTimeout(function () {\r\n                                    resolve(function () {\r\n                                        removeRipple(div);\r\n                                    });\r\n                                }, 225 + 100);\r\n                            });\r\n                        });\r\n                    })];\r\n            });\r\n        });\r\n    };\r\n    Object.defineProperty(class_24.prototype, \"unbounded\", {\r\n        get: function () {\r\n            return this.type === 'unbounded';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_24.prototype.render = function () {\r\n        var _b;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { role: \"presentation\", class: (_b = {},\r\n                _b[mode] = true,\r\n                _b['unbounded'] = this.unbounded,\r\n                _b) }));\r\n    };\r\n    Object.defineProperty(class_24.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_24, \"style\", {\r\n        get: function () { return \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:rippleAnimation 225ms forwards,fadeInAnimation 75ms forwards;animation:rippleAnimation 225ms forwards,fadeInAnimation 75ms forwards;will-change:transform,opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale,1));transform:translate(var(--translate-end)) scale(var(--final-scale,1));-webkit-animation:fadeOutAnimation .15s forwards;animation:fadeOutAnimation .15s forwards}\\@-webkit-keyframes rippleAnimation{0%{-webkit-animation-timing-function:cubic-bezier(.4,0,.2,1);animation-timing-function:cubic-bezier(.4,0,.2,1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale,1));transform:translate(var(--translate-end)) scale(var(--final-scale,1))}}\\@keyframes rippleAnimation{0%{-webkit-animation-timing-function:cubic-bezier(.4,0,.2,1);animation-timing-function:cubic-bezier(.4,0,.2,1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale,1));transform:translate(var(--translate-end)) scale(var(--final-scale,1))}}\\@-webkit-keyframes fadeInAnimation{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:.16}}\\@keyframes fadeInAnimation{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:.16}}\\@-webkit-keyframes fadeOutAnimation{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:.16}to{opacity:0}}\\@keyframes fadeOutAnimation{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:.16}to{opacity:0}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_24;\r\n}());\r\nvar removeRipple = function (ripple) {\r\n    ripple.classList.add('fade-out');\r\n    setTimeout(function () {\r\n        ripple.remove();\r\n    }, 200);\r\n};\r\nvar PADDING = 10;\r\nvar INITIAL_ORIGIN_SCALE = 0.5;\r\nvar Select = /** @class */ (function () {\r\n    function class_25(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.inputId = \"ion-sel-\" + selectIds++;\r\n        this.didInit = false;\r\n        this.isExpanded = false;\r\n        /**\r\n         * If `true`, the user cannot interact with the select.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The text to display on the cancel button.\r\n         */\r\n        this.cancelText = 'Cancel';\r\n        /**\r\n         * The text to display on the ok button.\r\n         */\r\n        this.okText = 'OK';\r\n        /**\r\n         * The name of the control, which is submitted with the form data.\r\n         */\r\n        this.name = this.inputId;\r\n        /**\r\n         * If `true`, the select can accept multiple values.\r\n         */\r\n        this.multiple = false;\r\n        /**\r\n         * The interface the select should use: `action-sheet`, `popover` or `alert`.\r\n         */\r\n        this.interface = 'alert';\r\n        /**\r\n         * Any additional options that the `alert`, `action-sheet` or `popover` interface\r\n         * can take. See the [AlertController API docs](../../alert/AlertController/#create), the\r\n         * [ActionSheetController API docs](../../action-sheet/ActionSheetController/#create) and the\r\n         * [PopoverController API docs](../../popover/PopoverController/#create) for the\r\n         * create options for each interface.\r\n         */\r\n        this.interfaceOptions = {};\r\n        this.onClick = function (ev) {\r\n            _this_1.setFocus();\r\n            _this_1.open(ev);\r\n        };\r\n        this.onFocus = function () {\r\n            _this_1.ionFocus.emit();\r\n        };\r\n        this.onBlur = function () {\r\n            _this_1.ionBlur.emit();\r\n        };\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionCancel = createEvent(this, \"ionCancel\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n    }\r\n    class_25.prototype.disabledChanged = function () {\r\n        this.emitStyle();\r\n    };\r\n    class_25.prototype.valueChanged = function () {\r\n        this.updateOptions();\r\n        this.emitStyle();\r\n        if (this.didInit) {\r\n            this.ionChange.emit({\r\n                value: this.value,\r\n            });\r\n        }\r\n    };\r\n    class_25.prototype.connectedCallback = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var checked, checked;\r\n            var _this_1 = this;\r\n            return __generator(this, function (_b) {\r\n                if (this.value === undefined) {\r\n                    if (this.multiple) {\r\n                        checked = this.childOpts.filter(function (o) { return o.selected; });\r\n                        this.value = checked.map(function (o) { return getOptionValue(o); });\r\n                    }\r\n                    else {\r\n                        checked = this.childOpts.find(function (o) { return o.selected; });\r\n                        if (checked) {\r\n                            this.value = getOptionValue(checked);\r\n                        }\r\n                    }\r\n                }\r\n                this.updateOptions();\r\n                this.updateOverlayOptions();\r\n                this.emitStyle();\r\n                this.mutationO = watchForOptions(this.el, 'ion-select-option', function () { return __awaiter(_this_1, void 0, void 0, function () {\r\n                    return __generator(this, function (_b) {\r\n                        this.updateOptions();\r\n                        this.updateOverlayOptions();\r\n                        return [2 /*return*/];\r\n                    });\r\n                }); });\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    class_25.prototype.disconnectedCallback = function () {\r\n        if (this.mutationO) {\r\n            this.mutationO.disconnect();\r\n            this.mutationO = undefined;\r\n        }\r\n    };\r\n    class_25.prototype.componentDidLoad = function () {\r\n        this.didInit = true;\r\n    };\r\n    /**\r\n     * Open the select overlay. The overlay is either an alert, action sheet, or popover,\r\n     * depending on the `interface` property on the `ion-select`.\r\n     *\r\n     * @param event The user interface event that called the open.\r\n     */\r\n    class_25.prototype.open = function (event) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var overlay, _b;\r\n            var _this_1 = this;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        if (this.disabled || this.isExpanded) {\r\n                            return [2 /*return*/, undefined];\r\n                        }\r\n                        _b = this;\r\n                        return [4 /*yield*/, this.createOverlay(event)];\r\n                    case 1:\r\n                        overlay = _b.overlay = _c.sent();\r\n                        this.isExpanded = true;\r\n                        overlay.onDidDismiss().then(function () {\r\n                            _this_1.overlay = undefined;\r\n                            _this_1.isExpanded = false;\r\n                            _this_1.setFocus();\r\n                        });\r\n                        return [4 /*yield*/, overlay.present()];\r\n                    case 2:\r\n                        _c.sent();\r\n                        return [2 /*return*/, overlay];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    class_25.prototype.createOverlay = function (ev) {\r\n        var selectInterface = this.interface;\r\n        if ((selectInterface === 'action-sheet' || selectInterface === 'popover') && this.multiple) {\r\n            console.warn(\"Select interface cannot be \\\"\" + selectInterface + \"\\\" with a multi-value select. Using the \\\"alert\\\" interface instead.\");\r\n            selectInterface = 'alert';\r\n        }\r\n        if (selectInterface === 'popover' && !ev) {\r\n            console.warn('Select interface cannot be a \"popover\" without passing an event. Using the \"alert\" interface instead.');\r\n            selectInterface = 'alert';\r\n        }\r\n        if (selectInterface === 'popover') {\r\n            return this.openPopover(ev);\r\n        }\r\n        if (selectInterface === 'action-sheet') {\r\n            return this.openActionSheet();\r\n        }\r\n        return this.openAlert();\r\n    };\r\n    class_25.prototype.updateOverlayOptions = function () {\r\n        var overlay = this.overlay;\r\n        if (!overlay) {\r\n            return;\r\n        }\r\n        var childOpts = this.childOpts;\r\n        switch (this.interface) {\r\n            case 'action-sheet':\r\n                overlay.buttons = this.createActionSheetButtons(childOpts);\r\n                break;\r\n            case 'popover':\r\n                var popover = overlay.querySelector('ion-select-popover');\r\n                if (popover) {\r\n                    popover.options = this.createPopoverOptions(childOpts);\r\n                }\r\n                break;\r\n            case 'alert':\r\n                var inputType = (this.multiple ? 'checkbox' : 'radio');\r\n                overlay.inputs = this.createAlertInputs(childOpts, inputType);\r\n                break;\r\n        }\r\n    };\r\n    class_25.prototype.createActionSheetButtons = function (data) {\r\n        var _this_1 = this;\r\n        var actionSheetButtons = data.map(function (option) {\r\n            return {\r\n                role: (option.selected ? 'selected' : ''),\r\n                text: option.textContent,\r\n                handler: function () {\r\n                    _this_1.value = getOptionValue(option);\r\n                }\r\n            };\r\n        });\r\n        // Add \"cancel\" button\r\n        actionSheetButtons.push({\r\n            text: this.cancelText,\r\n            role: 'cancel',\r\n            handler: function () {\r\n                _this_1.ionCancel.emit();\r\n            }\r\n        });\r\n        return actionSheetButtons;\r\n    };\r\n    class_25.prototype.createAlertInputs = function (data, inputType) {\r\n        return data.map(function (o) {\r\n            return {\r\n                type: inputType,\r\n                label: o.textContent,\r\n                value: getOptionValue(o),\r\n                checked: o.selected,\r\n                disabled: o.disabled\r\n            };\r\n        });\r\n    };\r\n    class_25.prototype.createPopoverOptions = function (data) {\r\n        var _this_1 = this;\r\n        return data.map(function (o) {\r\n            var value = getOptionValue(o);\r\n            return {\r\n                text: o.textContent,\r\n                value: value,\r\n                checked: o.selected,\r\n                disabled: o.disabled,\r\n                handler: function () {\r\n                    _this_1.value = value;\r\n                    _this_1.close();\r\n                }\r\n            };\r\n        });\r\n    };\r\n    class_25.prototype.openPopover = function (ev) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var interfaceOptions, mode, popoverOpts;\r\n            return __generator(this, function (_b) {\r\n                interfaceOptions = this.interfaceOptions;\r\n                mode = getIonMode$1(this);\r\n                popoverOpts = Object.assign(Object.assign({ mode: mode }, interfaceOptions), { component: 'ion-select-popover', cssClass: ['select-popover', interfaceOptions.cssClass], event: ev, componentProps: {\r\n                        header: interfaceOptions.header,\r\n                        subHeader: interfaceOptions.subHeader,\r\n                        message: interfaceOptions.message,\r\n                        value: this.value,\r\n                        options: this.createPopoverOptions(this.childOpts)\r\n                    } });\r\n                return [2 /*return*/, popoverController.create(popoverOpts)];\r\n            });\r\n        });\r\n    };\r\n    class_25.prototype.openActionSheet = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var mode, interfaceOptions, actionSheetOpts;\r\n            return __generator(this, function (_b) {\r\n                mode = getIonMode$1(this);\r\n                interfaceOptions = this.interfaceOptions;\r\n                actionSheetOpts = Object.assign(Object.assign({ mode: mode }, interfaceOptions), { buttons: this.createActionSheetButtons(this.childOpts), cssClass: ['select-action-sheet', interfaceOptions.cssClass] });\r\n                return [2 /*return*/, actionSheetController.create(actionSheetOpts)];\r\n            });\r\n        });\r\n    };\r\n    class_25.prototype.openAlert = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var label, labelText, interfaceOptions, inputType, mode, alertOpts;\r\n            var _this_1 = this;\r\n            return __generator(this, function (_b) {\r\n                label = this.getLabel();\r\n                labelText = (label) ? label.textContent : null;\r\n                interfaceOptions = this.interfaceOptions;\r\n                inputType = (this.multiple ? 'checkbox' : 'radio');\r\n                mode = getIonMode$1(this);\r\n                alertOpts = Object.assign(Object.assign({ mode: mode }, interfaceOptions), { header: interfaceOptions.header ? interfaceOptions.header : labelText, inputs: this.createAlertInputs(this.childOpts, inputType), buttons: [\r\n                        {\r\n                            text: this.cancelText,\r\n                            role: 'cancel',\r\n                            handler: function () {\r\n                                _this_1.ionCancel.emit();\r\n                            }\r\n                        },\r\n                        {\r\n                            text: this.okText,\r\n                            handler: function (selectedValues) {\r\n                                _this_1.value = selectedValues;\r\n                            }\r\n                        }\r\n                    ], cssClass: ['select-alert', interfaceOptions.cssClass,\r\n                        (this.multiple ? 'multiple-select-alert' : 'single-select-alert')] });\r\n                return [2 /*return*/, alertController.create(alertOpts)];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Close the select interface.\r\n     */\r\n    class_25.prototype.close = function () {\r\n        // TODO check !this.overlay || !this.isFocus()\r\n        if (!this.overlay) {\r\n            return Promise.resolve(false);\r\n        }\r\n        return this.overlay.dismiss();\r\n    };\r\n    class_25.prototype.updateOptions = function () {\r\n        // iterate all options, updating the selected prop\r\n        var canSelect = true;\r\n        var _b = this, value = _b.value, childOpts = _b.childOpts, compareWith = _b.compareWith, multiple = _b.multiple;\r\n        for (var _c = 0, childOpts_1 = childOpts; _c < childOpts_1.length; _c++) {\r\n            var selectOption = childOpts_1[_c];\r\n            var optValue = getOptionValue(selectOption);\r\n            var selected = canSelect && isOptionSelected(value, optValue, compareWith);\r\n            selectOption.selected = selected;\r\n            // if current option is selected and select is single-option, we can't select\r\n            // any option more\r\n            if (selected && !multiple) {\r\n                canSelect = false;\r\n            }\r\n        }\r\n    };\r\n    class_25.prototype.getLabel = function () {\r\n        return findItemLabel(this.el);\r\n    };\r\n    class_25.prototype.hasValue = function () {\r\n        return this.getText() !== '';\r\n    };\r\n    Object.defineProperty(class_25.prototype, \"childOpts\", {\r\n        get: function () {\r\n            return Array.from(this.el.querySelectorAll('ion-select-option'));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_25.prototype.getText = function () {\r\n        var selectedText = this.selectedText;\r\n        if (selectedText != null && selectedText !== '') {\r\n            return selectedText;\r\n        }\r\n        return generateText(this.childOpts, this.value, this.compareWith);\r\n    };\r\n    class_25.prototype.setFocus = function () {\r\n        if (this.buttonEl) {\r\n            this.buttonEl.focus();\r\n        }\r\n    };\r\n    class_25.prototype.emitStyle = function () {\r\n        this.ionStyle.emit({\r\n            'interactive': true,\r\n            'select': true,\r\n            'has-placeholder': this.placeholder != null,\r\n            'has-value': this.hasValue(),\r\n            'interactive-disabled': this.disabled,\r\n            'select-disabled': this.disabled\r\n        });\r\n    };\r\n    class_25.prototype.render = function () {\r\n        var _b;\r\n        var _this_1 = this;\r\n        var _c = this, placeholder = _c.placeholder, name = _c.name, disabled = _c.disabled, isExpanded = _c.isExpanded, value = _c.value, el = _c.el;\r\n        var mode = getIonMode$1(this);\r\n        var labelId = this.inputId + '-lbl';\r\n        var label = findItemLabel(el);\r\n        if (label) {\r\n            label.id = labelId;\r\n        }\r\n        var addPlaceholderClass = false;\r\n        var selectText = this.getText();\r\n        if (selectText === '' && placeholder != null) {\r\n            selectText = placeholder;\r\n            addPlaceholderClass = true;\r\n        }\r\n        renderHiddenInput(true, el, name, parseValue(value), disabled);\r\n        var selectTextClasses = {\r\n            'select-text': true,\r\n            'select-placeholder': addPlaceholderClass\r\n        };\r\n        return (h(Host, { onClick: this.onClick, role: \"combobox\", \"aria-haspopup\": \"dialog\", \"aria-disabled\": disabled ? 'true' : null, \"aria-expanded\": \"\" + isExpanded, \"aria-labelledby\": labelId, class: (_b = {},\r\n                _b[mode] = true,\r\n                _b['in-item'] = hostContext('ion-item', el),\r\n                _b['select-disabled'] = disabled,\r\n                _b) }, h(\"div\", { class: selectTextClasses }, selectText), h(\"div\", { class: \"select-icon\", role: \"presentation\" }, h(\"div\", { class: \"select-icon-inner\" })), h(\"button\", { type: \"button\", onFocus: this.onFocus, onBlur: this.onBlur, disabled: disabled, ref: (function (btnEl) { return _this_1.buttonEl = btnEl; }) })));\r\n    };\r\n    Object.defineProperty(class_25.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_25, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"disabled\": [\"disabledChanged\"],\r\n                \"placeholder\": [\"disabledChanged\"],\r\n                \"value\": [\"valueChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_25, \"style\", {\r\n        get: function () { return \":host{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;font-family:var(--ion-font-family,inherit);overflow:hidden;z-index:2}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}:host(.in-item){position:static;max-width:45%}:host(.select-disabled){opacity:.4;pointer-events:none}:host(.ion-focused) button{border:2px solid #5e9ed6}.select-placeholder{color:currentColor;opacity:.33}button{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none}:host-context([dir=rtl]) button,[dir=rtl] button{left:unset;right:unset;right:0}button::-moz-focus-inner{border:0}.select-icon{position:relative}.select-text{-ms-flex:1;flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.select-icon-inner{left:5px;top:50%;margin-top:-3px;position:absolute;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:currentColor;opacity:.33;pointer-events:none}:host-context([dir=rtl]) .select-icon-inner,[dir=rtl] .select-icon-inner{left:unset;right:unset;right:5px}:host{--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:16px}.select-icon{width:12px;height:18px}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_25;\r\n}());\r\nvar getOptionValue = function (el) {\r\n    var value = el.value;\r\n    return (value === undefined)\r\n        ? el.textContent || ''\r\n        : value;\r\n};\r\nvar parseValue = function (value) {\r\n    if (value == null) {\r\n        return undefined;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.join(',');\r\n    }\r\n    return value.toString();\r\n};\r\nvar isOptionSelected = function (currentValue, compareValue, compareWith) {\r\n    if (currentValue === undefined) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(currentValue)) {\r\n        return currentValue.some(function (val) { return compareOptions(val, compareValue, compareWith); });\r\n    }\r\n    else {\r\n        return compareOptions(currentValue, compareValue, compareWith);\r\n    }\r\n};\r\nvar compareOptions = function (currentValue, compareValue, compareWith) {\r\n    if (typeof compareWith === 'function') {\r\n        return compareWith(currentValue, compareValue);\r\n    }\r\n    else if (typeof compareWith === 'string') {\r\n        return currentValue[compareWith] === compareValue[compareWith];\r\n    }\r\n    else {\r\n        return currentValue === compareValue;\r\n    }\r\n};\r\nvar generateText = function (opts, value, compareWith) {\r\n    if (value === undefined) {\r\n        return '';\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value\r\n            .map(function (v) { return textForValue(opts, v, compareWith); })\r\n            .filter(function (opt) { return opt !== null; })\r\n            .join(', ');\r\n    }\r\n    else {\r\n        return textForValue(opts, value, compareWith) || '';\r\n    }\r\n};\r\nvar textForValue = function (opts, value, compareWith) {\r\n    var selectOpt = opts.find(function (opt) {\r\n        return compareOptions(getOptionValue(opt), value, compareWith);\r\n    });\r\n    return selectOpt\r\n        ? selectOpt.textContent\r\n        : null;\r\n};\r\nvar selectIds = 0;\r\nvar SelectOption = /** @class */ (function () {\r\n    function class_26(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.inputId = \"ion-selopt-\" + selectOptionIds++;\r\n        /**\r\n         * If `true`, the user cannot interact with the select option.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * If `true`, the element is selected.\r\n         */\r\n        this.selected = false;\r\n    }\r\n    class_26.prototype.render = function () {\r\n        return (h(Host, { role: \"option\", id: this.inputId, class: getIonMode$1(this) }));\r\n    };\r\n    Object.defineProperty(class_26.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_26, \"style\", {\r\n        get: function () { return \":host{display:none}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_26;\r\n}());\r\nvar selectOptionIds = 0;\r\nvar Tab = /** @class */ (function () {\r\n    function class_27(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.loaded = false;\r\n        /** @internal */\r\n        this.active = false;\r\n    }\r\n    class_27.prototype.componentWillLoad = function () {\r\n    };\r\n    /** Set the active component for the tab */\r\n    class_27.prototype.setActive = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.prepareLazyLoaded()];\r\n                    case 1:\r\n                        _b.sent();\r\n                        this.active = true;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    class_27.prototype.prepareLazyLoaded = function () {\r\n        if (!this.loaded && this.component != null) {\r\n            this.loaded = true;\r\n            try {\r\n                return attachComponent(this.delegate, this.el, this.component, ['ion-page']);\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n        return Promise.resolve(undefined);\r\n    };\r\n    class_27.prototype.render = function () {\r\n        var _b = this, tab = _b.tab, active = _b.active, component = _b.component;\r\n        return (h(Host, { role: \"tabpanel\", \"aria-hidden\": !active ? 'true' : null, \"aria-labelledby\": \"tab-button-\" + tab, class: {\r\n                'ion-page': component === undefined,\r\n                'tab-hidden': !active\r\n            } }, h(\"slot\", null)));\r\n    };\r\n    Object.defineProperty(class_27.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_27, \"style\", {\r\n        get: function () { return \":host(.tab-hidden){display:none!important}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_27;\r\n}());\r\nvar TabBar = /** @class */ (function () {\r\n    function class_28(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.keyboardVisible = false;\r\n        /**\r\n         * If `true`, the tab bar will be translucent.\r\n         * Only applies when the mode is `\"ios\"` and the device supports\r\n         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\r\n         */\r\n        this.translucent = false;\r\n        this.ionTabBarChanged = createEvent(this, \"ionTabBarChanged\", 7);\r\n    }\r\n    class_28.prototype.selectedTabChanged = function () {\r\n        if (this.selectedTab !== undefined) {\r\n            this.ionTabBarChanged.emit({\r\n                tab: this.selectedTab\r\n            });\r\n        }\r\n    };\r\n    class_28.prototype.onKeyboardWillHide = function () {\r\n        var _this_1 = this;\r\n        setTimeout(function () { return _this_1.keyboardVisible = false; }, 50);\r\n    };\r\n    class_28.prototype.onKeyboardWillShow = function () {\r\n        if (this.el.getAttribute('slot') !== 'top') {\r\n            this.keyboardVisible = true;\r\n        }\r\n    };\r\n    class_28.prototype.componentWillLoad = function () {\r\n        this.selectedTabChanged();\r\n    };\r\n    class_28.prototype.render = function () {\r\n        var _b;\r\n        var _c = this, color = _c.color, translucent = _c.translucent, keyboardVisible = _c.keyboardVisible;\r\n        var mode = getIonMode$1(this);\r\n        return (h(Host, { role: \"tablist\", \"aria-hidden\": keyboardVisible ? 'true' : null, class: Object.assign(Object.assign({}, createColorClasses$1(color)), (_b = {}, _b[mode] = true, _b['tab-bar-translucent'] = translucent, _b['tab-bar-hidden'] = keyboardVisible, _b)) }, h(\"slot\", null)));\r\n    };\r\n    Object.defineProperty(class_28.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_28, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"selectedTab\": [\"selectedTabChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_28, \"style\", {\r\n        get: function () { return \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom,0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box!important;box-sizing:content-box!important}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb),.7);background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none!important}:host{--background:var(--ion-tab-bar-background,var(--ion-background-color,#fff));--background-focused:var(--ion-tab-bar-background-focused,#e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color,var(--ion-border-color,var(--ion-color-step-150,rgba(0,0,0,0.2))));--color:var(--ion-tab-bar-color,var(--ion-color-step-450,#8c8c8c));--color-selected:var(--ion-tab-bar-color-activated,var(--ion-color-primary,#3880ff));height:50px}\\@supports ((-webkit-backdrop-filter:blur(0)) or (backdrop-filter:blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb,255,255,255),0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb),.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb,255,255,255),.6)}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_28;\r\n}());\r\nvar TabButton = /** @class */ (function () {\r\n    function class_29(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        /**\r\n         * If `true`, the user cannot interact with the tab button.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The selected tab component\r\n         */\r\n        this.selected = false;\r\n        this.onKeyUp = function (ev) {\r\n            if (ev.key === 'Enter' || ev.key === ' ') {\r\n                _this_1.selectTab(ev);\r\n            }\r\n        };\r\n        this.onClick = function (ev) {\r\n            _this_1.selectTab(ev);\r\n        };\r\n        this.ionTabButtonClick = createEvent(this, \"ionTabButtonClick\", 7);\r\n    }\r\n    class_29.prototype.onTabBarChanged = function (ev) {\r\n        this.selected = this.tab === ev.detail.tab;\r\n    };\r\n    class_29.prototype.componentWillLoad = function () {\r\n        if (this.layout === undefined) {\r\n            this.layout = config.get('tabButtonLayout', 'icon-top');\r\n        }\r\n    };\r\n    class_29.prototype.selectTab = function (ev) {\r\n        if (this.tab !== undefined) {\r\n            if (!this.disabled) {\r\n                this.ionTabButtonClick.emit({\r\n                    tab: this.tab,\r\n                    href: this.href,\r\n                    selected: this.selected\r\n                });\r\n            }\r\n            ev.preventDefault();\r\n        }\r\n    };\r\n    Object.defineProperty(class_29.prototype, \"hasLabel\", {\r\n        get: function () {\r\n            return !!this.el.querySelector('ion-label');\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_29.prototype, \"hasIcon\", {\r\n        get: function () {\r\n            return !!this.el.querySelector('ion-icon');\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_29.prototype, \"tabIndex\", {\r\n        get: function () {\r\n            if (this.disabled) {\r\n                return -1;\r\n            }\r\n            var hasTabIndex = this.el.hasAttribute('tabindex');\r\n            if (hasTabIndex) {\r\n                return this.el.getAttribute('tabindex');\r\n            }\r\n            return 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    class_29.prototype.render = function () {\r\n        var _b;\r\n        var _c = this, disabled = _c.disabled, hasIcon = _c.hasIcon, hasLabel = _c.hasLabel, tabIndex = _c.tabIndex, href = _c.href, rel = _c.rel, target = _c.target, layout = _c.layout, selected = _c.selected, tab = _c.tab;\r\n        var mode = getIonMode$1(this);\r\n        var attrs = {\r\n            download: this.download,\r\n            href: href,\r\n            rel: rel,\r\n            target: target\r\n        };\r\n        return (h(Host, { onClick: this.onClick, onKeyup: this.onKeyUp, role: \"tab\", tabindex: tabIndex, \"aria-selected\": selected ? 'true' : null, id: tab !== undefined ? \"tab-button-\" + tab : null, class: (_b = {},\r\n                _b[mode] = true,\r\n                _b['tab-selected'] = selected,\r\n                _b['tab-disabled'] = disabled,\r\n                _b['tab-has-label'] = hasLabel,\r\n                _b['tab-has-icon'] = hasIcon,\r\n                _b['tab-has-label-only'] = hasLabel && !hasIcon,\r\n                _b['tab-has-icon-only'] = hasIcon && !hasLabel,\r\n                _b[\"tab-layout-\" + layout] = true,\r\n                _b['ion-activatable'] = true,\r\n                _b['ion-selectable'] = true,\r\n                _b['ion-focusable'] = true,\r\n                _b) }, h(\"a\", Object.assign({}, attrs, { tabIndex: -1 }), h(\"slot\", null), mode === 'md' && h(\"ion-ripple-effect\", { type: \"unbounded\" }))));\r\n    };\r\n    Object.defineProperty(class_29.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_29, \"style\", {\r\n        get: function () { return \":host{--ripple-color:var(--color-selected);-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;background:var(--background);color:var(--color)}:host,a{height:100%;outline:none}a{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;border:0;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){a{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}:host(.ion-focused){background:var(--background-focused)}\\@media (any-hover:hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none!important}:host(.tab-disabled){pointer-events:none;opacity:.4}::slotted(ion-icon),::slotted(ion-label){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon),:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}::slotted(ion-badge){padding-left:6px;padding-right:6px;padding-top:1px;padding-bottom:1px;left:calc(50% + 6px);top:4px;height:auto;font-size:12px;line-height:16px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}:host-context([dir=rtl]) ::slotted(ion-badge),[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-icon){margin-top:4px;font-size:30px}::slotted(ion-icon:before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-end) ::slotted(ion-badge),:host(.tab-layout-icon-start) ::slotted(ion-badge){left:calc(50% + 35px);top:10px}:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}:host(.tab-has-label-only) ::slotted(ion-badge),:host(.tab-layout-icon-hide) ::slotted(ion-badge){left:calc(50% + 30px);top:10px}:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}:host(.tab-has-icon-only) ::slotted(ion-badge),:host(.tab-layout-label-hide) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_29;\r\n}());\r\nvar Textarea = /** @class */ (function () {\r\n    function class_30(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.inputId = \"ion-input-\" + textareaIds++;\r\n        this.didBlurAfterEdit = false;\r\n        this.hasFocus = false;\r\n        /**\r\n         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.\r\n         */\r\n        this.autocapitalize = 'none';\r\n        /**\r\n         * This Boolean attribute lets you specify that a form control should have input focus when the page loads.\r\n         */\r\n        this.autofocus = false;\r\n        /**\r\n         * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `\"password\"`, `false` for all other types.\r\n         */\r\n        this.clearOnEdit = false;\r\n        /**\r\n         * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke.\r\n         */\r\n        this.debounce = 0;\r\n        /**\r\n         * If `true`, the user cannot interact with the textarea.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The name of the control, which is submitted with the form data.\r\n         */\r\n        this.name = this.inputId;\r\n        /**\r\n         * If `true`, the user cannot modify the value.\r\n         */\r\n        this.readonly = false;\r\n        /**\r\n         * If `true`, the user must fill in a value before submitting a form.\r\n         */\r\n        this.required = false;\r\n        /**\r\n         * If `true`, the element will have its spelling and grammar checked.\r\n         */\r\n        this.spellcheck = false;\r\n        /**\r\n         * If `true`, the element height will increase based on the value.\r\n         */\r\n        this.autoGrow = false;\r\n        /**\r\n         * The value of the textarea.\r\n         */\r\n        this.value = '';\r\n        this.onInput = function (ev) {\r\n            if (_this_1.nativeInput) {\r\n                _this_1.value = _this_1.nativeInput.value;\r\n            }\r\n            _this_1.emitStyle();\r\n            _this_1.ionInput.emit(ev);\r\n        };\r\n        this.onFocus = function () {\r\n            _this_1.hasFocus = true;\r\n            _this_1.focusChange();\r\n            _this_1.ionFocus.emit();\r\n        };\r\n        this.onBlur = function () {\r\n            _this_1.hasFocus = false;\r\n            _this_1.focusChange();\r\n            _this_1.ionBlur.emit();\r\n        };\r\n        this.onKeyDown = function () {\r\n            _this_1.checkClearOnEdit();\r\n        };\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionInput = createEvent(this, \"ionInput\", 7);\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n    }\r\n    class_30.prototype.debounceChanged = function () {\r\n        this.ionChange = debounceEvent(this.ionChange, this.debounce);\r\n    };\r\n    class_30.prototype.disabledChanged = function () {\r\n        this.emitStyle();\r\n    };\r\n    /**\r\n     * Update the native input element when the value changes\r\n     */\r\n    class_30.prototype.valueChanged = function () {\r\n        var nativeInput = this.nativeInput;\r\n        var value = this.getValue();\r\n        if (nativeInput && nativeInput.value !== value) {\r\n            nativeInput.value = value;\r\n        }\r\n        this.runAutoGrow();\r\n        this.emitStyle();\r\n        this.ionChange.emit({ value: value });\r\n    };\r\n    class_30.prototype.connectedCallback = function () {\r\n        this.emitStyle();\r\n        this.debounceChanged();\r\n        {\r\n            this.el.dispatchEvent(new CustomEvent('ionInputDidLoad', {\r\n                detail: this.el\r\n            }));\r\n        }\r\n    };\r\n    class_30.prototype.disconnectedCallback = function () {\r\n        {\r\n            document.dispatchEvent(new CustomEvent('ionInputDidUnload', {\r\n                detail: this.el\r\n            }));\r\n        }\r\n    };\r\n    class_30.prototype.componentDidLoad = function () {\r\n        this.runAutoGrow();\r\n    };\r\n    // TODO: performance hit, this cause layout thrashing\r\n    class_30.prototype.runAutoGrow = function () {\r\n        var nativeInput = this.nativeInput;\r\n        if (nativeInput && this.autoGrow) {\r\n            readTask(function () {\r\n                nativeInput.style.height = 'inherit';\r\n                nativeInput.style.height = nativeInput.scrollHeight + 'px';\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Sets focus on the specified `ion-textarea`. Use this method instead of the global\r\n     * `input.focus()`.\r\n     */\r\n    class_30.prototype.setFocus = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_b) {\r\n                if (this.nativeInput) {\r\n                    this.nativeInput.focus();\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Returns the native `<textarea>` element used under the hood.\r\n     */\r\n    class_30.prototype.getInputElement = function () {\r\n        return Promise.resolve(this.nativeInput);\r\n    };\r\n    class_30.prototype.emitStyle = function () {\r\n        this.ionStyle.emit({\r\n            'interactive': true,\r\n            'textarea': true,\r\n            'input': true,\r\n            'interactive-disabled': this.disabled,\r\n            'has-placeholder': this.placeholder != null,\r\n            'has-value': this.hasValue(),\r\n            'has-focus': this.hasFocus\r\n        });\r\n    };\r\n    /**\r\n     * Check if we need to clear the text input if clearOnEdit is enabled\r\n     */\r\n    class_30.prototype.checkClearOnEdit = function () {\r\n        if (!this.clearOnEdit) {\r\n            return;\r\n        }\r\n        // Did the input value change after it was blurred and edited?\r\n        if (this.didBlurAfterEdit && this.hasValue()) {\r\n            // Clear the input\r\n            this.value = '';\r\n        }\r\n        // Reset the flag\r\n        this.didBlurAfterEdit = false;\r\n    };\r\n    class_30.prototype.focusChange = function () {\r\n        // If clearOnEdit is enabled and the input blurred but has a value, set a flag\r\n        if (this.clearOnEdit && !this.hasFocus && this.hasValue()) {\r\n            this.didBlurAfterEdit = true;\r\n        }\r\n        this.emitStyle();\r\n    };\r\n    class_30.prototype.hasValue = function () {\r\n        return this.getValue() !== '';\r\n    };\r\n    class_30.prototype.getValue = function () {\r\n        return this.value || '';\r\n    };\r\n    class_30.prototype.render = function () {\r\n        var _b;\r\n        var _this_1 = this;\r\n        var mode = getIonMode$1(this);\r\n        var value = this.getValue();\r\n        var labelId = this.inputId + '-lbl';\r\n        var label = findItemLabel(this.el);\r\n        if (label) {\r\n            label.id = labelId;\r\n        }\r\n        return (h(Host, { \"aria-disabled\": this.disabled ? 'true' : null, class: Object.assign(Object.assign({}, createColorClasses$1(this.color)), (_b = {}, _b[mode] = true, _b)) }, h(\"textarea\", { class: \"native-textarea\", ref: function (el) { return _this_1.nativeInput = el; }, autoCapitalize: this.autocapitalize, autoFocus: this.autofocus, disabled: this.disabled, maxLength: this.maxlength, minLength: this.minlength, name: this.name, placeholder: this.placeholder || '', readOnly: this.readonly, required: this.required, spellCheck: this.spellcheck, cols: this.cols, rows: this.rows, wrap: this.wrap, onInput: this.onInput, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeyDown }, value)));\r\n    };\r\n    Object.defineProperty(class_30.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_30, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"debounce\": [\"debounceChanged\"],\r\n                \"disabled\": [\"disabledChanged\"],\r\n                \"value\": [\"valueChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_30, \"style\", {\r\n        get: function () { return \".sc-ion-textarea-ios-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--border-radius:0;display:block;position:relative;-ms-flex:1;flex:1;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;background:var(--background);color:var(--color);font-family:var(--ion-font-family,inherit);white-space:pre-wrap;z-index:2}.ion-color.sc-ion-textarea-ios-h{background:initial;color:var(--ion-color-base)}ion-item.sc-ion-textarea-ios-h, ion-item .sc-ion-textarea-ios-h{-ms-flex-item-align:baseline;align-self:baseline}ion-item.sc-ion-textarea-ios-h:not(.item-label), ion-item:not(.item-label) .sc-ion-textarea-ios-h{--padding-start:0}.native-textarea.sc-ion-textarea-ios{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;resize:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){.native-textarea.sc-ion-textarea-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-textarea.sc-ion-textarea-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea[disabled].sc-ion-textarea-ios{opacity:.4}.cloned-input.sc-ion-textarea-ios{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios, [dir=rtl] .sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios, [dir=rtl].sc-ion-textarea-ios .cloned-input.sc-ion-textarea-ios{left:unset;right:unset;right:0}.sc-ion-textarea-ios-h{--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:0;font-size:inherit}.item-label-floating.sc-ion-textarea-ios-h, .item-label-floating .sc-ion-textarea-ios-h, .item-label-stacked.sc-ion-textarea-ios-h, .item-label-stacked .sc-ion-textarea-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_30;\r\n}());\r\nvar textareaIds = 0;\r\nvar Toggle = /** @class */ (function () {\r\n    function class_31(hostRef) {\r\n        var _this_1 = this;\r\n        registerInstance(this, hostRef);\r\n        this.inputId = \"ion-tg-\" + toggleIds++;\r\n        this.lastDrag = 0;\r\n        this.activated = false;\r\n        /**\r\n         * The name of the control, which is submitted with the form data.\r\n         */\r\n        this.name = this.inputId;\r\n        /**\r\n         * If `true`, the toggle is selected.\r\n         */\r\n        this.checked = false;\r\n        /**\r\n         * If `true`, the user cannot interact with the toggle.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The value of the toggle does not mean if it's checked or not, use the `checked`\r\n         * property for that.\r\n         *\r\n         * The value of a toggle is analogous to the value of a `<input type=\"checkbox\">`,\r\n         * it's only used when the toggle participates in a native `<form>`.\r\n         */\r\n        this.value = 'on';\r\n        this.onClick = function () {\r\n            if (_this_1.lastDrag + 300 < Date.now()) {\r\n                _this_1.checked = !_this_1.checked;\r\n            }\r\n        };\r\n        this.onFocus = function () {\r\n            _this_1.ionFocus.emit();\r\n        };\r\n        this.onBlur = function () {\r\n            _this_1.ionBlur.emit();\r\n        };\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n        this.ionStyle = createEvent(this, \"ionStyle\", 7);\r\n    }\r\n    class_31.prototype.checkedChanged = function (isChecked) {\r\n        this.ionChange.emit({\r\n            checked: isChecked,\r\n            value: this.value\r\n        });\r\n    };\r\n    class_31.prototype.disabledChanged = function () {\r\n        this.emitStyle();\r\n        if (this.gesture) {\r\n            this.gesture.setDisabled(this.disabled);\r\n        }\r\n    };\r\n    class_31.prototype.connectedCallback = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _b;\r\n            var _this_1 = this;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        _b = this;\r\n                        return [4 /*yield*/, import('./index-14bae62d.js')];\r\n                    case 1:\r\n                        _b.gesture = (_c.sent()).createGesture({\r\n                            el: this.el,\r\n                            gestureName: 'toggle',\r\n                            gesturePriority: 100,\r\n                            threshold: 5,\r\n                            passive: false,\r\n                            onStart: function () { return _this_1.onStart(); },\r\n                            onMove: function (ev) { return _this_1.onMove(ev); },\r\n                            onEnd: function (ev) { return _this_1.onEnd(ev); },\r\n                        });\r\n                        this.disabledChanged();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    class_31.prototype.disconnectedCallback = function () {\r\n        if (this.gesture) {\r\n            this.gesture.destroy();\r\n            this.gesture = undefined;\r\n        }\r\n    };\r\n    class_31.prototype.componentWillLoad = function () {\r\n        this.emitStyle();\r\n    };\r\n    class_31.prototype.emitStyle = function () {\r\n        this.ionStyle.emit({\r\n            'interactive-disabled': this.disabled,\r\n        });\r\n    };\r\n    class_31.prototype.onStart = function () {\r\n        this.activated = true;\r\n        // touch-action does not work in iOS\r\n        this.setFocus();\r\n    };\r\n    class_31.prototype.onMove = function (detail) {\r\n        if (shouldToggle(document, this.checked, detail.deltaX, -10)) {\r\n            this.checked = !this.checked;\r\n            hapticSelection();\r\n        }\r\n    };\r\n    class_31.prototype.onEnd = function (ev) {\r\n        this.activated = false;\r\n        this.lastDrag = Date.now();\r\n        ev.event.preventDefault();\r\n        ev.event.stopImmediatePropagation();\r\n    };\r\n    class_31.prototype.getValue = function () {\r\n        return this.value || '';\r\n    };\r\n    class_31.prototype.setFocus = function () {\r\n        if (this.buttonEl) {\r\n            this.buttonEl.focus();\r\n        }\r\n    };\r\n    class_31.prototype.render = function () {\r\n        var _b;\r\n        var _this_1 = this;\r\n        var _c = this, inputId = _c.inputId, disabled = _c.disabled, checked = _c.checked, activated = _c.activated, color = _c.color, el = _c.el;\r\n        var mode = getIonMode$1(this);\r\n        var labelId = inputId + '-lbl';\r\n        var label = findItemLabel(el);\r\n        var value = this.getValue();\r\n        if (label) {\r\n            label.id = labelId;\r\n        }\r\n        renderHiddenInput(true, el, this.name, (checked ? value : ''), disabled);\r\n        return (h(Host, { onClick: this.onClick, role: \"checkbox\", \"aria-disabled\": disabled ? 'true' : null, \"aria-checked\": \"\" + checked, \"aria-labelledby\": labelId, class: Object.assign(Object.assign({}, createColorClasses$1(color)), (_b = {}, _b[mode] = true, _b['in-item'] = hostContext('ion-item', el), _b['toggle-activated'] = activated, _b['toggle-checked'] = checked, _b['toggle-disabled'] = disabled, _b['interactive'] = true, _b)) }, h(\"div\", { class: \"toggle-icon\" }, h(\"div\", { class: \"toggle-inner\" })), h(\"button\", { type: \"button\", onFocus: this.onFocus, onBlur: this.onBlur, disabled: disabled, ref: function (btnEl) { return _this_1.buttonEl = btnEl; } })));\r\n    };\r\n    Object.defineProperty(class_31.prototype, \"el\", {\r\n        get: function () { return getElement(this); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_31, \"watchers\", {\r\n        get: function () {\r\n            return {\r\n                \"checked\": [\"checkedChanged\"],\r\n                \"disabled\": [\"disabledChanged\"]\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(class_31, \"style\", {\r\n        get: function () { return \":host{-webkit-box-sizing:content-box!important;box-sizing:content-box!important;display:inline-block;outline:none;contain:content;cursor:pointer;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.ion-focused) input{border:2px solid #5e9ed6}:host(.toggle-disabled){pointer-events:none}button{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none}:host-context([dir=rtl]) button,[dir=rtl] button{left:unset;right:unset;right:0}button::-moz-focus-inner{border:0}:host{--background:rgba(var(--ion-text-color-rgb,0,0,0),0.088);--background-checked:var(--ion-color-primary,#3880ff);--handle-background:#fff;--handle-background-checked:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;position:relative;width:51px;height:32px;contain:strict}:host(.ion-color.toggle-checked) .toggle-icon{background:var(--ion-color-base)}.toggle-icon{border-radius:16px;display:block;position:relative;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-transition:background-color .3s;transition:background-color .3s;background:var(--background);overflow:hidden;pointer-events:none}.toggle-inner{left:2px;top:2px;border-radius:14px;position:absolute;width:28px;height:28px;-webkit-transition:width .12s ease-in-out 80ms,left .11s ease-in-out 80ms,right .11s ease-in-out 80ms,-webkit-transform .3s;transition:width .12s ease-in-out 80ms,left .11s ease-in-out 80ms,right .11s ease-in-out 80ms,-webkit-transform .3s;transition:transform .3s,width .12s ease-in-out 80ms,left .11s ease-in-out 80ms,right .11s ease-in-out 80ms;transition:transform .3s,width .12s ease-in-out 80ms,left .11s ease-in-out 80ms,right .11s ease-in-out 80ms,-webkit-transform .3s;background:var(--handle-background);-webkit-box-shadow:0 3px 12px rgba(0,0,0,.16),0 3px 1px rgba(0,0,0,.1);box-shadow:0 3px 12px rgba(0,0,0,.16),0 3px 1px rgba(0,0,0,.1);will-change:transform;contain:strict}:host-context([dir=rtl]) .toggle-inner,[dir=rtl] .toggle-inner{left:unset;right:unset;right:2px}:host(.toggle-checked) .toggle-icon{background:var(--background-checked)}:host(.toggle-activated) .toggle-icon:before,:host(.toggle-checked) .toggle-icon:before{-webkit-transform:scale3d(0,0,0);transform:scale3d(0,0,0)}:host(.toggle-checked) .toggle-inner{-webkit-transform:translate3d(19px,0,0);transform:translate3d(19px,0,0);background:var(--handle-background-checked)}:host-context([dir=rtl]).toggle-checked .toggle-inner,:host-context([dir=rtl]):host(.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(-1 * 19px),0,0);transform:translate3d(calc(-1 * 19px),0,0)}:host(.toggle-activated.toggle-checked) .toggle-inner:before{-webkit-transform:scale3d(0,0,0);transform:scale3d(0,0,0)}:host(.toggle-activated) .toggle-inner{width:34px}:host(.toggle-activated.toggle-checked) .toggle-inner{left:-4px}:host-context([dir=rtl]).toggle-activated.toggle-checked .toggle-inner,:host-context([dir=rtl]):host(.toggle-activated.toggle-checked) .toggle-inner{left:unset;right:unset;right:-4px}:host(.toggle-disabled){opacity:.3}:host(.in-item[slot]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:16px;padding-right:8px;padding-top:6px;padding-bottom:5px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host(.in-item[slot]){padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:8px;padding-inline-end:8px}}:host(.in-item[slot=start]){padding-left:0;padding-right:16px;padding-top:6px;padding-bottom:5px}\\@supports ((-webkit-margin-start:0) or (margin-inline-start:0)) or (-webkit-margin-start:0){:host(.in-item[slot=start]){padding-left:unset;padding-right:unset;-webkit-padding-start:0;padding-inline-start:0;-webkit-padding-end:16px;padding-inline-end:16px}}\"; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return class_31;\r\n}());\r\nvar shouldToggle = function (doc, checked, deltaX, margin) {\r\n    var isRTL = doc.dir === 'rtl';\r\n    if (checked) {\r\n        return (!isRTL && (margin > deltaX)) ||\r\n            (isRTL && (-margin < deltaX));\r\n    }\r\n    else {\r\n        return (!isRTL && (-margin < deltaX)) ||\r\n            (isRTL && (margin > deltaX));\r\n    }\r\n};\r\nvar toggleIds = 0;\r\nexport { AlAngleEditor as al_angle_editor, AlConsole as al_console, AlSettings as al_control_panel, AlEdgeEditor as al_edge_editor, AlGraphEditor as al_graph_editor, AlSettings$1 as al_graph_settings, AlNodeEditor as al_node_editor, AlNodeList as al_node_list, AlSettings$2 as al_settings, Tabs as al_tabs, AlUrlPicker as al_url_picker, AlSettings$3 as al_view_controls, Aleph as al_viewer, App as ion_app, Button as ion_button, Icon as ion_icon, Input as ion_input, Item as ion_item, ItemDivider as ion_item_divider, Label as ion_label, List as ion_list, ListHeader as ion_list_header, Range as ion_range, RippleEffect as ion_ripple_effect, Select as ion_select, SelectOption as ion_select_option, Tab as ion_tab, TabBar as ion_tab_bar, TabButton as ion_tab_button, Textarea as ion_textarea, Toggle as ion_toggle };\r\n"],"sourceRoot":""}