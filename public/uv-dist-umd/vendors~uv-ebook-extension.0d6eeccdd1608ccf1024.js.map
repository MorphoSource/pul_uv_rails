{"version":3,"sources":["webpack://UV/./node_modules/@universalviewer/uv-ebook-components/dist/esm-es5/core-2fe5e2de.js","webpack://UV/./node_modules/@universalviewer/uv-ebook-components/dist/esm-es5/loader.mjs","webpack://UV/./node_modules/@universalviewer/uv-ebook-components/dist/esm/polyfills/index.js","webpack://UV/./node_modules/@universalviewer/uv-ebook-components/loader/index.mjs"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,iBAAiB,SAAI,IAAI,SAAI;AAC7B,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,sBAAsB,SAAI,IAAI,SAAI;AAClC,iDAAiD,QAAQ;AACzD,wCAAwC,QAAQ;AAChD,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,EAAE;AACrC,uBAAuB,iCAAiC,EAAE;AAC1D,mDAAmD,uDAAuD,EAAE;AAC5G,mDAAmD,0DAA0D,EAAE;AAC/G;AACA;AACA;AACA;AACA,gEAAgE;AAChE,8BAA8B,gCAAgC;AAC9D,SAAS;AACT;AACA,eAAe;AACf;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,CAAC;AACD;AACA,iCAAiC,0BAA0B;AAC3D,yDAAyD,qEAAqE;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,wCAAwC,EAAE;AAC1G;AACA;AACA,6DAA6D,qCAAqC,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wLAIP,IAAI,cAAc,WAAgB,CAAC;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mCAAmC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6NAAyC;AACxD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,4EAA4E,EAAE;AAC9E;AACA;AACA,oEAAoE,UAAU,8CAA8C;AAC5H;AACA;AACA;AACA;AACA;AACA,qCAAqC,mNAAoC;AACzE;AACA;AACA;AACA;AACA,wEAAwE,UAAU,kCAAkC;AACpH;AACA,KAAK;AACL,CAAC,EAAE;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,yCAAyC,KAAK,iCAAiC;AAC9K;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uCAAuC,EAAE;AACrH,yEAAyE,uCAAuC,EAAE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAyD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sCAAsC,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAwE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0BAA0B,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAmD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAqD,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAA6C;AACzE,KAAK;AACL,wBAAwB,yCAAyC,aAAa,EAAE,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,sCAAsC;AACtC,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oDAAoD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,EAAE;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qDAAqD,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0CAA0C,EAAE;AACrF;AACA;AACA;AACA;AACA,qCAAqC,oCAAoC,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE,EAAE;AACT,uDAAuD,EAAE,sBAAsB,aAAa;AAC5F,4CAA4C,kBAAkB,UAAU,mBAAmB;AAC3F;AACA;AACA;AACA;AACA;AACA,4DAA4D,iCAAiC,EAAE;AAC/F;AACA;AACA,6BAA6B,gEAAgE,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC,sCAAsC;AACsD;;;;;;;;;;;;;AC9xC7H;AAAA;AAAA;AAAuE;AACvE;AACA,WAAW,2DAAQ;AACnB,QAAQ,2DAAa,iDAAiD,uSAAuS,2DAA2D,mDAAmD;AAC3d,KAAK;AACL;AACgC;;;;;;;;;;;;;ACNhC;AAAA;AAAO;AACP;;AAEA;;AAEA;AACA,kBAAkB,qLAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4LAAsB;AACxC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA,CAAC;;AAE8C;AACJ","file":"vendors~uv-ebook-extension.0d6eeccdd1608ccf1024.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nvar NAMESPACE = 'uv-ebook-components';\r\nvar queueCongestion = 0;\r\nvar queuePending = false;\r\nvar isSvgMode = false;\r\nvar win = window;\r\nvar doc = document;\r\nvar plt = {\r\n    $flags$: 0,\r\n    $resourcesUrl$: '',\r\n    jmp: function (h) { return h(); },\r\n    raf: function (h) { return requestAnimationFrame(h); },\r\n    ael: function (el, eventName, listener, opts) { return el.addEventListener(eventName, listener, opts); },\r\n    rel: function (el, eventName, listener, opts) { return el.removeEventListener(eventName, listener, opts); },\r\n};\r\nvar supportsListenerOptions = /*@__PURE__*/ (function () {\r\n    var supportsListenerOptions = false;\r\n    try {\r\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\r\n            get: function () { supportsListenerOptions = true; }\r\n        }));\r\n    }\r\n    catch (e) { }\r\n    return supportsListenerOptions;\r\n})();\r\nvar supportsConstructibleStylesheets = /*@__PURE__*/ (function () {\r\n    try {\r\n        new CSSStyleSheet();\r\n        return true;\r\n    }\r\n    catch (e) { }\r\n    return false;\r\n})();\r\nvar hostRefs = new WeakMap();\r\nvar getHostRef = function (ref) { return hostRefs.get(ref); };\r\nvar registerInstance = function (lazyInstance, hostRef) { return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef); };\r\nvar registerHost = function (elm) {\r\n    var hostRef = {\r\n        $flags$: 0,\r\n        $hostElement$: elm,\r\n        $instanceValues$: new Map()\r\n    };\r\n    {\r\n        hostRef.$onInstancePromise$ = new Promise(function (r) { return hostRef.$onInstanceResolve$ = r; });\r\n    }\r\n    {\r\n        hostRef.$onReadyPromise$ = new Promise(function (r) { return hostRef.$onReadyResolve$ = r; });\r\n        elm['s-p'] = [];\r\n        elm['s-rc'] = [];\r\n    }\r\n    return hostRefs.set(elm, hostRef);\r\n};\r\nvar isMemberInElement = function (elm, memberName) { return memberName in elm; };\r\nvar consoleError = function (e) { return console.error(e); };\r\nvar moduleCache = /*@__PURE__*/ new Map();\r\nvar loadModule = function (cmpMeta, hostRef, hmrVersionId) {\r\n    // loadModuleImport\r\n    var exportName = cmpMeta.$tagName$.replace(/-/g, '_');\r\n    var bundleId = (cmpMeta.$lazyBundleIds$);\r\n    var module = moduleCache.get(bundleId);\r\n    if (module) {\r\n        return module[exportName];\r\n    }\r\n    return import(\r\n    /* webpackInclude: /\\.entry\\.js$/ */\r\n    /* webpackExclude: /\\.system\\.entry\\.js$/ */\r\n    /* webpackMode: \"lazy\" */\r\n    \"./\" + bundleId + \".entry.js\" + '').then(function (importedModule) {\r\n        {\r\n            moduleCache.set(bundleId, importedModule);\r\n        }\r\n        return importedModule[exportName];\r\n    }, consoleError);\r\n};\r\nvar styles = new Map();\r\nvar queueDomReads = [];\r\nvar queueDomWrites = [];\r\nvar queueDomWritesLow = [];\r\nvar queueTask = function (queue, write) { return function (cb) {\r\n    queue.push(cb);\r\n    if (!queuePending) {\r\n        queuePending = true;\r\n        if (write && plt.$flags$ & 4 /* queueSync */) {\r\n            nextTick(flush);\r\n        }\r\n        else {\r\n            plt.raf(flush);\r\n        }\r\n    }\r\n}; };\r\nvar consume = function (queue) {\r\n    for (var i = 0; i < queue.length; i++) {\r\n        try {\r\n            queue[i](performance.now());\r\n        }\r\n        catch (e) {\r\n            consoleError(e);\r\n        }\r\n    }\r\n    queue.length = 0;\r\n};\r\nvar consumeTimeout = function (queue, timeout) {\r\n    var i = 0;\r\n    var ts = 0;\r\n    while (i < queue.length && (ts = performance.now()) < timeout) {\r\n        try {\r\n            queue[i++](ts);\r\n        }\r\n        catch (e) {\r\n            consoleError(e);\r\n        }\r\n    }\r\n    if (i === queue.length) {\r\n        queue.length = 0;\r\n    }\r\n    else if (i !== 0) {\r\n        queue.splice(0, i);\r\n    }\r\n};\r\nvar flush = function () {\r\n    queueCongestion++;\r\n    // always force a bunch of medium callbacks to run, but still have\r\n    // a throttle on how many can run in a certain time\r\n    // DOM READS!!!\r\n    consume(queueDomReads);\r\n    var timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\r\n        ? performance.now() + (10 * Math.ceil(queueCongestion * (1.0 / 22.0)))\r\n        : Infinity;\r\n    // DOM WRITES!!!\r\n    consumeTimeout(queueDomWrites, timeout);\r\n    consumeTimeout(queueDomWritesLow, timeout);\r\n    if (queueDomWrites.length > 0) {\r\n        queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);\r\n        queueDomWrites.length = 0;\r\n    }\r\n    if (queuePending = ((queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length) > 0)) {\r\n        // still more to do yet, but we've run out of time\r\n        // let's let this thing cool off and try again in the next tick\r\n        plt.raf(flush);\r\n    }\r\n    else {\r\n        queueCongestion = 0;\r\n    }\r\n};\r\nvar nextTick = /*@__PURE__*/ function (cb) { return Promise.resolve().then(cb); };\r\nvar writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\r\n/**\r\n * Default style mode id\r\n */\r\n/**\r\n * Reusable empty obj/array\r\n * Don't add values to these!!\r\n */\r\nvar EMPTY_OBJ = {};\r\nvar isComplexType = function (o) {\r\n    // https://jsperf.com/typeof-fn-object/5\r\n    o = typeof o;\r\n    return o === 'object' || o === 'function';\r\n};\r\nvar getDynamicImportFunction = function (namespace) {\r\n    return \"__sc_import_\" + namespace.replace(/\\s|-/g, '_');\r\n};\r\nvar patchEsm = function () {\r\n    // @ts-ignore\r\n    if (!(win.CSS && win.CSS.supports && win.CSS.supports('color', 'var(--c)'))) {\r\n        // @ts-ignore\r\n        return import('./css-shim-978387b1-1e75855f.js').then(function () {\r\n            plt.$cssShim$ = win.__stencil_cssshim;\r\n            if (plt.$cssShim$) {\r\n                return plt.$cssShim$.initShim();\r\n            }\r\n        });\r\n    }\r\n    return Promise.resolve();\r\n};\r\nvar patchBrowser = function () { return __awaiter(void 0, void 0, void 0, function () {\r\n    var importMeta, regex, scriptElm, opts, resourcesUrl;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                {\r\n                    plt.$cssShim$ = win.__stencil_cssshim;\r\n                }\r\n                importMeta = \"\";\r\n                regex = new RegExp(\"/\" + NAMESPACE + \"(\\\\.esm)?\\\\.js($|\\\\?|#)\");\r\n                scriptElm = Array.from(doc.querySelectorAll('script')).find(function (s) { return (regex.test(s.src) ||\r\n                    s.getAttribute('data-stencil-namespace') === NAMESPACE); });\r\n                opts = scriptElm['data-opts'];\r\n                if (!(importMeta !== '')) return [3 /*break*/, 1];\r\n                return [2 /*return*/, Object.assign(Object.assign({}, opts), { resourcesUrl: new URL('.', importMeta).href })];\r\n            case 1:\r\n                resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href));\r\n                patchDynamicImport(resourcesUrl.href);\r\n                if (!!window.customElements) return [3 /*break*/, 3];\r\n                // @ts-ignore\r\n                return [4 /*yield*/, import('./dom-96781eef-a2fb04dd.js')];\r\n            case 2:\r\n                // @ts-ignore\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3: return [2 /*return*/, Object.assign(Object.assign({}, opts), { resourcesUrl: resourcesUrl.href })];\r\n        }\r\n    });\r\n}); };\r\nvar patchDynamicImport = function (base) {\r\n    var importFunctionName = getDynamicImportFunction(NAMESPACE);\r\n    try {\r\n        // There is a caching issue in V8, that breaks using import() in Function\r\n        // By generating a random string, we can workaround it\r\n        // Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info\r\n        win[importFunctionName] = new Function('w', \"return import(w);//\" + Math.random());\r\n    }\r\n    catch (e) {\r\n        var moduleMap_1 = new Map();\r\n        win[importFunctionName] = function (src) {\r\n            var url = new URL(src, base).href;\r\n            var mod = moduleMap_1.get(url);\r\n            if (!mod) {\r\n                var script_1 = doc.createElement('script');\r\n                script_1.type = 'module';\r\n                script_1.src = URL.createObjectURL(new Blob([\"import * as m from '\" + url + \"'; window.\" + importFunctionName + \".m = m;\"], { type: 'application/javascript' }));\r\n                mod = new Promise(function (resolve) {\r\n                    script_1.onload = function () {\r\n                        resolve(win[importFunctionName].m);\r\n                        script_1.remove();\r\n                    };\r\n                });\r\n                moduleMap_1.set(url, mod);\r\n                doc.head.appendChild(script_1);\r\n            }\r\n            return mod;\r\n        };\r\n    }\r\n};\r\nvar parsePropertyValue = function (propValue, propType) {\r\n    // ensure this value is of the correct prop type\r\n    if (propValue != null && !isComplexType(propValue)) {\r\n        if (propType & 4 /* Boolean */) {\r\n            // per the HTML spec, any string value means it is a boolean true value\r\n            // but we'll cheat here and say that the string \"false\" is the boolean false\r\n            return (propValue === 'false' ? false : propValue === '' || !!propValue);\r\n        }\r\n        if (propType & 2 /* Number */) {\r\n            // force it to be a number\r\n            return parseFloat(propValue);\r\n        }\r\n        if (propType & 1 /* String */) {\r\n            // could have been passed as a number or boolean\r\n            // but we still want it as a string\r\n            return String(propValue);\r\n        }\r\n        // redundant return here for better minification\r\n        return propValue;\r\n    }\r\n    // not sure exactly what type we want\r\n    // so no need to change to a different type\r\n    return propValue;\r\n};\r\nvar HYDRATED_CLASS = 'hydrated';\r\nvar createTime = function (fnName, tagName) {\r\n    if (tagName === void 0) { tagName = ''; }\r\n    {\r\n        return function () { return; };\r\n    }\r\n};\r\nvar uniqueTime = function (key, measureText) {\r\n    {\r\n        return function () { return; };\r\n    }\r\n};\r\nvar rootAppliedStyles = new WeakMap();\r\nvar registerStyle = function (scopeId, cssText, allowCS) {\r\n    var style = styles.get(scopeId);\r\n    if (supportsConstructibleStylesheets && allowCS) {\r\n        style = (style || new CSSStyleSheet());\r\n        style.replace(cssText);\r\n    }\r\n    else {\r\n        style = cssText;\r\n    }\r\n    styles.set(scopeId, style);\r\n};\r\nvar addStyle = function (styleContainerNode, cmpMeta, mode, hostElm) {\r\n    var scopeId = getScopeId(cmpMeta.$tagName$);\r\n    var style = styles.get(scopeId);\r\n    // if an element is NOT connected then getRootNode() will return the wrong root node\r\n    // so the fallback is to always use the document for the root node in those cases\r\n    styleContainerNode = (styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc);\r\n    if (style) {\r\n        if (typeof style === 'string') {\r\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\r\n            var appliedStyles = rootAppliedStyles.get(styleContainerNode);\r\n            var styleElm = void 0;\r\n            if (!appliedStyles) {\r\n                rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\r\n            }\r\n            if (!appliedStyles.has(scopeId)) {\r\n                {\r\n                    if (plt.$cssShim$) {\r\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\r\n                        var newScopeId = styleElm['s-sc'];\r\n                        if (newScopeId) {\r\n                            scopeId = newScopeId;\r\n                            // we don't want to add this styleID to the appliedStyles Set\r\n                            // since the cssVarShim might need to apply several different\r\n                            // stylesheets for the same component\r\n                            appliedStyles = null;\r\n                        }\r\n                    }\r\n                    else {\r\n                        styleElm = doc.createElement('style');\r\n                        styleElm.innerHTML = style;\r\n                    }\r\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\r\n                }\r\n                if (appliedStyles) {\r\n                    appliedStyles.add(scopeId);\r\n                }\r\n            }\r\n        }\r\n        else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\r\n            styleContainerNode.adoptedStyleSheets = __spreadArrays(styleContainerNode.adoptedStyleSheets, [\r\n                style\r\n            ]);\r\n        }\r\n    }\r\n    return scopeId;\r\n};\r\nvar attachStyles = function (elm, cmpMeta, mode) {\r\n    var endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\r\n    var scopeId = addStyle(elm.getRootNode(), cmpMeta, mode, elm);\r\n    endAttachStyles();\r\n};\r\nvar getScopeId = function (tagName, mode) { return 'sc-' + (tagName); };\r\n/**\r\n * Production h() function based on Preact by\r\n * Jason Miller (@developit)\r\n * Licensed under the MIT License\r\n * https://github.com/developit/preact/blob/master/LICENSE\r\n *\r\n * Modified for Stencil's compiler and vdom\r\n */\r\n// const stack: any[] = [];\r\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\r\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\r\nvar h = function (nodeName, vnodeData) {\r\n    var children = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        children[_i - 2] = arguments[_i];\r\n    }\r\n    var child = null;\r\n    var simple = false;\r\n    var lastSimple = false;\r\n    var vNodeChildren = [];\r\n    var walk = function (c) {\r\n        for (var i = 0; i < c.length; i++) {\r\n            child = c[i];\r\n            if (Array.isArray(child)) {\r\n                walk(child);\r\n            }\r\n            else if (child != null && typeof child !== 'boolean') {\r\n                if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\r\n                    child = String(child);\r\n                }\r\n                if (simple && lastSimple) {\r\n                    // If the previous child was simple (string), we merge both\r\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\r\n                }\r\n                else {\r\n                    // Append a new vNode, if it's text, we create a text vNode\r\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\r\n                }\r\n                lastSimple = simple;\r\n            }\r\n        }\r\n    };\r\n    walk(children);\r\n    if (vnodeData) {\r\n        {\r\n            var classData_1 = vnodeData.className || vnodeData.class;\r\n            if (classData_1) {\r\n                vnodeData.class = typeof classData_1 !== 'object'\r\n                    ? classData_1\r\n                    : Object.keys(classData_1)\r\n                        .filter(function (k) { return classData_1[k]; })\r\n                        .join(' ');\r\n            }\r\n        }\r\n    }\r\n    var vnode = newVNode(nodeName, null);\r\n    vnode.$attrs$ = vnodeData;\r\n    if (vNodeChildren.length > 0) {\r\n        vnode.$children$ = vNodeChildren;\r\n    }\r\n    return vnode;\r\n};\r\nvar newVNode = function (tag, text) {\r\n    var vnode = {\r\n        $flags$: 0,\r\n        $tag$: tag,\r\n        $text$: text,\r\n        $elm$: null,\r\n        $children$: null\r\n    };\r\n    {\r\n        vnode.$attrs$ = null;\r\n    }\r\n    return vnode;\r\n};\r\nvar Host = {};\r\nvar isHost = function (node) { return node && node.$tag$ === Host; };\r\n/**\r\n * Production setAccessor() function based on Preact by\r\n * Jason Miller (@developit)\r\n * Licensed under the MIT License\r\n * https://github.com/developit/preact/blob/master/LICENSE\r\n *\r\n * Modified for Stencil's compiler and vdom\r\n */\r\nvar setAccessor = function (elm, memberName, oldValue, newValue, isSvg, flags) {\r\n    if (oldValue === newValue) {\r\n        return;\r\n    }\r\n    var isProp = isMemberInElement(elm, memberName);\r\n    var ln = memberName.toLowerCase();\r\n    if (memberName === 'class') {\r\n        var classList = elm.classList;\r\n        var oldClasses_1 = parseClassList(oldValue);\r\n        var newClasses_1 = parseClassList(newValue);\r\n        classList.remove.apply(classList, oldClasses_1.filter(function (c) { return c && !newClasses_1.includes(c); }));\r\n        classList.add.apply(classList, newClasses_1.filter(function (c) { return c && !oldClasses_1.includes(c); }));\r\n    }\r\n    else if (memberName === 'ref') {\r\n        // minifier will clean this up\r\n        if (newValue) {\r\n            newValue(elm);\r\n        }\r\n    }\r\n    else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {\r\n        // Event Handlers\r\n        // so if the member name starts with \"on\" and the 3rd characters is\r\n        // a capital letter, and it's not already a member on the element,\r\n        // then we're assuming it's an event listener\r\n        if (memberName[2] === '-') {\r\n            // on- prefixed events\r\n            // allows to be explicit about the dom event to listen without any magic\r\n            // under the hood:\r\n            // <my-cmp on-click> // listens for \"click\"\r\n            // <my-cmp on-Click> // listens for \"Click\"\r\n            // <my-cmp on-ionChange> // listens for \"ionChange\"\r\n            // <my-cmp on-EVENTS> // listens for \"EVENTS\"\r\n            memberName = memberName.slice(3);\r\n        }\r\n        else if (isMemberInElement(win, ln)) {\r\n            // standard event\r\n            // the JSX attribute could have been \"onMouseOver\" and the\r\n            // member name \"onmouseover\" is on the window's prototype\r\n            // so let's add the listener \"mouseover\", which is all lowercased\r\n            memberName = ln.slice(2);\r\n        }\r\n        else {\r\n            // custom event\r\n            // the JSX attribute could have been \"onMyCustomEvent\"\r\n            // so let's trim off the \"on\" prefix and lowercase the first character\r\n            // and add the listener \"myCustomEvent\"\r\n            // except for the first character, we keep the event name case\r\n            memberName = ln[2] + memberName.slice(3);\r\n        }\r\n        if (oldValue) {\r\n            plt.rel(elm, memberName, oldValue, false);\r\n        }\r\n        if (newValue) {\r\n            plt.ael(elm, memberName, newValue, false);\r\n        }\r\n    }\r\n    else {\r\n        // Set property if it exists and it's not a SVG\r\n        var isComplex = isComplexType(newValue);\r\n        if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\r\n            try {\r\n                if (!elm.tagName.includes('-')) {\r\n                    var n = newValue == null ? '' : newValue;\r\n                    // Workaround for Safari, moving the <input> caret when re-assigning the same valued\r\n                    if (memberName === 'list') {\r\n                        isProp = false;\r\n                        // tslint:disable-next-line: triple-equals\r\n                    }\r\n                    else if (oldValue == null || elm[memberName] != n) {\r\n                        elm[memberName] = n;\r\n                    }\r\n                }\r\n                else {\r\n                    elm[memberName] = newValue;\r\n                }\r\n            }\r\n            catch (e) { }\r\n        }\r\n        if (newValue == null || newValue === false) {\r\n            {\r\n                elm.removeAttribute(memberName);\r\n            }\r\n        }\r\n        else if ((!isProp || (flags & 4 /* isHost */) || isSvg) && !isComplex) {\r\n            newValue = newValue === true ? '' : newValue;\r\n            {\r\n                elm.setAttribute(memberName, newValue);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar parseClassListRegex = /\\s/;\r\nvar parseClassList = function (value) { return (!value) ? [] : value.split(parseClassListRegex); };\r\nvar updateElement = function (oldVnode, newVnode, isSvgMode, memberName) {\r\n    // if the element passed in is a shadow root, which is a document fragment\r\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\r\n    // if it's not a shadow root, then we add attrs/props to the same element\r\n    var elm = (newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host) ? newVnode.$elm$.host : newVnode.$elm$;\r\n    var oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\r\n    var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\r\n    {\r\n        // remove attributes no longer present on the vnode by setting them to undefined\r\n        for (memberName in oldVnodeAttrs) {\r\n            if (!(memberName in newVnodeAttrs)) {\r\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\r\n            }\r\n        }\r\n    }\r\n    // add new & update changed attributes\r\n    for (memberName in newVnodeAttrs) {\r\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\r\n    }\r\n};\r\nvar createElm = function (oldParentVNode, newParentVNode, childIndex, parentElm) {\r\n    // tslint:disable-next-line: prefer-const\r\n    var newVNode = newParentVNode.$children$[childIndex];\r\n    var i = 0;\r\n    var elm;\r\n    var childNode;\r\n    if (newVNode.$text$ !== null) {\r\n        // create text node\r\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\r\n    }\r\n    else {\r\n        // create element\r\n        elm = newVNode.$elm$ = (doc.createElement(newVNode.$tag$));\r\n        // add css classes, attrs, props, listeners, etc.\r\n        {\r\n            updateElement(null, newVNode, isSvgMode);\r\n        }\r\n        if (newVNode.$children$) {\r\n            for (i = 0; i < newVNode.$children$.length; ++i) {\r\n                // create the node\r\n                childNode = createElm(oldParentVNode, newVNode, i);\r\n                // return node could have been null\r\n                if (childNode) {\r\n                    // append our new node\r\n                    elm.appendChild(childNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return elm;\r\n};\r\nvar addVnodes = function (parentElm, before, parentVNode, vnodes, startIdx, endIdx) {\r\n    var containerElm = (parentElm);\r\n    var childNode;\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n        if (vnodes[startIdx]) {\r\n            childNode = createElm(null, parentVNode, startIdx);\r\n            if (childNode) {\r\n                vnodes[startIdx].$elm$ = childNode;\r\n                containerElm.insertBefore(childNode, before);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar removeVnodes = function (vnodes, startIdx, endIdx, vnode, elm) {\r\n    for (; startIdx <= endIdx; ++startIdx) {\r\n        if (vnode = vnodes[startIdx]) {\r\n            elm = vnode.$elm$;\r\n            callNodeRefs(vnode);\r\n            // remove the vnode's element from the dom\r\n            elm.remove();\r\n        }\r\n    }\r\n};\r\nvar updateChildren = function (parentElm, oldCh, newVNode, newCh) {\r\n    var oldStartIdx = 0;\r\n    var newStartIdx = 0;\r\n    var oldEndIdx = oldCh.length - 1;\r\n    var oldStartVnode = oldCh[0];\r\n    var oldEndVnode = oldCh[oldEndIdx];\r\n    var newEndIdx = newCh.length - 1;\r\n    var newStartVnode = newCh[0];\r\n    var newEndVnode = newCh[newEndIdx];\r\n    var node;\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n        if (oldStartVnode == null) {\r\n            // Vnode might have been moved left\r\n            oldStartVnode = oldCh[++oldStartIdx];\r\n        }\r\n        else if (oldEndVnode == null) {\r\n            oldEndVnode = oldCh[--oldEndIdx];\r\n        }\r\n        else if (newStartVnode == null) {\r\n            newStartVnode = newCh[++newStartIdx];\r\n        }\r\n        else if (newEndVnode == null) {\r\n            newEndVnode = newCh[--newEndIdx];\r\n        }\r\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\r\n            patch(oldStartVnode, newStartVnode);\r\n            oldStartVnode = oldCh[++oldStartIdx];\r\n            newStartVnode = newCh[++newStartIdx];\r\n        }\r\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\r\n            patch(oldEndVnode, newEndVnode);\r\n            oldEndVnode = oldCh[--oldEndIdx];\r\n            newEndVnode = newCh[--newEndIdx];\r\n        }\r\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\r\n            patch(oldStartVnode, newEndVnode);\r\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\r\n            oldStartVnode = oldCh[++oldStartIdx];\r\n            newEndVnode = newCh[--newEndIdx];\r\n        }\r\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\r\n            patch(oldEndVnode, newStartVnode);\r\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\r\n            oldEndVnode = oldCh[--oldEndIdx];\r\n            newStartVnode = newCh[++newStartIdx];\r\n        }\r\n        else {\r\n            {\r\n                // new element\r\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            if (node) {\r\n                {\r\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (oldStartIdx > oldEndIdx) {\r\n        addVnodes(parentElm, (newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$), newVNode, newCh, newStartIdx, newEndIdx);\r\n    }\r\n    else if (newStartIdx > newEndIdx) {\r\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\r\n    }\r\n};\r\nvar isSameVnode = function (vnode1, vnode2) {\r\n    // compare if two vnode to see if they're \"technically\" the same\r\n    // need to have the same element tag, and same key to be the same\r\n    if (vnode1.$tag$ === vnode2.$tag$) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nvar patch = function (oldVNode, newVNode) {\r\n    var elm = newVNode.$elm$ = oldVNode.$elm$;\r\n    var oldChildren = oldVNode.$children$;\r\n    var newChildren = newVNode.$children$;\r\n    if (newVNode.$text$ === null) {\r\n        // element node\r\n        {\r\n            {\r\n                // either this is the first render of an element OR it's an update\r\n                // AND we already know it's possible it could have changed\r\n                // this updates the element's css classes, attrs, props, listeners, etc.\r\n                updateElement(oldVNode, newVNode, isSvgMode);\r\n            }\r\n        }\r\n        if (oldChildren !== null && newChildren !== null) {\r\n            // looks like there's child vnodes for both the old and new vnodes\r\n            updateChildren(elm, oldChildren, newVNode, newChildren);\r\n        }\r\n        else if (newChildren !== null) {\r\n            // no old child vnodes, but there are new child vnodes to add\r\n            if (oldVNode.$text$ !== null) {\r\n                // the old vnode was text, so be sure to clear it out\r\n                elm.textContent = '';\r\n            }\r\n            // add the new vnode children\r\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\r\n        }\r\n        else if (oldChildren !== null) {\r\n            // no new child vnodes, but there are old child vnodes to remove\r\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\r\n        }\r\n    }\r\n    else if (oldVNode.$text$ !== newVNode.$text$) {\r\n        // update the text content for the text only vnode\r\n        // and also only if the text is different than before\r\n        elm.data = newVNode.$text$;\r\n    }\r\n};\r\nvar callNodeRefs = function (vNode) {\r\n    {\r\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\r\n        vNode.$children$ && vNode.$children$.forEach(callNodeRefs);\r\n    }\r\n};\r\nvar renderVdom = function (hostElm, hostRef, cmpMeta, renderFnResults) {\r\n    var oldVNode = hostRef.$vnode$ || newVNode(null, null);\r\n    var rootVnode = isHost(renderFnResults)\r\n        ? renderFnResults\r\n        : h(null, null, renderFnResults);\r\n    rootVnode.$tag$ = null;\r\n    rootVnode.$flags$ |= 4 /* isHost */;\r\n    hostRef.$vnode$ = rootVnode;\r\n    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm);\r\n    // synchronous patch\r\n    patch(oldVNode, rootVnode);\r\n};\r\nvar attachToAncestor = function (hostRef, ancestorComponent) {\r\n    if (ancestorComponent && !hostRef.$onRenderResolve$) {\r\n        ancestorComponent['s-p'].push(new Promise(function (r) { return hostRef.$onRenderResolve$ = r; }));\r\n    }\r\n};\r\nvar scheduleUpdate = function (elm, hostRef, cmpMeta, isInitialLoad) {\r\n    {\r\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\r\n    }\r\n    if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\r\n        hostRef.$flags$ |= 512 /* needsRerender */;\r\n        return;\r\n    }\r\n    var endSchedule = createTime('scheduleUpdate', cmpMeta.$tagName$);\r\n    var ancestorComponent = hostRef.$ancestorComponent$;\r\n    var instance = hostRef.$lazyInstance$;\r\n    var update = function () { return updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad); };\r\n    attachToAncestor(hostRef, ancestorComponent);\r\n    var promise;\r\n    if (isInitialLoad) {\r\n        {\r\n            hostRef.$flags$ |= 256 /* isListenReady */;\r\n            if (hostRef.$queuedListeners$) {\r\n                hostRef.$queuedListeners$.forEach(function (_a) {\r\n                    var methodName = _a[0], event = _a[1];\r\n                    return safeCall(instance, methodName, event);\r\n                });\r\n                hostRef.$queuedListeners$ = null;\r\n            }\r\n        }\r\n    }\r\n    endSchedule();\r\n    // there is no ancestorc omponent or the ancestor component\r\n    // has already fired off its lifecycle update then\r\n    // fire off the initial update\r\n    return then(promise, function () { return writeTask(update); });\r\n};\r\nvar updateComponent = function (elm, hostRef, cmpMeta, instance, isInitialLoad) {\r\n    // updateComponent\r\n    var endUpdate = createTime('update', cmpMeta.$tagName$);\r\n    var rc = elm['s-rc'];\r\n    if (isInitialLoad) {\r\n        // DOM WRITE!\r\n        attachStyles(elm, cmpMeta, hostRef.$modeName$);\r\n    }\r\n    var endRender = createTime('render', cmpMeta.$tagName$);\r\n    {\r\n        {\r\n            try {\r\n                // looks like we've got child nodes to render into this host element\r\n                // or we need to update the css class/attrs on the host element\r\n                // DOM WRITE!\r\n                renderVdom(elm, hostRef, cmpMeta, instance.render());\r\n            }\r\n            catch (e) {\r\n                consoleError(e);\r\n            }\r\n        }\r\n    }\r\n    if (plt.$cssShim$) {\r\n        plt.$cssShim$.updateHost(elm);\r\n    }\r\n    {\r\n        hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\r\n    }\r\n    {\r\n        hostRef.$flags$ |= 2 /* hasRendered */;\r\n    }\r\n    if (rc) {\r\n        // ok, so turns out there are some child host elements\r\n        // waiting on this parent element to load\r\n        // let's fire off all update callbacks waiting\r\n        rc.forEach(function (cb) { return cb(); });\r\n        elm['s-rc'] = undefined;\r\n    }\r\n    endRender();\r\n    endUpdate();\r\n    {\r\n        var childrenPromises = elm['s-p'];\r\n        var postUpdate = function () { return postUpdateComponent(elm, hostRef, cmpMeta); };\r\n        if (childrenPromises.length === 0) {\r\n            postUpdate();\r\n        }\r\n        else {\r\n            Promise.all(childrenPromises).then(postUpdate);\r\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\r\n            childrenPromises.length = 0;\r\n        }\r\n    }\r\n};\r\nvar postUpdateComponent = function (elm, hostRef, cmpMeta) {\r\n    var endPostUpdate = createTime('postUpdate', cmpMeta.$tagName$);\r\n    var instance = hostRef.$lazyInstance$;\r\n    var ancestorComponent = hostRef.$ancestorComponent$;\r\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\r\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\r\n        {\r\n            // DOM WRITE!\r\n            // add the css class that this element has officially hydrated\r\n            elm.classList.add(HYDRATED_CLASS);\r\n        }\r\n        endPostUpdate();\r\n        {\r\n            hostRef.$onReadyResolve$(elm);\r\n            if (!ancestorComponent) {\r\n                appDidLoad();\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        {\r\n            safeCall(instance, 'componentDidUpdate');\r\n        }\r\n        endPostUpdate();\r\n    }\r\n    {\r\n        hostRef.$onInstanceResolve$(elm);\r\n    }\r\n    // load events fire from bottom to top\r\n    // the deepest elements load first then bubbles up\r\n    {\r\n        if (hostRef.$onRenderResolve$) {\r\n            hostRef.$onRenderResolve$();\r\n            hostRef.$onRenderResolve$ = undefined;\r\n        }\r\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\r\n            nextTick(function () { return scheduleUpdate(elm, hostRef, cmpMeta, false); });\r\n        }\r\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\r\n    }\r\n    // ( •_•)\r\n    // ( •_•)>⌐■-■\r\n    // (⌐■_■)\r\n};\r\nvar forceUpdate = function (elm, cmpMeta) {\r\n    {\r\n        var hostRef = getHostRef(elm);\r\n        if ((hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\r\n            scheduleUpdate(elm, hostRef, cmpMeta, false);\r\n        }\r\n    }\r\n};\r\nvar appDidLoad = function (who) {\r\n    // on appload\r\n    // we have finish the first big initial render\r\n    {\r\n        doc.documentElement.classList.add(HYDRATED_CLASS);\r\n    }\r\n    {\r\n        plt.$flags$ |= 2 /* appLoaded */;\r\n    }\r\n};\r\nvar safeCall = function (instance, method, arg) {\r\n    if (instance && instance[method]) {\r\n        try {\r\n            return instance[method](arg);\r\n        }\r\n        catch (e) {\r\n            consoleError(e);\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\nvar then = function (promise, thenFn) {\r\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\r\n};\r\nvar getValue = function (ref, propName) { return getHostRef(ref).$instanceValues$.get(propName); };\r\nvar setValue = function (ref, propName, newVal, cmpMeta) {\r\n    // check our new property value against our internal value\r\n    var hostRef = getHostRef(ref);\r\n    var elm = hostRef.$hostElement$;\r\n    var oldVal = hostRef.$instanceValues$.get(propName);\r\n    var flags = hostRef.$flags$;\r\n    var instance = hostRef.$lazyInstance$;\r\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\r\n    if (newVal !== oldVal && (!(flags & 8 /* isConstructingInstance */) || oldVal === undefined)) {\r\n        // gadzooks! the property's value has changed!!\r\n        // set our new value!\r\n        hostRef.$instanceValues$.set(propName, newVal);\r\n        if (instance) {\r\n            if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\r\n                // looks like this value actually changed, so we've got work to do!\r\n                // but only if we've already rendered, otherwise just chill out\r\n                // queue that we need to do an update, but don't worry about queuing\r\n                // up millions cuz this function ensures it only runs once\r\n                scheduleUpdate(elm, hostRef, cmpMeta, false);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar proxyComponent = function (Cstr, cmpMeta, flags) {\r\n    if (cmpMeta.$members$) {\r\n        // It's better to have a const than two Object.entries()\r\n        var members = Object.entries(cmpMeta.$members$);\r\n        var prototype_1 = Cstr.prototype;\r\n        members.forEach(function (_a) {\r\n            var memberName = _a[0], memberFlags = _a[1][0];\r\n            if (((memberFlags & 31 /* Prop */) ||\r\n                ((flags & 2 /* proxyState */) &&\r\n                    (memberFlags & 32 /* State */)))) {\r\n                // proxyComponent - prop\r\n                Object.defineProperty(prototype_1, memberName, {\r\n                    get: function () {\r\n                        // proxyComponent, get value\r\n                        return getValue(this, memberName);\r\n                    },\r\n                    set: function (newValue) {\r\n                        // proxyComponent, set value\r\n                        setValue(this, memberName, newValue, cmpMeta);\r\n                    },\r\n                    configurable: true,\r\n                    enumerable: true\r\n                });\r\n            }\r\n            else if ((flags & 1 /* isElementConstructor */) && (memberFlags & 64 /* Method */)) {\r\n                // proxyComponent - method\r\n                Object.defineProperty(prototype_1, memberName, {\r\n                    value: function () {\r\n                        var args = [];\r\n                        for (var _i = 0; _i < arguments.length; _i++) {\r\n                            args[_i] = arguments[_i];\r\n                        }\r\n                        var ref = getHostRef(this);\r\n                        return ref.$onInstancePromise$.then(function () {\r\n                            var _a;\r\n                            return (_a = ref.$lazyInstance$)[memberName].apply(_a, args);\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        if ((flags & 1 /* isElementConstructor */)) {\r\n            var attrNameToPropName_1 = new Map();\r\n            prototype_1.attributeChangedCallback = function (attrName, _oldValue, newValue) {\r\n                var _this = this;\r\n                plt.jmp(function () {\r\n                    var propName = attrNameToPropName_1.get(attrName);\r\n                    _this[propName] = newValue === null && typeof _this[propName] === 'boolean'\r\n                        ? false\r\n                        : newValue;\r\n                });\r\n            };\r\n            // create an array of attributes to observe\r\n            // and also create a map of html attribute name to js property name\r\n            Cstr.observedAttributes = members\r\n                .filter(function (_a) {\r\n                var _ = _a[0], m = _a[1];\r\n                return m[0] & 15;\r\n            } /* HasAttribute */) // filter to only keep props that should match attributes\r\n                .map(function (_a) {\r\n                var propName = _a[0], m = _a[1];\r\n                var attrName = m[1] || propName;\r\n                attrNameToPropName_1.set(attrName, propName);\r\n                return attrName;\r\n            });\r\n        }\r\n    }\r\n    return Cstr;\r\n};\r\nvar addEventListeners = function (elm, hostRef, listeners) {\r\n    hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || [];\r\n    var removeFns = listeners.map(function (_a) {\r\n        var flags = _a[0], name = _a[1], method = _a[2];\r\n        var target = (getHostListenerTarget(elm, flags));\r\n        var handler = hostListenerProxy(hostRef, method);\r\n        var opts = hostListenerOpts(flags);\r\n        plt.ael(target, name, handler, opts);\r\n        return function () { return plt.rel(target, name, handler, opts); };\r\n    });\r\n    return function () { return removeFns.forEach(function (fn) { return fn(); }); };\r\n};\r\nvar hostListenerProxy = function (hostRef, methodName) {\r\n    return function (ev) {\r\n        {\r\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\r\n                // instance is ready, let's call it's member method for this event\r\n                hostRef.$lazyInstance$[methodName](ev);\r\n            }\r\n            else {\r\n                hostRef.$queuedListeners$.push([methodName, ev]);\r\n            }\r\n        }\r\n    };\r\n};\r\nvar getHostListenerTarget = function (elm, flags) {\r\n    if (flags & 8 /* TargetWindow */)\r\n        return win;\r\n    return elm;\r\n};\r\nvar hostListenerOpts = function (flags) { return supportsListenerOptions ?\r\n    {\r\n        'passive': (flags & 1 /* Passive */) !== 0,\r\n        'capture': (flags & 2 /* Capture */) !== 0,\r\n    }\r\n    : (flags & 2 /* Capture */) !== 0; };\r\nvar initializeComponent = function (elm, hostRef, cmpMeta, hmrVersionId, Cstr) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var endLoad, endNewInstance, scopeId, endRegisterStyles, style, ancestorComponent, schedule;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0)) return [3 /*break*/, 3];\r\n                // we haven't initialized this element yet\r\n                hostRef.$flags$ |= 32 /* hasInitializedComponent */;\r\n                // lazy loaded components\r\n                // request the component's implementation to be\r\n                // wired up with the host element\r\n                Cstr = loadModule(cmpMeta);\r\n                if (!Cstr.then) return [3 /*break*/, 2];\r\n                endLoad = uniqueTime();\r\n                return [4 /*yield*/, Cstr];\r\n            case 1:\r\n                Cstr = _a.sent();\r\n                endLoad();\r\n                _a.label = 2;\r\n            case 2:\r\n                if (!Cstr.isProxied) {\r\n                    proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\r\n                    Cstr.isProxied = true;\r\n                }\r\n                endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\r\n                // ok, time to construct the instance\r\n                // but let's keep track of when we start and stop\r\n                // so that the getters/setters don't incorrectly step on data\r\n                {\r\n                    hostRef.$flags$ |= 8 /* isConstructingInstance */;\r\n                }\r\n                // construct the lazy-loaded component implementation\r\n                // passing the hostRef is very important during\r\n                // construction in order to directly wire together the\r\n                // host element and the lazy-loaded instance\r\n                try {\r\n                    new Cstr(hostRef);\r\n                }\r\n                catch (e) {\r\n                    consoleError(e);\r\n                }\r\n                {\r\n                    hostRef.$flags$ &= ~8 /* isConstructingInstance */;\r\n                }\r\n                endNewInstance();\r\n                scopeId = getScopeId(cmpMeta.$tagName$);\r\n                if (!styles.has(scopeId) && Cstr.style) {\r\n                    endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\r\n                    style = Cstr.style;\r\n                    registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\r\n                    endRegisterStyles();\r\n                }\r\n                _a.label = 3;\r\n            case 3:\r\n                ancestorComponent = hostRef.$ancestorComponent$;\r\n                schedule = function () { return scheduleUpdate(elm, hostRef, cmpMeta, true); };\r\n                if (ancestorComponent && ancestorComponent['s-rc']) {\r\n                    // this is the intial load and this component it has an ancestor component\r\n                    // but the ancestor component has NOT fired its will update lifecycle yet\r\n                    // so let's just cool our jets and wait for the ancestor to continue first\r\n                    // this will get fired off when the ancestor component\r\n                    // finally gets around to rendering its lazy self\r\n                    // fire off the initial update\r\n                    ancestorComponent['s-rc'].push(schedule);\r\n                }\r\n                else {\r\n                    schedule();\r\n                }\r\n                return [2 /*return*/];\r\n        }\r\n    });\r\n}); };\r\nvar connectedCallback = function (elm, cmpMeta) {\r\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\r\n        var endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\r\n        // connectedCallback\r\n        var hostRef_1 = getHostRef(elm);\r\n        if (cmpMeta.$listeners$) {\r\n            // initialize our event listeners on the host element\r\n            // we do this now so that we can listening to events that may\r\n            // have fired even before the instance is ready\r\n            hostRef_1.$rmListeners$ = addEventListeners(elm, hostRef_1, cmpMeta.$listeners$);\r\n        }\r\n        if (!(hostRef_1.$flags$ & 1 /* hasConnected */)) {\r\n            // first time this component has connected\r\n            hostRef_1.$flags$ |= 1 /* hasConnected */;\r\n            {\r\n                // find the first ancestor component (if there is one) and register\r\n                // this component as one of the actively loading child components for its ancestor\r\n                var ancestorComponent = elm;\r\n                while ((ancestorComponent = (ancestorComponent.parentNode || ancestorComponent.host))) {\r\n                    // climb up the ancestors looking for the first\r\n                    // component that hasn't finished its lifecycle update yet\r\n                    if ((ancestorComponent['s-p'])) {\r\n                        // we found this components first ancestor component\r\n                        // keep a reference to this component's ancestor component\r\n                        attachToAncestor(hostRef_1, (hostRef_1.$ancestorComponent$ = ancestorComponent));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // Lazy properties\r\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\r\n            if (cmpMeta.$members$) {\r\n                Object.entries(cmpMeta.$members$).forEach(function (_a) {\r\n                    var memberName = _a[0], memberFlags = _a[1][0];\r\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\r\n                        var value = elm[memberName];\r\n                        delete elm[memberName];\r\n                        elm[memberName] = value;\r\n                    }\r\n                });\r\n            }\r\n            {\r\n                // connectedCallback, taskQueue, initialLoad\r\n                // angular sets attribute AFTER connectCallback\r\n                // https://github.com/angular/angular/issues/18909\r\n                // https://github.com/angular/angular/issues/19940\r\n                nextTick(function () { return initializeComponent(elm, hostRef_1, cmpMeta); });\r\n            }\r\n        }\r\n        endConnected();\r\n    }\r\n};\r\nvar disconnectedCallback = function (elm) {\r\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\r\n        var hostRef = getHostRef(elm);\r\n        {\r\n            if (hostRef.$rmListeners$) {\r\n                hostRef.$rmListeners$();\r\n                hostRef.$rmListeners$ = undefined;\r\n            }\r\n        }\r\n        // clear CSS var-shim tracking\r\n        if (plt.$cssShim$) {\r\n            plt.$cssShim$.removeHost(elm);\r\n        }\r\n    }\r\n};\r\nvar bootstrapLazy = function (lazyBundles, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var endBootstrap = createTime();\r\n    var cmpTags = [];\r\n    var exclude = options.exclude || [];\r\n    var head = doc.head;\r\n    var customElements = win.customElements;\r\n    var y = /*@__PURE__*/ head.querySelector('meta[charset]');\r\n    var visibilityStyle = /*@__PURE__*/ doc.createElement('style');\r\n    var deferredConnectedCallbacks = [];\r\n    var appLoadFallback;\r\n    var isBootstrapping = true;\r\n    Object.assign(plt, options);\r\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\r\n    if (options.syncQueue) {\r\n        plt.$flags$ |= 4 /* queueSync */;\r\n    }\r\n    lazyBundles.forEach(function (lazyBundle) { return lazyBundle[1].forEach(function (compactMeta) {\r\n        var cmpMeta = {\r\n            $flags$: compactMeta[0],\r\n            $tagName$: compactMeta[1],\r\n            $members$: compactMeta[2],\r\n            $listeners$: compactMeta[3],\r\n        };\r\n        {\r\n            cmpMeta.$members$ = compactMeta[2];\r\n        }\r\n        {\r\n            cmpMeta.$listeners$ = compactMeta[3];\r\n        }\r\n        var tagName = cmpMeta.$tagName$;\r\n        var HostElement = /** @class */ (function (_super) {\r\n            __extends(HostElement, _super);\r\n            // StencilLazyHost\r\n            function HostElement(self) {\r\n                var _this = \r\n                // @ts-ignore\r\n                _super.call(this, self) || this;\r\n                self = _this;\r\n                registerHost(self);\r\n                return _this;\r\n            }\r\n            HostElement.prototype.connectedCallback = function () {\r\n                var _this = this;\r\n                if (appLoadFallback) {\r\n                    clearTimeout(appLoadFallback);\r\n                    appLoadFallback = null;\r\n                }\r\n                if (isBootstrapping) {\r\n                    // connectedCallback will be processed once all components have been registered\r\n                    deferredConnectedCallbacks.push(this);\r\n                }\r\n                else {\r\n                    plt.jmp(function () { return connectedCallback(_this, cmpMeta); });\r\n                }\r\n            };\r\n            HostElement.prototype.disconnectedCallback = function () {\r\n                var _this = this;\r\n                plt.jmp(function () { return disconnectedCallback(_this); });\r\n            };\r\n            HostElement.prototype['s-hmr'] = function (hmrVersionId) {\r\n            };\r\n            HostElement.prototype.forceUpdate = function () {\r\n                forceUpdate(this, cmpMeta);\r\n            };\r\n            HostElement.prototype.componentOnReady = function () {\r\n                return getHostRef(this).$onReadyPromise$;\r\n            };\r\n            return HostElement;\r\n        }(HTMLElement));\r\n        cmpMeta.$lazyBundleIds$ = lazyBundle[0];\r\n        if (!exclude.includes(tagName) && !customElements.get(tagName)) {\r\n            cmpTags.push(tagName);\r\n            customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\r\n        }\r\n    }); });\r\n    // visibilityStyle.innerHTML = cmpTags.map(t => `${t}:not(.hydrated)`) + '{display:none}';\r\n    visibilityStyle.innerHTML = cmpTags + '{visibility:hidden}.hydrated{visibility:inherit}';\r\n    visibilityStyle.setAttribute('data-styles', '');\r\n    head.insertBefore(visibilityStyle, y ? y.nextSibling : head.firstChild);\r\n    // Process deferred connectedCallbacks now all components have been registered\r\n    isBootstrapping = false;\r\n    if (deferredConnectedCallbacks.length > 0) {\r\n        deferredConnectedCallbacks.forEach(function (host) { return host.connectedCallback(); });\r\n    }\r\n    else {\r\n        plt.jmp(function () { return appLoadFallback = setTimeout(appDidLoad, 30, 'timeout'); });\r\n    }\r\n    // Fallback appLoad event\r\n    endBootstrap();\r\n};\r\nvar createEvent = function (ref, name, flags) {\r\n    var elm = getElement(ref);\r\n    return {\r\n        emit: function (detail) {\r\n            return elm.dispatchEvent(new (CustomEvent)(name, {\r\n                bubbles: !!(flags & 4 /* Bubbles */),\r\n                composed: !!(flags & 2 /* Composed */),\r\n                cancelable: !!(flags & 1 /* Cancellable */),\r\n                detail: detail\r\n            }));\r\n        }\r\n    };\r\n};\r\nvar getElement = function (ref) { return getHostRef(ref).$hostElement$; };\r\nexport { patchEsm as a, bootstrapLazy as b, createEvent as c, getElement as g, h, patchBrowser as p, registerInstance as r };\r\n","import { a as patchEsm, b as bootstrapLazy } from './core-2fe5e2de.js';\r\nvar defineCustomElements = function (win, options) {\r\n    return patchEsm().then(function () {\r\n        bootstrapLazy([[\"uv-ebook-reader_2\", [[0, \"uv-ebook-reader\", { \"width\": [1], \"height\": [1], \"mobileWidth\": [2, \"mobile-width\"], \"minSpreadWidth\": [2, \"min-spread-width\"], \"_bookPath\": [32], \"_bookReady\": [32], \"_prevEnabled\": [32], \"_mobile\": [32], \"_nextEnabled\": [32], \"_showDivider\": [32], \"load\": [64], \"resize\": [64], \"display\": [64], \"getBook\": [64] }, [[8, \"keydown\", \"handleKeyDown\"]]], [0, \"uv-ebook-toc\", { \"toc\": [16], \"selected\": [1025], \"disabled\": [4] }]]]], options);\r\n    });\r\n};\r\nexport { defineCustomElements };\r\n","export function applyPolyfills() {\n  var win = window;\n\n  var promises = [];\n\n  if (!win.customElements || (win.Element && (!win.Element.prototype.closest || !win.Element.prototype.matches || !win.Element.prototype.remove))) {\n    promises.push(import('./dom.js'));\n  }\n\n  function checkIfURLIsSupported() {\n    try {\n      var u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      return (u.href === 'http://a/c%20d') && u.searchParams;\n    } catch(e) {\n      return false;\n    }\n  }\n\n  if (\n    'function' !== typeof Object.assign || !Object.entries ||\n    !Array.prototype.find || !Array.prototype.includes ||\n    !String.prototype.startsWith || !String.prototype.endsWith ||\n    (win.NodeList && !win.NodeList.prototype.forEach) ||\n    !win.fetch ||\n    !checkIfURLIsSupported() ||\n    typeof WeakMap == 'undefined'\n  ) {\n    promises.push(import('./core-js.js'));\n  }\n  return Promise.all(promises);\n}\n","\n(function() {\n  if (\n    // No Reflect, no classes, no need for shim because native custom elements\n    // require ES2015 classes or Reflect.\n    window.Reflect === undefined ||\n    window.customElements === undefined\n  ) {\n    return;\n  }\n  var BuiltInHTMLElement = HTMLElement;\n  window.HTMLElement = /** @this {!Object} */ function HTMLElement() {\n    return Reflect.construct(\n        BuiltInHTMLElement, [], /** @type {!Function} */ (this.constructor));\n  };\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();\n\nexport * from '../dist/esm/polyfills/index.js';\nexport * from '../dist/esm-es5/loader.mjs';\n"],"sourceRoot":""}